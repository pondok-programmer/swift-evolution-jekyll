{
  "0": {
    "id": "0",
    "title": "SE-0001 Allow (most) keywords as argument labels",
    "content": "Allow (most) keywords as argument labels Proposal: SE-0001 Author: Doug Gregor Status: Implemented (Swift 2.2) Bug: SR-344 Introduction Argument labels are an important part of the interface of a Swift function, describing what particular arguments to the function do and improving readability. Sometimes, the most natural label for an argument coincides with a language keyword, such as in, repeat, or defer. Such keywords should be allowed as argument labels, allowing better expression of these interfaces. Motivation In some functions, the best argument label for a particular parameter happens to coincide with a language keyword. For example, consider a module-scope function that finds the index of a particular value in a collection. A natural name for this would be indexOf(_:in:): indexOf(value, in: collection) However, because in is a keyword, one would actually have to use backticks to escape the in, e.g.: indexOf(value, `in`: collection) When defining new APIs in Swift, authors will tend to pick other non-keyword words (e.g., within for this example), even if they aren’t ideal. However, this issue also comes up when importing Objective-C APIs under the “omit needless words” heuristics, requiring escaping to use those APIs. For example: event.touchesMatching([.Began, .Moved], `in`: view) NSXPCInterface(`protocol`: SomeProtocolType.Protocol) Proposed solution Allow the use of all keywords except inout, var, and let as argument labels. This affects the grammar in three places: Call expressions, such as the examples above. Here, we have no grammatic ambiguities, because “ `: `&quot; does not appear in any grammar production within a parenthesized expression list. This is, by far, the most important case. Function/subscript/initializer declarations: aside from the three exclusions above, there is no ambiguity here because the keyword will always be followed by an identifier, ‘:’, or ‘_’. For example: func touchesMatching(phase: NSTouchPhase, in view: NSView?) -&gt; Set&lt;NSTouch&gt; Keywords that introduce or modify a parameter—-currently just “inout”, “let”, and “var”—-will need to retain their former meanings. If we invent an API that uses such keywords, they will still need to be back-ticked: func addParameter(name: String, `inout`: Bool) Function types: these are actually easier than #2, because the parameter name is always followed by a ‘:’: (NSTouchPhase, in: NSView?) -&gt; Set&lt;NSTouch&gt; (String, inout: Bool) -&gt; Void Impact on existing code This functionality is strictly additive, and does not break any existing code: it only makes some previously ill-formed code well-formed, and does not change the behavior of any well-formed code. Alternatives considered The primary alternative here is to do nothing: Swift APIs will continue to avoid keywords for argument labels, even when they are the most natural word for the label, and imported APIs will either continue to use backticks or will need to be renamed. This alternative leaves a large number of imported APIs (nearly 200) requiring either some level of renaming of the API or backticks at the call site. A second alternative is to focus on in itself, which is by far the most common keyword argument in imported APIs. In a brief survey of imported APIs, in accounted for 90% of the conflicts with existing keywords. Moreover, the keyword in is only used in two places in the Swift grammar–for loops and closures–so it could be made context-sensitive. However, this solution is somewhat more complicated (because it requires more context-sensitive keyword parsing) and less general.",
    "url": "http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html",
    "relUrl": "/docs/2019-08-26-0001-keywords-as-argument-labels.html"
  },
  "1": {
    "id": "1",
    "title": "SE-0002 Removing currying `func` declaration syntax",
    "content": "Removing currying func declaration syntax Proposal: SE-0002 Author: Joe Groff Status: Implemented (Swift 3) Implementation: apple/swift@983a674 Introduction Curried function declaration syntax func foo(x: Int)(y: Int) is of limited usefulness and creates a lot of language and implementation complexity. We should remove it. Motivation The presence of curried function syntax has knock-on effects, complicating other language features: The presence of currying invites confusion over keyword rules and the declaration name of functions. We’ve argued several times over whether curried arguments represent a continuation of the function’s arguments, begin the argument list of a new function, or deserve to follow different rules altogether. It has subtle interactions with ‘var’ and ‘inout’ argument annotations. A curried function with ‘inout’ parameters anywhere other than its first clause cannot be partially applied without surprising semantic restrictions, limiting its usefulness. With ‘var’ parameters, there’s the question of at what level the ‘var’ gets bound; many users expect it at the outermost partial application, but we currently bind at the innermost partial application. The idioms of the standard library, Cocoa, and most third-party code don’t really make ML-style argument currying of free functions profitable. In Cocoa and the standard library, most things are methods, where we can still get useful partial application via self.method and maybe someday .map { f($0) } as well. The curried function design also predates the design of the keyword argument model. We have plans to move away from the arguments-are-a-single-tuple model too (which is already belied by things like @autoclosure and inout), which pushes us even further away from the ML argument model. Many users have observed the uselessness of our currying feature, and asked for Scala-style f(_, 1) freeform partial application as an alternative. The fact that even functionally-oriented users don’t see much value in our currying feature makes me feel like we might be better off without it. It definitely fails the “would we add it if we didn’t have it already” test. Detailed design We remove support for multiple argument patterns in func declarations, reducing the grammar for func-signature to allow only one argument clause. For migration purposes, existing code that uses currying declaration syntax can be transformed to explicitly return a closure instead: // Before: func curried(x: Int)(y: String) -&gt; Float { return Float(x) + Float(y)! } // After: func curried(x: Int) -&gt; (String) -&gt; Float { return {(y: String) -&gt; Float in return Float(x) + Float(y)! } } I don’t propose changing the semantics of methods, which formally remain functions of type Self -&gt; Args -&gt; Return. Impact on existing code This is removing a language feature, so will obviously break existing code that uses the feature. We feel that currying is of sufficiently marginal utility, runs against the grain of emerging language practice, and there’s a reasonable automatic migration, so the impact is acceptable in order to simplify the language. Alternatives considered The alternative would be to preserve currying as-is, which as discussed above, is not ideal. Although I don’t propose taking any immediate action, future alternative designs to provide similar functionality in a more idiomatic way include: Scala-like ad-hoc partial application syntax, such that something like foo(_, bar: 2) would be shorthand for { x in foo(x, bar: 2) }. This has the benefit of arguably being more readable with our keyword-argument- oriented API design, and also more flexible than traditional currying, which requires argument order to be preconsidered by the API designer. Method and/or operator slicing syntax. We have self.method to partially bind a method to its self parameter, and could potentially add .method(argument) to partially bind a method to its non-self arguments, which would be especially useful for higher-order methods like map and filter. Haskell-like (2+)/(+2) syntax for partially applying operators might also be nice.",
    "url": "http://localhost:4000/docs/2019-08-26-0002-remove-currying.html",
    "relUrl": "/docs/2019-08-26-0002-remove-currying.html"
  },
  "2": {
    "id": "2",
    "title": "SE-0003 Removing `var` from Function Parameters",
    "content": "Removing var from Function Parameters Proposal: SE-0003 Author: David Farler Review Manager: Joe Pamer Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift@8a5ed40 Note This proposal underwent some major changes from its original form. See the end of this document for historical information and why this proposal changed. Introduction There has been some confusion of semantics when a function parameter is marked as inout compared to var. Both give a mutable local copy of a value but parameters marked inout are automatically written back. Function parameters are immutable by default: func foo(i: Int) { i += 1 // illegal } func foo(var i: Int) { i += 1 // OK, but the caller cannot observe this mutation. } Here, the local copy of x mutates but the write does not propagate back to the original value that was passed, so the caller can never observe the change directly. For that to happen to value types, you have to mark the parameter with inout: func doSomethingWithVar(var i: Int) { i = 2 // This will NOT have an effect on the caller&#39;s Int that was passed, but i can be modified locally } func doSomethingWithInout(inout i: Int) { i = 2 // This will have an effect on the caller&#39;s Int that was passed. } var x = 1 print(x) // 1 doSomethingWithVar(x) print(x) // 1 doSomethingWithInout(&amp;x) print(x) // 2 Motivation Using var annotations on function parameters have limited utility, optimizing for a line of code at the cost of confusion with inout, which has the semantics most people expect. To emphasize the fact these values are unique copies and don’t have the write-back semantics of inout, we should not allow var here. In summary, the problems that motivate this change are: var is often confused with inout in function parameters. var is often confused to make value types have reference semantics. Function parameters are not refutable patterns like in if-, while-, guard-, for-in-, and case statements. Design This is a trivial change to the parser. In Swift 2.2, a deprecation warning will be emitted while in Swift 3 it will become an error. Impact on existing code As a purely mechanical migration away from these uses of var, a temporary variable can be immediately introduced that shadows the immutable copy in all of the above uses. For example: func foo(i: Int) { var i = i } However, shadowing is not necessarily an ideal fix and may indicate an anti-pattern. We expect users of Swift to rethink some of their existing code where these are used but it is not strictly necessary to react to this language change. Alternatives considered This proposal originally included removal of var bindings for all refutable patterns as well as function parameters. Original SE-0003 Proposal Removal of var from refutable patterns was reconsidered due to the burden it placed on valid mutation patterns already in use in Swift 2 code. You can view the discussion on the swift-evolution mailing list here: Initial Discussion of Reconsideration The rationale for a final conclusion was also sent to the swift-evolution list, which you can view here: Note on Revision of the Proposal",
    "url": "http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html",
    "relUrl": "/docs/2019-08-26-0003-remove-var-parameters.html"
  },
  "3": {
    "id": "3",
    "title": "SE-0004 Remove the `++` and `--` operators",
    "content": "Remove the ++ and -- operators Proposal: SE-0004 Author: Chris Lattner Status: Implemented (Swift 3) Implementation: apple/swift@8e12008 Introduction The increment/decrement operators in Swift were added very early in the development of Swift, as a carry-over from C. These were added without much consideration, and haven’t been thought about much since then. This document provides a fresh look at them, and ultimately recommends we just remove them entirely, since they are confusing and not carrying their weight. As a quick refresher, there are four operators in this family: let a = ++x // pre-increment - returns input value after mutation let b = x++ // post-increment - returns copy of input value before mutation let c = --x // pre-decrement - returns input value after mutation let d = x-- // post-decrement - returns copy of input value before mutation However, the result value of these operators are frequently ignored. Advantages of These Operators The primary advantage of these operators is their expressive capability. They are shorthand for (e.g.) x += 1 on a numeric type, or x.advance() on an iterator-like value. When the return value is needed, the Swift += operator cannot be used in-line, since (unlike C) it returns Void. The second advantage of Swift supporting this family of operators is continuity with C, and other common languages in the extended C family (C++, Objective-C, Java, C#, Javascript, etc). People coming to Swift from these other languages may reasonably expect these operators to exist. That said, there are also popular languages which have kept the majority of C operators but dropped these (e.g. Python). Disadvantages of These Operators These operators increase the burden to learn Swift as a first programming language - or any other case where you don’t already know these operators from a different language. Their expressive advantage is minimal - x++ is not much shorter than x += 1. Swift already deviates from C in that the =, += and other assignment-like operations returns Void (for a number of reasons). These operators are inconsistent with that model. Swift has powerful features that eliminate many of the common reasons you’d use ++i in a C-style for loop in other languages, so these are relatively infrequently used in well-written Swift code. These features include the for-in loop, ranges, enumerate, map, etc. Code that actually uses the result value of these operators is often confusing and subtle to a reader/maintainer of code. They encourage “overly tricky” code which may be cute, but difficult to understand. While Swift has well defined order of evaluation, any code that depended on it (like foo(++a, a++)) would be undesirable even if it was well-defined. These operators are applicable to relatively few types: integer and floating point scalars, and iterator-like concepts. They do not apply to complex numbers, matrices, etc. Finally, these fail the metric of “if we didn’t already have these, would we add them to Swift 3?” Proposed Approach We should just drop these operators entirely. In terms of roll-out, we should deprecate them in the Spring Swift 2.x release (with a nice Fixit hint to cover common cases), and remove them completely in Swift 3. Alternatives considered Simplest alternative: we could keep them. More interesting to consider, we could change these operators to return Void. This solves some of the problems above, but introduces a new question: once the result is gone, the difference between the prefix and postfix form also vanishes. Given that, we would have to pick between these unfortunate choices: 1) Keep both x++ and ++x in the language, even though they do the same thing. 2) Drop one of x++ or ++x. C++ programmers generally prefer the prefix forms, but everyone else generally prefers the postfix forms. Dropping either one would be a significant deviation from C. Despite considering these options carefully, they still don’t justify the complexity that the operators add to Swift.",
    "url": "http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html",
    "relUrl": "/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html"
  },
  "4": {
    "id": "4",
    "title": "SE-0005 Better Translation of Objective-C APIs Into Swift",
    "content": "Better Translation of Objective-C APIs Into Swift Proposal: SE-0005 Authors: Doug Gregor, Dave Abrahams Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Reviewer notes This review is part of a group of three related reviews, running concurrently: SE-0023 API Design Guidelines (Review) SE-0006 Apply API Guidelines to the Standard Library (Review) SE-0005 Better Translation of Objective-C APIs Into Swift (Review) These reviews are running concurrently because they interact strongly (e.g., an API change in the standard library will correspond to a particular guideline, or an importer rule implements a particular guideline, etc.). Because of these interactions, and to keep discussion manageable, we ask that you: Please get a basic understanding of all three documents before posting review commentary Please post your review of each individual document in response to its review announcement. It’s okay (and encouraged) to make cross-references between the documents in your review where it helps you make a point. Introduction This proposal describes how we can improve Swift’s “Clang Importer”, which is responsible for mapping C and Objective-C APIs into Swift, to translate the names of Objective-C functions, types, methods, properties, etc. into names that more closely align with the [Swift API Design Guidelines][api-design-guidelines] being developed as part of Swift 3. Our approach focuses on the differences between the Objective-C [Coding Guidelines for Cocoa][objc-cocoa-guidelines] and the Swift API Design Guidelines, using some simple linguistic analysis to aid the automatic translation from Objective-C names to more “Swifty” names. The results of this transformation can be seen in the Swift 3 API Guidelines Review repository, which contains Swift projections of Objective-C APIs in Swift 2 (swift-2 branch) and Swift 3 (swift-3 branch) along with partially-migrated sample code. One can also see the overall changes by comparing the two branches. Motivation The Objective-C [Coding Guidelines for Cocoa][objc-cocoa-guidelines] provide a framework for creating clear, consistent APIs in Objective-C, where they work extraordinarily well. However, Swift is a different language: in particular, it is strongly typed and provides type inference, generics, and overloading. As a result, Objective-C APIs that feel right in Objective-C can feel wordy when used in Swift. For example: let content = listItemView.text.stringByTrimmingCharactersInSet( NSCharacterSet.whitespaceAndNewlineCharacterSet()) The APIs used here follow the Objective-C guidelines. A more “Swifty” version of the same code might instead look like this: let content = listItemView.text.trimming(.whitespaceAndNewlines) The latter example more closely adheres to the [Swift API Design Guidelines][api-design-guidelines], in particular, omitting “needless” words that restate the types already enforced by the compiler (view, string, character set, etc.). The goal of this proposal is to make imported Objective-C feel more “Swifty”, providing a more fluid experience for Swift programmers using Objective-C APIs. The solution in this proposal applies equally to the Objective-C frameworks (e.g., all of Cocoa and Cocoa Touch) and any Objective-C APIs that are available to Swift in mix-and-match projects. Note that the [Swift core libraries][core-libraries] reimplement the APIs of Objective-C frameworks, so any API changes to those frameworks (Foundation, XCTest, etc.) will be reflected in the Swift 3 implementations of the core libraries. Proposed solution The proposed solution involves identifying the differences between the Objective-C [Coding Guidelines for Cocoa][objc-cocoa-guidelines] and the [Swift API Design Guidelines][api-design-guidelines] to build a set of transformations that map from the former to the latter based on the guidelines themselves and other observed conventions in Objective-C. This is an extension of other heuristics in the Clang importer that translate names, e.g., the mapping of global enum constants into Swift’s cases (which strips common prefixes from the enum constant names) and the mapping from Objective-C factory methods (e.g., +[NSNumber numberWithBool:]) to Swift initializers (NSNumber(bool: true)). The heuristics described in this proposal will require iteration, tuning, and experimentation across a large body of Objective-C APIs to get right. Moreover, it will not be perfect: some APIs will undoubtedly end up being less clear in Swift following this translation than they had been before. Therefore, the goal is to make the vast majority of imported Objective-C APIs feel more “Swifty”, and allow the authors of Objective-C APIs that end up being less clear to address those problems on a per-API basis via annotation within the Objective-C headers. The proposed solution involves several related changes to the Clang importer: Generalize the applicability of the swift_name attribute: The Clang swift_name attribute currently allows limited renaming of enum cases and factory methods. It should be generalized to allow arbitrary renaming of any C or Objective-C entity when it is imported into Swift, allowing authors of C or Objective-C APIs more fine-grained control over the process. Prune redundant type names: The Objective-C Coding Guidelines for Cocoa require that the method describe each argument. When those descriptions restate the type of the corresponding parameter, the name conflicts with the omit needless words guideline for Swift APIs. Therefore, we prune these type names during import. Add default arguments: In cases where the Objective-C API strongly hints at the need for a default argument, infer the default argument when importing the API. For example, an option-set parameter can be defaulted to []. Add first argument labels: If the first parameter of a method is defaulted, it should have an argument label. Determine a first argument label for that method. Prepend “is” to Boolean properties: Boolean properties should read as assertions on the receiver, but the Objective-C Coding Guidelines for Cocoa prohibit the use of “is” on properties. Import such properties with “is” prepended. Lowercase values: The Swift API Design Guidelines have non-type declarations lowercased. Lowercase non-prefixed values whenever they are imported, including enumerators (whether they end up in Swift as enum cases or option sets) and any other properties/functions (e.g., a property named URLHandler will be lowercased to urlHandler). Adopt Comparable to classes that implement compare(_:) -&gt; NSComparisonResult: The objective-c classes that implement compare all have declared a capability of being compared in an ordered manner. Comparable formalizes this declaration into an implementable operator by the import process. To get a sense of what these transformations do, consider a portion of the imported UIBezierPath API in Swift 2: class UIBezierPath : NSObject, NSCopying, NSCoding { convenience init(ovalInRect: CGRect) func moveToPoint(_: CGPoint) func addLineToPoint(_: CGPoint) func addCurveToPoint(_: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint) func addQuadCurveToPoint(_: CGPoint, controlPoint: CGPoint) func appendPath(_: UIBezierPath) func bezierPathByReversingPath() -&gt; UIBezierPath func applyTransform(_: CGAffineTransform) var empty: Bool { get } func containsPoint(_: CGPoint) -&gt; Bool func fillWithBlendMode(_: CGBlendMode, alpha: CGFloat) func strokeWithBlendMode(_: CGBlendMode, alpha: CGFloat) func copyWithZone(_: NSZone) -&gt; AnyObject func encodeWithCoder(_: NSCoder) } And the same API imported under our current, experimental implementation of this proposal: class UIBezierPath : NSObject, NSCopying, NSCoding { convenience init(ovalIn rect: CGRect) func move(to point: CGPoint) func addLine(to point: CGPoint) func addCurve(to endPoint: CGPoint, controlPoint1 controlPoint1: CGPoint, controlPoint2 controlPoint2: CGPoint) func addQuadCurve(to endPoint: CGPoint, controlPoint controlPoint: CGPoint) func append(_ bezierPath: UIBezierPath) func reversing() -&gt; UIBezierPath func apply(_ transform: CGAffineTransform) var isEmpty: Bool { get } func contains(_ point: CGPoint) -&gt; Bool func fill(_ blendMode: CGBlendMode, alpha alpha: CGFloat) func stroke(_ blendMode: CGBlendMode, alpha alpha: CGFloat) func copy(with zone: NSZone = nil) -&gt; AnyObject func encode(with aCoder: NSCoder) } In the latter case, a number of words that restated type information in the original APIs have been pruned. The result is closer to following the Swift API Design Guidelines. For example, this shows that Swift developers can now copy any object conforming to the NSCopying with a simple call to foo.copy() instead of calling foo.copyWithZone(nil). Implementation Experience An experimental implementation of this proposal is available in the main Swift repository. There are a set of compiler flags that one can use to see the results of applying this proposal to imported Objective-C APIs (e.g., via the script in utils/omit-needless-words.py) and to Swift code itself. The flags are: -enable-omit-needless-words: this flag enables most of the changes to the Clang importer (bullets 1, 2, 4, and 5 in the prior section). It is currently suitable only for printing the Swift interface to Objective-C modules (e.g., via swift-ide-test) in the Swift master branch and [Swift 2.2 branch][swift-2_2-branch], and is enabled on the [Swift 3 API Guidelines branch][swift-3-api-guidelines-branch]. -enable-infer-default-arguments: this flag enables inference of default arguments in the Clang importer (bullet 3 in the prior section). -swift3-migration: only available on the [Swift 2.2 branch][swift-2_2-branch], this flag performs basic migration from Swift 2 names to the Swift 3 names via Fix-Its. Tied together with other compiler flags (e.g., -fixit-code, -fixit-all) and a script to collect and apply Fix-Its (in utils/apply-fixit-edits.py), this flag provides a rudimentary migrator that lets us see how Swift code would look under the proposed changes, updating both declarations and use sites. To actually get the “Swift 3 experience” of compiling code using these names, one can use the [Swift 3 API Guidelines branch][swift-3-api-guidelines-branch], which enables these features by default along with the changes to the standard library. Detailed design This section details the experimental implementation of rules 2-5 in prose. The actual implementation is available in the Swift source tree, mostly in the omitNeedlessWords functions of lib/Basic/StringExtras.cpp. The descriptions in this section are described in terms of the incoming Objective-C API. For example, Objective-C method names are “selectors”, e.g., startWithQueue:completionHandler: is a selector with two selector pieces, startWithQueue and completionHandler. A direct mapping of this name into Swift would produce startWithQueue(_:completionHandler:). Prune redundant type names Objective-C API names often contain names of parameter and/or result types that would be omitted in a Swift API. The following rules are designed to identify and remove these words. [Omit Needless Words] Identifying type names The matching process described below searches in a selector piece for a suffix of a string called the type name, which is defined as follows: For most Objective-C types, the type name is the name under which Swift imports the type, ignoring nullability. For example, Objective-C type Type Name float Float nullable NSString String UIDocument UIDocument nullable UIDocument UIDocument NSInteger NSInteger NSUInteger NSUInteger CGFloat CGFloat When the Objective-C type is a block, the type name is “Block.” When the Objective-C type is a pointer- or reference-to-function, the type name is “Function.” When the Objective-C type is a typedef other than NSInteger, NSUInteger, or CGFloat (which follow the first rule above), the type name is that of the underlying type. For example, when the Objective-C type is UILayoutPriority, which is a typedef for float, we try to match the string “Float”. [Compensate for Weak Type Information] Matching In order to prune a redundant type name from a selector piece, we need to match a substring of the selector that identifies the type. A couple of basic rules govern all matches: Matches begin and end at word boundaries in both type names and selector pieces. Word boundaries occur at the beginning and end of a string, and before every capital letter. Treating every capital letter as the beginning of a word allows us to match uppercased acronyms without maintaining a special lists of acronyms or prefixes: func documentForURL(_: NSURL) -&gt; NSDocument? while preventing partial-word mismatches: var thumbnailPreview : UIView // not matched Matched text extends to the end of the type name. Because we accept a match for any suffix of the type name, this code: func constraintEqualToAnchor(anchor: NSLayoutAnchor) -&gt; NSLayoutConstraint? can be pruned as follows: func constraintEqualTo(anchor: NSLayoutAnchor) -&gt; NSLayoutConstraint? Conveniently, matching by suffix also means that module prefixes such as NS do not prevent matching or pruning. Matches are a sequence of one or more of the following: Basic matches Any substring of the selector piece matches an identical substring of the type name, e.g., String in appendString matches String in NSString: func appendString(_: NSString) Index in the selector piece matches Int in the type name: func characterAtIndex(_: Int) -&gt; unichar Collection matches Indexes or Indices in the selector piece matches IndexSet in the type name: func removeObjectsAtIndexes(_: NSIndexSet) A plural noun in the selector piece matches a collection type name if the noun’s singular form matches the name of the collection’s element type: func arrangeObjects(_: [AnyObject]) -&gt; [AnyObject] Special suffix matches The empty string in the selector piece matches Type or _t in the type name: func writableTypesForSaveOperation(_: NSSaveOperationType) -&gt; [String] func objectForKey(_: KeyType) -&gt; AnyObject func startWithQueue(_: dispatch_queue_t, completionHandler: MKMapSnapshotCompletionhandler) The empty string in the selector piece matches one or more digits followed by “D” in the type name: func pointForCoordinate(_: CLLocationCoordinate2D) -&gt; NSPoint In the examples above, the italic text is effectively skipped, so the bold part of the selector piece can be matched and pruned. Pruning Restrictions The following restrictions govern the pruning steps listed in the next section. If any step would violate one of these rules, it is skipped. Never make a selector piece entirely empty. Never transform the first selector piece into a Swift keyword, to avoid forcing the user to escape it with backticks. In Swift, the first Objective-C selector piece becomes: the base name of a method or the full name of a property neither of which can match a Swift keyword without forcing the user to write backticks. For example, extension NSParagraphStyle { &nbsp;&nbsp;class func defaultParagraphStyle() -&gt; NSParagraphStyle } let defaultStyle = NSParagraphStyle.defaultParagraphStyle() // OK would become: extension NSParagraphStyle { &nbsp;&nbsp;class func `default`() -&gt; NSParagraphStyle } let defaultStyle = NSParagraphStyle.`default`() // Awkward By contrast, later selector pieces become argument labels, which are allowed to match Swift keywords without requiring backticks: receiver.handle(someMessage, for: somebody) // OK Never transform a name into “get”, “set”, “with”, “for”, or “using”, just to avoid creating absurdly vacuous names. Never prune a suffix from a parameter introducer unless the suffix is immediately preceded by a preposition, verb, or gerund. This heuristic has the effect of preventing us from breaking up sequences of nouns that refer to a parameter. Dropping just the suffix of a noun phrase tends to imply something unintended about the parameter that follows. For example, func setTextColor(_: UIColor) ... button.setTextColor(.red()) // clear If we were to drop Color, leaving just Text, call sites would become confusing: func setText(_: UIColor) ... button.setText(.red()) // appears to be setting the text! Note: We don’t maintain a list of nouns, but if we did, this rule could be more simply phrased as “don’t prune a suffix leaving a trailing noun before a parameter”. Never prune a suffix from the base name of a method that matches a property of the enclosing class: This heuristic has the effect of preventing us from producing too-generic names for methods that conceptually modify a property of the class. var gestureRecognizers: [UIGestureRecognizer] func addGestureRecognizer(_: UIGestureRecognizer) If we were to drop GestureRecognizer, leaving just add, we end up with a method that conceptually modifies the gestureRecognizers property but uses an overly generic name to do so: var gestureRecognizers: [UIGestureRecognizer] func add(_: UIGestureRecognizer) // should indicate that we&#39;re adding to the property Pruning Steps The following pruning steps are performed in the order shown: Prune the result type from the head of type-preserving transforms. Specifically, when the receiver type is the same as the result type and the type name is matched at the head of the first selector piece and the match is followed by a preposition then prune the match. You can think of the affected operations as properties or non-mutating methods that produce a transformed version of the receiver. For example: extension NSColor { &nbsp;&nbsp;func colorWithAlphaComponent(_: CGFloat) -&gt; NSColor } let translucentForeground = foregroundColor.colorWithAlphaComponent(0.5) becomes: extension NSColor { &nbsp;&nbsp;func withAlphaComponent(_: CGFloat) -&gt; NSColor } let translucentForeground = foregroundColor.withAlphaComponent(0.5) Prune an additional hanging “By”. Specifically, if anything was pruned in step 1 and the remaining selector piece begins with “By” followed by a gerund, then prune the initial “By” as well. This heuristic allows us to arrive at usage of the form a = b.frobnicating(c). For example: extension NSString { &nbsp;&nbsp;func stringByApplyingTransform(_: NSString, reverse: Bool) -&gt; NSString? } let sanitizedInput = rawInput.stringByApplyingTransform(NSStringTransformToXMLHex, reverse: false) becomes: extension NSString { &nbsp;&nbsp;func applyingTransform(_: NSString, reverse: Bool) -&gt; NString? } let sanitizedInput = rawInput.applyingTransform(NSStringTransformToXMLHex, reverse: false) Prune a match for any type name in the signature from the tail of the preceding selector piece. Specifically, From the tail of: Prune a match for: a selector piece that introduces a parameter the parameter type name the name of a property the property type name the name of a zero-argument method the return type name For example, extension NSDocumentController { &nbsp;&nbsp;func documentForURL(_ url: NSURL) -&gt; NSDocument? // parameter introducer } extension NSManagedObjectContext { &nbsp;&nbsp;var parentContext: NSManagedObjectContext? // property } extension UIColor { &nbsp;&nbsp;class func darkGrayColor() -&gt; UIColor // zero-argument method } ... myDocument = self.documentForURL(locationOfFile) if self.managedObjectContext.parentContext != changedContext { return } foregroundColor = .darkGrayColor() becomes: extension NSDocumentController { &nbsp;&nbsp;func documentFor(_ url: NSURL) -&gt; NSDocument? } extension NSManagedObjectContext { &nbsp;&nbsp;var parent : NSManagedObjectContext? } extension UIColor { &nbsp;&nbsp;class func darkGray() -&gt; UIColor } ... myDocument = self.documentFor(locationOfFile) if self.managedObjectContext.parent != changedContext { return } foregroundColor = .darkGray() Prune a match for the enclosing type from the base name of a method so long as the match starts after a verb. For example, extension UIViewController { &nbsp;&nbsp;func dismissViewControllerAnimated(flag: Bool, completion: (() -&gt; Void)? = nil) } becomes: extension UIViewController { &nbsp;&nbsp;func dismissAnimated(flag: Bool, completion: (() -&gt; Void)? = nil) } Why Does Order Matter? Some steps below prune matches from the head of the first selector piece, and some prune from the tail. When pruning restrictions prevent both the head and tail from being pruned, prioritizing head-pruning steps can keep method families together. For example, in NSFontDescriptor: func fontDescriptorWithSymbolicTraits(_: NSFontSymbolicTraits) -&gt; NSFontDescriptor func fontDescriptorWithSize(_: CGFloat) -&gt; UIFontDescriptor func fontDescriptorWithMatrix(_: CGAffineTransform) -&gt; UIFontDescriptor ... becomes: func withSymbolicTraits(_: UIFontDescriptorSymbolicTraits) -&gt; UIFontDescriptor func withSize(_: CGFloat) -&gt; UIFontDescriptor func withMatrix(_: CGAffineTransform) -&gt; UIFontDescriptor ... If we instead began by pruning SymbolicTraits from the tail of the first method name, the prohibition against creating absurdly vacuous names would prevent us from pruning “fontDescriptorWith” down to “with”, resulting in: func fontDescriptorWith(_: NSFontSymbolicTraits) -&gt; NSFontDescriptor // inconsistent func withSize(_: CGFloat) -&gt; UIFontDescriptor func withMatrix(_: CGAffineTransform) -&gt; UIFontDescriptor ... Add Default Arguments For any method that is not a single-parameter setter, default arguments are added to parameters in the following cases: Nullable trailing closure parameters are given a default value of nil. Nullable NSZone parameters are given a default value of nil. Zones are essentially unused in Swift and should always be nil. Option set types whose type name contain the word “Options” are given a default value of [] (the empty option set). NSDictionary parameters with names that involve “options”, “attributes”, or “info” are given a default value of [:]. Together, these heuristics allow code like: rootViewController.presentViewController(alert, animated: true, completion: nil) UIView.animateWithDuration( 0.2, delay: 0.0, options: [], animations: { self.logo.alpha = 0.0 }) { _ in self.logo.hidden = true } to become: rootViewController.present(alert, animated: true) UIView.animateWithDuration( 0.2, delay: 0.0, animations: { self.logo.alpha = 0.0 }) { _ in self.logo.hidden = true } Add First Argument Labels If the first selector piece contains a preposition, split the first selector piece at the last preposition, turning everything starting with the last preposition into a required label for the first argument. As well as creating first argument label for a significant number of APIs, this heuristic eliminates words that refer only to the first argument from call sites where the argument’s default value is used. For example, instead of: extension UIBezierPath { func enumerateObjectsWith(_: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void) } array.enumerateObjectsWith(.Reverse) { // OK // .. } array.enumerateObjectsWith() { // ?? With what? // .. } &lt;/pre&gt; we get: extension NSArray { func enumerateObjects(options _: NSEnumerationOptions = [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void) } array.enumerateObjects(options: .Reverse) { // OK // .. } array.enumerateObjects() { // OK // .. } &lt;/pre&gt; #### Use getter names for Boolean Properties **For Boolean properties, use the name of the getter as the property name in Swift*. For example: swift @interface NSBezierPath : NSObject @property (readonly,getter=isEmpty) BOOL empty; will become extension NSBezierPath { var isEmpty: Bool } if path.isEmpty { ... } ### Conformance of implementers of compare method Currently, in comparing protocols, for example developers usually have to extend `NSDate` to make it to conform to `Comparable`, or use `compare(_:) -&gt; NSComparisonResult` method of `NSDate` directly. In this case Using comparison operators on `NSDate`s will make the code more readable, such as `someDate &lt; today`, rather than `someDate.compare(today) == .OrderedAscending`. Since the import process can determine if a class implements the objective-c method for comparison all classes that implement this method will then be imported as adopting `Comparable`. A survey of Foundation classes reveals not just NSDate but a few other classes that would be affected by this change. swift func compare(other: NSDate) -&gt; NSComparisonResult func compare(decimalNumber: NSNumber) -&gt; NSComparisonResult func compare(otherObject: NSIndexPath) -&gt; NSComparisonResult func compare(string: String) -&gt; NSComparisonResult func compare(otherNumber: NSNumber) -&gt; NSComparisonResult ## Impact on existing code The proposed changes are massively source-breaking for Swift code that makes use of Objective-C frameworks, and will require a migrator to translate Swift 2 code into Swift 3 code. The `-swift3-migration` flag described in the [Implementation Experience](#implementation-experience) section can provide the basics for such a migrator. Additionally, the compiler needs to provide good error messages (with Fix-Its) for Swift code that refers to the old (pre-transformed) Objective-C names, which could be achieved with some combination of the Fix-Its described previously and a secondary name lookup mechanism retaining the old names. ## Acknowledgments The automatic translation described in this proposal has been developed as part of the effort to produce the [Swift API Design Guidelines][api-design-guidelines] with Dmitri Hrybenko, Ted Kremenek, Chris Lattner, Alex Migicovsky, Max Moiseev, Ali Ozer, and Tony Parker. The addendum of comparable was originally proposed to the [core-libraries] mailing list by [Chris Amanse](https://github.com/chrisamanse) and modified to fit to this proposal after review by Philippe Hausler. [objc-cocoa-guidelines]: https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html &quot;Coding Guidelines for Cocoa&quot; [api-design-guidelines]: https://swift.org/documentation/api-design-guidelines &quot;API Design Guidelines&quot; [core-libraries]: https://swift.org/core-libraries/ &quot;Swift Core Libraries&quot; [swift-3-api-guidelines-branch]: https://github.com/apple/swift/tree/swift-3-api-guidelines &quot;Swift 3 API Guidelines branch&quot; [swift-2_2-branch]: https://github.com/apple/swift/tree/swift-2.2-branch &quot;Swift 2.2 branch&quot;",
    "url": "http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html",
    "relUrl": "/docs/2019-08-26-0005-objective-c-name-translation.html"
  },
  "5": {
    "id": "5",
    "title": "SE-0006 Apply API Guidelines to the Standard Library",
    "content": "Apply API Guidelines to the Standard Library Proposal: SE-0006 Authors: Dave Abrahams, Dmitri Gribenko, Maxim Moiseev Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Reviewer notes This review is part of a group of three related reviews, running concurrently: SE-0023 API Design Guidelines (Review) SE-0006 Apply API Guidelines to the Standard Library (Review) SE-0005 Better Translation of Objective-C APIs Into Swift (Review) These reviews are running concurrently because they interact strongly (e.g., an API change in the standard library will correspond to a particular guideline, or an importer rule implements a particular guideline, etc.). Because of these interactions, and to keep discussion manageable, we ask that you: Please get a basic understanding of all three documents before posting review commentary Please post your review of each individual document in response to its review announcement. It’s okay (and encouraged) to make cross-references between the documents in your review where it helps you make a point. Introduction Swift API Design Guidelines being developed as part of Swift 3. It is important that the Standard Library is an exemplar of Swift API Design Guidelines: the APIs from the Standard Library are, probably, the most frequently used Swift APIs in any application domain; the Standard Library also sets precedent for other libraries. In this project, we are reviewing the entire Standard Library and updating it to follow the guidelines. Proposed solution The actual work is being performed on the swift-3-api-guidelines branch of the Swift repository. On high level, the changes can be summarized as follows. Strip Type suffix from protocol names. In a few special cases this means adding a Protocol suffix to get out of the way of type names that are primary (though most of these we expect to be obsoleted by Swift 3 language features). The concept of generator is renamed to iterator across all APIs. The type Bit, which was only used as the index for CollectionOfOne, was removed. We recommend using Int instead. The generic parameter name in unsafe pointer types was renamed from Memory to Pointee. No-argument initializers were removed from unsafe pointer types. We recommend using the nil literal instead. PermutationGenerator was removed. MutableSliceable was removed. Use Collection where SubSequence : MutableCollection instead. sort() =&gt; sorted(), sortInPlace() =&gt; sort(). reverse() =&gt; reversed(). enumerate() =&gt; enumerated(). partition() API was simplified. It composes better with collection slicing now. SequenceType.minElement() =&gt; .min(), .maxElement() =&gt; .max(). Some initializers for sequence and collection adapters were removed. We suggest calling the corresponding algorithm function or method instead. Some functions were changed into properties and vice versa. String factory methods dealing with nul-terminated UTF-8 data (a.k.a. C-strings) became initializers. API diffs Differences between Swift 2.2 Standard library API and the proposed API are added to this section as they are being implemented on the swift-3-api-guidelines branch. For repetitive changes that affect many types, only one representative instance is shown in the diff. For example, generate() was renamed to makeIterator(). We only show the diff for the protocol requirement, and all other renames of this method are implied. If a type was renamed, we show only the diff for the type declaration, all other effects on the API where the name is used are implied. Strip Type suffix from protocol names. -public protocol BooleanType { ... } +public protocol Boolean { ... } -public protocol SequenceType { ... } +public protocol Sequence { ... } -public protocol CollectionType : ... { ... } +public protocol Collection : ... { ... } -public protocol MutableCollectionType : ... { ... } +public protocol MutableCollection : ... { ... } -public protocol RangeReplaceableCollectionType : ... { ... } +public protocol RangeReplaceableCollection : ... { ... } -public protocol AnyCollectionType : ... { ... } +public protocol AnyCollectionProtocol : ... { ... } -public protocol IntegerType : ... { ... } +public protocol Integer : ... { ... } -public protocol SignedIntegerType : ... { ... } +public protocol SignedInteger : ... { ... } -public protocol UnsignedIntegerType : ... { ... } +public protocol UnsignedInteger : ... { ... } -public protocol FloatingPointType : ... { ... } +public protocol FloatingPoint : ... { ... } -public protocol ForwardIndexType { ... } +public protocol ForwardIndex { ... } -public protocol BidirectionalIndexType : ... { ... } +public protocol BidirectionalIndex : ... { ... } -public protocol RandomAccessIndexType : ... { ... } +public protocol RandomAccessIndex : ... { ... } -public protocol IntegerArithmeticType : ... { ... } +public protocol IntegerArithmetic : ... { ... } -public protocol SignedNumberType : ... { ... } +public protocol SignedNumber : ... { ... } -public protocol IntervalType : ... { ... } +public protocol Interval : ... { ... } -public protocol LazyCollectionType : ... { ... } +public protocol LazyCollectionProtocol : ... { ... } -public protocol LazySequenceType : ... { ... } +public protocol LazySequenceProtocol : ... { ... } -public protocol OptionSetType : ... { ... } +public protocol OptionSet : ... { ... } -public protocol OutputStreamType : ... { ... } +public protocol OutputStream : ... { ... } -public protocol BitwiseOperationsType { ... } +public protocol BitwiseOperations { ... } -public protocol ReverseIndexType : ... { ... } +public protocol ReverseIndexProtocol : ... { ... } -public protocol SetAlgebraType : ... { ... } +public protocol SetAlgebra : ... { ... } -public protocol UnicodeCodecType { ... } +public protocol UnicodeCodec { ... } -public protocol CVarArgType { ... } +public protocol CVarArg { ... } -public protocol MirrorPathType { ... } +public protocol MirrorPath { ... } -public protocol ErrorType { ... } +public protocol ErrorProtocol { ... } The concept of “generator” is renamed to “iterator” across all APIs. -public protocol GeneratorType { ... } +public protocol IteratorProtocol { ... } public protocol Collection : ... { - associatedtype Generator : GeneratorType = IndexingGenerator&lt;Self&gt; + associatedtype Iterator : IteratorProtocol = IndexingIterator&lt;Self&gt; - func generate() -&gt; Generator + func makeIterator() -&gt; Iterator } -public struct IndexingGenerator&lt;Elements : Indexable&gt; : ... { ... } +public struct IndexingIterator&lt;Elements : Indexable&gt; : ... { ... } -public struct GeneratorOfOne&lt;Element&gt; : ... { ... } +public struct IteratorOverOne&lt;Element&gt; : ... { ... } -public struct EmptyGenerator&lt;Element&gt; : ... { ... } +public struct EmptyIterator&lt;Element&gt; : ... { ... } -public struct AnyGenerator&lt;Element&gt; : ... { ... } +public struct AnyIterator&lt;Element&gt; : ... { ... } -public struct LazyFilterGenerator&lt;Base : GeneratorType&gt; : ... { ... } +public struct LazyFilterIterator&lt;Base : IteratorProtocol&gt; : ... { ... } -public struct FlattenGenerator&lt;Base : ...&gt; : ... { ... } +public struct FlattenIterator&lt;Base : ...&gt; : ... { ... } -public struct JoinGenerator&lt;Base : ...&gt; : ... { ... } +public struct JoinedIterator&lt;Base : ...&gt; : ... { ... } -public struct LazyMapGenerator&lt;Base : ...&gt; ... { ... } +public struct LazyMapIterator&lt;Base : ...&gt; ... { ... } -public struct RangeGenerator&lt;Element : ForwardIndexType&gt; : ... { ... } +public struct RangeIterator&lt;Element : ForwardIndex&gt; : ... { ... } -public struct GeneratorSequence&lt;Base : GeneratorType&gt; : ... { ... } +public struct IteratorSequence&lt;Base : IteratorProtocol&gt; : ... { ... } -public struct StrideToGenerator&lt;Element : Strideable&gt; : ... { ... } +public struct StrideToIterator&lt;Element : Strideable&gt; : ... { ... } -public struct StrideThroughGenerator&lt;Element : Strideable&gt; : ... { ... } +public struct StrideThroughIterator&lt;Element : Strideable&gt; : ... { ... } -public struct UnsafeBufferPointerGenerator&lt;Element&gt; : ... { ... } +public struct UnsafeBufferPointerIterator&lt;Element&gt; : ... { ... } The type Bit, which was only used as the index for CollectionOfOne, was removed. We recommend using Int instead. -public enum Bit : ... { ... } PermutationGenerator was removed. -public struct PermutationGenerator&lt; - C : CollectionType, Indices : SequenceType - where C.Index == Indices.Generator.Element -&gt; : ... { ... } MutableSliceable was removed. Use Collection where SubSequence : MutableCollection instead. -public protocol MutableSliceable : CollectionType, MutableCollectionType { - subscript(_: Range&lt;Index&gt;) -&gt; SubSequence { get set } -} The generic parameter name in unsafe pointer types was renamed from Memory to Pointee. No-argument initializers were removed from unsafe pointer types. We recommend using the nil literal instead. // The same changes applied to `UnsafePointer`, `UnsafeMutablePointer` and // `AutoreleasingUnsafeMutablePointer`. public struct UnsafePointer&lt; - Memory + Pointee &gt; ... : { - public var memory: Memory { get set } + public var pointee: Pointee { get set } // Use `nil` instead. - public init() } public struct OpaquePointer : ... { // Use `nil` instead. - public init() } sort() =&gt; sorted(), sortInPlace() =&gt; sort(). We also added argument labels to closures. extension Sequence where Self.Iterator.Element : Comparable { @warn_unused_result - public func sort() -&gt; [Generator.Element] + public func sorted() -&gt; [Iterator.Element] } extension Sequence { @warn_unused_result - public func sort( + public func sorted( - @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool + @noescape isOrderedBefore isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool ) -&gt; [Iterator.Element] } extension MutableCollection where Self.Iterator.Element : Comparable { @warn_unused_result(mutable_variant=&quot;sort&quot;) - public func sort() -&gt; [Generator.Element] + public func sorted() -&gt; [Iterator.Element] } extension MutableCollection { @warn_unused_result(mutable_variant=&quot;sort&quot;) - public func sort( + public func sorted( - @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool + @noescape isOrderedBefore isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool ) -&gt; [Iterator.Element] } extension MutableCollection where Self.Index : RandomAccessIndex, Self.Iterator.Element : Comparable { - public mutating func sortInPlace() + public mutating func sort() } extension MutableCollection where Self.Index : RandomAccessIndex { - public mutating func sortInPlace( + public mutating func sort( - @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool + @noescape isOrderedBefore isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool ) } reverse() =&gt; reversed(). extension SequenceType { - public func reverse() -&gt; [Generator.Element] + public func reversed() -&gt; [Iterator.Element] } extension CollectionType where Index : BidirectionalIndexType { - public func reverse() -&gt; ReverseCollection&lt;Self&gt; + public func reversed() -&gt; ReverseCollection&lt;Self&gt; } extension CollectionType where Index : RandomAccessIndexType { - public func reverse() -&gt; ReverseRandomAccessCollection&lt;Self&gt; + public func reversed() -&gt; ReverseRandomAccessCollection&lt;Self&gt; } extension LazyCollectionProtocol where Index : BidirectionalIndexType, Elements.Index : BidirectionalIndexType { - public func reverse() + public func reversed() -&gt; LazyCollection&lt;ReverseCollection&lt;Elements&gt;&gt; } extension LazyCollectionProtocol where Index : RandomAccessIndexType, Elements.Index : RandomAccessIndexType { - public func reverse() + public func reversed() -&gt; LazyCollection&lt;ReverseRandomAccessCollection&lt;Elements&gt;&gt; } enumerate() =&gt; enumerated(). extension Sequence { - public func enumerate() -&gt; EnumerateSequence&lt;Self&gt; + public func enumerated() -&gt; EnumeratedSequence&lt;Self&gt; } -public struct EnumerateSequence&lt;Base : SequenceType&gt; : ... { ... } +public struct EnumeratedSequence&lt;Base : Sequence&gt; : ... { ... } -public struct EnumerateGenerator&lt;Base : GeneratorType&gt; : ... { ... } +public struct EnumeratedIterator&lt;Base : IteratorProtocol&gt; : ... { ... } partition() API was simplified: the range argument was removed. It composes better with collection slicing now, and is more uniform with other collection algorithms. We also added @noescape and an argument label to the closure. extension MutableCollection where Index : RandomAccessIndex { public mutating func partition( - range: Range&lt;Index&gt;, - isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool + @noescape isOrderedBefore isOrderedBefore: (Iterator.Element, Iterator.Element) -&gt; Bool ) -&gt; Index } extension MutableCollection where Index : RandomAccessIndex, Iterator.Element : Comparable { - public mutating func partition(range: Range&lt;Index&gt;) -&gt; Index + public mutating func partition() -&gt; Index } SequenceType.minElement() =&gt; .min(), .maxElement() =&gt; .max(). We also added argument labels to closures. extension Sequence { - public func minElement( + public func min( - @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool + @noescape isOrderedBefore isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Iterator.Element? - public func maxElement( + public func max( - @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool + @noescape isOrderedBefore isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Iterator.Element? } extension Sequence where Iterator.Element : Comparable { - public func minElement() -&gt; Iterator.Element? + public func min() -&gt; Iterator.Element? - public func maxElement() -&gt; Iterator.Element? + public func max() -&gt; Iterator.Element? } Some initializers for sequence, collection and iterator adapters were removed. We suggest calling the corresponding algorithm function or method instead. extension Repeated { - public init(count: Int, repeatedValue: Element) } +/// Return a collection containing `n` repetitions of `elementInstance`. +public func repeatElement&lt;T&gt;(element: T, count n: Int) -&gt; Repeated&lt;T&gt; public struct LazyMapSequence&lt;Base : Sequence, Element&gt; : ... { // Call `.lazy.map` on the sequence instead. - public init(_ base: Base, transform: (Base.Generator.Element) -&gt; Element) } public struct LazyMapCollection&lt;Base : Collection, Element&gt; : ... { // Call `.lazy.map` on the collection instead. - public init(_ base: Base, transform: (Base.Generator.Element) -&gt; Element) } public struct LazyFilterIterator&lt;Base : IteratorProtocol&gt; : ... { // Call `.lazy.filter` on the sequence instead. - public init( - _ base: Base, - whereElementsSatisfy predicate: (Base.Element) -&gt; Bool - ) } public struct RangeIterator&lt;Element : ForwardIndex&gt; : ... { // Use the &#39;generate()&#39; method on the collection instead. - public init(_ bounds: Range&lt;Element&gt;) // Use the &#39;..&lt;&#39; operator. - public init(start: Element, end: Element) } public struct ReverseCollection&lt;Base : ...&gt; : ... { // Use the &#39;reverse()&#39; method on the collection. - public init(_ base: Base) } public struct ReverseRandomAccessCollection&lt;Base : ...&gt; : ... { // Use the &#39;reverse()&#39; method on the collection. - public init(_ base: Base) } public struct Slice&lt;Base : Indexable&gt; : ... { // Use the slicing syntax. - public init(base: Base, bounds: Range&lt;Index&gt;) } public struct MutableSlice&lt;Base : MutableIndexable&gt; : ... { // Use the slicing syntax. - public init(base: Base, bounds: Range&lt;Index&gt;) } public struct EnumeratedIterator&lt;Base : IteratorProtocol&gt; : ... { // Use the &#39;enumerated()&#39; method. - public init(_ base: Base) } public struct EnumeratedSequence&lt;Base : IteratorProtocol&gt; : ... { // Use the &#39;enumerated()&#39; method. - public init(_ base: Base) } public struct IndexingIterator&lt;Elements : Indexable&gt; : ... { // Call &#39;iterator()&#39; on the collection instead. - public init(_elements: Elements) } public struct HalfOpenInterval&lt;Bound : Comparable&gt; : ... { // Use the &#39;..&lt;&#39; operator. - public init(_ start: Bound, _ end: Bound) } public struct ClosedInterval&lt;Bound : Comparable&gt; : ... { // Use the &#39;...&#39; operator. - public init(_ start: Bound, _ end: Bound) } Some functions were changed into properties and vice versa. -public func unsafeUnwrap&lt;T&gt;(nonEmpty: T?) -&gt; T extension Optional { + public var unsafelyUnwrapped: Wrapped { get } } public struct Mirror { - public func superclassMirror() -&gt; Mirror? + public var superclassMirror: Mirror? { get } } public protocol CustomReflectable { - func customMirror() -&gt; Mirror + var customMirror: Mirror { get } } public protocol Collection : ... { - public func underestimateCount() -&gt; Int + public var underestimatedCount: Int { get } } public protocol CustomPlaygroundQuickLookable { - func customPlaygroundQuickLook() -&gt; PlaygroundQuickLook + var customPlaygroundQuickLook: PlaygroundQuickLook { get } } extension String { - public var lowercaseString: String { get } + public func lowercased() - public var uppercaseString: String { get } + public func uppercased() } public enum UnicodeDecodingResult { - public func isEmptyInput() -&gt; Bool { + public var isEmptyInput: Bool } Base names and argument labels were changed to follow guidelines about first argument labels. (Some changes in this category are already specified elsewhere in the diff and are not repeated.) public protocol ForwardIndex { - func advancedBy(n: Distance) -&gt; Self + func advanced(by n: Distance) -&gt; Self - func advancedBy(n: Distance, limit: Self) -&gt; Self + func advanced(by n: Distance, limit: Self) -&gt; Self - func distanceTo(end: Self) -&gt; Distance + func distance(to end: Self) -&gt; Distance } public struct Set&lt;Element : Hashable&gt; : ... { - public mutating func removeAtIndex(index: Index) -&gt; Element + public mutating func remove(at index: Index) -&gt; Element } public struct Dictionary&lt;Key : Hashable, Value&gt; : ... { - public mutating func removeAtIndex(index: Index) -&gt; Element + public mutating func remove(at index: Index) -&gt; Element - public func indexForKey(key: Key) -&gt; Index? + public func index(forKey key: Key) -&gt; Index? - public mutating func removeValueForKey(key: Key) -&gt; Value? + public mutating func removeValue(forKey key: Key) -&gt; Value? } extension Sequence where Iterator.Element : Sequence { // joinWithSeparator(_:) =&gt; join(separator:) - public func joinWithSeparator&lt; + public func joined&lt; Separator : Sequence where Separator.Iterator.Element == Iterator.Element.Iterator.Element - &gt;(separator: Separator) -&gt; JoinSequence&lt;Self&gt; + &gt;(separator separator: Separator) -&gt; JoinedSequence&lt;Self&gt; } extension Sequence where Iterator.Element == String { - public func joinWithSeparator(separator: String) -&gt; String + public func joined(separator separator: String) -&gt; String } public class ManagedBuffer&lt;Value, Element&gt; : ... { public final class func create( - minimumCapacity: Int, + minimumCapacity minimumCapacity: Int, initialValue: (ManagedProtoBuffer&lt;Value, Element&gt;) -&gt; Value ) -&gt; ManagedBuffer&lt;Value, Element&gt; } public protocol Streamable { - func writeTo&lt;Target : OutputStream&gt;(inout target: Target) + func write&lt;Target : OutputStream&gt;(inout to target: Target) } public func dump&lt;T, TargetStream : OutputStream&gt;( value: T, - inout _ target: TargetStream, + inout to target: TargetStream, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max ) -&gt; T extension Sequence { - public func startsWith&lt; + public func starts&lt; PossiblePrefix : Sequence where PossiblePrefix.Iterator.Element == Iterator.Element &gt;( - possiblePrefix: PossiblePrefix, + with possiblePrefix: PossiblePrefix, @noescape isEquivalent: (Iterator.Element, Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Bool - public func startsWith&lt; + public func starts&lt; PossiblePrefix : Sequence where PossiblePrefix.Iterator.Element == Iterator.Element &gt;( - possiblePrefix: PossiblePrefix + with possiblePrefix: PossiblePrefix ) -&gt; Bool } extension CollectionType where Iterator.Element : Equatable { - public func indexOf(element: Iterator.Element) -&gt; Index? + public func index(of element: Iterator.Element) -&gt; Index? } extension CollectionType { - public func indexOf(predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index? + public func index(where predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index? } extension String.Index { - public func samePositionIn(utf8: String.UTF8View) -&gt; String.UTF8View.Index + public func samePosition(in utf8: String.UTF8View) -&gt; String.UTF8View.Index - public func samePositionIn(utf16: String.UTF16View) -&gt; String.UTF16View.Index + public func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index - public func samePositionIn(unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index + public func samePosition(in unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index } extension String.UTF16View.Index { - public func samePositionIn(characters: String) -&gt; String.Index + public func samePosition(in characters: String) -&gt; String.Index - public func samePositionIn(utf8: String.UTF8View) -&gt; String.UTF8View.Index + public func samePosition(in utf8: String.UTF8View) -&gt; String.UTF8View.Index - public func samePositionIn(unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index + public func samePosition(in unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index } extension String.UTF8View.Index { - public func samePositionIn(characters: String) -&gt; String.Index + public func samePosition(in characters: String) -&gt; String.Index - public func samePositionIn(utf16: String.UTF16View) -&gt; String.UTF16View.Index + public func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index - public func samePositionIn(unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index + public func samePosition(in unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index } extension String.UnicodeScalarView.Index { - public func samePositionIn(characters: String) -&gt; String.Index + public func samePosition(in characters: String) -&gt; String.Index - public func samePositionIn(utf16: String.UTF16View) -&gt; String.UTF16View.Index + public func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index - public func samePositionIn(utf16: String.UTF16View) -&gt; String.UTF16View.Index + public func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index } Lowercase enum cases and static properties. public struct Float { - public static var NaN: Float + public static var nan: Float } public struct Double { - public static var NaN: Double + public static var nan: Double public struct CGFloat { - public static var NaN: CGFloat + public static var nan: CGFloat } public protocol FloatingPoint : ... { - static var NaN: Self { get } + static var nan: Self { get } } public enum FloatingPointClassification { - case SignalingNaN + case signalingNaN - case QuietNaN + case quietNaN - case NegativeInfinity + case negativeInfinity - case NegativeNormal + case negativeNormal - case NegativeSubnormal + case negativeSubnormal - case NegativeZero + case negativeZero - case PositiveZero + case positiveZero - case PositiveSubnormal + case positiveSubnormal - case PositiveNormal + case positiveNormal - case PositiveInfinity + case positiveInfinity } public enum ImplicitlyUnwrappedOptional&lt;Wrapped&gt; : ... { - case None + case none - case Some(Wrapped) + case some(Wrapped) } public enum Optional&lt;Wrapped&gt; : ... { - case None + case none - case Some(Wrapped) + case some(Wrapped) } public struct Mirror { public enum AncestorRepresentation { - case Generated + case generated - case Customized(() -&gt; Mirror) + case customized(() -&gt; Mirror) - case Suppressed + case suppressed } public enum DisplayStyle { - case struct, class, enum, tuple, optional, collection + case `struct`, `class`, `enum`, tuple, optional, collection - case dictionary, `set` + case dictionary, `set` } } public enum PlaygroundQuickLook { - case Text(String) + case text(String) - case Int(Int64) + case int(Int64) - case UInt(UInt64) + case uInt(UInt64) - case Float(Float32) + case float(Float32) - case Double(Float64) + case double(Float64) - case Image(Any) + case image(Any) - case Sound(Any) + case sound(Any) - case Color(Any) + case color(Any) - case BezierPath(Any) + case bezierPath(Any) - case AttributedString(Any) + case attributedString(Any) - case Rectangle(Float64,Float64,Float64,Float64) + case rectangle(Float64,Float64,Float64,Float64) - case Point(Float64,Float64) + case point(Float64,Float64) - case Size(Float64,Float64) + case size(Float64,Float64) - case Logical(Bool) + case bool(Bool) - case Range(Int64, Int64) + case range(Int64, Int64) - case View(Any) + case view(Any) - case Sprite(Any) + case sprite(Any) - case URL(String) + case url(String) - case _Raw([UInt8], String) + case _raw([UInt8], String) } String factory methods dealing with nul-terminated UTF-8 data (a.k.a. C-strings) became initializers. extension String { - public static func fromCString(cs: UnsafePointer&lt;CChar&gt;) -&gt; String? + public init?(validatingUTF8 cString: UnsafePointer&lt;CChar&gt;) - public static func fromCStringRepairingIllFormedUTF8(cs: UnsafePointer&lt;CChar&gt;) -&gt; (String?, hadError: Bool) + public init(cString: UnsafePointer&lt;CChar&gt;) + public static func decodeCString&lt;Encoding : UnicodeCodec&gt;( + cString: UnsafePointer&lt;Encoding.CodeUnit&gt;, + as encoding: Encoding.Type, + repairingInvalidCodeUnits isReparing: Bool = true) + -&gt; (result: String, repairsMade: Bool)? } String methods that mirror imported methods on NSString are renamed to reflect the new importing rules. extension String { - public static func localizedNameOfStringEncoding( - encoding: NSStringEncoding - ) -&gt; String + public static func localizedName( + ofStringEncoding encoding: NSStringEncoding + ) -&gt; String - public static func pathWithComponents(components: [String]) -&gt; String + public static func path(withComponents components: [String]) -&gt; String - public init?(UTF8String bytes: UnsafePointer&lt;CChar&gt;) + public init?(utf8String bytes: UnsafePointer&lt;CChar&gt;) - public func canBeConvertedToEncoding(encoding: NSStringEncoding) -&gt; Bool + public func canBeConverted(toEncoding encoding: NSStringEncoding) -&gt; Bool - public var capitalizedString: String + public var capitalized: String - public var localizedCapitalizedString: String + public var localizedCapitalized: String - public func capitalizedStringWithLocale(locale: NSLocale?) -&gt; String + public func capitalized(with locale: NSLocale?) -&gt; String - public func commonPrefixWithString( - aString: String, options: NSStringCompareOptions) -&gt; String + public func commonPrefix( + with aString: String, options: NSStringCompareOptions = []) -&gt; String - public func completePathIntoString( - outputName: UnsafeMutablePointer&lt;String&gt; = nil, - caseSensitive: Bool, - matchesIntoArray: UnsafeMutablePointer&lt;[String]&gt; = nil, - filterTypes: [String]? = nil - ) -&gt; Int + public func completePath( + into outputName: UnsafeMutablePointer&lt;String&gt; = nil, + caseSensitive: Bool, + matchesInto matchesIntoArray: UnsafeMutablePointer&lt;[String]&gt; = nil, + filterTypes: [String]? = nil + ) -&gt; Int - public func componentsSeparatedByCharactersInSet( - separator: NSCharacterSet - ) -&gt; [String] + public func componentsSeparatedByCharacters( + in separator: NSCharacterSet + ) -&gt; [String] - public func componentsSeparatedByString(separator: String) -&gt; [String] + public func componentsSeparated(by separator: String) -&gt; [String] - public func cStringUsingEncoding(encoding: NSStringEncoding) -&gt; [CChar]? + public func cString(usingEncoding encoding: NSStringEncoding) -&gt; [CChar]? - public func dataUsingEncoding( - encoding: NSStringEncoding, - allowLossyConversion: Bool = false - ) -&gt; NSData? + public func data( + usingEncoding encoding: NSStringEncoding, + allowLossyConversion: Bool = false + ) -&gt; NSData? - public func enumerateLinguisticTagsInRange( - range: Range&lt;Index&gt;, - scheme tagScheme: String, - options opts: NSLinguisticTaggerOptions, - orthography: NSOrthography?, - _ body: - (String, Range&lt;Index&gt;, Range&lt;Index&gt;, inout Bool) -&gt; () - ) + public func enumerateLinguisticTags( + in range: Range&lt;Index&gt;, + scheme tagScheme: String, + options opts: NSLinguisticTaggerOptions = [], + orthography: NSOrthography? = nil, + _ body: + (String, Range&lt;Index&gt;, Range&lt;Index&gt;, inout Bool) -&gt; () + ) - public func enumerateSubstringsInRange( - range: Range&lt;Index&gt;, - options opts:NSStringEnumerationOptions, - _ body: ( - substring: String?, substringRange: Range&lt;Index&gt;, - enclosingRange: Range&lt;Index&gt;, inout Bool - ) -&gt; () - ) + public func enumerateSubstrings( + in range: Range&lt;Index&gt;, + options opts:NSStringEnumerationOptions = [], + _ body: ( + substring: String?, substringRange: Range&lt;Index&gt;, + enclosingRange: Range&lt;Index&gt;, inout Bool + ) -&gt; () + ) - public func fileSystemRepresentation() -&gt; [CChar] + public var fileSystemRepresentation: [CChar] - public func getBytes( - inout buffer: [UInt8], - maxLength maxBufferCount: Int, - usedLength usedBufferCount: UnsafeMutablePointer&lt;Int&gt;, - encoding: NSStringEncoding, - options: NSStringEncodingConversionOptions, - range: Range&lt;Index&gt;, - remainingRange leftover: UnsafeMutablePointer&lt;Range&lt;Index&gt;&gt; - ) -&gt; Bool + public func getBytes( + inout buffer: [UInt8], + maxLength maxBufferCount: Int, + usedLength usedBufferCount: UnsafeMutablePointer&lt;Int&gt;, + encoding: NSStringEncoding, + options: NSStringEncodingConversionOptions = [], + range: Range&lt;Index&gt;, + remaining leftover: UnsafeMutablePointer&lt;Range&lt;Index&gt;&gt; + ) -&gt; Bool - public func getLineStart( - start: UnsafeMutablePointer&lt;Index&gt;, - end: UnsafeMutablePointer&lt;Index&gt;, - contentsEnd: UnsafeMutablePointer&lt;Index&gt;, - forRange: Range&lt;Index&gt; - ) + public func getLineStart( + start: UnsafeMutablePointer&lt;Index&gt;, + end: UnsafeMutablePointer&lt;Index&gt;, + contentsEnd: UnsafeMutablePointer&lt;Index&gt;, + for range: Range&lt;Index&gt; + ) - public func getParagraphStart( - start: UnsafeMutablePointer&lt;Index&gt;, - end: UnsafeMutablePointer&lt;Index&gt;, - contentsEnd: UnsafeMutablePointer&lt;Index&gt;, - forRange: Range&lt;Index&gt; - ) + public func getParagraphStart( + start: UnsafeMutablePointer&lt;Index&gt;, + end: UnsafeMutablePointer&lt;Index&gt;, + contentsEnd: UnsafeMutablePointer&lt;Index&gt;, + for range: Range&lt;Index&gt; + ) public init( - contentsOfURL url: NSURL, + contentsOf url: NSURL, encoding enc: NSStringEncoding ) throws public init( - contentsOfURL url: NSURL, + contentsOf url: NSURL, usedEncoding enc: UnsafeMutablePointer&lt;NSStringEncoding&gt; = nil ) throws public init?( - CString: UnsafePointer&lt;CChar&gt;, + cString: UnsafePointer&lt;CChar&gt;, encoding enc: NSStringEncoding ) - public init(format: String, _ arguments: CVarArgType...) + public init(format: String, _ arguments: CVarArg...) - public init(format: String, arguments: [CVarArgType]) + public init(format: String, arguments: [CVarArg]) - public init(format: String, locale: NSLocale?, _ args: CVarArgType...) + public init(format: String, locale: NSLocale?, _ args: CVarArg...) - public init(format: String, locale: NSLocale?, arguments: [CVarArgType]) + public init(format: String, locale: NSLocale?, arguments: [CVarArg]) - public func lengthOfBytesUsingEncoding(encoding: NSStringEncoding) -&gt; Int + public func lengthOfBytes(usingEncoding encoding: NSStringEncoding) -&gt; Int - public func lineRangeForRange(aRange: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt; + public func lineRange(for aRange: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt; - public func linguisticTagsInRange( - range: Range&lt;Index&gt;, - scheme tagScheme: String, - options opts: NSLinguisticTaggerOptions = [], - orthography: NSOrthography? = nil, - tokenRanges: UnsafeMutablePointer&lt;[Range&lt;Index&gt;]&gt; = nil // FIXME:Can this be nil? - ) -&gt; [String] + public func linguisticTags( + in range: Range&lt;Index&gt;, + scheme tagScheme: String, + options opts: NSLinguisticTaggerOptions = [], + orthography: NSOrthography? = nil, + tokenRanges: UnsafeMutablePointer&lt;[Range&lt;Index&gt;]&gt; = nil // FIXME:Can this be nil? + ) -&gt; [String] - public var localizedLowercaseString: String + public var localizedLowercase: String - public func lowercaseStringWithLocale(locale: NSLocale?) -&gt; String + public func lowercaseString(with locale: NSLocale?) -&gt; String - func maximumLengthOfBytesUsingEncoding(encoding: NSStringEncoding) -&gt; Int + func maximumLengthOfBytes(usingEncoding encoding: NSStringEncoding) -&gt; Int - public func paragraphRangeForRange(aRange: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt; + public func paragraphRange(for aRange: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt; - public func rangeOfCharacterFromSet( - aSet: NSCharacterSet, - options mask:NSStringCompareOptions = [], - range aRange: Range&lt;Index&gt;? = nil - ) -&gt; Range&lt;Index&gt;? + public func rangeOfCharacter( + from aSet: NSCharacterSet, + options mask:NSStringCompareOptions = [], + range aRange: Range&lt;Index&gt;? = nil + ) -&gt; Range&lt;Index&gt;? - func rangeOfComposedCharacterSequenceAtIndex(anIndex: Index) -&gt; Range&lt;Index&gt; + func rangeOfComposedCharacterSequence(at anIndex: Index) -&gt; Range&lt;Index&gt; - public func rangeOfComposedCharacterSequencesForRange( - range: Range&lt;Index&gt; - ) -&gt; Range&lt;Index&gt; + public func rangeOfComposedCharacterSequences( + for range: Range&lt;Index&gt; + ) -&gt; Range&lt;Index&gt; - public func rangeOfString( - aString: String, - options mask: NSStringCompareOptions = [], - range searchRange: Range&lt;Index&gt;? = nil, - locale: NSLocale? = nil - ) -&gt; Range&lt;Index&gt;? + public func range( + of aString: String, + options mask: NSStringCompareOptions = [], + range searchRange: Range&lt;Index&gt;? = nil, + locale: NSLocale? = nil + ) -&gt; Range&lt;Index&gt;? - public func localizedStandardContainsString(string: String) -&gt; Bool + public func localizedStandardContains(string: String) -&gt; Bool - public func localizedStandardRangeOfString(string: String) -&gt; Range&lt;Index&gt;? + public func localizedStandardRange(of string: String) -&gt; Range&lt;Index&gt;? - public var stringByAbbreviatingWithTildeInPath: String + public var abbreviatingWithTildeInPath: String - public func stringByAddingPercentEncodingWithAllowedCharacters( - allowedCharacters: NSCharacterSet - ) -&gt; String? + public func addingPercentEncoding( + withAllowedCharaters allowedCharacters: NSCharacterSet + ) -&gt; String? - public func stringByAddingPercentEscapesUsingEncoding( - encoding: NSStringEncoding - ) -&gt; String? + public func addingPercentEscapes( + usingEncoding encoding: NSStringEncoding + ) -&gt; String? - public func stringByAppendingFormat( - format: String, _ arguments: CVarArgType... - ) -&gt; String + public func appendingFormat( + format: String, _ arguments: CVarArg... + ) -&gt; String - public func stringByAppendingPathComponent(aString: String) -&gt; String + public func appendingPathComponent(aString: String) -&gt; String - public func stringByAppendingPathExtension(ext: String) -&gt; String? + public func appendingPathExtension(ext: String) -&gt; String? - public func stringByAppendingString(aString: String) -&gt; String + public func appending(aString: String) -&gt; String - public var stringByDeletingLastPathComponent: String + public var deletingLastPathComponent: String - public var stringByDeletingPathExtension: String + public var deletingPathExtension: String - public var stringByExpandingTildeInPath: String + public var expandingTildeInPath: String - public func stringByFoldingWithOptions( - options: NSStringCompareOptions, locale: NSLocale? - ) -&gt; String + public func folding( + options: NSStringCompareOptions = [], locale: NSLocale? + ) -&gt; String - public func stringByPaddingToLength( - newLength: Int, withString padString: String, startingAtIndex padIndex: Int - ) -&gt; String + public func padding( + toLength newLength: Int, + with padString: String, + startingAt padIndex: Int + ) -&gt; String - public var stringByRemovingPercentEncoding: String? + public var removingPercentEncoding: String? - public func stringByReplacingCharactersInRange( - range: Range&lt;Index&gt;, withString replacement: String - ) -&gt; String + public func replacingCharacters( + in range: Range&lt;Index&gt;, with replacement: String + ) -&gt; String - public func stringByReplacingOccurrencesOfString( - target: String, - withString replacement: String, - options: NSStringCompareOptions = [], - range searchRange: Range&lt;Index&gt;? = nil - ) -&gt; String + public func replacingOccurrences( + of target: String, + with replacement: String, + options: NSStringCompareOptions = [], + range searchRange: Range&lt;Index&gt;? = nil + ) -&gt; String - public func stringByReplacingPercentEscapesUsingEncoding( - encoding: NSStringEncoding - ) -&gt; String? + public func replacingPercentEscapes( + usingEncoding encoding: NSStringEncoding + ) -&gt; String? - public var stringByResolvingSymlinksInPath: String + public var resolvingSymlinksInPath: String - public var stringByStandardizingPath: String + public var standardizingPath: String - public func stringByTrimmingCharactersInSet(set: NSCharacterSet) -&gt; String + public func trimmingCharacters(in set: NSCharacterSet) -&gt; String - public func stringsByAppendingPaths(paths: [String]) -&gt; [String] + public func strings(byAppendingPaths paths: [String]) -&gt; [String] - public func substringFromIndex(index: Index) -&gt; String + public func substring(from index: Index) -&gt; String - public func substringToIndex(index: Index) -&gt; String + public func substring(to index: Index) -&gt; String - public func substringWithRange(aRange: Range&lt;Index&gt;) -&gt; String + public func substring(with aRange: Range&lt;Index&gt;) -&gt; String - public var localizedUppercaseString: String + public var localizedUppercase: String - public func uppercaseStringWithLocale(locale: NSLocale?) -&gt; String + public func uppercaseString(with locale: NSLocale?) -&gt; String - public func writeToFile( - path: String, atomically useAuxiliaryFile:Bool, - encoding enc: NSStringEncoding - ) throws + public func write( + toFile path: String, atomically useAuxiliaryFile:Bool, + encoding enc: NSStringEncoding + ) throws - public func writeToURL( - url: NSURL, atomically useAuxiliaryFile: Bool, - encoding enc: NSStringEncoding - ) throws + public func write( + to url: NSURL, atomically useAuxiliaryFile: Bool, + encoding enc: NSStringEncoding + ) throws - public func stringByApplyingTransform( - transform: String, reverse: Bool - ) -&gt; String? + public func applyingTransform( + transform: String, reverse: Bool + ) -&gt; String? - public func containsString(other: String) -&gt; Bool + public func contains(other: String) -&gt; Bool - public func localizedCaseInsensitiveContainsString(other: String) -&gt; Bool + public func localizedCaseInsensitiveContains(other: String) -&gt; Bool } Miscellaneous changes. public struct EnumeratedIterator&lt;Base : IteratorProtocol&gt; : ... { - public typealias Element = (index: Int, element: Base.Element) + public typealias Element = (offset: Int, element: Base.Element) } public struct Array&lt;Element&gt; : ... { // Same changes were also applied to `ArraySlice` and `ContiguousArray`. - public init(count: Int, repeatedValue: Element) + public init(repeating: Element, count: Int) } public protocol Sequence : ... { public func split( - maxSplit: Int = Int.max, + maxSplits maxSplits: Int = Int.max, - allowEmptySlices: Bool = false, + omittingEmptySubsequences: Bool = true, @noescape isSeparator: (Iterator.Element) throws -&gt; Bool ) rethrows -&gt; [SubSequence] } extension Sequence where Iterator.Element : Equatable { public func split( - separator: Iterator.Element, + separator separator: Iterator.Element, - maxSplit: Int = Int.max, + maxSplits maxSplits: Int = Int.max, - allowEmptySlices: Bool = false + omittingEmptySubsequences: Bool = true ) -&gt; [AnySequence&lt;Iterator.Element&gt;] { } public protocol Sequence : ... { - public func lexicographicalCompare&lt; + public func lexicographicallyPrecedes&lt; OtherSequence : Sequence where OtherSequence.Iterator.Element == Iterator.Element &gt;( other: OtherSequence, @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Bool { } extension Sequence where Iterator.Element : Equatable { - public func lexicographicalCompare&lt; + public func lexicographicallyPrecedes&lt; OtherSequence : Sequence where OtherSequence.Iterator.Element == Iterator.Element &gt;( other: OtherSequence ) -&gt; Bool { } public protocol Collection : ... { - func prefixUpTo(end: Index) -&gt; SubSequence + func prefix(upTo end: Index) -&gt; SubSequence - func suffixFrom(start: Index) -&gt; SubSequence + func suffix(from start: Index) -&gt; SubSequence - func prefixThrough(position: Index) -&gt; SubSequence + func prefix(through position: Index) -&gt; SubSequence } // Changes to this protocol affect `Array`, `ArraySlice`, `ContiguousArray` and // other types. public protocol RangeReplaceableCollection : ... { + public init(repeating repeatedValue: Iterator.Element, count: Int) - mutating func replaceRange&lt; + mutating func replaceSubrange&lt; C : CollectionType where C.Iterator.Element == Iterator.Element &gt;( subRange: Range&lt;Int&gt;, with newElements: C ) - mutating func insert(newElement: Iterator.Element, atIndex i: Int) + mutating func insert(newElement: Iterator.Element, at i: Int) - mutating func insertContentsOf&lt; + mutating func insert&lt; S : Collection where S.Iterator.Element == Iterator.Element - &gt;(newElements: S, at i: Index) + &gt;(contentsOf newElements: S, at i: Index) - mutating func removeAtIndex(index: Int) -&gt; Element + mutating func remove(at index: Int) -&gt; Element - mutating func removeAll(keepCapacity keepCapacity: Bool = false) + mutating func removeAll(keepingCapacity keepingCapacity: Bool = false) - mutating func removeRange(subRange: Range&lt;Index&gt;) + mutating func removeSubrange(subRange: Range&lt;Index&gt;) - mutating func appendContentsOf&lt;S : SequenceType&gt;(newElements: S) + mutating func append&lt;S : SequenceType&gt;(contentsOf newElements: S) } +extension Set : SetAlgebra {} public struct Dictionary&lt;Key : Hashable, Value&gt; : ... { - public typealias Element = (Key, Value) + public typealias Element = (key: Key, value: Value) } public struct DictionaryLiteral&lt;Key, Value&gt; : ... { - public typealias Element = (Key, Value) + public typealias Element = (key: Key, value: Value) } extension String { - public mutating func appendContentsOf(other: String) { + public mutating func append(other: String) { - public mutating appendContentsOf&lt;S : SequenceType&gt;(newElements: S) + public mutating append&lt;S : SequenceType&gt;(contentsOf newElements: S) - public mutating func replaceRange&lt; + public mutating func replaceSubrange&lt; C: CollectionType where C.Iterator.Element == Character &gt;( subRange: Range&lt;Index&gt;, with newElements: C ) - public mutating func replaceRange( + public mutating func replaceSubrange( subRange: Range&lt;Index&gt;, with newElements: String ) - public mutating func insert(newElement: Character, atIndex i: Index) + public mutating func insert(newElement: Character, at i: Index) - public mutating func insertContentsOf&lt; + public mutating func insert&lt; S : Collection where S.Iterator.Element == Character - &gt;(newElements: S, at i: Index) + &gt;(contentsOf newElements: S, at i: Index) - public mutating func removeAtIndex(i: Index) -&gt; Character + public mutating func remove(at i: Index) -&gt; Character - public mutating func removeRange(subRange: Range&lt;Index&gt;) + public mutating func removeSubrange(subRange: Range&lt;Index&gt;) - mutating func removeAll(keepCapacity keepCapacity: Bool = false) + mutating func removeAll(keepingCapacity keepingCapacity: Bool = false) - public init(count: Int, repeatedValue c: Character) + public init(repeating repeatedValue: Character, count: Int) - public init(count: Int, repeatedValue c: UnicodeScalar) + public init(repeating repeatedValue: UnicodeScalar, count: Int) - public var utf8: UTF8View { get } + public var utf8: UTF8View { get set } - public var utf16: UTF16View { get } + public var utf16: UTF16View { get set } - public var characters: CharacterView { get } + public var characters: CharacterView { get set } } public enum UnicodeDecodingResult { - case Result(UnicodeScalar) - case EmptyInput - case Error + case scalarValue(UnicodeScalar) + case emptyInput + case error } public struct ManagedBufferPointer&lt;Value, Element&gt; : ... { - public var allocatedElementCount: Int { get } + public var capacity: Int { get } } public struct RangeIterator&lt;Element : ForwardIndex&gt; : ... { - public var startIndex: Element { get set } - public var endIndex: Element { get set } } public struct ObjectIdentifier : ... { - public var uintValue: UInt { get } } extension UInt { + /// Create a `UInt` that captures the full value of `objectID`. + public init(_ objectID: ObjectIdentifier) } extension Int { + /// Create an `Int` that captures the full value of `objectID`. + public init(_ objectID: ObjectIdentifier) } -public struct Repeat&lt;Element&gt; : ... { ... } +public struct Repeated&lt;Element&gt; : ... { ... } public struct StaticString : ... { - public var byteSize: Int { get } + public var utf8CodeUnitCount: Int { get } // Use the &#39;String(_:)&#39; initializer. - public var stringValue: String { get } } extension Strideable { - public func stride(to end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt; } +public func stride&lt;T : Strideable&gt;(from start: T, to end: T, by stride: T.Stride) -&gt; StrideTo&lt;T&gt; extension Strideable { - public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt; } +public func stride&lt;T : Strideable&gt;(from start: T, through end: T, by stride: T.Stride) -&gt; StrideThrough&lt;T&gt; public func transcode&lt; Input : IteratorProtocol, InputEncoding : UnicodeCodec, OutputEncoding : UnicodeCodec where InputEncoding.CodeUnit == Input.Element&gt;( inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type, _ input: Input, _ output: (OutputEncoding.CodeUnit) -&gt; Void, - stopOnError: Bool + stoppingOnError: Bool ) -&gt; Bool extension UnsafeMutablePointer { - public static func alloc(num: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt; + public init(allocatingCapacity count: Int) - public func dealloc(num: Int) + public func deallocateCapacity(count: Int) - public func initialize(newvalue: Memory) + public func initializePointee(newValue: Pointee, count: Int = 1) - public func move() -&gt; Memory + public func take() -&gt; Pointee - public func destroy() - public func destroy(count: Int) + public func deinitializePointee(count count: Int = 1) } -public struct COpaquePointer : ... { ... } +public struct OpaquePointer : ... { ... } -public func unsafeAddressOf(object: AnyObject) -&gt; UnsafePointer&lt;Void&gt; +public func unsafeAddress(of object: AnyObject) -&gt; UnsafePointer&lt;Void&gt; -public func unsafeBitCast&lt;T, U&gt;(x: T, _: U.Type) -&gt; U +public func unsafeBitCast&lt;T, U&gt;(x: T, to: U.Type) -&gt; U -public func unsafeDowncast&lt;T : AnyObject&gt;(x: AnyObject) -&gt; T +public func unsafeDowncast&lt;T : AnyObject&gt;(x: AnyObject, to: T.Type) -&gt; T -public func print&lt;Target: OutputStream&gt;( +public func print&lt;Target : OutputStream&gt;( items: Any..., separator: String = &quot; &quot;, terminator: String = &quot; n&quot;, - inout toStream output: Target + inout to output: Target ) -public func debugPrint&lt;Target: OutputStream&gt;( +public func debugPrint&lt;Target : OutputStream&gt;( items: Any..., separator: String = &quot; &quot;, terminator: String = &quot; n&quot;, - inout toStream output: Target + inout to output: Target ) public struct Unmanaged&lt;Instance : AnyObject&gt; { - public func toOpaque() -&gt; COpaquePointer } extension OpaquePointer { + public init&lt;T&gt;(bitPattern bits: Unmanaged&lt;T&gt;) } public enum UnicodeDecodingResult + : Equatable { - public var isEmptyInput: Bool } -public func readLine(stripNewline stripNewline: Bool = true) -&gt; String? +public func readLine(strippingNewline strippingNewline: Bool = true) -&gt; String? struct UnicodeScalar { // Use &#39;UnicodeScalar(&quot; 0&quot;)&#39; instead. - init() - public func escape(asASCII forceASCII: Bool) -&gt; String + public func escaped(asASCII forceASCII: Bool) -&gt; String } public func transcode&lt; Input : IteratorProtocol, InputEncoding : UnicodeCodec, OutputEncoding : UnicodeCodec where InputEncoding.CodeUnit == Input.Element &gt;( - inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type, - _ input: Input, _ output: (OutputEncoding.CodeUnit) -&gt; Void, - stoppingOnError stopOnError: Bool + input: Input, + from inputEncoding: InputEncoding.Type, + to outputEncoding: OutputEncoding.Type, + stoppingOnError stopOnError: Bool, + sendingOutputTo processCodeUnit: (OutputEncoding.CodeUnit) -&gt; Void ) -&gt; Bool extension UTF16 { - public static func measure&lt; + public static func transcodedLength&lt; Encoding : UnicodeCodec, Input : IteratorProtocol where Encoding.CodeUnit == Input.Element &gt;( - _: Encoding.Type, input: Input, repairIllFormedSequences: Bool + of input: Input, + decodedAs sourceEncoding: Encoding.Type, + repairingIllFormedSequences: Bool - ) -&gt; (Int, Bool)? + ) -&gt; (count: Int, isASCII: Bool)? { } -public struct RawByte {} -final public class VaListBuilder {} -public func withVaList&lt;R&gt;( - builder: VaListBuilder, - @noescape _ f: CVaListPointer -&gt; R) --&gt; R Impact on existing code The proposed changes are massively source-breaking for Swift code, and will require a migrator to translate Swift 2 code into Swift 3 code. The API diffs from this proposal will be the primary source of the information about the required transformations. In addition, to the extent the language allows, the library will keep old names as unavailable symbols with a renamed annotation, that allows the compiler to produce good error messages and emit Fix-Its.",
    "url": "http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html",
    "relUrl": "/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html"
  },
  "6": {
    "id": "6",
    "title": "SE-0007 Remove C-style for-loops with conditions and incrementers",
    "content": "Remove C-style for-loops with conditions and incrementers Proposal: SE-0007 Author: Erica Sadun Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Bugs: SR-226, SR-227 Introduction The C-style for-loop appears to be a mechanical carry-over from C rather than a genuinely Swift-specific construct. It is rarely used and not very Swift-like. More Swift-typical construction is already available with for-in statements and stride. Removing for loops would simplify the language and starve the most common use-points for -- and ++, which are already due to be eliminated from the language. The value of this construct is limited and I believe its removal should be seriously considered. This proposal was discussed on the Swift Evolution list in the C-style For Loops thread and reviewed in the [Review] Remove C-style for-loops with conditions and incrementers thread. Advantages of For Loops Swift design supported a shallow learning curve using familiar constants and control structures. The for-loop mimics C and limits the effort needed to master this control flow. Disadvantages of For Loops Both for-in and stride provide equivalent behavior using Swift-coherent approaches without being tied to legacy terminology. There is a distinct expressive disadvantage in using for-loops compared to for-in in succinctness for-loop implementations do not lend themselves to use with collections and other core Swift types. The for-loop encourages use of unary incrementors and decrementors, which will be soon removed from the language. The semi-colon delimited declaration offers a steep learning curve from users arriving from non C-like languages If the for-loop did not exist, I doubt it would be considered for inclusion in Swift 3. Proposed Approach I suggest that the for-loop be deprecated in Swift 2.x and removed entirely in Swift 3, with coverage removed from the Swift Programming Language to match the revisions in the current 2.2 update. Alternatives considered Not removing for-loop from Swift, losing the opportunity to streamline the language and discard an unneeded control flow item. Impact on existing code A search of the Apple Swift codebase suggests this feature is rarely used. Community members of the Swift-Evolution mail list confirm that it does not feature in many pro-level apps and can be worked around for those few times when for-loops do pop up. For example: char *blk_xor(char *dst, const char *src, size_t len) { const char *sp = src; for (char *dp = dst; sp - src &lt; len; sp++, dp++) *dp ^= *sp; return dst; } versus func blk_xor(dst: UnsafeMutablePointer&lt;CChar&gt;, src: UnsafePointer&lt;CChar&gt;, len: Int) -&gt; UnsafeMutablePointer&lt;CChar&gt; { for i in 0..&lt;len { dst[i] ^= src[i] } return dst } A search of github’s Swift gists suggests the approach is used primarily by those new to the language with minimal language skills and is abandoned as language mastery is achieved. For example: for var i = 0 ; i &lt; 10 ; i++ { print(i) } and var array = [10,20,30,40,50] for(var i=0 ; i &lt; array.count ;i++){ println(&quot;array[i] (array[i])&quot;) } Community Responses “I am certainly open to considering dropping the C-style for loop. IMO, it is a rarely used feature of Swift that doesn’t carry its weight. Many of the reasons to remove them align with the rationale for removing – and ++. “ – Chris Lattner, clattner@apple.com “My intuition completely agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I’d like to see is how often C-style for loops are actually used in Swift. It’s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it’s a good candidate for removal.” – Douglas Gregnor, dgregor@apple.com “Every time I’ve used a C-style for loop in Swift it was because I forgot that .indices existed. If it’s removed, a fixme pointing that direction might be useful.” – David Smith, david_smith@apple.com “For what it’s worth we don’t have a single C style for loop in the Lyft codebase.” – Keith Smiley, keithbsmiley@gmail.com “Just checked; ditto Khan Academy.” – Andy Matsuchak, andy@andymatuschak.org “We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.” – Eric Chamberlain, eric.chamberlain@arctouch.com “Every time I’ve tried to use a C-style for loop, I’ve ended up switching to a while loop because my iteration variable ended up having the wrong type (e.g. having an optional type when the value must be non-optional for the body to execute). The Postmates codebase contains no instances of C-style for loops in Swift.” – Lily Ballard, lily@sb.org “I found a couple of cases of them in my codebase, but they were trivially transformed into “proper” Swift-style for loops that look better anyway. If it were a vote, I’d vote for eliminating C-style.” – Sean Heber, sean@fifthace.com",
    "url": "http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html",
    "relUrl": "/docs/2019-08-26-0007-remove-c-style-for-loops.html"
  },
  "7": {
    "id": "7",
    "title": "SE-0008 Add a Lazy flatMap for Sequences of Optionals #",
    "content": "Add a Lazy flatMap for Sequences of Optionals Proposal: SE-0008 Author: Oisin Kidney Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-361 Introduction Currently, the Swift standard library has two versions of flatMap. One which flattens a sequence of sequences after a transformation: [1, 2, 3] .flatMap { n in n..&lt;5 } // [1, 2, 3, 4, 2, 3, 4, 3, 4] And another which flattens a sequence of Optionals: (1...10) .flatMap { n in n % 2 == 0 ? n/2 : nil } // [1, 2, 3, 4, 5] However, there is only a lazy implementation for the first version: [1, 2, 3] .lazy .flatMap { n in n..&lt;5 } // LazyCollection&lt;FlattenBidirectionalCollection&lt;LazyMapCollection&lt;Array&lt;Int&gt;, Range&lt;Int&gt;&gt;&gt;&gt; (1...10) .lazy .flatMap { n in n % 2 == 0 ? n/2 : nil } // [1, 2, 3, 4, 5] Swift Evolution Discussions: Lazy flatMap for Optionals, Review Motivation Seeing as the already-existing flatMap has a lazy version for nested sequences, a missing lazy version for sequences of Optionals seems like a gap. The usefulness of lazy sequences is well documented, especially when refactoring imperative nested for-loops into chains of methods, which can unnecessarily allocate intermediate arrays if done eagerly. Proposed Approach Making use of already-existing types in the standard library, flatMap’s functionality can be achieved with a map-filter-map chain: extension LazySequenceType { @warn_unused_result public func flatMap&lt;T&gt;(transform: Elements.Generator.Element -&gt; T?) -&gt; LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Elements, T?&gt;&gt;, T&gt; { return self .map(transform) .filter { opt in opt != nil } .map { notNil in notNil! } } } Detailed Design A version for LazyCollectionTypes is almost identical: extension LazyCollectionType { @warn_unused_result public func flatMap&lt;T&gt;(transform: Elements.Generator.Element -&gt; T?) -&gt; LazyMapCollection&lt;LazyFilterCollection&lt;LazyMapCollection&lt;Elements, T?&gt;&gt;, T&gt; { return self .map(transform) .filter { opt in opt != nil } .map { notNil in notNil! } } } However, a “bidirectional” version cannot be written in this way, since no FilterBidirectionalCollection exists. The other form of flatMap uses a flatten method on nested sequences, which has both a CollectionType form and a form for CollectionTypes with BidirectionalIndexTypes. However, Swift’s current type system doesn’t allow a similar method to be defined on sequences of Optionals. This means we have to rely on filter, which only has a SequenceType and CollectionType implementation. Impact on existing code Alternatives considered Custom struct It would also be possible to add a new struct, and a method on LazySequenceType: public struct FlatMapOptionalGenerator&lt;G: GeneratorType, Element&gt;: GeneratorType { private let transform: G.Element -&gt; Element? private var generator: G public mutating func next() -&gt; Element? { while let next = generator.next() { if let transformed = transform(next) { return transformed } } return nil } } public struct FlatMapOptionalSequence&lt;S: LazySequenceType, Element&gt;: LazySequenceType { private let transform: S.Generator.Element -&gt; Element? private let sequence: S public func generate() -&gt; FlatMapOptionalGenerator&lt;S.Generator, Element&gt; { return FlatMapOptionalGenerator(transform: transform, generator: sequence.generate()) } } extension LazySequenceType { public func flatMap&lt;T&gt;(transform: Generator.Element -&gt; T?) -&gt; FlatMapOptionalSequence&lt;Self, T&gt; { return FlatMapOptionalSequence(transform: transform, sequence: self) } } However, this implementation does not have a LazyCollectionType version. To add one, and a bidirectional implementation, six new types (three SequenceTypes, three GeneratorTypes) would have to be added to the standard library. New Filter struct This would involve adding a FilterBidirectionalCollection to the standard library. Arguably, this is a gap currently. It would allow both flatMap versions to mirror each other, with minimal new types. Make Optional Conform to SequenceType This is a far-reaching, separate proposal, but it would solve the issue that this proposal seeks to solve. It’s worth bearing in mind, though, that Optional probably wouldn’t have a BidirectionalIndexType, so the bidirectional version of flatMap wouldn’t exist on Optionals, anyway.",
    "url": "http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html",
    "relUrl": "/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html"
  },
  "8": {
    "id": "8",
    "title": "SE-0009 Require self for accessing instance members",
    "content": "Require self for accessing instance members Proposal: SE-0009 Author: David Hart Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction The current version of Swift (2.1) requires using self when accessing instance members in closures. The proposal suggests extending this to all member accesses (as is intrinsically the case in Objective-C). It has the benefit of documenting instance properties vs local variables and instance functions vs local functions or closures. Swift Evolution Discussion Thread Motivation This proposal makes it obvious which are instance properties vs local variables, as well as which are instance functions vs local functions/closures. This has several advantages: More readable at the point of use. More consistent than only requiring self in closure contexts. Less confusing from a learning point of view. Lets the compiler warn users (and avoids bugs) where the authors mean to use a local variable but instead are unknowingly using an instance property (and the other way round). One example of a bug avoidable by the proposal (provided by Rudolf Adamkovic): class MyViewController : UIViewController { @IBOutlet var button: UIButton! var name: String = &quot;David&quot; func updateButton() { // var title = &quot;Hello (name)&quot; button.setTitle(title, forState: .Normal) // forgot to comment this line but the compiler does not complain and title is now referencing UIViewController’s title by mistake button.setTitleColor(UIColor.blackColor(), forState: .Normal) } } The API Design Guidelines are meant for writing APIs but I still think they represent fundamentals of Swift. The two first points are: Clarity at the point of use is your most important goal. Code is read far more than it is written. Clarity is more important than brevity. Although Swift code can be compact, it is a non-goal to enable the smallest possible code with the fewest characters. Brevity in Swift code, where it occurs, is a side-effect of the strong type system and features that naturally reduce boilerplate. And I believe that the proposition is directly in line with those objectives. Counter-argument The counter-argument brought up by two members of the community is that the current behaviour “makes the capturing semantics of self stand out more in closures”. While this is true, the author finds its usefulness lacking. In the following lines of code, we know without a shadow of a doubt that foobar is a throwing function and that barfoo does not throw. try foobar() barfoo() But with an example of self in a closure: foobar({ print(self.description) }) The self keyword in the previous lines of code gives a hint but does not bring any certitudes: self might have been forced by the compiler to hint at possible memory issues, self might have been a programmer choice if the closure is non-escaping. And in the reverse example: barfoo({ print(description) }) the closure might be non-escaping, the description might be referring to a local variable (which we missed the declaration of) shadowing the instance property in an escaping closure. In both of these examples, the self keyword does not tell us with any certainty that we should or not be careful about reference cycle issues without checking the signature of the called function, only that self is captured. With the proposition, self gets some meaning back: it indicates which are local and which are instance properties. Proposed Solution I suggest that not using self for accessing instance properties and functions is applied in two stages. In Swift 2.x, it could start as a warning and Xcode could provide a Fix-It. Then, it could become a compiler error in Swift 3 and the migrator would help transition code over. The following code which used to compile would generate an error at the documented lines: class Person { var name: String = &quot;David&quot; func foo() { print(&quot;Hello (name)&quot;) // would not compile } func bar() { foo() // would not compile } } The code would have to be modified as so to compile correctly: class Person { var name: String = &quot;David&quot; func foo() { print(&quot;Hello (self.name)&quot;) } func bar() { self.foo() } } Impact on existing code A lot of code written since the original change would be impacted by this proposal, but it seems like it can be easily fixed by both the migrator tool and an Xcode Fix-It. Alternatives considered The alternative is to keep the current behaviour, but it has the aforementioned disadvantages. An alternative would be to demote from a compiler error to a warning. Community Responses “I actually encountered at least two bugs in my app introduced by this implicit “self” behavior. It can be dangerous and hard to track down.” – Rudolf Adamkovic, salutis@me.com “Given this, some teams use underscores for their iVars which is very unfortunate. Myself, I use self whenever possible to be explicit. I’d like the language to force us to be clear.” – Dan, robear18@gmail.com “I’m not sure how many Swift users this effects, but I’m colorblind and I really struggle with the local vs properties syntax coloring.” – Tyler Cloutier, cloutiertyler@aol.com “+1 I’ve had a lot of weird things happen that I’ve traced to mistakes in properties having the same name as function arguments. I’ve hardly ever had this issue in modern Obj-C.” – Colin Cornaby, colin.cornaby@mac.com “Teaching wise, its much less confusing for self to be required so students don’t mix up instance properties and local vars. Especially when self is required in closures, it confuses students. If self is mandatory for all instance properties, it would be so much clearer and much easier to read.” – Yichen Cao, ycao@me.com “this avoids confusion, maintains a consistent language approach, and thus helps reducing bugs. Sure, it might lead to less poetic haiku code, but that is not necessarily a bad thing in medium to large scale software products with more than one person working on it and possible/eventual change of people on the project over time.” – Panajev “I’m +1 on this, for the reasons already stated by others, but not as strongly as I was a year ago. I was very worried about this with Swift 1 was first released, but since then, I haven’t actually made this mistake, possibly because I’m so paranoid about it.” – Michael Buckley, michael@buckleyisms.com",
    "url": "http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html",
    "relUrl": "/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html"
  },
  "9": {
    "id": "9",
    "title": "SE-0010 Add StaticString.UnicodeScalarView",
    "content": "Add StaticString.UnicodeScalarView Proposal: SE-0010 Author: Lily Ballard Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction There is no way to create a substring of a StaticString that is still typed as StaticString. There should be. Swift Evolution Discussion Thread, Review Motivation It is occasionally useful to be able to produce a substring of a StaticString that can be passed to APIs expecting a StaticString. For example, extracting the filename from __FILE__. But there is no way to do this today, as StaticString does not provide any means by which to create a new instance beyond the trivial nullary init() initializer (which creates an empty string). Proposed solution We add a new type StaticString.UnicodeScalarView that conforms to CollectionType and a new property unicodeScalars on StaticString. We also add 2 initializers to StaticString init(_ unicodeScalars: UnicodeScalarView) init(_ unicodeScalars: Slice&lt;UnicodeScalarView&gt;) Together, this allows the user to manipulate the unicode scalar view to produce the desired slice, and then to create a StaticString from the results. This has the added benefit of providing a convenient way to work with StaticStrings as a sequence of UnicodeScalars instead of as a UTF8 buffer. Detailed design The API looks like this: extension StaticString { /// The value of `self` as a collection of [Unicode scalar values](http://www.unicode.org/glossary/#unicode_scalar_value). public var unicodeScalars: UnicodeScalarView { get } /// Construct the `StaticString` corresponding to the given /// `UnicodeScalarView`. public init(_: UnicodeScalarView) /// Construct the `StaticString` corresponding to the given /// `UnicodeScalarView` slice. public init(_: Slice&lt;UnicodeScalarView&gt;) /// A collection of [Unicode scalar values](http://www.unicode.org/glossary/#unicode_scalar_value) that /// encode a `StaticString`. public struct UnicodeScalarView : CollectionType { init(_: StaticString) /// A position in a `StaticString.UnicodeScalarView`. public struct Index : BidirectionalIndexType, Comparable { /// Returns the next consecutive value after `self`. /// /// - Requires: The next value is representable. @warn_unused_result public func successor() -&gt; Index /// Returns the previous consecutive value before `self`. /// /// - Requires: The previous value is representable. @warn_unused_result public func predecessor() -&gt; Index } /// The position of the first `UnicodeScalar` if the `StaticString` is /// non-empty; identical to `endIndex` otherwise. public var startIndex: Index { get } /// The &quot;past the end&quot; position. /// /// `endIndex` is not a valid argument to `subscript`, and is always /// reachable from `startIndex` by zero or more applications of /// `successor()`. public var endIndex: Index { get } /// Returns `true` iff `self` is empty. public var isEmpty: Bool { get } public subscript(position: Index) -&gt; UnicodeScalar { get } } } Impact on existing code None. Alternatives considered We could add a subscript(bounds: Range&lt;Index&gt;) to StaticString directly, but there’s no good way to define Index (for the same reasons String doesn’t conform to CollectionType). We could expose an unsafe initializer from a pointer, so the user can manipulate utf8Start to produce the desired pointer, but this would be very unsafe and allow users to try and trick code taking StaticString into accepting a dynamic string instead.",
    "url": "http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html",
    "relUrl": "/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html"
  },
  "10": {
    "id": "10",
    "title": "SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations",
    "content": "Replace typealias keyword with associatedtype for associated type declarations Proposal: SE-0011 Author: Loïc Lecrenier Review Manager: Doug Gregor Status: Implemented (Swift 2.2) Decision Notes: Rationale Bug: SR-511 Introduction The typealias keyword is currently used to declare two kinds of types: Type Aliases (alternative name for an existing type) Associated Types (placeholder name to type used as part of a protocol) These two kinds of declarations are different and should use distinct keywords. This would emphasize the difference between them and reduce some of the confusion surrounding the use of associated types. The proposed new keyword is associatedtype. Review Thread Motivation Re-using typealias for associated type declarations is confusing in many ways. It is not obvious that typealias in protocols means something else than in other places. It hides the existence of associated types to beginners, which allows them to write code they misunderstand. It is not clear that concrete type aliases are forbidden inside protocols. In particular, 2 + 3 leads to programmers writing protocol Prot { typealias Container : SequenceType typealias Element = Container.Generator.Element } without realizing that Element is a new associated type with a default value of Container.Generator.Element instead of a type alias to Container.Generator.Element. However, this code protocol Prot { typealias Container : SequenceType } extension Prot { typealias Element = Container.Generator.Element } declares Element as a type alias to Container.Generator.Element. These subtleties of the language currently require careful consideration to understand. Proposed solution For declaring associated types, replace the typealias keyword with associatedtype. This solves the issues mentioned above: typealias can now only be used for type aliases declaration. Beginners are now forced to learn about associated types when creating protocols. An error message can now be displayed when someone tries to create a type alias inside a protocol. This eliminates the confusion showed in the previous code snippets. protocol Prot { associatedtype Container : SequenceType typealias Element = Container.Generator.Element // error: cannot declare type alias inside protocol, use protocol extension instead } protocol Prot { associatedtype Container : SequenceType } extension Prot { typealias Element = Container.Generator.Element } Alternative keywords considered: type, associated, requiredtype, placeholdertype, … Proposed Approach For declaring associated types, I suggest adding associatedtype and deprecating typealias in Swift 2.2, and removing typealias entirely in Swift 3. Impact on existing code As it simply replaces one keyword for another, the transition to associatedtype could be easily automated without any risk of breaking existing code. Mailing List Original Alternative Keywords",
    "url": "http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html",
    "relUrl": "/docs/2019-08-26-0011-replace-typealias-associated.html"
  },
  "11": {
    "id": "11",
    "title": "SE-0012 Add `@noescape` to public library API",
    "content": "Add @noescape to public library API Proposal: SE-0012 Author: Jacob Bandes-Storch Review Manager: Philippe Hausler Status: Rejected Decision Notes: Rationale Revision history v1 Initial version v1.2 Updates after component owners review and discussion Summary Swift provides the @noescape declaration attribute which indicates that a closure’s execution is guaranteed not to escape the function call. clang also provides support for this via a “noescape” attribute, which is automatically imported into Swift as @noescape We propose exposing this attribute in CF and Foundation as CF_NOESCAPE and NS_NOESCAPE We also propose applying this declaration to a number of closure-taking APIs in CF and Foundation Swift Evolution Discussion Thread Introduction @noescape Swift provides a @noescape declaration attribute which can be applied to closure parameters, indicating that the closure’s execution is guaranteed not to escape the function call. func withLock(@noescape perform closure: () -&gt; Void) { myLock.lock() closure() myLock.unlock() } Thus, a closure argument is guaranteed to be executed (if executed at all) before the function returns. This enables the compiler to perform various optimizations, such as omitting unnecessary capturing/retaining/releasing of self. For example, just as “self.” may be omitted in the context of a method, since a @noescape closure is known not to capture self, properties and methods can be accessed without the self. prefix: class MyClass { var counter = 0 func incrementCounter() { counter += 1 // &quot;self.&quot; elided in an instance method withLock { // Without @noescape, the following line would produce the error // &quot;reference to property &#39;counter&#39; in closure requires // explicit &#39;self.&#39; to make capture semantics explicit&quot;. counter += 1 } } } In C and Objective-C Clang understands the noescape attribute, spelled __attribute__((noescape)) or __attribute__((__noescape__)). When function definitions whose block or function-pointer parameters have this attribute are imported to Swift, they are visible with a Swift @noescape attribute. void performWithLock(__attribute__((noescape)) void (^block)()) { // exposed as @noescape to Swift lock(myLock); block(); unlock(myLock); } - (void)performWithLock:(__attribute__((noescape)) void (^)())block { // exposed as @noescape to Swift [myLock lock]; block(); [myLock unlock]; } Motivation Many standard methods and functions — particularly in Foundation and libdispatch — have non-escaping closure semantics, but do not have __attribute__((noescape)). This thwarts the compiler optimizations and syntax shortcuts granted by @noescape, when they should otherwise be applied. In pure Swift, there is no workaround, but by writing some custom C/Objective-C wrapper functions, users can work around these limitations: // MyProject-Bridging-Header.h NS_INLINE void MyDispatchSyncWrapper(dispatch_queue_t queue, __attribute__((noescape)) dispatch_block_t block) { dispatch_sync(queue, block); } However, it’s clear that library functions with non-escaping semantics should be marked with the noescape attribute at the source, so that users don’t have to wrap every function they’d like to use. Proposed solution Audit system C/Objective-C libraries (libdispatch, Foundation, …) for functions and methods with closure parameters that are guaranteed not to escape the lifetime of the call. See the end of this document for a proposed list of candidate functions/methods. Annotate such functions and methods’ block/function-pointer parameters with __attribute__((noescape)) via a macro where appropriate. Add a new macro in a common area (CoreFoundation/Foundation) to provide a compiler support braced use of this attribute. This macro will allow higher level frameworks and applications to adopt this annotation where appropriate. For libraries with Swift-specific forks (like swift-corelibs-libdispatch), the change should be made in the Apple-internal upstream version as well. Example patch An example patch to libdispatch can be seen at https://github.com/apple/swift-corelibs-libdispatch/pull/6/files. Impact on existing code Users who previously used functions which are newly @noescape may have unnecessary instances of self. in their code. However, there should be no breaking syntax changes and no functional difference. Alternatives considered The Swift compiler’s support for supplementary “API notes” (.apinotes files) could be extended and used to annotate closure parameters as non-escaping. However, I believe it’s better to put annotations in headers for the following reasons: The presence of __attribute__((noescape)) in library headers clarifies API contracts, and encourages users to use this attribute in their own code where applicable. With apinotes, the benefits to Swift would be limited to specific libraries and functions, leaving annotation in the hands of the Swift compiler project. Given a version of a library with annotated headers, however, no extra compiler configuration is required to take advantage of the annotation. As Clang itself improves, the benefits of __attribute__((noescape)) can be granted to Objective-C callers as well as Swift (for example, by suppressing -Wimplicit-retain-self &lt;rdar://19914650&gt;). CoreFoundation CoreFoundation will now provide a macro for annotating noescape methods and the following public functions will be annotated accordingly: #if __has_attribute(noescape) #define CF_NOESCAPE __attribute__((noescape)) #else #define CF_NOESCAPE #endif CFArray void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction CF_NOESCAPE applier, void *context); CFBag void CFBagApplyFunction(CFBagRef theBag, CFBagApplierFunction CF_NOESCAPE applier, void *context); CFDictionary void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction CF_NOESCAPE applier, void *context); CFSet void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction CF_NOESCAPE applier, void *context); CFTree void CFTreeApplyFunctionToChildren(CFTreeRef tree, CFTreeApplierFunction CF_NOESCAPE applier, void *context); Foundation Foundation will provide the following macro and methods annotated accordingly: #define NS_NOESCAPE CF_NOESCAPE NSArray - (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (NS_NOESCAPE *)(ObjectType, ObjectType, void * _Nullable))comparator context:(nullable void *)context; - (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (NS_NOESCAPE *)(ObjectType, ObjectType, void * _Nullable))comparator context:(nullable void *)context hint:(nullable NSData *)hint; - (void)enumerateObjectsUsingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexOfObjectPassingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexOfObjectAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSIndexSet *)indexesOfObjectsPassingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSIndexSet *)indexesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSIndexSet *)indexesOfObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSArray&lt;ObjectType&gt; *)sortedArrayUsingComparator:(NSComparator NS_NOESCAPE)cmptr NS_AVAILABLE(10_6, 4_0); - (NSArray&lt;ObjectType&gt; *)sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmptr NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexOfObject:(ObjectType)obj inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmp NS_AVAILABLE(10_6, 4_0); // binary search NSMutableArray - (void)sortUsingFunction:(NSInteger (NS_NOESCAPE *)(ObjectType, ObjectType, void * _Nullable))compare context:(nullable void *)context; - (void)sortUsingComparator:(NSComparator NS_NOESCAPE)cmptr NS_AVAILABLE(10_6, 4_0); - (void)sortWithOptions:(NSSortOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmptr NS_AVAILABLE(10_6, 4_0); NSAttributedString - (void)enumerateAttributesInRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSDictionary&lt;NSString *, id&gt; *attrs, NSRange range, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateAttribute:(NSString *)attrName inRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(id _Nullable value, NSRange range, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); NSCalendar - (void)enumerateDatesStartingAfterDate:(NSDate *)start matchingComponents:(NSDateComponents *)comps options:(NSCalendarOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSDate * _Nullable date, BOOL exactMatch, BOOL *stop))block NS_AVAILABLE(10_9, 8_0); NSData - (void) enumerateByteRangesUsingBlock:(void (NS_NOESCAPE ^)(const void *bytes, NSRange byteRange, BOOL *stop))block NS_AVAILABLE(10_9, 7_0); NSDictionary - (void)enumerateKeysAndObjectsUsingBlock:(void (NS_NOESCAPE ^)(KeyType key, ObjectType obj, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(KeyType key, ObjectType obj, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (NSArray&lt;KeyType&gt; *)keysSortedByValueUsingComparator:(NSComparator NS_NOESCAPE)cmptr NS_AVAILABLE(10_6, 4_0); - (NSArray&lt;KeyType&gt; *)keysSortedByValueWithOptions:(NSSortOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmptr NS_AVAILABLE(10_6, 4_0); - (NSSet&lt;KeyType&gt; *)keysOfEntriesPassingTest:(BOOL (NS_NOESCAPE ^)(KeyType key, ObjectType obj, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSSet&lt;KeyType&gt; *)keysOfEntriesWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(KeyType key, ObjectType obj, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); NSIndexSet - (void)enumerateIndexesUsingBlock:(void (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateIndexesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateIndexesInRange:(NSRange)range options:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexPassingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSUInteger)indexInRange:(NSRange)range options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSIndexSet *)indexesPassingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSIndexSet *)indexesWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSIndexSet *)indexesInRange:(NSRange)range options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (void)enumerateRangesUsingBlock:(void (NS_NOESCAPE ^)(NSRange range, BOOL *stop))block NS_AVAILABLE(10_7, 5_0); - (void)enumerateRangesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSRange range, BOOL *stop))block NS_AVAILABLE(10_7, 5_0); - (void)enumerateRangesInRange:(NSRange)range options:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSRange range, BOOL *stop))block NS_AVAILABLE(10_7, 5_0); NSLinguisticTagger - (void)enumerateTagsInRange:(NSRange)range scheme:(NSString *)tagScheme options:(NSLinguisticTaggerOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSString *tag, NSRange tokenRange, NSRange sentenceRange, BOOL *stop))block NS_AVAILABLE(10_7, 5_0); - (void)enumerateLinguisticTagsInRange:(NSRange)range scheme:(NSString *)tagScheme options:(NSLinguisticTaggerOptions)opts orthography:(nullable NSOrthography *)orthography usingBlock:(void (NS_NOESCAPE ^)(NSString *tag, NSRange tokenRange, NSRange sentenceRange, BOOL *stop))block NS_AVAILABLE(10_7, 5_0); NSMetadataQuery - (void)enumerateResultsUsingBlock:(void (NS_NOESCAPE ^)(id result, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_9, 7_0); - (void)enumerateResultsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(id result, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_9, 7_0); NSOrderedSet - (void)enumerateObjectsUsingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block; - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block; - (void)enumerateObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block; - (NSUInteger)indexOfObjectPassingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate; - (NSUInteger)indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate; - (NSUInteger)indexOfObjectAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate; - (NSIndexSet *)indexesOfObjectsPassingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate; - (NSIndexSet *)indexesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate; - (NSIndexSet *)indexesOfObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate; - (NSUInteger)indexOfObject:(ObjectType)object inSortedRange:(NSRange)range options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmp; // binary search - (NSArray&lt;ObjectType&gt; *)sortedArrayUsingComparator:(NSComparator NS_NOESCAPE)cmptr; - (NSArray&lt;ObjectType&gt; *)sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmptr; NSMutableOrderedSet - (void)sortUsingComparator:(NSComparator NS_NOESCAPE)cmptr; - (void)sortWithOptions:(NSSortOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmptr; - (void)sortRange:(NSRange)range options:(NSSortOptions)opts usingComparator:(NSComparator NS_NOESCAPE)cmptr; NSRegularExpression - (void)enumerateMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range usingBlock:(void (NS_NOESCAPE ^)(NSTextCheckingResult * _Nullable result, NSMatchingFlags flags, BOOL *stop))block; NSSet - (void)enumerateObjectsUsingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (NSSet&lt;ObjectType&gt; *)objectsPassingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); - (NSSet&lt;ObjectType&gt; *)objectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(ObjectType obj, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0); NSString - (void)enumerateSubstringsInRange:(NSRange)range options:(NSStringEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop))block NS_AVAILABLE(10_6, 4_0); - (void)enumerateLinesUsingBlock:(void (NS_NOESCAPE ^)(NSString *line, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);",
    "url": "http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html",
    "relUrl": "/docs/2019-08-26-0012-add-noescape-to-public-library-api.html"
  },
  "12": {
    "id": "12",
    "title": "SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)",
    "content": "Remove Partial Application of Non-Final Super Methods (Swift 2.2) Proposal: SE-0013 Author: David Farler Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction Prior to Swift 2.2, calls to superclass methods like super.foo() in Native Swift classes were dispatched statically by recording a reference to the function and calling it directly by its mangled name. In Swift 2.2, class methods invoked via super will use dynamic dispatch. That is, the method will be looked up in the superclass’s vtable at runtime. However, if the method is marked with final, it will use the old static dispatch, since no class will be able to override it. The mechanisms that support currying require thunks to be emitted so that the function can be called at various uncurrying levels. Currying will be removed in Swift 3.0 so, rather than invest more engineering in those mechanisms, I propose that we disallow partial application of non-final methods through super, except where the self parameter is implicitly captured. Swift Evolution Discussion Thread Motivation The motivation of this change is partially motivated by implementation concerns. The machinery for curry thunk mechanism has a lot of assumptions about what the ultimate function call will be: an apply of a static function_ref or a dynamic dispatch through a class_method, which originate in something like doFoo(self.foo) (note self instead of super). Rather than risk regressions stemming from significant replumbing, it would a good tradeoff to pull in this limited portion of the currying removals in Swift 3.0. Detailed design In terms of design and implementation, this is a trivial change. In semantic analysis, perform the following check on call expressions: if the call expression is based in super, the referenced function isn’t final, and the application does not fulfill all of the parameters, emit an error diagnostic. Example Code Illegal: Partial application of non-final method func doFoo(f: () -&gt; ()) { f() } class Base { func foo()() {} } class Derived : Base { override func foo()() { doFoo(super.foo()) // Illegal - doesn&#39;t apply the second time. } } OK: Partial application of final method This is safe because the new dynamic super dispatch mechanisms don’t kick in for final methods - these fall back to the original static function reference because no class can ever override the original implementation. func doFoo(f: () -&gt; ()) { f() } class Base { final func foo()() {} } class Derived : Base { func bar() { doFoo(super.foo()) // OK - method is final. } } The implementation for this change is available on apple/swift/remove-partial-super. OK: Partial application with implicit self Partial application of the implicit self parameter is still allowed with this change. When you pass super.foo around, you have in fact partially applied the method - you’ve captured the self argument present in all Swift method calls. This is safe because no explicit thunks need to be generated at SILGen - the partial_apply instruction will create a closure without additional SIL code. func doFoo(f: () -&gt; ()) { f() } class Base { func foo() {} } class Derived : Base { func bar() { doFoo(super.foo) // OK - only partially applies self } } Impact on existing code Given that we’ve decided to remove currying outright, this would be a small percentage of that usage. Generally, calls on super are for delegation, where all arguments are often present. Alternatives considered The only alternative is to make super method dispatch a citizen in the thunk emission process, which requires deep changes to SILGen, symbol mangling, and IRGen. Although this more comprehensive change would allow us to adopt dynamic super dispatch with no source changes for those writing in Swift, I believe the proposal is a reasonable tradeoff.",
    "url": "http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html",
    "relUrl": "/docs/2019-08-26-0013-remove-partial-application-super.html"
  },
  "13": {
    "id": "13",
    "title": "SE-0014 Constraining `AnySequence.init`",
    "content": "Constraining AnySequence.init Proposal: SE-0014 Author: Max Moiseev Review Manager: Doug Gregor Status: Implemented (Swift 2.2) Decision Notes: Rationale Bug: SR-474 Introduction In order to allow AnySequence delegate calls to the underlying sequence, its initializer should have extra constraints. Swift Evolution Discussion Motivation At the moment AnySequence does not delegate calls to SequenceType protocol methods to the underlying base sequence, which results in dynamic downcasts in places where this behavior is needed (see default implementations of SequenceType.dropFirst or SequenceType.prefix). Besides, and this is even more important, customized implementations of SequenceType methods would be ignored without delegation. Proposed solution See the implementation in this PR. In order for this kind of delegation to become possible, _SequenceBox needs to be able to ‘wrap’ not only the base sequence but also its associated SubSequence. So instead of being declared like this: internal class _SequenceBox&lt;S : SequenceType&gt; : _AnySequenceBox&lt;S.Generator.Element&gt; { ... } it would become this: internal class _SequenceBox&lt; S : SequenceType where S.SubSequence : SequenceType, S.SubSequence.Generator.Element == S.Generator.Element, S.SubSequence.SubSequence == S.SubSequence &gt; : _AnySequenceBox&lt;S.Generator.Element&gt; { ... } Which, in its turn, will lead to AnySequence.init getting a new set of constraints as follows. Before the change: public struct AnySequence&lt;Element&gt; : SequenceType { public init&lt; S: SequenceType where S.Generator.Element == Element &gt;(_ base: S) { ... } } After the change: public struct AnySequence&lt;Element&gt; : SequenceType { public init&lt; S: SequenceType where S.Generator.Element == Element, S.SubSequence : SequenceType, S.SubSequence.Generator.Element == Element, S.SubSequence.SubSequence == S.SubSequence &gt;(_ base: S) { ... } } These constraints, in fact, should be applied to SequenceType protocol itself (although, that is not currently possible), as we expect every SequenceType implementation to satisfy them already. Worth mentioning that technically S.SubSequence.SubSequence == S.SubSequence does not have to be this strict, as any sequence with the same element type would do, but that is currently not representable. Impact on existing code New constraints do not affect any built-in types that conform to SequenceType protocol as they are essentially constructed like this (SubSequence.SubSequence == SubSequence). 3rd party collections, if they use the default SubSequence (i.e. Slice), should also be fine. Those having custom SubSequences may stop conforming to the protocol.",
    "url": "http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html",
    "relUrl": "/docs/2019-08-26-0014-constrained-AnySequence.html"
  },
  "14": {
    "id": "14",
    "title": "SE-0015 Tuple comparison operators",
    "content": "Tuple comparison operators Proposal: SE-0015 Author: Lily Ballard Review Manager: Dave Abrahams Status: Implemented (Swift 2.2) Decision Notes: Rationale Implementation: apple/swift#408 Introduction Implement comparison operators on tuples up to some arity. Swift Evolution Discussion, Review Note: The review was initially started on the wrong thread with the wrong title and subsequently corrected. Motivation It’s annoying to try and compare tuples of comparable values and discover that tuples don’t support any of the common comparison operators. There’s an extremely obvious definition of == and != for tuples of equatable values, and a reasonably obvious definition of the ordered comparison operators as well (lexicographical compare). Beyond just comparing tuples, being able to compare tuples also makes it easier to implement comparison operators for tuple-like structs, as the relevant operator can just compare tuples containing the struct properties. Proposed solution The Swift standard library should provide generic implementations of the comparison operators for all tuples up to some specific arity. The arity should be chosen so as to balance convenience (all tuples support this) and code size (every definition adds to the size of the standard library). When Swift gains support for conditional conformation to protocols, and if Swift ever gains support for extending tuples, then the tuples up to the chosen arity should also be conditionally declared as conforming to Equatable and Comparable. If Swift ever gains support for variadic type parameters, then we should investigate redefining the operators (and protocol conformance) in terms of variadic types, assuming there’s no serious codesize issues. Detailed design The actual definitions will be generated by gyb. The proposed arity here is 6, which is large enough for most reasonable tuples (but not as large as I’d prefer), without having massive code increase. After implementing this proposal for arity 6, a Ninja-ReleaseAssert build increases codesize for libswiftCore.dylib (for both macosx and iphoneos) by 43.6KiB, which is a 1.4% increase. The generated definitions look like the following (for arity 3): @warn_unused_result public func == &lt;A: Equatable, B: Equatable, C: Equatable&gt;(lhs: (A,B,C), rhs: (A,B,C)) -&gt; Bool { return lhs.0 == rhs.0 &amp;&amp; lhs.1 == rhs.1 &amp;&amp; lhs.2 == rhs.2 } @warn_unused_result public func != &lt;A: Equatable, B: Equatable, C: Equatable&gt;(lhs: (A,B,C), rhs: (A,B,C)) -&gt; Bool { return lhs.0 != rhs.0 || lhs.1 != rhs.1 || lhs.2 != rhs.2 } @warn_unused_result public func &lt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A,B,C), rhs: (A,B,C)) -&gt; Bool { if lhs.0 != rhs.0 { return lhs.0 &lt; rhs.0 } if lhs.1 != rhs.1 { return lhs.1 &lt; rhs.1 } return lhs.2 &lt; rhs.2 } @warn_unused_result public func &lt;= &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A,B,C), rhs: (A,B,C)) -&gt; Bool { if lhs.0 != rhs.0 { return lhs.0 &lt; rhs.0 } if lhs.1 != rhs.1 { return lhs.1 &lt; rhs.1 } return lhs.2 &lt;= rhs.2 } @warn_unused_result public func &gt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A,B,C), rhs: (A,B,C)) -&gt; Bool { if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0 } if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 } return lhs.2 &gt; rhs.2 } @warn_unused_result public func &gt;= &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A,B,C), rhs: (A,B,C)) -&gt; Bool { if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0 } if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 } return lhs.2 &gt;= rhs.2 } Impact on existing code No existing code should be affected. Alternatives considered I tested building a Ninja-ReleaseAssert build for tuples up to arity 12, but that had a 171KiB codesize increase (5.5%). I have not tried any other arities.",
    "url": "http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html",
    "relUrl": "/docs/2019-08-26-0015-tuple-comparison-operators.html"
  },
  "15": {
    "id": "15",
    "title": "SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer",
    "content": "Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer Proposal: SE-0016 Author: Michael Buckley Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1115 Previous Revision: 1 Introduction Just as users can create Unsafe[Mutable]Pointers from Ints and UInts, they should be able to create Ints and UInts from Unsafe[Mutable]Pointers. This will allow users to call C functions with intptr_t and uintptr_t parameters, and will allow users to perform more advanced pointer arithmetic than is allowed by UnsafePointers. Swift Evolution Discussion, Review Motivation Swift currently lacks the ability to perform many complex operations on pointers, such as checking pointer alignment, tagging pointers, or XORing pointers (for working with XOR linked lists, for example). As a systems programming language, Swift ought to be able to solve these problems natively and concisely. Additionally, since some C functions take intptr_t and uintptr_t parameters, Swift currently has no ability to call these functions directly. Users must wrap calls to these functions in C code. Proposed solution Initializers will be added to Int and UInt to convert from UnsafePointer, UnsafeMutablePointer, and OpaquePointer. Currently, the only workaround which can solve these problems is to write any code that requires pointer arithmetic in C. Writing this code in Swift will be no safer than it is in C, as this is a fundamentally unsafe operation. However, it will be cleaner in that users will not be forced to write C code. Detailed design The initializers will be implemented using the built-in ptrtoint_Word function. extension UInt { init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) { self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue)) } init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) { self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue)) } init(bitPattern: OpaquePointer) { self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue)) } } extension Int { init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) { self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue)) } init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) { self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue)) } init(bitPattern: OpaquePointer) { self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue)) } } As an example, these initializers will allow the user to get the next address of an XOR linked list in Swift. struct XORLinkedList&lt;T&gt; { let address: UnsafePointer&lt;T&gt; ... func successor(_ predecessor: XORLinkedList&lt;T&gt;) -&gt; XORLinkedList&lt;T&gt; { let next = UInt(bitPattern: address) ^ UInt(bitPattern: predecessor.address) return XorLinkedList(UnsafePointer&lt;T&gt;(bitPattern: next)) } } Impact on existing code There is no impact on existing code. Alternatives considered Three alternatives were considered. The first alternative was to add an intValue function to Unsafe[Mutable]Pointer. This alternative was rejected because it is preferred that type conversions be implemented as initializers where possible. The next alternative was to add functions to Unsafe[Mutable]Pointer which covered the identified pointer arithmetic cases. This alternative was rejected because it either would have required us to imagine every use-case of pointer arithmetic and write functions for them, which is an impossible task, or it would have required adding a full suite of arithmetic and bitwise operators to Unsafe[Mutable]Pointer. Because some of these operations are defined only on signed integers, and others on unsigned, it would have required splitting Unsafe[Mutable]Pointer into signed and unsigned variants, which would have complicated things for users who did not need to do pointer arithmetic. Additionally, the implementations of these operations would have probably converted the pointers to integers, perform a single operation, and then convert them back. When chaining operations, this would create a lot of unnecessary conversions. The last alternative was to forgo these initializers and force users to write all their complicated pointer code in C. This alternative was rejected because it makes Swift less useful as a systems programming language. Changes from revision 1 The proposal was amended post-acceptance to include OpaquePointer. Originally it only included UnsafePointer and UnsafeMutablePointer.",
    "url": "http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html",
    "relUrl": "/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html"
  },
  "16": {
    "id": "16",
    "title": "SE-0017 Change `Unmanaged` to use `UnsafePointer`",
    "content": "Change Unmanaged to use UnsafePointer Proposal: SE-0017 Author: Jacob Bandes-Storch Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1485 Introduction The standard library Unmanaged&lt;Instance&gt; struct provides a type-safe object wrapper that does not participate in ARC; it allows the user to make manual retain/release calls. Swift Evolution Discussion, Proposed Rewrite Discussion, Review Motivation The following methods are provided for converting to/from Unmanaged: static func fromOpaque(value: COpaquePointer) -&gt; Unmanaged&lt;Instance&gt; func toOpaque() -&gt; COpaquePointer However, C APIs that accept void * or const void * are exposed to Swift as UnsafePointer&lt;Void&gt; or UnsafeMutablePointer&lt;Void&gt;, rather than COpaquePointer. In practice, users must convert UnsafePointer → COpaquePointer → Unmanaged, which leads to bloated code such as someFunction(context: UnsafeMutablePointer(Unmanaged.passUnretained(self).toOpaque())) info.retain = { Unmanaged&lt;AnyObject&gt;.fromOpaque(COpaquePointer($0)).retain() } info.copyDescription = { Unmanaged.passRetained(CFCopyDescription(Unmanaged.fromOpaque(COpaquePointer($0)).takeUnretainedValue())) } Proposed solution In the Unmanaged API, replace the usage of COpaquePointer with UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;. The affected functions are fromOpaque() and toOpaque(). Only very minor modification is required from the current implementation: @_transparent @warn_unused_result public static func fromOpaque(value: UnsafePointer&lt;Void&gt;) -&gt; Unmanaged { // Null pointer check is a debug check, because it guards only against one // specific bad pointer value. _debugPrecondition( value != nil, &quot;attempt to create an Unmanaged instance from a null pointer&quot;) return Unmanaged(_private: unsafeBitCast(value, Instance.self)) } @_transparent @warn_unused_result public func toOpaque() -&gt; UnsafeMutablePointer&lt;Void&gt; { return unsafeBitCast(_value, UnsafeMutablePointer&lt;Void&gt;.self) } Note that values of type UnsafeMutablePointer can be passed to functions accepting either UnsafePointer or UnsafeMutablePointer, so for simplicity and ease of use, we choose UnsafePointer as the input type to fromOpaque(), and UnsafeMutablePointer as the return type of toOpaque(). The example usage above no longer requires conversions: someFunction(context: Unmanaged.passUnretained(self).toOpaque()) info.retain = { Unmanaged&lt;AnyObject&gt;.fromOpaque($0).retain() } info.copyDescription = { Unmanaged.passRetained(CFCopyDescription(Unmanaged.fromOpaque($0).takeUnretainedValue())) } Impact on existing code Code previously calling Unmanaged API with COpaquePointer will need to change to use UnsafePointer. The COpaquePointer variants can be kept with availability attributes to aid the transition, such as: @available(*, unavailable, message=&quot;use fromOpaque(value: UnsafeMutablePointer&lt;Void&gt;) instead&quot;) @available(*, unavailable, message=&quot;use toOpaque() -&gt; UnsafePointer&lt;Void&gt; instead&quot;) Code that uses COpaquePointer does not seem to depend on it heavily, and would not be significantly harmed by this change. Alternatives considered Make no change. However, it has been said on swift-evolution that COpaquePointer is vestigial, and better bridging of C APIs is desired, so we do want to move in this direction.",
    "url": "http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html",
    "relUrl": "/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html"
  },
  "17": {
    "id": "17",
    "title": "SE-0018 Flexible Memberwise Initialization",
    "content": "Flexible Memberwise Initialization Proposal: SE-0018 Author: Matthew Johnson Review Manager: Chris Lattner Status: Deferred Decision Notes: Rationale Introduction The Swift compiler is currently able to generate a memberwise initializer for use in some circumstances, however there are currently many limitations to this. This proposal builds on the idea of a compiler generated memberwise initializer, making the capability available to any initializer that opts in. Swift-evolution thread: Proposal Draft: flexible memberwise initialization Motivation When designing initializers for a type we are currently faced with the unfortunate fact that the more flexibility we wish to offer users the more boilerplate we are required to write and maintain. We usually end up with more boilerplate and less flexibility than desired. There have been various strategies employed to mitigate this problem, including: Sometimes properties that should be immutable are made mutable and a potentially unsafe ad-hoc two-phase initialization pattern is employed where an instance is initialized and then configured immediately afterwards. This allows the developer to avoid including boilerplate in every initializer that would otherwise be required to initialize immutable properties. Sometimes mutable properties that have a sensible default value are simply default-initialized and the same post-initialization configuration strategy is employed when the default value is not correct for the intended use. This results in an instance which may pass through several states that are incorrect for the intended use before it is correctly initialized for its intended use. Underlying this problem is the fact that initialization scales with M x N complexity (M members, N initializers). We need as much help from the compiler as we can get! Flexible and concise initialization for both type authors and consumers will encourages using immutability where possible and removes the need for boilerplate from the concerns one must consider when designing the intializers for a type. Quoting Chris Lattner: The default memberwise initializer behavior of Swift has at least these deficiencies (IMO): 1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back. 2) Access control + the memberwise init often requires you to implement it yourself. 3) We don’t get memberwise inits for classes. 4) var properties with default initializers should have their parameter to the synthesized initializer defaulted. 5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it). Add to the list “all or nothing”. The compiler generates the entire initializer and does not help to eliminate boilerplate for any other initializers where it may be desirable to use memberwise intialization for a subset of members and initialize others manually. It is common to have a type with a number of public members that are intended to be configured by clients, but also with some private state comprising implementation details of the type. This is especially prevalent in UI code which may expose many properties for configuring visual appearance, etc. Flexibile memberwise initialization can provide great benefit in these use cases, but it immediately becomes useless if it is “all or nothing”. We need a flexible solution that can synthesize memberwise initialization for some members while allowing the type author full control over initialization of implementation details. Proposed solution I propose adding a memberwise declaration modifier for initializers which allows them to opt-in to synthesis of memberwise initialization. This proposal adopts a model for property eligibility where stored properties automatically receive memberwise initialization parameters unless they are deemed ineligible for one of several reasons. An opt-in model using a memberwise declaration modifier allowing properties to opt-in to memberwise initialization synthesis is also possible. The two approaches are not mutually exclusive: it is possible to use the automatic model when no properties have the memberwise declaration modifier and the opt-in model when one or more properties do have the memberwise declaration modifier. A future enhancement to this proposal may introduce the opt-in model, allowing programmers to choose which model is preferred for a specific type they are authoring. The automatic model of the current proposal determines the set of properties that receive memberwise initialization parameters by considering only the initializer declaration and the declarations for all properties that are at least as visible as the initializer (including any behaviors attached to the properties). The rules are as follows: The access level of the property is at least as visible as the memberwise initializer. The visiblity of the setter is used for var properties. They do not have a behavior which prohibits memberwise initialization (e.g. the ‘lazy’ behavior). If the property is a let property it may not have an initial value. The parameters are synthesized in the parameter list in the location of the ... placeholder. It is a compile-time error for a memberwise initializer to omit the ... placeholder. The parameter list is ordered as follows: All parameters without default values precede parameters with default values. Within each group, parameters follow property declaration order. Under the current proposal only var properties could specify a default value, which would be the initial value for that property. It may be possible for let properties to specify a default value in the future using the @default enhancement or some other mechanism allowing the default value to be specified. Examples This section of the document contains several examples of the solution in action. It does not cover every possible scenario. If there are concrete examples you are wondering about please post them to the list. I will be happy to discuss them and will add any examples we consider important to this section as the discussion progresses. Specific details on how synthesis is performed are contained in the detailed design. Replacing the current memberwise initializer struct S { let s: String let i: Int // user declares: memberwise init(...) {} // compiler synthesizes: init(s: String, i: Int) { /* synthesized */ self.s = s /* synthesized */ self.i = i } } Var properties with initial values NOTE: this example is only possible for var properties due to the initialization rules for let properties. If the initializer expression contains side effects, then the side effect is not evaluated if passed in explicitly by a caller of the memberwise initializer. struct S { var s: String = &quot;hello&quot; var i: Int = 42 // user declares: memberwise init(...) {} // compiler synthesizes: init(s: String = &quot;hello&quot;, i: Int = 42) { /* synthesized */ self.s = s /* synthesized */ self.i = i } } Access control struct S { let s: String private let i: Int // user declares: memberwise init(...) { // compiler error, i memberwise initialization cannot be synthesized // for i because it is less visible than the initializer itself } } struct S { let s: String private let i: Int // user declares: memberwise init(...) { i = 42 } // compiler synthesizes (suppressing memberwise initialization for properties with lower visibility): init(s: String) { /* synthesized */ self.s = s // body of the user&#39;s initializer remains i = 42 } } Manually declared parameters struct S { let s: String private let i: Int // user declares: memberwise init(anInt: Int, anotherInt: Int, ...) { i = anInt &gt; anotherInt ? anInt : anotherInt } // compiler synthesizes (suppressing memberwise initialization for properties with lower visibility): init(anInt: Int, anotherInt: Int, s: String) { /* synthesized */ self.s = s // body of the user&#39;s initializer remains i = anInt &gt; anotherInt ? anInt : anotherInt } } Lazy properties and incompatible behaviors struct S { let s: String lazy var i: Int = InitialValueForI() // user declares: memberwise init(...) { } // compiler synthesizes: init(s: String) { /* synthesized */ self.s = s // compiler does not synthesize initialization for i // because it contains a behavior that is incompatible with // memberwise initialization. } } Detailed design Syntax changes This proposal introduces two new syntactic elements: the memberwise declaration modifier and the ... memberwise parameter placeholder. Designated initializers opt-in to synthesized memberwise initialization with the memberwise declaration modifier. This modifier will cause the compiler to follow the procedure outlined later in the design to synthesize memberwise parameters as well as memberwise initialization code at the beginning of the initializer body. Overview Throughout this design the term memberwise initialization parameter is used to refer to initializer parameters synthesized by the compiler as part of memberwise initialization synthesis. Algorithm Determine the set of properties eligible for memberwise initialization synthesis. Properties are eligible for memberwise initialization synthesis if: The access level of the property is at least as visible as the memberwise initializer. The visiblity of the setter is used for var properties. They do not have a behavior which prohibits memberwise initialization. If the property is a let property it may not have an initial value. Determine the default value, if one exists, for each memberwise initialization parameter. Under the current proposal only var properties could specify a default value, which would be the initial value for that property. If the initializer declares any parameters with external labels matching the name of any of the properties eligible for memberwise initialization report a compiler error. Synthesize memberwise initialization parameters in the location where the ... placeholder was specified. The synthesized parameters should have external labels matching the property name. Place the synthesized parameters in the following order: All parameters without default values precede parameters with default values. Within each group, follow property declaration order. Synthesize initialization of all memberwise initialization parameters at the beginning of the initializer body. If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning. It is unlikely that overwriting the value provided by the caller is the desired behavior. Impact on existing code This proposal will also support generating an implicit memberwise initializer for classes and structs when the following conditions are true: The type declares no initializers explicitly. The type is: a struct a root class a class whose superclass has a designated intializer requiring no arguments The implicitly generated memberwise initializer will have the highest access level possible while still allowing all stored properties to be eligible for memberwise parameter synthesis, but will have at most internal visibility. Currently this means its visibility will be internal when all stored properties of the type have setters with at least internal visibility, and private otherwise (when one or more stored properties are private or private(set)). The implicitly synthesized initializer will be identical to an initializer declared explicitly as follows: memberwise init(...) {} or private memberwise init(...) {}. NOTE: Because the memberwise declaration modifier only applies to designated initializers, it may not be used with class initializers defined in an extension. It may be used with struct initializers defined in an extension as long as all of the struct’s stored properties are visible to the extension. The changes described in this proposal are almost entirely additive. The only existing code that will break will be in the case of structs with stored private properties or var properties that have private setters which had been receiving an internal implicitly synthesized memberwise initializer. Options for addressing this impact are: If the implicitly synthesized memberwise initializer was only used within the same source file no change is necessary. An implicit private memberwise initializer will still be synthesized by the compiler. A mechanical migration could generate the explicit code necessary to declare the previously implicit initializer. This would be an internal memberwise initializer with explicit parameters used to manually initialize the stored properties with private setters. If the “Access control for init” enhancement were accepted the private members could have their access control modified to private internal(init) which would allow the implict memberwise intializer to continue to have internal visibility as all stored properties would be eligible for parameter synthesis by an internal memberwise initializer. The only other impact on existing code is that memberwise parameters corresponding to var properties with initial values will now have default values. This will be a change in the behavior of the implicit memberwise initializer but will not break any code. The change will simply allow new code to use that initializer without providing an argument for such parameters. Future enhancements In the spirit of incremental change, the current proposal is focused on core functionality. It is possible to enhance that core functionality with additional features. These enhancements may be turned into proposals after the current proposal is accepted. @default It is not possible under the current proposal to specify a default value for memberwise initialization parameters of let properties. This is an unfortunate limitation and a solution to this is a highly desired enhancement to the current proposal. One possible solution would be to introduce the @default attribute allowing let properties to specify a default value for the parameter the compiler synthesizes in memberwise initializers. There are two possible syntactic approaches that could be taken by @default: Make @default a modifier. The same syntax is used as for initial values, but when the @default attribute is specified for a property the specified value is a default rather than an initial value. Allow the default value to be specified using an attribute argument. Each syntax has advantages and disadvantages: The first syntax is arguably cleaner and more readable. The first syntax makes it impossible to specify both an initial value and a default value for the same property. This is advantageous because a let property should never have both and initial values for var properties are effectively just a default value anyway. The second syntax may have less potential for confusion and thus more clear as it uses significantly different syntax for specifying initial and default values. Example using the first syntax option struct S { @default let s: String = &quot;hello&quot; @default let i: Int = 42 // user declares: memberwise init(...) {} // compiler synthesizes: init(s: String = &quot;hello&quot;, i: Int = 42) { /* synthesized */ self.s = s /* synthesized */ self.i = i } } Example using the second syntax option struct S { @default(&quot;hello&quot;) let s: String @default(42) let i: Int // user declares: memberwise init(...) {} // compiler synthesizes: init(s: String = &quot;hello&quot;, i: Int = 42) { /* synthesized */ self.s = s /* synthesized */ self.i = i } } memberwise properties The rules of the current proposal are designed to synthesize memberwise parameters for the correct set of properties as best as possible. Of course there will be times when the rules don’t match what is desired. Introducing a memberwise declaration modifier for properties would allow programmers to specify exactly which properties should participate in memberwise initialization synthesis. It allows full control and has the clarity afforded by being explicit. Specifc use cases this feature would support include allowing private properties to receive synthesized memberwise parameters in a public initializer, or allow public properties to be omitted from parameter synthesis. An example of this struct S { // both properties receive memberwise initialization parameters // regardless of access control. memberwise public let s: String memberwise private let i: Int // neither property receives a memberwise initialization parameter // regardless of access control. public var s2 = &quot;&quot; private var i2 = 42 // user declares: memberwise init(...) {} // compiler synthesizes: init(s: String, i: Int) { /* synthesized */ self.s = s /* synthesized */ self.i = i } } Access control for init In some cases it may be desirable to be able to specify distinct access control for memberwise initialization when using the automatic model, for example if that model almost has the desired behavior, but the initialization visibiltiy of one property must be adjusted to produce the necessary result. The syntax used would be identical to that used for specifying distinct access control for a setter. This feature would likely have its greatest utility in allowing more-private members to participate in more-public memberwise initializers. It may also be used to inhibit memberwise initialization for some members, although that use would usually be discouraged if the @nomemberwise proposal were also accepted. struct S { private internal(init) let s: String private i: Int // user declares: memberwise init(...) { i = getTheValueForI() } // compiler synthesizes (including a parameter for private member s despite the fact that this is an internal memberwis initializer): init(s: String) { /* synthesized */ self.s = s // body of the user&#39;s initializer remains i = getTheValueForI() } } If this enhancement were submitted the first property eligibility rule would be updates as follows: Their init access level is at least as visible as the memberwise initializer. If the property does not have an init acccess level, the access level of its setter must be at least as visible as the memberwise initializer. @nomemberwise There may be cases where the author of a type would like to prevent a specific property from participating in memberwise initialization either for all initializers or for a specific initializer. The @nomemberwise attribute for properties and initializers supports this use case. Memberwise initializers can explicitly prevent memberwise initialization for specific properties by including them in a list of property names provided to the @nomemberwise attribute like this: @nomemberwise(prop1, prop2). Under the automatic model, properties would be able to explicitly opt-out of memberwise initialization with the @nomemberwise attribute. When they do so they would not be eligible for memberwise initialization synthesis. Because of this they must be initialized directly with an initial value or initialized directly by every initializer for the type. The @nomemberwise attribute would introduce two additional eligibility rules when deterimining which properties can participtate in memberwise initialization. The property is not annotated with the @nomemberwise attribute. The property is not included in the @nomemberwise attribute list attached of the initializer. If super is included in the @nomemberwise attribute list no superclass properties will participate in memberwise initialization. Examples NOTE: This example doesn’t really save a lot. Imagine ten properties with only one excluded from memberwise initialization. struct S { let s: String let i: Int // user declares: @nomemberwise(i) memberwise init(...) { i = getTheValueForI() } // compiler synthesizes (suppressing memberwise initialization for properties mentioned in the @nomemberwise attribute): init(s: String) { /* synthesized */ self.s = s // body of the user&#39;s initializer remains i = getTheValueForI() } } struct S { let s: String @nomemberwise let i: Int // user declares: memberwise init() { i = 42 } // compiler synthesizes: init(s: String) { /* synthesized */ self.s = s // body of the user&#39;s intializer remains i = 42 } } Memberwise initializer chaining / parameter forwarding Ideally it would be possible to define convenience and delegating initializers without requiring them to manually declare parameters and pass arguments to the designated initializer for memberwise intialized properties. It would also be ideal if designated initializers also did not have to the same for memberwise intialization parmaeters of super. A general solution for parameter forwarding would solve this problem. A future parameter forwarding proposal to support this use case and others is likely to be pursued. Objective-C Class Import Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks a future proposal could recommend introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers. Mutable Objective-C properties could be marked with the MEMBERWISE attribute. Readonly Objective-C properties could not be marked with the MEMBERWISE attribute. The MEMBERWISE attribute should only be used for properties that are initialized with a default value (not a value provided directly by the caller or computed in some way) in all of the class’s initializers. Objective-C initializers could also be marked with the MEMBERWISE attribute. When Swift imports an Objective-C initializer marked with this attribute it could allow callers to provide memberwise values for the properties declared in the class that are marked with the MEMBERWISE attribute. At call sites for these initializers the compiler could perform a transformation that results in the memberwise properties being set with the provided value immediately after initialization of the instance completes. It may also be desirable to allow specific initializers to hide the memberwise parameter for specific properties if necessary. NOMEMBERWISE(prop1, prop2) It is important to observe that the mechanism for performing memberwise initialization of Objective-C classes (post-initialization setter calls) must be implemented in a different way than native Swift memberwise initialization. As long as developers are careful in how they annotate Objective-C types this implementation difference should not result in any observable differences to callers. The difference in implementation is necessary if we wish to use call-site memberwise initialization syntax in Swift when initializing instances of Cocoa classes. There have been several threads with ideas for better syntax for initializing members of Cocoa class instances. I believe memberwise initialization is the best way to do this as it allows full configuration of the instance in the initializer call. Obviously supporting memberwise initialization with Cocoa classes would require Apple to add the MEMBERWISE attribute where appropriate. A proposal for the Objective-C class import provision is of significantly less value if this did not happen. My recommendation is that an Objective-C import proposal should be drafted and submitted if this proposal is submitted, but not until the core team is confident that Apple will add the necessary annotations to their frameworks. Alternatives considered Require stored properties to opt-in to memberwise initialization This is a reasonable option and and I expect a healthy debate about which default is better. The decision to adopt the automatic model by default was made for several reasons: The memberwise initializer for structs does not currently require an annotation for properties to opt-in. Requiring an annotation for a mechanism designed to supersede that mechanism may be viewed as boilerplate. Stored properties with public visibility are often intialized directly with a value provided by the caller. Stored properties with less visibility than a memberwise initializer are not eligible for memberwise initialization. No annotation is required to indicate that and it is usually not desired. The automatic model cannot exist unless it is the default. The opt-in model can exist alongside the automatic model and itself be opted-into simply by specifying the memberwise declaration modifier on one or more properties. I do think a strong argument can be made that it may be more clear to require a memberwise declaration modifier on stored properties in order to opt-in to memberwise initialization. Allow all initializers to participate in memberwise initialization This option was not seriously considered. It would impact existing code and it would provide no indication in the declaration of the initializer that the compiler will synthesize additional parameters and perform additional initialization of stored properties in the body of the initializer. Require initializers to opt-out of memberwise initialization This option was also not seriously considered. It has the same problems as allowing all initializers to participate in memberwise initialization. Allow parameters to be synthesized for properties with a lower access level than the initializer I considered allowing parameters to be synthesized for properties that are not directly visible to callers of the initializer. There is no direct conflict with the access modifier and it is possible to write such code manually. I decided against this approach because as it is unlikely to be the right approach most of the time. In cases where it is the right approach I think it is a good thing to require developers to write this code manually. Reasons to limit memberwise parameter synthesis to members which are at least as visible as the initializer include: Makes logical sense at first blush. Memberwise inits publishing private state would be odd/surprising. Safer default, in that you don’t accidentally publish stuff you don’t want through a memberwise init. It is likely the more common desire of the author of an initializer. If the caller can’t see a member it probably doesn’t make sense to allow them to initialize it. If we expose more private-members by default then memberwise initialization is useless under the current proposal in many cases. There would be no way to prevent synthesis of parameters for more-private members. We have to choose between allowing callers to initialize our internal state or forgoing the benefit of memberwise initialization. If a proposal for @nomemberwise is put forward and adopted that would allow us to prevent synthesis of parameters for members as desired. Unfortunately @nomemberwise would need to be used much more heavily than it otherwise would (i.e. to prevent synthesis of memberwise parameters for more-private members). It would be better if @nomemberwise was not necessary most of the time. If callers must be able to provide memberwise arguments for more-private members directly it is still possible to allow that while taking advantage of memberwise initialization for same-or-less-private members. You just need to declare a memberwise init with explicitly declared parameters for the more-private members and initialize them manually in the body. If the “Access control for init” enhancement is accepted another option would be upgrading the visibility of init for the more-private member while retaining its access level for the getter and setter. Requiring the programmer to explicitly expose a more-private member either via init access control or by writing code that it directly is arguably a very good thing. Reasons we might want to allow memberwise parameter synthesis for members with lower visiblity than the initializer: Not doing so puts tension between access control for stored properties and memberwise inits. You have to choose between narrower access control or getting the benefit of a memberwise init. Another way to say it: this design means that narrow access control leads to boilerplate. NOTE: The tension mentioned here is lessened by #6 above: memberwise initialization can still be used for same-or-less-private members and the requirement to explicitly expose more-private members to more-public initializers one way or another is arguably a good thing. Require initializers to explicitly specify memberwise initialization parameters The thread “helpers for initializing properties of the same name as parameters” discussed an idea for synthesizing property initialization in the body of the initializer while requiring the parameters to be declard explicitly. struct Foo { let bar: String let bas: Int let baz: Double init(self.bar: String, self.bas: Int, bax: Int) { // self.bar = bar synthesized by the compiler // self.bas = bas synthesized by the compiler self.baz = Double(bax) } } The downside of this approach is that it does not address the M x N scaling issue mentioned in the motivation section. The manual initialization statements are elided, but the boilerplate parameter declarations still grow at the rate MxN (properties x initializers). It also does not address forwarding of memberwise initialization parameters which makes it useless for convenience and delegating initializers. Proponents of this approach believe it provides additional clarity and control over the current proposal. Under the current proposal full control is still available. It requires initializers to opt-in to memberwise initialization. When full control is necessary an initializer will simply not opt-in to memberwise initialization synthesis. The boilerplate saved in the examples on the list is relatively minimal and is tolerable in situations where full control of initialization is required. I believe the memberwise declaration modifier on the initializer and the placeholder in the parameter list make it clear that the compiler will synthesize additional parameters. Furthermore, IDEs and generated documentation will contain the full, synthesized signature of the initializer. Finally, this idea is not mutually exclusive with the current proposal. It could even work in the declaration of a memberwise initializer, so long the corresponding property was made ineligible for memberwise intialization synthesis. Adopt “type parameter list” syntax like Kotlin and Scala Several commenters in the mailing list thread have suggested using syntax like Kotlin and Scala that looks like this: struct Rect(var origin: Point = Point(), var size: Size = Size()) {} Which would expand to: struct Rect {} // Whether the initial value is included here or not is unclear. // Mailing list suggestions have not included it. var origin: Point // = Point() var size: Size // = Size() init(origin: Point = Point(), size: Size = Size()) { self.origin = origin self.size = size } This approach was not chosen because it is not compatible with the goal of this proposal to provide a flexible and scalable solution for memberwise initialization. Specific reasons include: This proposal supports partial memberwise initialization. Initializers can receive non-memberwise parameters and can initialize private state manually while still exposing public properties for direct initialization by callers via memberwise initialization. This proposal supports multiple memberwise initializers. It may be necessary to support more than one way to initialize private state while still desiring direct initialization of public properties via memberwise initialization. This proposal supports more flexibility for organizing property declarations. The Scala / Kotlin syntax may be acceptable in really simple cases. Unfortunately it requires placing property declarations in a single list at the beginning of the type declaration. This is extremely limiting. It is especially unfortunatey for types which contain generic parameters and inheritance clauses. Property declarations would be sandwiched in between those two clauses cluttering up type-level information with member-level information This proposal is not mutually exclusive with supporting the “type parameter list” syntax. They are aimed at solving different problems and could live side-by-side. A future proposal could introduce similar syntax. One option for such a proposal would be to provide a simple expansion into property declarations, allowing the current proposal to drive synthesis of the initializer (assuming the default parameter values for let properties problem is solved by that time). In fairness I would like to repeat the advantages of the Scala / Kotlin syntax that have been mentioned: It might support default values for parameters corresponding to let properties. It could allow parameter labels to be specified. It is more concise than the current proposal in some cases. Responses to these points follow: If the expansion of this syntax does not supply initial values to the synthesized properties and only uses the default value for parameters of the synthesized initializer this is true. The downside of doing this is that var properties no longer have an initial value which may be desirable if you write additional initializers for the type. I believe we should continue the discussion about default values for let properties. Ideally we can find an acceptable solution that will work with the current proposal, as well as any additional syntactic sugar we add in the future. I don’t believe allowing parameter labels for memberwise initialization parameters is a good idea. Callers are directly initializing a property and are best served by a label that matches the name of the property. If you really need to provide a different name you can still do so by writing your initializer manually. With future enhancements to the current proposal you may be able to use memberwise intialization for properties that do not require a custom label while manually initialzing properties that do need one. The Scala / Kotlin syntax is indeed more concise in some cases, but not in all cases. Under this proposal the example given above is actually more concise than it is with that syntax: struct Rect { var origin: Point = Point(), size: Size = Size() } vs struct Rect(var origin: Point = Point(), var size: Size = Size()) {}",
    "url": "http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html",
    "relUrl": "/docs/2019-08-26-0018-flexible-memberwise-initialization.html"
  },
  "18": {
    "id": "18",
    "title": "SE-0019 Swift Testing",
    "content": "Swift Testing Proposal: SE-0019 Authors: Max Howell, Daniel Dunbar, Mattt Thompson Review Manager: Rick Ballard Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-592 Introduction Testing is an essential part of modern software development. Tight integration of testing into the Swift Package Manager will help ensure a stable and reliable packaging ecosystem. SE Review Link, Second Review Proposed Solution We propose to extend our conventional package directory layout to accommodate test modules. Any subdirectory of the package root directory named “Tests” or any subdirectory of an existing module directory named “Tests” will comprise a test module. For example: Package ├── Sources │ └── Foo │ └──Foo.swift └── Tests └── Foo └── Test.swift Or: Package └── Sources ├── Foo.swift └── Tests └── Test.swift Or, for projects with a single module: Package ├── Sources │ └── Foo.swift └── Tests └── TestFoo.swift The filename: TestFoo.swift is arbitrary. In the examples above a test case is created for the module Foo based on the sources in the relevant subdirectories. A test-module is created per subdirectory of Tests, so: Package ├── Sources │ └── Foo │ └──Foo.swift └── Tests └── Foo └── Test.swift └── Bar └── Test.swift Would create two test-modules. The modules in this example may test different aspects of the module Foo, it is entirely up to the package author. Additionally, we propose that building a module also builds that module’s corresponding tests. Although this would result in slightly increased build times, we believe that tests are important enough to justify this (one might even consider slow building tests to be a code smell). We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles. As an exception, when packages are built in release mode we will not build tests because for release builds we should not enable testability. However, considering the need for release-mode testing this will be a future direction. This feature is controversial; many are worried always building tests will slow debug cycles. We understand these concerns but think knowing quickly tests have been broken by code changes is important. However we will provide an command line option to not build tests and will be open to reversing this decision in future should it be proven unwise. Command-Line Interface We propose the following syntax to execute all tests (though not the tests of any dependent packages): $ swift test The command line should accept the names of specific test cases to run: swift test TestModule.FooTestCase Or specific tests: swift test TestModule.FooTestCase.test1 In the future we would like to support running specific kinds of tests: swift test --kind=performance swift test would forward any other arguments to the underlying testing framework and it would decide how to interpret them. Sometimes test sources cannot compile and fixing them is not the most pressing priority. Thus it will be possible to skip building tests with an additional flag: swift build --without-tests It is desirable to sometimes specify to only build specific tests, the command line for this will fall out of future work that allows specification of targets that swift build should specifically build in isolation. Users should be able to run the tests of all their dependencies. This is not the default behavior, but a flag will be provided. Command Output Executing a test from the terminal will produce user-readable output. This should incorporate colorization and other formatting similar to other testing tools to indicate the success and failure of different tests. For example: $ swift test --output module Running tests for PackageX (x/100) .........x.....x................... Completed Elapsed time: 0.2s 98 Success 2 Failure 1 Warning FAILURE: Tests/TestsA.swift:24 testFoo() XCTAssertTrue expected true, got false FAILURE: Tests/TestsB.swift:10 testBar() XCTAssertEqual WARNING: Tests/TestsC.swift:1 &quot;Some Warning&quot; An additional option may be passed to the testing command to output JUnit-style XML or other formats that can be integrated with continuous integration (CI) and other systems. Running swift test will firstly trigger a build. We feel this is the most expected result considering tests must be built before they can be run and almost all other tools build before running tests. However we will provide a flag to not build first. Test-only Dependencies There is already a mechanism to specify test-only dependencies. It is very basic, but a new proposal should be made for more advanced Package.swift functionality. This proposal also does not cover the need for utility code, ie. a module that is built for tests to consume that is provided as part of a package and is not desired to be an external package. This is something we would like to add as part of a future proposal. Test-target configuration This proposal does not allow a test-module to have module dependencies from its own package, and thus there is no provided mechanism to specify or configure tests in the Package.swift file. This will be added, but as part of a broader proposal for the future of the Package.swift file. Automatic Dependency Determination Testing is important and it is important to make the barrier to testing as minimal as possible. Thus, by analyzing the names of test targets, we will automatically determine the most likely dependency of that test and accommodate accordingly. For example, a test for “Foo” will depend on compilation of the library target Foo. Any additional dependencies or dependencies that could not be automatically determined would need to be specified in a package manifest separately. Debug / Release Configuration Although tests built in debug configuration are generally run against modules also build in debug configuration, it is sometimes necessary to specify the build configuration for tests separately. It is also sometimes necessary to explicitly specify this information for every build, such as when building in a release configuration to execute performance tests. We would like to eventually support these use cases, however this will not be present in the initial implementation of this feature. Testability Swift can build modules with “testability”, which allows tests to access entities with internal access control. Because it would be tedious for users to specify this requirement for tests, we intend to build debug builds with testability by default. It is desirable that modules that are built for testing can identify this fact in their sources. Thus at a future time we will provide a define. Test Frameworks Initially, the Swift Package Manager will use XCTest as its underlying test framework. However, testing is an evolving art form, so we’d like to support other approaches that might allow frameworks other than XCTest to be supported by the package manager. We expect that such an implementation would take the form of a Swift protocol that the package manager defines, which other testing frameworks can adopt. Impact On Existing Code Current releases of the package manager already exclude directories named “Tests” from target-determination. Directories named FooTests are not excluded, but as it stands this is a cause of compile failure, so in fact these changes will positively impact existing code. Alternatives Considered We considered supporting the following layout: Package └── Sources │ └── Foo.swift └── FooTests └── Test.swift This was considered because of the vast number of existing Xcode projects out there that are laid out in the fashion. However it was decided that the rules for these layouts are inconsistent with our existing simple set. When users experience unexpected consequences of layouts with our convention approach it can be confusing and tricky to diagnose, so we should instead submit another proposal in the future that allows easy configuration of targets in Package.swift. We considered decoupling testing from SwiftPM altogether. However, since tests must be built and dependencies of tests must be managed complete decoupling is not possible. The coupling will be minimal, with a separate library and executable for tests, this is about as far as we think it is prudent to go. We considered not baking in support for XCTest and only having a protocol for testing. We would like to get testing up to speed as soon as possible. Using XCTest allows this to occur. We also think there is value in packages being able to depend on a testing framework being provided by the Swift system. However nothing stops us eventually making the support for XCTest work via our protocol system.",
    "url": "http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html",
    "relUrl": "/docs/2019-08-26-0019-package-manager-testing.html"
  },
  "19": {
    "id": "19",
    "title": "SE-0020 Swift Language Version Build Configuration",
    "content": "Swift Language Version Build Configuration Proposal: SE-0020 Author: David Farler Review Manager: Doug Gregor Status: Implemented (Swift 2.2) Implementation: apple/swift@c32fb8e Introduction This proposal aims to add a new build configuration option to Swift 2.2: #if swift. Swift-evolution threads: Swift 2.2: #if swift language version Review Motivation Over time, Swift syntax may change but library and package authors will want their code to work with multiple versions of the language. Up until now, the only recourse developers have is to maintain separate release branches that follow the language. This gives developers another tool to track syntax changes without having to maintain separate source trees. We also want to ease the transition between language revisions for package authors that distribute their source code, so clients can build their package with older or newer Swift. Proposed solution The solution is best illustrated with a simple example: #if swift(&gt;=2.2) print(&quot;Active!&quot;) #else this! code! will! not! parse! or! produce! diagnostics! #endif Detailed design This will use existing version mechanics already present in the compiler. The version of the language is baked into the compiler when it’s built, so we know how to determine whether a block of code is active. If the version is at least as recent as specified in the condition, the active branch is parsed and compiled into your code. Like other build configurations, #if swift isn’t line-based - it encloses whole statements or declarations. However, unlike the others, the compiler won’t parse inactive branches guarded by #if swift or emit lex diagnostics, so syntactic differences for other Swift versions can be in the same file. For now, we’ll only expect up to two version components, since it will be unlikely that a syntax change will make it in a +0.0.1 revision. The argument to the configuration function is a unary prefix expression, with one expected operator, &gt;=, for simplicity. If the need arises, this can be expanded to include other comparison operators. Impact on existing code This mechanism is opt-in, so existing code won’t be affected by this change. Alternatives considered We considered two other formats for the version argument: String literals (#if swift(&quot;2.2&quot;)): this allows us to embed an arbitrary number of version components, but syntax changes are unlikely in micro-revisions. If we need another version component, the parser change won’t be severe. Just plain #if swift(2.2): Although &gt;= is a sensible default, it isn’t clear what the comparison is here, and might be assumed to be ==. Argument lists (#if swift(2, 2): This parses flexibly but can indicate that the second 2 might be an argument with a different meaning, instead of a component of the whole version.",
    "url": "http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html",
    "relUrl": "/docs/2019-08-26-0020-if-swift-version.html"
  },
  "20": {
    "id": "20",
    "title": "SE-0021 Naming Functions with Argument Labels",
    "content": "Naming Functions with Argument Labels Proposal: SE-0021 Author: Doug Gregor Review Manager: Joe Groff Status: Implemented (Swift 2.2) Decision Notes: Rationale Implementation: apple/swift@ecfde0e Introduction Swift includes support for first-class functions, such that any function (or method) can be placed into a value of function type. However, when specifying the name of a function, one can only provide the base name, (e.g., insertSubview) without the argument labels. For overloaded functions, this means that one must disambiguate based on type information, which is awkward and verbose. This proposal allows one to provide argument labels when referencing a function, eliminating the need to provide type context in most cases. Swift-evolution thread: The first draft of this proposal was discussed here. It included support for naming getters/setters (separately brought up by Michael Henson here, continued here). Joe Groff convinced me that lenses are a better approach for working with getters/setters, so I’ve dropped them from this version of the proposal. Motivation It’s fairly common in Swift for multiple functions or methods to have the same “base name”, but be distinguished by parameter labels. For example, UIView has three methods with the same base name insertSubview: extension UIView { func insertSubview(view: UIView, at index: Int) func insertSubview(view: UIView, aboveSubview siblingSubview: UIView) func insertSubview(view: UIView, belowSubview siblingSubview: UIView) } When calling these methods, the argument labels distinguish the different methods, e.g., someView.insertSubview(view, at: 3) someView.insertSubview(view, aboveSubview: otherView) someView.insertSubview(view, belowSubview: otherView) However, when referencing the function to create a function value, one cannot provide the labels: let fn = someView.insertSubview // ambiguous: could be any of the three methods In some cases, it is possible to use type annotations to disambiguate: let fn: (UIView, Int) = someView.insertSubview // ok: uses insertSubview(_:at:) let fn: (UIView, UIView) = someView.insertSubview // error: still ambiguous! To resolve the latter case, one must fall back to creating a closure: let fn: (UIView, UIView) = { view, otherView in button.insertSubview(view, aboveSubview: otherView) } which is painfully tedious. One additional bit of motivation: Swift should probably get some way to ask for the Objective-C selector for a given method (rather than writing a string literal). The argument to such an operation would likely be a reference to a method, which would benefit from being able to name any method, including getters and setters. Proposed solution I propose to extend function naming to allow compound Swift names (e.g., insertSubview(_:aboveSubview:)) anywhere a name can occur. Specifically, let fn = someView.insertSubview(_:at:) let fn1 = someView.insertSubview(_:aboveSubview:) The same syntax can also refer to initializers, e.g., let buttonFactory = UIButton.init(type:) The “produce the Objective-C selector for the given method” operation will be the subject of a separate proposal. However, here is one possibility that illustrations how it uses the proposed syntax here: let getter = Selector(NSDictionary.insertSubview(_:aboveSubview:)) // produces insertSubview:aboveSubview:. Detailed Design Grammatically, the primary-expression grammar will change from: primary-expression -&gt; identifier generic-argument-clause[opt] to: primary-expression -&gt; unqualified-name generic-argument-clause[opt] unqualified-name -&gt; identifier | identifier &#39;(&#39; ((identifier | &#39;_&#39;) &#39;:&#39;)+ &#39;)&#39; Within the parentheses, the use of “+” is important, because it disambiguates: f() as a call to f rather than a reference to an f with no arguments. Zero-argument function references will still require disambiguation via contextual type information. Note that the reference to the name must include all of the arguments present in the declaration; arguments for defaulted or variadic parameters cannot be skipped. For example: func foo(x x: Int, y: Int = 7, strings: String...) { ... } let fn1 = foo(x:y:strings:) // okay let fn2 = foo(x:) // error: no function named &#39;foo(x:)&#39; Impact on existing code This is a purely additive feature that has no impact on existing code. Alternatives considered Joe Groff notes that lenses are a better solution than manually retrieving getter/setter functions when the intent is to actually operate on the properties. Bartlomiej Cichosz suggests a general partial application syntax using _ as a placeholder, e.g., aGameView.insertSubview(_, aboveSubview: playingSurfaceView) When all arguments are _, this provides the ability to name any method: aGameView.insertSubview(_, aboveSubview: _) I decided not to go with this because I don’t believe we need such a general partial application syntax in Swift. Closures using the $ names are nearly as concise, and eliminate any questions about how the _ placeholder maps to an argument of the partially-applied function: { aGameView.insertSubview($0, aboveSubview: playingSurfaceView) } We could elide the underscores in the names, e.g., let fn1 = someView.insertSubview(:aboveSubview:) However, this makes it much harder to visually distinguish methods with no first argument label from methods with a first argument label, e.g., f(x:) vs. f(:x:). Additionally, empty argument labels in function names are written using the underscores everywhere else in the system (e.g., the Clang swift_name attribute), and we should maintain consistency.",
    "url": "http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html",
    "relUrl": "/docs/2019-08-26-0021-generalized-naming.html"
  },
  "21": {
    "id": "21",
    "title": "SE-0022 Referencing the Objective-C selector of a method",
    "content": "Referencing the Objective-C selector of a method Proposal: SE-0022 Author: Doug Gregor Review Manager: Joe Groff Status: Implemented (Swift 2.2) Decision Notes: Rationale Implementation: apple/swift#1170 Introduction In Swift 2, Objective-C selectors are written as string literals (e.g., &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This proposal seeks to replace this error-prone approach with Selector initialization syntax that refers to a specific method via its Swift name. Swift-evolution thread: here, Review, Amendments after acceptance Motivation The use of string literals for selector names is extremely error-prone: there is no checking that the string is even a well-formed selector, much less that it refers to any known method, or a method of the intended class. Moreover, with the effort to perform automatic renaming of Objective-C APIs, the link between Swift name and Objective-C selector is non-obvious. By providing explicit “create a selector” syntax based on the Swift name of a method, we eliminate the need for developers to reason about the actual Objective-C selectors being used. Proposed solution Introduce a new expression #selector that allows one to build a selector from a reference to a method, e.g., control.sendAction(#selector(MyApplication.doSomething), to: target, forEvent: event) where “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C: extension MyApplication { @objc(jumpUpAndDown:) func doSomething(sender: AnyObject?) { … } } By naming the Swift method and having the #selector expression do the work to form the Objective-C selector, we free the developer from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C. This proposal composes with the Naming Functions with Argument Labels proposal, which lets us name methods along with their argument labels, e.g.: let sel = #selector(UIView.insertSubview(_:atIndex:)) // produces the Selector &quot;insertSubview:atIndex:&quot; With the introduction of the #selector syntax, we should deprecate the use of string literals to form selectors. Ideally, we could perform the deprecation in Swift 2.2 and remove the syntax entirely from Swift 3. Additionally, we should introduce specific migrator support to translate string-literals-as-selectors into method references. Doing this well is non-trivial, requiring the compiler/migrator to find all of the declarations with a particular Objective-C selector and determine which one to reference. However, it should be feasible, and we can migrate other references to a specific, string-based initialization syntax (e.g., Selector(&quot;insertSubview:atIndex:&quot;)). Detailed design The subexpression of the #selector expression must be a reference to an objc method. Specifically, the input expression must be a direct reference to an Objective-C method, possibly parenthesized and possibly with an “as” cast (which can be used to disambiguate same-named Swift methods). For example, here is a “highly general” example: let sel = #selector(((UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void)) The expression inside #selector is limited to be a series of instance or class members separated by . where the last component may be disambiguated using as. In particular, this prohibits performing method calls inside #selector, clarifying that the subexpression of #selector will not be evaluated and no side effects occur because of it. The complete grammar of #selector is: selector → #selector(selector-path) selector-path → type-identifier . selector-member-path as-disambiguationopt selector-path → selector-member-path as-disambiguationopt selector-member-path → identifier selector-member-path → unqualified-name selector-member-path → identifier . selector-member-path as-disambiguation → as type-identifier Impact on existing code The introduction of the #selector expression has no impact on existing code. However, deprecating and removing the string-literal-as-selector syntax is a source-breaking change. We can migrate the uses to either the new #selector expression or to explicit initialization of a Selector from a string. Alternatives considered The primary alternative is type-safe selectors, which would introduce a new “selector” calling convention to capture the type of an @objc method, including its selector. One major benefit of type-safe selectors is that they can carry type information, improving type safety. From that discussion, referencing MyClass.observeNotification would produce a value of type: @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void Objective-C APIs that accept selectors could provide type information (e.g., via Objective-C attributes or new syntax for a typed SEL), improving type safety for selector-based APIs. Personally, I feel that type-safe selectors are a well-designed feature that isn’t worth doing: one would probably not use them outside of interoperability with existing Objective-C APIs, because closures are generally preferable (in both Swift and Objective-C). The cost of adding this feature to both Swift and Clang is significant, and we would also need adoption across a significant number of Objective-C APIs to make it worthwhile. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred anyway. Therefore, we should implement the simpler feature in this proposal rather than the far more complicated (but admittedly more type-safe) alternative approach. Syntactically, @selector(method reference) would match Objective-C more closely, but it doesn’t make sense in Swift where @ always refers to attributes. The original version of this proposal suggested using a magic Selector initializer, e.g.: let sel = Selector(((UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) - However, concerns over this being magic syntax that looks like instance construction (but is not actually representable in Swift as an initializer), along with existing uses of # to denote special expressions (e.g., #available), caused the change to the #selector syntax at the completion of the public review. Revision history 2016-05-20: The proposal was amended post-acceptance to limit the syntax inside the subexpression of #selector, in particular disallowing methods calls. Originally any valid Swift expression was supported.",
    "url": "http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html",
    "relUrl": "/docs/2019-08-26-0022-objc-selectors.html"
  },
  "22": {
    "id": "22",
    "title": "SE-0023 API Design Guidelines",
    "content": "API Design Guidelines Proposal: SE-0023 Authors: Dave Abrahams, Doug Gregor, Dmitri Gribenko, Ted Kremenek, Chris Lattner, Alex Migicovsky, Max Moiseev, Ali Ozer, Tony Parker Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Reviewer notes This review is part of a group of three related reviews, running concurrently: SE-0023 API Design Guidelines (Review) SE-0006 Apply API Guidelines to the Standard Library (Review) SE-0005 Better Translation of Objective-C APIs Into Swift (Review) These reviews are running concurrently because they interact strongly (e.g., an API change in the standard library will correspond to a particular guideline, or an importer rule implements a particular guideline, etc.). Because of these interactions, and to keep discussion manageable, we ask that you: Please get a basic understanding of all three documents before posting review commentary Please post your review of each individual document in response to its review announcement. It’s okay (and encouraged) to make cross-references between the documents in your review where it helps you make a point. Introduction The design of commonly-used libraries has a large impact on the overall feel of a programming language. Great libraries feel like an extension of the language itself, and consistency across libraries elevates the overall development experience. To aid in the construction of great Swift libraries, one of the major goals for Swift 3 is to define a set of API design guidelines and to apply those design guidelines consistently. Proposed solution The proposed API Design Guidelines are available at https://swift.org/documentation/api-design-guidelines/. The sources for these guidelines are available at https://github.com/apple/swift-internals. Pull requests for trivial copyediting changes are most welcome. More substantive changes should be handled as part of the review process. Impact on existing code The existence of API Design Guidelines has no specific impact on existing code. However, two companion proposals that apply these guidelines to the Standard Library and via the Clang importer will have a massive impact on existing code, changing a significant number of APIs.",
    "url": "http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html",
    "relUrl": "/docs/2019-08-26-0023-api-guidelines.html"
  },
  "23": {
    "id": "23",
    "title": "SE-0024 Optional Value Setter `??=`",
    "content": "Optional Value Setter ??= Proposal: SE-0024 Author: James Campbell Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction Introduce a new operator an “Optional Value Setter”. If the optional is set via this operator then the new value is only set if there isn’t an already existing value. Swift-evolution thread: link to the discussion thread for that proposal Motivation In certain cases the ?? operation doesn’t help with lengthly variable names, i.e., really.long.lvalue[expression] = really.long.lvalue[expression] ?? &quot;&quot;. In addtition to this other languages such as Ruby contain a pipe operator really.long.lvalue[expression] ||= &quot;&quot; which works the same way and which is very popular. This lowers the barrier of entry for programmers from that language. In the interest in conciseness and clarity I feel this would be a great addition to swift and would bring the length of that previous statement from really.long.lvalue[expression] = really.long.lvalue[expression] ?? &quot;&quot; to really.long.lvalue[expression] ??= &quot;&quot; Proposed solution In this solution an optonals value wouldn’t be set if it already contains a value (i.e .Some), ideally willSet and didSet are only called if this operation occurs. var itemsA:[Item]? = nil var itemsB:[Item]? = [Item()] itemsA ??= [] // itemsA is set since its value is .None itemsB ??= [] // itemsB&#39;s value isn&#39;t changed since its value is .Some Impact on existing code Since this is a strictly additive and optional feature, it won’t affect existing code and should make code more concise going forward. Alternatives considered Other syntaxes included ?= but we felt it didn’t match the convention of the ?? in a = a ?? &quot;&quot;.",
    "url": "http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html",
    "relUrl": "/docs/2019-08-26-0024-optional-value-setter.html"
  },
  "24": {
    "id": "24",
    "title": "SE-0025 Scoped Access Level",
    "content": "Scoped Access Level Proposal: SE-0025 Author: Ilya Belenkiy Status: Implemented (Swift 3) Review Manager: Doug Gregor Decision Notes: Rationale Bug: SR-1275 Previous revision: 1 Introduction Scoped access level allows hiding implementation details of a class or a class extension at the class/extension level, instead of a file. It is a concise expression of the intent that a particular part of a class or extension definition is there only to implement a public API for other classes or extensions and must not be used directly anywhere outside of the scope of the class or the extension. Swift Evolution Discussion, Next Steps Discussion Motivation Currently, the only reliable way to hide implementation details of a class is to put the code in a separate file and mark it as private. This is not ideal for the following reasons: It is not clear whether the implementation details are meant to be completely hidden or can be shared with some related code without the danger of misusing the APIs marked as private. If a file already has multiple classes, it is not clear if a particular API is meant to be hidden completely or can be shared with the other classes. It forces a one class per file structure, which is very limiting. Putting related APIs and/or related implementations in the same file helps ensure consistency and reduces the time to find a particular API or implementation. This does not mean that the classes in the same file need to share otherwise hidden APIs, but there is no way to express such sharability with the current access levels. Another, less reliable, way is to prefix APIs that are meant to be hidden with a _ or do something similar. That works, but it’s not enforced by the compiler, and those APIs show up in tools like code completion, so the programmer has to filter out the noise — although these tools could quite easily support hiding methods with the _ prefix standard. Also, there is a greater danger of using private APIs if they do something similar to public APIs but are somehow more optimized (because they make additional assumptions about the internal state). The existing solutions are in some ways similar to those for untyped collections. It is usually possible to give a collection a name that would imply the type of elements it holds (similar to using _ to indicate private), but it is not the same as specifying it explicitly. Just as with generics, the intent not to share the implementation details with any other class is much clearer with support from the language as opposed to relying on where the code is in the project. Also, with untyped collections, it is possible to add an element of a different type (deliberately or not). Generics make that impossible, and it’s enforced by the compiler. Similarly, a dedicated access level modifier could enforce hiding implementation details at the compiler level and make it impossible to accidentally misuse or (deliberately use) implementation details in a context that the class meant not to share. Proposed solution Add another access level modifier that is meant to express that the API is visible only within the scope in which it is defined. Properties, functions, and nested types marked this way would be completely hidden outside the class or class extension definition. After the first review, the core team decided that it would be best to use private for this access level and rename other access level modifiers for consistency. The most popular set of names is: public: symbol visible outside the current module internal: symbol visible within the current module fileprivate: symbol visible within the current file private: symbol visible within the current declaration (names proposed by Chris Lattner as an adjustment from names proposed by James Berry) Detailed design When a function, variable, constant, subscript, or initializer is defined with private access modifier, it is visible only within that lexical scope. For example: class A { private var counter = 0 // public API that hides the internal state func incrementCount() { ++counter } // hidden API, not visible outside of this lexical scope private func advanceCount(dx: Int) { counter += dx } // incrementTwice() is not visible here } extension A { // counter is not visible here // advanceCount() is not visible here // may be useful only to implement some other methods of the extension // hidden from anywhere else, so incrementTwice() doesn’t show up in // code completion outside of this extension private func incrementTwice() { incrementCount() incrementCount() } } Complications with private types When a type is defined with the private access modifier, things become a little more complicated. Of course the type itself is visible only within the lexical scope it is defined in, but what about members of the type? class Outer { private class Inner { var value = 0 } func test() { // Can Outer.test reference Inner&#39;s initializer? let inner = Inner() // Can Outer.test reference Inner&#39;s &#39;value&#39; property? print(inner.value) } } If the members of a private type are themselves considered private, it is very clear that they cannot be used outside of the type itself. However, it is also not currently permitted for a member to have an access level greater than its enclosing type. This restriction produces a conundrum: the type can be referenced within its enclosing lexical scope, but none of its members can. Ignoring formal concerns, the most likely expected behavior is that members not explicitly marked private are permitted to be accessed within the enclosing scope of the private type. To achieve this goal, we relax a few of the existing rules: The default level of access control anywhere is internal. The compiler should not warn when a broader level of access control is used within a type with more restrictive access, such as internal within a private type. This allows the designer of the type to select the access they would use were they to make the type more widely accessible. (The members still cannot be accessed outside the enclosing lexical scope because the type itself is still restricted, i.e. outside code will never encounter a value of that type.) The type of a member can reference only declarations that are accessible wherever the member is accessible. (This relaxes an existing rule that states that the type of a declaration may not reference any declarations that have broader access.) The change permits the following code: struct Outer { private typealias Value = Int private struct Inner { var value: Value } } and continues to treat this code as illegal: struct Outer { private struct Inner { private typealias Value = Int var value: Value } } A member that satisfies a protocol requirement may never be private. Similarly, a required initializer may never be private. As before, an extension with an explicit access modifier overrides the default internal access by specifying a default scope. Therefore, within an extension marked private, the default access level is fileprivate (since extensions are always declared at file scope). This matches the behavior of types declared private at file scope. As before, an explicit access modifier on an extension sets the maximum allowed access within that extension, and the compiler will warn on overly broad access within an extension that has an explicit access modifier. Impact on existing code Existing code will need to rename private to fileprivate to achieve the same semantics, although in many cases the new meaning of private is likely to still compile and to run exactly as before. Alternatives considered Do nothing and use _ and / or split the code into more files and use the private modifier. The proposed solution makes the intent much clearer and enforced by the compiler, and the language does not dictate how the code must be organized. Introduce a scoped namespace that would make it possible to hide APIs in part of the file. This introduces an extra level of grouping and nesting and forces APIs to be grouped by access level instead of a logical way that may make more sense. Introduce a different access modifier and keep the current names unchanged. The proposal originally followed this approach to be completely compatible with the existing code, but the core team decided that it was better to use private for this modifier because it’s much closer to what the term means in other languages. Alternatives considered for “the private type issue” Use fileprivate rather than internal as the default access level within private and fileprivate types. This is a more narrow change from the original model, but didn’t have any benefits once we determined that the warning for unnecessarily broad access wasn’t useful. Introduce a new “parent” access level that declares an entity to be accessible within the parent lexical scope, rather than the immediately enclosing scope. This idea seems effective for private but is overly specific within types with any broader access and not worth the added complexity. We would also have to determine its name within the language, or decide that this level of access could not be spelled explicitly and was available only as the default access within private types. Introduce a new “default” access level that names the default access within a scope. Within a private type, this would have the “parent” semantics from (2); elsewhere it would follow the rules laid down in previous versions of Swift. This idea likewise added complexity to the model for only a small gain in expressivity, and we would likewise have to determine a name for it within the language. Changes from revision 1 The proposal was amended post-acceptance by Robert Widmann and Jordan Rose to account for “the private type issue”. Only that section was added; there were no semantic changes to the rest of the proposal. This amendment requires a small amount of work to implement compared to the alternatives considered, and was determined by the Core Team to be a small enough set of changes in the spirit of the original proposal that a full review was not necessary.",
    "url": "http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html",
    "relUrl": "/docs/2019-08-26-0025-scoped-access-level.html"
  },
  "25": {
    "id": "25",
    "title": "SE-0026 Abstract classes and methods",
    "content": "Abstract classes and methods Proposal: SE-0026 Author: David Scrève Review Manager: Joe Groff Status: Deferred Decision Notes: Rationale Introduction When developing framework and reusable code, we need to develop classes that are partially abstract with partial implementation. Protocol and protocol extensions provide this, but they cannot have attributes as classes have. A partial class combines the behavior of a class with the requirement of implementing methods in inherited class like protocols. Swift-Evolution Discussion Motivation like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development sometimes required abstract classes facility. An abstract class is like a regular class, but some methods/properties are not implemented and must be implemented in one of inherited classes. An abstract class can inherit from other class, implements protocols and has members attributes as opposite from protocols. Only some methods and properties might be abstract. The goal of abstract classes is to encapsulate a generic behavior that may need some specific implementation methods which are not known in abstract class. This behavior requires attributes that are used by internal abstract class method. Example : Considere a generic RESTClient that is included in a framework : class RESTClient { var timeout = 3000 var url : String { assert(false,&quot;Must be overriden&quot;) return &quot;&quot; } func performNetworkCall() { let restURL = self.url print(&quot;Performing URL call to (restURL) with timeout (self.timeout)&quot;) } } And an implementation : class MyRestServiceClient : RESTClient { override var url : String { return &quot;http://www.foo.com/client&quot; } } As you can see, url properties must be implemented by inherited class and should not be implemented by ancestor. As workaround, we have added assertion, but this error is only detected at runtime and not at compile time and might create crash for end-user. Another workaround would be to use the delegate/datasource pattern, but the delegate will not be able to use inheritance provided by classes. Proposed solution We propose to add a new keyword to indicate that a method or a property is abstract and not implemented in current class. This indicates that method or properties must be implemented in inherited class that can be implemented. We propose the keyword abstract that must be added to class and property/method : abstract class RESTClient { var timeout = 3000 abstract var url : String { get } func performNetworkCall() { let restURL = self.url print(&quot;Performing URL call to (restURL) with timeout (self.timeout)&quot;) } } And an implementation : class MyRestServiceClient : RESTClient { override var url : String { return &quot;http://www.foo.com/client&quot; } } Detailed design An abstract class cannot be instanciated. Abstract method/property cannot have implementation. If a class contains one or more abstract methods/properties, it must be declared abstract. A class that inherits from abstract must be declared abstract if it does not implements all inherited methods/properties. If you try to implement an abstract class or a inherited class that implements partially abstract methods/properties, you will get a compiler error. As for override keyword, abstract properties apply on setter, getter and observers. When declaring an abstract property, you must specify which methods must be implemented : get, set, didSet, willSet. If you do not specify anything, only setter and getter are made abstract as below : abstract var url : String Observers provides default empty implementation. Type is mandatory for abstract properties since it cannot be inferred. Impact on existing code This change has no impact on existing code, but might change the ABI that is being stabilizing in Swift 3.0. Alternatives considered As first reading, it seems that protocols and protocol extensions might fit the need. It actually does not because abstract classes can have attributes and properties that protocols do not support. An alternative solution would be to add attributes to protocols and protocol extensions, but this might break compatibility with Objective-C runtime.",
    "url": "http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html",
    "relUrl": "/docs/2019-08-26-0026-abstract-classes-and-methods.html"
  },
  "26": {
    "id": "26",
    "title": "SE-0027 Expose code unit initializers on String",
    "content": "Expose code unit initializers on String Proposal: SE-0027 Author: Zachary Waldowski Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography. Swift has such utilities, but currently only exposed through String.Type.fromCString(_:) and String.Type.fromCStringRepairingIllFormedUTF8(_:). See swift-evolution thread and draft proposal. Motivation In developing a parser, a coworker did the yeoman’s work of benchmarking Swift’s Unicode types. He swore up and down that String.Type.fromCString(_:) (use) was the fastest way he found. I, stubborn and noobish as I am, was skeptical that a better way couldn’t be wrought from Swift’s UnicodeCodecTypes. After reading through stdlib source and doing my own testing, this is no wives’ tale. fromCString is essentially the only public-facing user of String.Type._fromCodeUnitSequence(_:input:), which serves the exact role of both efficient and safe initialization-by-buffer-copy. After many attempts, I’ve concluded that the currently available String APIs are deficient, as they provide much worse performance without guaranteeing more Unicode safety. Of course, fromCString(_:) isn’t a silver bullet; it forces a UTF-8 encoding with a null sentinel, requiring either a copy of the origin buffer or regressing to the much slower character-by-character append path if a terminator needs to be added. This is the case with formats that specify the length up front, or unstructured payloads that use another terminator). It also prevents the string itself from containing the null character. Finally, the fromCString(_:) constructor requires a call to strlen, even if that’s already been calculated in users’ code. Proposed solution I’d like to expose an equivalent to String.Type._fromCodeUnitSequence(_:input:) as public API: static func decode&lt;Encoding: UnicodeCodecType, Input: CollectionType where Input.Generator.Element == Encoding.CodeUnit&gt;(_: Input, as: Encoding.Type, repairingInvalidCodeUnits: Bool = default) -&gt; (result: String, repairsMade: Bool)? For convenience, the Bool flag here is also separated out to a more common-case pair of String initializers: init&lt;...&gt;(codeUnits: Input, as: Encoding.Type) init?&lt;...&gt;(validatingCodeUnits: Input, as: Encoding.Type) Finally, for more direct compatibility with String.Type.fromCString(_:) and String.Type.fromCStringRepairingIllFormedUTF8(_:), these constructors are overloaded for pointer-based strings of unknown length: init(cString: UnsafePointer&lt;CChar&gt;) init?(validatingCString: UnsafePointer&lt;CChar&gt;) Detailed design See full implementation. We start by backporting the Swift 3.0 versions of the CString constructors, then making them generic over their input and codec. This is a fairly straightforward renaming of the internal APIs. The initializer, its labels, and their order were chosen to match other non-cast initializers in the stdlib. “Sequence” was removed, as it was a misnomer. “input” was kept as a generic name in order to allow for future refinements. These new constructors swap the expectations for the default: fromCString could fail on invalid code unit sequences, but init(cString:) will unconditionally succeed. This, as developed against Swift 3, should “most probably [be] the right thing”. The backported constructors follow the Swift 3.0 naming guidelines, and presumably won’t require any more changes after implementing this proposal. The new API has overloads that continue to work the old strlen way, while allowing users to specify arbitrary code unit sequences through UnsafeBufferPointer. Low-level performance benefits like these are extremely important to performance-sensitive code. In the case of reading from buffers of unknown length, keeping copies low is vital. The use of String.Type._fromWellFormedCodeUnitSequence(_:input:) was replaced with the new public API. Impact on existing code String.Type.fromCString(_:) and String.Type.fromCStringRepairingIllFormedUTF8(_:) are replaced with String.init(validatingCString:) and String.init(cString:), respectively. Do note that this is a reversal of the default expectations, as discussed above. The old methods refer to the new signatures using deprecation attributes, presumably for removal in Swift 3.0. Alternatives considered Do nothing. This seems suboptimal. For many use cases, String lacking this constructor is a limiting factor on performance for many kinds of pure-Swift implementations. A String.UTF8View and String.UTF16View solution (See also “Make String.append(_:) faster”) Make String.UTF8View and String.UTF16View mutable (a la String.UnicodeScalarView) with amortized O(1) append(_:)/appendContentsOf(_:). At least on the String.UTF16View side, this would be a simple change lifting the append(_:) from String.UnicodeScalarView. This would serve advanced use cases well, including supplanting String.Type._fromWellFormedCodeUnitSequence(_:input:). This might be the better long-term solution from the perspective of API maintenance, but in the meantime this proposal has a fairly low impact. A protocol-oriented API. Some kind of func decode&lt;Encoding&gt;(_:) on SequenceType. It’s not really clear this method would be related to string processing, and would require some kind of bounding (like where Generator.Element: UnsignedIntegerType), but that would be introducing a type bound that doesn’t exist already. Make the NSString bridge faster. After reading the bridge code, I don’t really know why it’s slower. Maybe it’s a bug. Make String.append(_:) faster. I don’t completely understand the growth strategy of _StringCore, but it doesn’t seem to exhibit the documented amortized O(1), even when reserveCapacity(_:) is used. In the pre-proposal discussion, a user noted that it seems like reserveCapacity acts like a no-op.",
    "url": "http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html",
    "relUrl": "/docs/2019-08-26-0027-string-from-code-units.html"
  },
  "27": {
    "id": "27",
    "title": "SE-0028 Modernizing Swift's Debugging Identifiers",
    "content": "Modernizing Swift’s Debugging Identifiers Proposal: SE-0028 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 2.2) Decision Notes: Rationale Bug: SR-669 Introduction This proposal aims to eliminate Swift’s use of “screaming snake case” like __FILE__ and __FUNCTION__ and replacing identifier instances with common octothorpe-prefixed lowercase #identifier representations. The Swift-Evolution discussion of this topic took place in the “[Review] SE-0022: Referencing the Objective-C selector of a method” thread and then in its own “[Proposal] Eliminating Swift’s Screaming Snake Case Identifiers” thread Motivation Swift offers built-in __FILE__, __LINE__, __COLUMN__, __FUNCTION__, and __DSO_HANDLE__ identifiers. The first four expand to string and integer literals corresponding to a current location in source code. The last provides an UnsafePointer to the current dynamic shared object (.dylib or .so file). These features provide high utility for logging, both tracing execution and enabling developers to capture error context. The current identifiers owe their syntax to C’s __FILE__ and __LINE__ macros. These are built into C’s preprocessor and expanded before running the C-language parser. Swift’s implementation differs from C’s but offers similar functionality and, unfortunately, similar symbols. This proposal aims to break free of the historic chains of their unsightly screaming snake case, which look like boa constrictors trying to digest fully swallowed keywords. Proposed solution Using octothorpe-prefixed keywords offers several advantages: They match the existing #available keyword (D. Gregor) They match SE-0022’s already-accepted #selector(...) approach that reference a method’s Objective-C selector (D. Gregor) They support targeted code completion (D. Gregor) They add a compiler-supported expression type that doesn’t steal keywords, introducing a convention where # means “invoke compiler substitution logic here” (J. Rose) They’d provide short-term solutions for a yet-as-undesigned macro system (D. Gregor) Detailed design This proposal renames the following identifiers: __FILE__ -&gt; #file __LINE__ -&gt; #line __COLUMN__ -&gt; #column __FUNCTION__ -&gt; #function (Added during review) __DSO_HANDLE__ -&gt; #dsohandle These identifiers retain the magic behavior of the existing __LINE__ features: in a normal expression context, they expand to the location at that point. In a default argument context, they expand to the location of the caller. Additional points to be considered by the Swift team for inclusion: Adding #filename to avoid using lastPathComponent on #file references. Retaining __FUNCTION__ to be renamed as #function. (Accepted during review) Adopting a lower-case naming standard including #dsohandle and a potential future #sourcelocation. Introducing #symbol, (e.g. Swift.Dictionary.Init(x:Int,y:String)), which summarizes context including module, type, and function. A fully qualified symbol enables users to access exactly the information they desire. It should contain parameter type information to properly identify member overloads. Possible Future Extensions SR-198 requested the coalescing of existing identifiers. A structured #sourcelocation identifier could be added as a follow-on if and when the Swift team decides to tackle a standardized source location type, which would provide individual field or keyword access. In support of summaries, Remy Demerest writes, “[I] love the idea that source location would be one object that you can print to get the full story while still retaining the possibility to use each individual components as needed, which is probably the rarer case. I never find myself wanting only some of properties and usually don’t include them simply because it takes longer to write the format properly, if I can get them all in one go it’s certainly a win.” Should such a type be adopted, I’d recommend support for common output summary representations suitably differentiated for debug and release logging. Alternatively #context, #releasecontext, and #debugcontext summaries could be added independently of the adoption of #sourcelocation. Implementation notes The octothorpe-delineated #line identifier already exists in Swift for resetting line numbers. Constraining the current #line directive to be the first token after a newline would disambiguate use. Alternatively, the context #line identifier could be renamed #linenumber. Review Acceptance and Modifications The review of SE-0028 “Modernizing Swift’s Debugging Identifiers” ran from January 29… February 2, 2016. The proposal has been accepted, with modifications: The core team agrees that we should rename all of the existing __FILE__, __LINE__, __COLUMN__, __FUNCTION__, and __DSO_HANDLE__ symbols to lowercase equivalents in the # namespace: #file, #line, #column, #function, #dsohandle. This includes keeping __FUNCTION__, and making #line have the dual behavior of being a directive when it is the first token on a line, but an expression otherwise. Renaming these symbols improves uniformity within the Swift language, and keeping all of them provides a smooth transition path from the old syntax to the new syntax. The core team isn’t thrilled with the magic “first token on a line” whitespace behavior that #line will be getting, and would like to start a discussion about renaming the old #line directive to something more specific and tailored to its purpose. Once that name and syntax is settled, we can rename the directive and remove the whitespace rule. The core team requests that #symbol be split out into a separate proposal, because it needs more detailed design work, and is an additive feature. For example, it might be appealing to provide a #mangledname expression that provides the current symbol as a mangled name: when fed into a demangler, a more structured form of the current symbol would be available.",
    "url": "http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html",
    "relUrl": "/docs/2019-08-26-0028-modernizing-debug-identifiers.html"
  },
  "28": {
    "id": "28",
    "title": "SE-0029 Remove implicit tuple splat behavior from function applications",
    "content": "Remove implicit tuple splat behavior from function applications Proposal: SE-0029 Author: Chris Lattner Review Manager: Joe Groff Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift@8e12008 Introduction Function call expressions (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift. Given something like: func foo(a : Int, b : Int) {} You can call it either with the typical syntactic form that passes arguments to each of its parameters: foo(42, b : 17) or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type): let x = (1, b: 2) foo(x) This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form. This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually. Swift-evolution thread: Proposal: Remove implicit tuple splat behavior from function applications Motivation This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form. A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code. This is extremely confusing if you don’t know the feature exists. There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter. The current implementation has a ton of implementation bugs - it doesn’t work reliably. The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden. The current implementation doesn’t work the way we would want a tuple splat operation to work. For example, arguably, you should be able to call foo with: func bar() -&gt; (Int, Int) { ... } foo(bar()) … but this is not allowed, since tuple labels are required to line up. You have to write: func bar() -&gt; (Int, b: Int) { … } foo(bar()) This makes this feature very difficult to use in practice, because you have to _‘ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees). The root problem here is that we use exactly the same syntax for both forms of function application. If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away. From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type. For a large number of reasons (including inout, default arguments, variadic arguments, labels, etc) we completely abandoned this model, but never came back to reevaluating the tuple splat behavior. If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form). Proposed solution The proposed solution is simple, we should just remove this feature from the Swift 3 compiler. Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3. However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course). One interesting aspect of this feature is that some people we’ve spoken to are very fond of it. However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it. This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one. Note: a common point of confusion about this proposal is that it does not propose removing the ability to pass tuples as values to functions. For example, this will still be perfectly valid: func f1(a : (Int, Int)) { ... } let x = (1, 2) f1(x) as are cases using generics: func f2&lt;T&gt;(a : T) -&gt; T { ... } let x = (1, 2) f2(x) The only affected case is when a single tuple argument is being expanded by the compiler out into multiple different declared parameters. Detailed design The design is straight-forward. In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form. The migrator would auto-apply the fixit hint as it does for other cases. Impact on existing code Any code that uses this feature will have to move to the traditional form. In the case of the example above, this means rewriting the code from: foo(x) into a form like this: foo(x.0, x.b) In the case where “x” is a complex expression, a temporary variable will need to be introduced. We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used. Alternatives considered The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, which has just been kept limping along). As such, the alternative is to actually design a proper feature to support this. Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this. For example, something like this could address the problems we have: foo(*x) // NOT a serious syntax proposal However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission: It is a pure-sugar feature, and therefore low priority. We don’t have an obvious sigil to use. “prefix-star” should be left unused for now in case we want to use it to refer to memory-related operations in the future. Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features). If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one. If a good design emerges, we can evaluate that design based on its merits. The final alternative is that we could leave the feature in the compiler. However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe. It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.",
    "url": "http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html",
    "relUrl": "/docs/2019-08-26-0029-remove-implicit-tuple-splat.html"
  },
  "29": {
    "id": "29",
    "title": "SE-0030 Property Behaviors",
    "content": "Property Behaviors Proposal: SE-0030 Author: Joe Groff Review Manager: Doug Gregor Status: Deferred Decision Notes: Rationale Introduction There are property implementation patterns that come up repeatedly. Rather than hardcode a fixed set of patterns into the compiler, we should provide a general “property behavior” mechanism to allow these patterns to be defined as libraries. Swift Evolution Discussion Review Motivation We’ve tried to accommodate several important patterns for properties with targeted language support, but this support has been narrow in scope and utility. For instance, Swift 1 and 2 provide lazy properties as a primitive language feature, since lazy initialization is common and is often necessary to avoid having properties be exposed as Optional. Without this language support, it takes a lot of boilerplate to get the same effect: class Foo { // lazy var foo = 1738 private var _foo: Int? var foo: Int { get { if let value = _foo { return value } let initialValue = 1738 _foo = initialValue return initialValue } set { _foo = newValue } } } Building lazy into the language has several disadvantages. It makes the language and compiler more complex and less orthogonal. It’s also inflexible; there are many variations on lazy initialization that make sense, but we wouldn’t want to hardcode language support for all of them. For instance, some applications may want the lazy initialization to be synchronized, but lazy only provides single-threaded initialization. The standard implementation of lazy is also problematic for value types. A lazy getter must be mutating, which means it can’t be accessed from an immutable value. Inline storage is also suboptimal for many memoization tasks, since the cache cannot be reused across copies of the value. A value-oriented memoized property implementation might look very different, using a class instance to store the cached value out-of-line in order to avoid mutation of the value itself. There are important property patterns outside of lazy initialization. It often makes sense to have “delayed”, once-assignable-then-immutable properties to support multi-phase initialization: class Foo { let immediatelyInitialized = &quot;foo&quot; var _initializedLater: String? // We want initializedLater to present like a non-optional &#39;let&#39; to user code; // it can only be assigned once, and can&#39;t be accessed before being assigned. var initializedLater: String { get { return _initializedLater! } set { assert(_initializedLater == nil) _initializedLater = newValue } } } Implicitly-unwrapped optionals allow this in a pinch, but give up a lot of safety compared to a non-optional ‘let’. Using IUO for multi-phase initialization gives up both immutability and nil-safety. We also have other application-specific property features like didSet/willSet that add language complexity for limited functionality. Beyond what we’ve baked into the language already, there’s a seemingly endless set of common property behaviors, including synchronized access, copying, and various kinds of proxying, all begging for language attention to eliminate their boilerplate. Proposed solution I suggest we allow for property behaviors to be implemented within the language. A var declaration can specify its behaviors in square brackets after the keyword: var [lazy] foo = 1738 which implements the property foo in a way described by the property behavior declaration for lazy: var behavior lazy&lt;Value&gt;: Value { var value: Value? = nil initialValue mutating get { if let value = value { return value } let initial = initialValue value = initial return initial } set { value = newValue } } Property behaviors can control the storage, initialization, and access of affected properties, obviating the need for special language support for lazy, observers, and other special-case property features. Examples Before describing the detailed design, I’ll run through some examples of potential applications for behaviors. Lazy The current lazy property feature can be reimplemented as a property behavior. // Property behaviors are declared using the `var behavior` keyword cluster. public var behavior lazy&lt;Value&gt;: Value { // Behaviors can declare storage that backs the property. private var value: Value? // Behaviors can bind the property&#39;s initializer expression with an // `initialValue` property declaration. initialValue // Behaviors can declare initialization logic for the storage. // (Stored properties can also be initialized in-line.) init() { value = nil } // Inline initializers are also supported, so `var value: Value? = nil` // would work equivalently. // Behaviors can declare accessors that implement the property. mutating get { if let value = value { return value } let initial = initialValue value = initial return initial } set { value = newValue } } Properties declared with the lazy behavior are backed by the Optional-typed storage and accessors from the behavior: var [lazy] x = 1738 // Allocates an Int? behind the scenes, inited to nil print(x) // Invokes the `lazy` getter, initializing the property x = 679 // Invokes the `lazy` setter Delayed Initialization A property behavior can model “delayed” initialization behavior, where the DI rules for properties are enforced dynamically rather than at compile time. This can avoid the need for implicitly-unwrapped optionals in multi-phase initialization. We can implement both a mutable variant, which allows for reassignment like a var: public var behavior delayedMutable&lt;Value&gt;: Value { private var value: Value? = nil get { guard let value = value else { fatalError(&quot;property accessed before being initialized&quot;) } return value } set { value = newValue } } and an immutable variant, which only allows a single initialization like a let: public var behavior delayedImmutable&lt;Value&gt;: Value { private var value: Value? = nil get { guard let value = value else { fatalError(&quot;property accessed before being initialized&quot;) } return value } // Perform an initialization, trapping if the // value is already initialized. set { if let _ = value { fatalError(&quot;property initialized twice&quot;) } value = initialValue } } This enables multi-phase initialization, like this: class Foo { var [delayedImmutable] x: Int init() { // We don&#39;t know &quot;x&quot; yet, and we don&#39;t have to set it } func initializeX(x: Int) { self.x = x // Will crash if &#39;self.x&#39; is already initialized } func getX() -&gt; Int { return x // Will crash if &#39;self.x&#39; wasn&#39;t initialized } } Property Observers A property behavior can also approximate the built-in behavior of didSet/willSet observers, by declaring support for custom accessors: public var behavior observed&lt;Value&gt;: Value { initialValue var value = initialValue // A behavior can declare accessor requirements, the implementations of // which must be provided by property declarations using the behavior. // The behavior may provide a default implementation of the accessors, in // order to make them optional. // The willSet accessor, invoked before the property is updated. The // default does nothing. mutating accessor willSet(newValue: Value) { } // The didSet accessor, invoked before the property is updated. The // default does nothing. mutating accessor didSet(oldValue: Value) { } get { return value } set { willSet(newValue) let oldValue = value value = newValue didSet(oldValue) } } A common complaint with didSet/willSet is that the observers fire on every write, not only ones that cause a real change. A behavior that supports a didChange accessor, which only gets invoked if the property value really changed to a value not equal to the old value, can be implemented as a new behavior: public var behavior changeObserved&lt;Value: Equatable&gt;: Value { initialValue var value = initialValue mutating accessor didChange(oldValue: Value) { } get { return value } set { let oldValue = value value = newValue if oldValue != newValue { didChange(oldValue) } } } For example: var [changeObserved] x: Int = 1 { didChange { print(&quot; (oldValue) =&gt; (x)&quot;) } } x = 1 // Prints nothing x = 2 // Prints 1 =&gt; 2 (Note that, like didSet/willSet today, neither behavior implementation will observe changes through class references that mutate a referenced class instance without changing the reference itself. Also, as currently proposed, behaviors would force the property to be initialized in-line, which is not acceptable for instance properties. That’s a limitation that can be lifted by future extensions.) Synchronized Property Access Objective-C supports atomic properties, which take a lock on get and set to synchronize accesses to a property. This is occasionally useful, and it can be brought to Swift as a behavior. The real implementation of atomic properties in ObjC uses a global bank of locks, but for illustrative purposes (and to demonstrate referring to self) I’ll use a per-object lock instead: // A class that owns a mutex that can be used to synchronize access to its // properties. public protocol Synchronizable: class { func withLock&lt;R&gt;(@noescape body: () -&gt; R) -&gt; R } // Behaviors can refer to a property&#39;s containing type using // the implicit `Self` generic parameter. Constraints can be // applied using a &#39;where&#39; clause, like in an extension. public var behavior synchronized&lt;Value where Self: Synchronizable&gt;: Value { initialValue var value: Value = initialValue get { return self.withLock { return value } } set { self.withLock { value = newValue } } } NSCopying Many Cocoa classes implement value-like objects that require explicit copying. Swift currently provides an @NSCopying attribute for properties to give them behavior like Objective-C’s @property(copy), invoking the copy method on new objects when the property is set. We can turn this into a behavior: public var behavior copying&lt;Value: NSCopying&gt;: Value { initialValue // Copy the value on initialization. var value: Value = initialValue.copy() get { return value } set { // Copy the value on reassignment. value = newValue.copy() } } This is a small sampling of the possibilities of behaviors. Let’s look at the proposed design in detail: Detailed design Property behavior declarations A property behavior declaration is introduced by the var behavior contextual keyword cluster. The declaration is designed to resemble the syntax of a property using the behavior: property-behavior-decl ::= attribute* decl-modifier* &#39;var&#39; &#39;behavior&#39; identifier // behavior name generic-signature? &#39;:&#39; type &#39;{&#39; property-behavior-member-decl* &#39;}&#39; Inside the behavior declaration, standard initializer, property, method, and nested type declarations are allowed, as are core accessor declarations —get and set. Accessor requirement declarations and initial value requirement declarations are also recognized contextually within the declaration: property-behavior-member-decl ::= decl property-behavior-member-decl ::= accessor-decl // get, set property-behavior-member-decl ::= accessor-requirement-decl property-behavior-member-decl ::= initial-value-requirement-decl Bindings within Behavior Declarations Inside a behavior declaration, self is implicitly bound to the value that contains the property instantiated using this behavior. For a freestanding property at global or local scope, this will be the empty tuple (), and for a static or class property, this will be the metatype. Within the behavior declaration, the type of self is abstract and represented by the implicit generic type parameter Self. Constraints can be placed on Self in the generic signature of the behavior, to make protocol members available on self: protocol Fungible { typealias Fungus func funge() -&gt; Fungus } var behavior runcible&lt;Value where Self: Fungible, Self.Fungus == Value&gt;: Value { get { return self.funge() } } Lookup within self is not implicit within behaviors and must always be explicit, since unqualified lookup refers to the behavior’s own members. self is immutable except in mutating methods, where it is considered an inout parameter unless the Self type has a class constraint. self cannot be accessed within inline initializers of the behavior’s storage or in init declarations, since these may run during the container’s own initialization phase. Definitions within behaviors can refer to other members of the behavior by unqualified lookup, or if disambiguation is necessary, by qualified lookup on the behavior’s name (since self is already taken to mean the containing value): var behavior foo&lt;Value&gt;: Value { var x: Int init() { x = 1738 } mutating func update(x: Int) { foo.x = x // Disambiguate reference to behavior storage } } If the behavior includes accessor requirement declarations, then the declared accessor names are bound as functions with labeled arguments: var behavior fakeComputed&lt;Value&gt;: Value { accessor get() -&gt; Value mutating accessor set(newValue: Value) get { return get() } set { set(newValue: newValue) } } Note that the behavior’s own core accessor implementations get { ... } and set { ... } are not referenceable this way. If the behavior includes an initial value requirement declaration, then the identifier initialValue is bound as a get-only computed property that evaluates the initial value expression for the property Properties and Methods in Behaviors Behaviors may include property and method declarations. Any storage produced by behavior properties is expanded into the containing scope of a property using the behavior. var behavior runcible&lt;Value&gt;: Value { var x: Int = 0 let y: String = &quot;&quot; ... } var [runcible] a: Int // expands to: var `a.[runcible].x`: Int let `a.[runcible].y`: String var a: Int { ... } For public behaviors, this is inherently fragile, so adding or removing storage is a breaking change. Resilience can be achieved by using a resilient type as storage. The instantiated properties must also be of types that are visible to potential users of the behavior, meaning that public behaviors must use storage with types that are either public or internal-with-availability, similar to the restrictions on inlineable functions. Method and computed property implementations have only immutable access to self and their storage by default, unless they are mutating. (As with computed properties, setters are mutating by default unless explicitly marked nonmutating). init in Behaviors The storage of a behavior must be initialized, either by inline initialization, or by an init declaration within the initializer: var behavior inlineInitialized&lt;Value&gt;: Value { var x: Int = 0 // initialized inline ... } var behavior initInitialized&lt;Value&gt;: Value { var x: Int init() { x = 0 } } Behaviors can contain at most one init declaration, which must take no parameters. This init declaration cannot take a visibility modifier; it is always as visible as the behavior itself. Neither inline initializers nor init declaration bodies may reference self, since they will be executed during the initialization of a property’s containing value. Initial Value Requirement Declaration An initial value requirement declaration specifies that a behavior requires any property declared using the behavior to be declared with an initial value expression. initial-value-requirement-decl ::= &#39;initialValue&#39; The initial value expression from the property declaration is coerced to the property’s type and bound to the initialValue identifier in the scope of the behavior. Loading from initialValue behaves like a get-only computed property, evaluating the expression every time it is loaded: var behavior evalTwice&lt;Value&gt;: Value { initialValue get { // Evaluate the initial value twice, for whatever reason. _ = initialValue return initialValue } } var [evalTwice] test: () = print(&quot;test&quot;) // Prints &quot;test&quot; twice _ = evalTwice A property declared with a behavior must have an initial value expression if and only if the behavior has an initial value requirement. Accessor Requirement Declarations An accessor requirement declaration specifies that a behavior requires any property declared using the behavior to provide an accessor implementation. An accessor requirement declaration is introduced by the contextual accessor keyword: accessor-requirement-decl ::= attribute* decl-modifier* &#39;accessor&#39; identifier function-signature function-body? An accessor requirement declaration looks like, and serves a similar role to, a function requirement declaration in a protocol. A property using the behavior must supply an implementation for each of its accessor requirements that don’t have a default implementation. The accessor names (with labeled arguments) are bound as functions within the behavior declaration: // Reinvent computed properties var behavior foobar&lt;Value&gt;: Value { accessor foo() -&gt; Value mutating accessor bar(bas: Value) get { return foo() } set { bar(bas: newValue) } } var [foobar] foo: Int { foo { return 0 } bar { // Parameter gets the name &#39;bas&#39; from the accessor requirement // by default, as with built-in accessors today. print(bas) } } var [foobar] bar: Int { foo { return 0 } bar(myNewValue) { // Parameter name can be overridden as well print(myNewValue) } } Accessor requirements can be made optional by specifying a default implementation: // Reinvent property observers var behavior observed&lt;Value&gt;: Value { // Requirements initialValue mutating accessor willSet(newValue: Value) { // do nothing by default } mutating accessor didSet(oldValue: Value) { // do nothing by default } // Implementation init() { value = initialValue } get { return value } set { willSet(newValue: newValue) let oldValue = value value = newValue didSet(oldValue: oldValue) } } Accessor requirements cannot take visibility modifiers; they are always as visible as the behavior itself. Like methods, accessors are not allowed to mutate the storage of the behavior or self unless declared mutating. Mutating accessors can only be invoked by the behavior from other mutating contexts. Core Accessor Declarations The behavior implements the property by defining its core accessors, get and optionally set. If a behavior only provides a getter, it produces read-only properties; if it provides both a getter and setter, it produces mutable properties (though properties that instantiate the behavior may still control the visibility of their setters). It is an error if a behavior declaration does not provide at least a getter. Using Behaviors in Property Declarations Property declarations gain the ability to instantiate behavior, with arbitrary accessors: property-decl ::= attribute* decl-modifier* core-property-decl core-property-decl ::= (&#39;var&#39; | &#39;let&#39;) behavior? pattern-binding ((&#39;,&#39; pattern-binding)+ | accessors)? behavior ::= &#39;[&#39; visibility? decl-ref &#39;]&#39; pattern-binding ::= var-pattern (&#39;:&#39; type)? inline-initializer? inline-initializer ::= &#39;=&#39; expr accessors ::= &#39;{&#39; accessor+ &#39;}&#39; | brace-stmt // see notes about disambiguation accessor ::= decl-modifier* decl-ref accessor-args? brace-stmt accessor-args ::= &#39;(&#39; identifier (&#39;,&#39; identifier)* &#39;)&#39; For example: public var [behavior] prop: Int { accessor1 { body() } behavior.accessor2(arg) { body() } } If multiple properties are declared in the same declaration, the behavior apply to every declared property. let properties cannot yet use behaviors. If the behavior requires accessors, the implementations for those accessors are taken from the property’s accessor declarations, matching by name. To support future composition of behaviors, the accessor definitions can use qualified names behavior.accessor. If an accessor requirement takes parameters, but the definition in for the property does not explicitly name parameters, the parameter labels from the behavior’s accessor requirement declaration are implicitly bound by default. var behavior foo&lt;Value&gt;: Value { accessor bar(arg: Int) ... } var [foo] x: Int { bar { print(arg) } // `arg` implicitly bound } var [foo] x: Int { bar(myArg) { print(myArg) } // `arg` explicitly bound to `myArg` } If any accessor definition in the property does not match up to a behavior requirement, it is an error. The shorthand for get-only computed properties is only allowed for computed properties that use no behaviors. Any property that uses behaviors with accessors must name all those accessors explicitly. If a property with behaviors declares an inline initializer, the initializer expression is captured as the implementation of a computed, get-only property which is bound to the behavior’s initializer requirement. If the behavior does not have a behavior requirement, then it is an error to use an inline initializer expression. Conversely, it is an error not to provide an initializer expression to a behavior that requires one. Properties cannot be declared using behaviors inside protocols. Under this proposal, even if a property with a behavior has an initial value expression, the type is always required to be explicitly declared. Behaviors also do not allow for out-of-line initialization of properties. Both of these restrictions can be lifted by future extensions; see the Future directions section below. Impact on existing code By itself, this is an additive feature that doesn’t impact existing code. However, with some of the future directions suggested, it can potentially obsolete lazy, willSet/didSet, and @NSCopying as hardcoded language features. We could grandfather these in, but my preference would be to phase them out by migrating them to library-based property behavior implementations. (Removing them should be its own separate proposal, though.) Alternatives considered Using a protocol (formal or not) instead of a new declaration A previous iteration of this proposal used an informal instantiation protocol for property behaviors, desugaring a behavior into function calls, so that: var [lazy] foo = 1738 would act as sugar for something like this: var `foo.[lazy]` = lazy(var: Int.self, initializer: { 1738 }) var foo: Int { get { return `foo.[lazy]`[varIn: self, initializer: { 1738 }] } set { `foo.[lazy]`[varIn: self, initializer: { 1738 }] = newValue } } There are a few disadvantages to this approach: Behaviors would pollute the namespace, potentially with multiple global functions and/or types. In practice, it would require every behavior to be implemented using a new (usually generic) type, which introduces runtime overhead for the type’s metadata structures. The property behavior logic ends up less clear, being encoded in unspecialized language constructs. Determining the capabilities of a behavior relied on function overload resolution, which can be fiddly, and would require a lot of special case diagnostic work to get good, property-oriented error messages out of. Without severely complicating the informal protocol, it would be difficult to support eager vs. deferred initializers, or allow mutating access to self concurrently with the property’s own storage without violating inout aliasing rules. The code generation for standalone behavior decls can hide this complexity. Making property behaviors a distinct declaration undeniably increases the language size, but the demand for something like behaviors is clearly there. In return for a new declaration, we get better namespacing, more efficient code generation, clearer, more descriptive code for their implementation, and more expressive power with better diagnostics. I argue that the complexity can pay for itself, today by eliminating several special-case language features, and potentially in the future by generalizing to other kinds of behaviors (or being subsumed by an all-encompassing macro system). For instance, a future func behavior could conceivably provide Python decorator-like behavior for transforming function bodies. “Template”-style behavior declaration syntax John McCall proposed a “template”-like syntax for property behaviors, used in a previous revision of this proposal: behavior var [lazy] name: Value = initialValue { ... } It’s appealing from a declaration-follows-use standpoint, and provides convenient places to slot in name, type, and initial value bindings. However, this kind of syntax is unprecedented in Swift, and in initial review, was not popular. Declaration syntax for properties using behaviors Alternatives to the proposed var [behavior] propertyName syntax include: A different set of brackets, var (behavior) propertyName or var {behavior} propertyName. Parens have the problem of being ambiguous with a tuple var declaration, requiring lookahead to resolve. Square brackets also work better with other declarations behaviors could be extended to apply to in the future, such as subscripts or functions An attribute, such as @behavior(lazy) or behavior(lazy) var. This is the most conservative answer, but is clunky. Use the behavior function name directly as an attribute, so that e.g. @lazy works. Use a new keyword, as in var x: T by behavior. Something on the right side of the colon, such as var x: lazy(T). To me this reads like lazy(T) is a type of some kind, which it really isn’t. Future directions The functionality proposed here is quite broad, so to attempt to minimize the review burden of the initial proposal, I’ve factored out several aspects for separate consideration: Behaviors for immutable let properties Since we don’t have an effects system (yet?), let behavior implementations have the potential to invalidate the immutability assumptions expected of let properties, and it would be the programmer’s responsibility to maintain them. We don’t support computed lets for the same reason, so I suggest leaving lets out of property behaviors for now. let behaviors could be added in the future when we have a comprehensive design for immutable computed properties and/or functions. Type inference of properties with behaviors There are subtle issues with inferring the type of a property using a behavior when the behavior introduces constraints on the property type. If you have something like this: var behavior uint16only: UInt16 { ... } var [uint16only] x = 1738 there are two, and possibly more, ways to define what happens: We type-check the initializer expression in isolation before resolving behaviors. In this case, 1738 would type-check by defaulting to Int, and then we’d raise an error instantiating the uint16only behavior, which requires a property to have type UInt16. We apply the behaviors before type-checking the initializer expression, introducing generic constraints on the contextual type of the initializer. In this case, applying the uint16only behavior would constrain the contextual type of the initializer to UInt16, and we’d successfully type-check the literal as a UInt16. There are merits and downsides to both approaches. To allow these issues to be given proper consideration, I’m subsetting them out by proposing to first require that properties with behaviors always declare an explicit type. Composing behaviors It is useful to be able to compose behaviors, for instance, to have a lazy property with observers that’s also synchronized. Relatedly, it is useful for subclasses to be able to override their inherited properties by applying behaviors over the base class implementation, as can be done with didSet and willSet today. Linear composition can be supported by allowing behaviors to stack, each referring to the underlying property beneath it by super or some other magic binding. However, this form of composition can be treacherous, since it allows for “incorrect” compositions of behaviors. One of lazy • synchronized or synchronized • lazy is going to do the wrong thing. This possibility can be handled somewhat by allowing certain compositions to be open-coded; John McCall has suggested that every composition ought to be directly implemented as an entirely distinct behavior. That of course has an obvious exponential explosion problem; it’s infeasible to anticipate and hand-code every useful combination of behaviors. These issues deserve careful separate consideration, so I’m leaving behavior composition out of this initial proposal. Deferred evaluation of initialization expressions This proposal does not suggest changing the allowed operations inside initialization expressions; in particular, an initialization of an instance property may not refer to self or other instance properties or methods, due to the potential for the expression to execute before the value is fully initialized: struct Foo { var a = 1 var b = a // Not allowed var c = foo() // Not allowed func foo() { } } This is inconvenient for behaviors like lazy that only ever evaluate the initial value expression after the true initialization phase has completed, and where it’s desirable to reference self to lazily initialize. Behaviors could be extended to annotate the initializer as “deferred”, which would allow the initializer expression to refer to self, while preventing the initializer expression from being evaluated at initialization time. (If we consider behaviors to be essentially always fragile, this could be inferred from the behavior implementation.) Out-of-line initialization with behaviors This proposal also does not allow for behaviors that support out-of-line initialization, as in: func foo() { // Out-of-line local variable initialization var [behavior] x: Int x = 1 } struct Foo { var [behavior] y: Int init() { // Out-of-line instance property initialization y = 1 } } This is a fairly serious limitation for instance properties. There are a few potential approaches we can take. One is to allow a behavior’s init logic to take an out-of-line initialization as a parameter, either directly or by having a different constraint on the initializer requirement that only allows it to be referred to from init (the opposite of “deferred”). It can also be supported indirectly by linear behavior composition, if the default root super behavior for a stack of properties defaults to a plain old stored property, which can then follow normal initialization rules. This is similar to how didSet/willSet behave today. However, this would not allow behaviors to change the initialization behavior in any way. Binding the name of a property using the behavior There are a number of clever things you can do with the name of a property if it can be referenced as a string, such as using it to look up a value in a map, to log, or to serialize. We could conceivably support a name requirement declaration: var behavior echo&lt;Value: StringLiteralConvertible&gt;: Value { name: String get { return name } } var [echo] echo: String print(echo) // =&gt; echo Overloading behaviors It may be useful for behaviors to be overloadable, for instance to give a different implementation to computed and stored variants of a concept: // A behavior for stored properties... var behavior foo&lt;Value&gt;: Value { initialValue var value: Value = initialValue get { ... } set { ... } } // Same behavior for computed properties... var behavior foo&lt;Value&gt;: Value { initialValue accessor get() -&gt; Value accessor set(newValue: Value) get { ... } set { ... } } We could resolve overloads by accessors, type constraints on Value, and/or initializer requirements. However, determining what this overload signature should be, and also the exciting interactions with type inference from initializer expressions, should be a separate discussion. Accessing “out-of-band” behavior members It is useful to add out-of-band operations to a property that aren’t normal members of its formal type, for instance, to clear a lazy property to be recomputed later, or to reset a property to an implementation-defined default value. This is useful, but it complicates the design of the feature. Aside from the obvious surface-level concerns of syntax for accessing these members, this also exposes behaviors as interface rather than purely an implementation detail, meaning their interaction with resilience, protocols, class inheritance, and other abstractions needs to be designed. It’s also a fair question whether out-of- band members should be tied to behaviors at all–it could be useful to design out-of-band members as an independent feature independent with behaviors.",
    "url": "http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html",
    "relUrl": "/docs/2019-08-26-0030-property-behavior-decls.html"
  },
  "30": {
    "id": "30",
    "title": "SE-0031 Adjusting `inout` Declarations for Type Decoration",
    "content": "Adjusting inout Declarations for Type Decoration Proposal: SE-0031 Authors: Joe Groff, Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#1333 Introduction The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation the keyword prepends argument names. We propose to move the inout keyword to the right side of the colon to decorate the type instead of the parameter label. The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread. Thread to Proposal, Review Motivation In Swift 2, the inout parameter lives on the label side rather than the type side of the colon although the keyword isn’t modifying the label but its type. Decorating types instead of labels offers identifiable advantages: It enables the inout keyword to properly integrate into full type syntax, for example: (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U It avoids notational similarity with arguments labeled inout, for example: func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void Moving it would allow inout to be used as a parameter label. While this isn’t a particularly strong motivation by itself, currently inout is the only keyword not allowed as a parameter label in Swift 3. Removing this restriction would simplify the language. It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift Detailed design parameter → external-parameter-name optlocal-parameter-name : type-annotation type-annotation → inout type-annotation Alternatives Considered Decorations using @inout (either @inout(T) or @inout T) were considered and discarded",
    "url": "http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html",
    "relUrl": "/docs/2019-08-26-0031-adjusting-inout-declarations.html"
  },
  "31": {
    "id": "31",
    "title": "SE-0032 Add `first(where:)` method to `Sequence`",
    "content": "Add first(where:) method to Sequence Proposal: SE-0032 Author: Lily Ballard Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1519 Previous Revisions: 1 Introduction Add a new extension method to Sequence called first(where:) that returns the found element. Discussion on swift-evolution started with a proposal with title Add find method to SequenceType Swift-evolution thread: Proposal: Add function SequenceType.find() Review Motivation It’s often useful to find the first element of a sequence that passes some given predicate. For Collections you can call index(of:) or index(where:) and pass the resulting index back into the subscript, but this is a bit awkward. For Sequences, there’s no easy way to do this besides a manual loop that doesn’t require filtering the entire sequence and producing an array. I have seen people write code like seq.lazy.filter(predicate).first, but this doesn’t actually work lazily because .first is only a method on Collection, which means the call to filter() ends up resolving to the Sequence.filter() that returns an Array instead of to LazySequenceProtocol.filter() that returns a lazy sequence. Users typically aren’t aware of this, which means they end up doing a lot more work than expected. Proposed solution Extend Sequence with a method called first(where:) that takes a predicate and returns an optional value of the first element that passes the predicate, if any. Detailed design Add the following extension to Sequence: extension Sequence { /// Returns the first element where `predicate` returns `true`, or `nil` /// if such value is not found. public func first(where predicate: @noescape (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Iterator.Element? { for elt in self { if try predicate(elt) { return elt } } return nil } } Impact on existing code None, this feature is purely additive. In theory, we might provide an automatic conversion from seq.filter(predicate).first or seq.lazy.filter(predicate).first to seq.first(where: predicate), although the existing code would continue to compile just fine. Alternatives considered None",
    "url": "http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html",
    "relUrl": "/docs/2019-08-26-0032-sequencetype-find.html"
  },
  "32": {
    "id": "32",
    "title": "SE-0033 Import Objective-C Constants as Swift Types",
    "content": "Import Objective-C Constants as Swift Types Proposal: SE-0033 Author: Jeff Kelley Review Manager: John McCall Status: Implemented (Swift 3) Decision Notes: Rationale Introduction Given a list of constants in an Objective-C file, add an attribute that will enable Swift to import them as either an Enum or a Struct, using RawRepresentable to convert to their original type. This way, instead of passing strings around for APIs, we can use more type-safe objects and take advantage of Swift’s code completion, as well as making our Swift (and Objective-C!) code more readable and more approachable to beginners. Swift-evolution thread: Original E-Mail, Replies Review Motivation Many Objective-C APIs currently use constants, especially NSString constants, to list possible values. Consider this small example from HKTypeIdentifiers.h for body measurements (comments and availability macros stripped for readability): HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyMassIndex; HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyFatPercentage; HK_EXTERN NSString * const HKQuantityTypeIdentifierHeight; HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyMass; HK_EXTERN NSString * const HKQuantityTypeIdentifierLeanBodyMass; When imported to Swift, these declarations are imported thusly: public let HKQuantityTypeIdentifierBodyMassIndex: String public let HKQuantityTypeIdentifierBodyFatPercentage: String public let HKQuantityTypeIdentifierHeight: String public let HKQuantityTypeIdentifierBodyMass: String public let HKQuantityTypeIdentifierLeanBodyMass: String The aim of this proposal is to encapsulate these strings into an enum or a struct that conforms to RawRepresentable to represent as type String. Why bother? When these APIs are used, the methods that use the constants simply take NSString parameters where these constants are to be used, such as the methods listed below. For a novice programmer, it’s not immediately clear that these methods take “special” values defined in another file altogether: + (nullable HKQuantityType *)quantityTypeForIdentifier:(NSString *)identifier; + (nullable HKCategoryType *)categoryTypeForIdentifier:(NSString *)identifier; + (nullable HKCharacteristicType *)characteristicTypeForIdentifier:(NSString *)identifier; + (nullable HKCorrelationType *)correlationTypeForIdentifier:(NSString *)identifier; Sometimes, as with NSError domains, it’s OK to use your own values when there are predefined constants, but other times, such as with HealthKit identifiers, it’s not. The former cases are well-handled by a struct, whereas the latter are well-handled by an enum. By adding a these cases, we can both better document our existing Objective-C code and provide more power in Swift. When a new programmer to the framework looks at the documentation, it will be immediately clear where the string—or other type—constants they need to use come from. Proposed solution As suggested by Doug Gregor on swift-evolution, combining a typedef with a new attribute could clean this up while still keeping everything as the original type internally. Here are examples using both structs and enums: Enums HealthKit identifiers are a good case for enums, as the user of the API cannot add new entries: typedef NSString * HKQuantityTypeIdentifier __attribute__((swift_wrapper(enum)); HK_EXTERN HKQuantityTypeIdentifier const HKQuantityTypeIdentifierBodyMassIndex; HK_EXTERN HKQuantityTypeIdentifier const HKQuantityTypeIdentifierBodyFatPercentage; HK_EXTERN HKQuantityTypeIdentifier const HKQuantityTypeIdentifierHeight; HK_EXTERN HKQuantityTypeIdentifier const HKQuantityTypeIdentifierBodyMass; HK_EXTERN HKQuantityTypeIdentifier const HKQuantityTypeIdentifierLeanBodyMass; With this additional type information, the Swift import would be vastly improved: enum HKQuantityTypeIdentifier : String { case BodyMassIndex case BodyFatPercentage case Height case BodyMass case LeanBodyMass } Method signatures in Objective-C would then use the new typedef: + (nullable HKQuantityType *)quantityTypeForIdentifier:(HKQuantityTypeIdentifier)identifier; This would allow us to call quantityTypeForIdentifier() from Swift with the struct constant directly, rather than having to call rawValue on it to extract the underlying String. The Swift code would look like this: let quantityType = HKQuantityType.quantityTypeForIdentifier(.BodyMassIndex) Once a type is imported as an enum, other modules—and the user fo the API—would not be able to add additional entries. Structs NSError domains are a good case for structs, as the user can add new entries. This subset of the declared domains: typedef NSString * NSErrorDomain __attribute__((swift_wrapper(struct))); FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain; FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain; FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain; FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain; would be imported as: struct NSErrorDomain : RawRepresentable { typealias RawValue = String init(rawValue: RawValue) var rawValue: RawValue { get } static var Cocoa: NSErrorDomain { get } static var POSIX: NSErrorDomain { get } static var OSStatus: NSErrorDomain { get } static var Mach: NSErrorDomain { get } } For types importing as structs, if other modules need to add additional instances of the constant, it would be imported as an extension: extern NSString * const NSURLErrorDomain; would be imported as: extension NSErrorDomain { static var URL: NSErrorDomain { get } } Naming The name of the new constants is determined by removing any common prefix and suffix from the type name and the given cases. Names are uppercase, as with these examples from Swift code today: struct NSSortOptions : OptionSetType { init(rawValue rawValue: UInt) static var Concurrent: NSSortOptions { get } static var Stable: NSSortOptions { get } } enum NSSearchPathDirectory : UInt { case ApplicationDirectory case DemoApplicationDirectory case DeveloperApplicationDirectory … case AllApplicationsDirectory case AllLibrariesDirectory case TrashDirectory } Impact on existing code Existing, unmodified Objective-C code will continue to be imported as-is with no changes. Existing Swift code that uses Objective-C code with these annotations will need to be updated to use the new types, but this should be possible to migrate to as all of the type information is present, and the Swift code will be using the Objective-C names for the constants. Alternatives considered The second draft of this proposal used struct solely, as some types don’t make sense to import as enums (e.g. error domains). This version adds enums back, allowing for both versions to be used depending on the appropriate type. The first draft of this proposal used enum instead of struct and did not contain RawRepresentable. It has been modified per list discussion; using RawRepresentable makes it easier to add new values defined elsewhere—e.g. in another module. There was some concern that enum didn’t quite match up with the aims of this proposal, as these identifier lists are not often switched over. My original idea considered marking regions of code using something like NS_CASE_LIST_BEGIN and NS_CASE_LIST_END, then importing the constants declared inside of the markers as an enum, but Doug’s typedef solution allows for methods to also be annotated, giving the proposal even more type information to use in Swift.",
    "url": "http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html",
    "relUrl": "/docs/2019-08-26-0033-import-objc-constants.html"
  },
  "33": {
    "id": "33",
    "title": "SE-0034 Disambiguating Line Control Statements from Debugging Identifiers",
    "content": "Disambiguating Line Control Statements from Debugging Identifiers Proposal: SE-0034 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-840 Introduction In being accepted, Swift Evolution SE-0028 (0028-modernizing-debug-identifiers.md) overloads the use of #line to mean both an identifier that maps to a calling site’s line number within a file and acts as part of a line control statement. This proposal nominates #setline to replace #line for file and line syntactic source control. The discussion took place on-line in the [Discussion]: Renaming #line, the line control statement thread. Review Revision Motivation Swift uses the following grammar to define line control statements: line-control-statement → #line line-control-statement → #line line-number file-name line-number → A decimal integer greater than zero file-name → static-string-literal The accepted implementation of SE-0028 disambiguates the two uses by requiring #line (the control statement) to appear at the first column. This is a stop-gap solution best remedied by renaming #line. The core team was not satisfied with the ‘first token on a line’ whitespace behavior required for overloading #line. Chris Lattner requested a discussion about renaming the old #line directive to something more specific and tailored to its purpose: “Once that name and syntax is settled, we can rename the directive and remove the whitespace rule.” Detailed design line-control-statement → #setline line-control-statement → #setline line-number file-name line-number → A decimal integer greater than zero file-name → static-string-literal­ Alternatives considered A more flexible grammar was suggested, however, as Lily Ballard pointed out: This feature isn’t something end users are going to use. And it’s not something that will ever reasonably apply to anything except #file and #line. This feature is only ever intended to be used by tools that auto-generate source files. The most important concerns here really should just be that whatever we use is trivial to generate correctly by even the simplest of tools and is readable. And since this won’t ever apply to anything beyond #file and #line, there’s no need to try to generalize this feature at all. A variety of other keywords were put forward in the discussion and can be found in the online discussion. Accepted form and modified design The accepted syntax for the line control statement will be modified as follows: #sourceLocation(file: &quot;foo&quot;, line: 42) #sourceLocation() // reset to original position. After discussing how to rationalize naming and capitalization of identifiers in the #-namespace, the core Swift team adopted a lower camel case model for identifiers. The line control statement will use lower camel case and be renamed #sourceLocation. The syntax for #setline was inconsistent with the other #-directives in that it didn’t use parentheses. After discussion, the core team adjusted the call to use parentheses and comma-separated colon-delimited argument and value pairs for the file and line arguments.",
    "url": "http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html",
    "relUrl": "/docs/2019-08-26-0034-disambiguating-line.html"
  },
  "34": {
    "id": "34",
    "title": "SE-0035 Limiting `inout` capture to `@noescape` contexts",
    "content": "Limiting inout capture to @noescape contexts Proposal: SE-0035 Author: Joe Groff Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-807 Introduction Swift’s behavior when closures capture inout parameters and escape their enclosing context is a common source of confusion. We should disallow implicit capture of inout parameters except in @noescape closures. Swift-evolution thread: only allow capture of inout parameters in @noescape closures Review Motivation Before we had @noescape, we still wanted inout parameters and mutating methods to be usable in closures, without compromising the strong guarantee that an inout parameter can only locally mutate its parameter without callers having to worry about unexpected aliasing or lifetime extension. Since Swift uses closures pervasively for standard library collection operations, and even for assertions and operators like &amp;&amp; and || via its @autoclosure feature, it would be extremely limiting if inout parameters could not be captured at all. Dave Abrahams designed our current capture semantics as a compromise: an inout parameter is captured as a shadow copy that is written back to the argument when the callee returns. This allows inout parameters to be captured and mutated with the expected semantics when the closure is called while the inout parameter is active: func captureAndCall(inout x: Int) { let closure = { x += 1 } closure() } var x = 22 captureAndCall(&amp;x) print(x) // =&gt; 23 But this leads to unintuitive results when the closure escapes, since the shadow copy is persisted independently of the original argument: func captureAndEscape(inout x: Int) -&gt; () -&gt; Void { let closure = { x += 1 } return closure } var x = 22 let closure = captureAndEscape(&amp;x) print(x) // =&gt; 22 closure() print(&quot;still (x)&quot;) // =&gt; still 22 This change has been a persistent source of confusion and bug reports, and was recently called out in David Ungar’s recent post to the IBM Swift Blog, “Seven Swift Snares &amp; How to Avoid Them”, one in a long line of complaints on the topic. Proposed solution I propose we make it so that implicitly capturing an inout parameter into an escapable closure is an error. We added the explicit @noescape annotation in Swift 1.2, and have since adopted it throughout the standard library where appropriate, so the compromise has outlived its usefulness and become a source of confusion. Detailed design Capturing an inout parameter, including self in a mutating method, becomes an error in an escapable closure literal, unless the capture is made explicit (and thereby immutable): func escape(f: () -&gt; ()) {} func noEscape(@noescape f: () -&gt; ()) {} func example(inout x: Int) { escape { _ = x } // error: closure cannot implicitly capture an inout parameter unless @noescape noEscape { _ = x } // OK, closure is @noescape escape {[x] in _ = x } // OK, immutable capture } struct Foo { mutating func example() { escape { _ = self } // error: closure cannot implicitly capture a mutating self parameter noEscape { _ = self } // OK } } For nested function declarations, we defer formation of a closure until a reference to the unapplied function is used as a value. If a nested function references inout parameters from its enclosing scope, we disallow references to the nested function that would form an escaping closure: func exampleWithNested(inout x: Int) { func nested() { _ = x } escape(nested) // error: nested function that references an inout cannot be escaped noEscape(nested) // OK } As an implementation detail, this eliminates the need for a shadow copy to be emitted for inout parameters in case they are referenced by closures. For code that is still accepted after this change, this should not have an observable effect, since a guaranteed optimization pass always removes the shadow copy when it is known not to escape. Impact on existing code This will break code that relies on the current inout capture semantics. Some particular legitimate cases that may be affected: A closure captures the parameter after its local mutations, and never mutates it further or expects to observe mutations from elsewhere. These use cases can explicitly capture the inout parameter immutably using a capture list, which is both more explicit and safer. The inout parameter is captured by escapable closures that dynamically never execute outside the originating scope, for instance, by referencing the parameter in a lazy sequence adapter that is applied in the immediate scope, or by forking off one or more dispatch_async jobs that access different parts of the parameter but which are synced with the originating scope before it exits. For these use cases, the shadow copy can be made explicit: func foo(q: dispatch_queue_t, inout x: Int) { var shadowX = x; defer { x = shadowX } // Operate on shadowX asynchronously instead of the original x dispatch_async(q) { use(&amp;shadowX) } doOtherStuff() dispatch_sync(q) {} } For migration, the compiler can offer one of the above fixits, checking the use of the captured inout for mutations after the capture to decide whether an immutable capture or explicit shadow copy is more appropriate. (Or naively, the fixit can just offer the shadow copy fixit.) This also increases pressure on libraries to make more use of @noescape where possible, as proposed in SE-0012. Alternatives considered A possible extension of this proposal is to introduce a new capture kind to ask for shadow copy capture: func foo(inout x: Int) { {[shadowcopy x] in use(&amp;x) } // strawman syntax } In discussion, we deemed this rare enough not to be worth the added complexity. An explicit copy using a new var declaration is much clearer and doesn’t require new language support.",
    "url": "http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html",
    "relUrl": "/docs/2019-08-26-0035-limit-inout-capture.html"
  },
  "35": {
    "id": "35",
    "title": "SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations",
    "content": "Requiring Leading Dot Prefixes for Enum Instance Member Implementations Proposal: SE-0036 Authors: Erica Sadun, Chris Lattner Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1236 Introduction Enumeration cases are essentially static not instance type members. Unlike static members in structures and classes, enumeration cases can be mentioned in initializers and instance methods without referencing a fully qualified type. This makes little sense. In no other case can an instance implementation directly access a static member. This proposal introduces a rule that requires leading dots or fully qualified references (EnumType.caseMember) to provide a more consistent developer experience to clearly disambiguate static cases from instance members. Discussion took place on the Swift Evolution mailing list in the [Discussion] Enum Leading Dot Prefixes thread. This proposal uses lowerCamelCase enumeration cases in compliance with current API Guideline Working Group guidance. Review Motivation Swift infers the enclosing type for a case on a developer’s behalf when the use is unambiguously of a single enumeration type. Inference enables you to craft switch statements like this: switch Coin() { case .heads: print(&quot;Heads&quot;) case .tails: print(&quot;Tails&quot;) } A leading dot has become a conventional shorthand for “enumeration case” across the language. When used internally in enum implementations, a leading dot is not required, nor is a type name to access the static case member. The following code is legal in Swift. enum Coin { case heads, tails func printMe() { switch self { case heads: print(&quot;Heads&quot;) // no leading dot case .tails: print(&quot;Tails&quot;) // leading dot } if self == heads { // no leading dot print(&quot;This is a head&quot;) } if self == .tails { // leading dot print(&quot;This is a tail&quot;) } } init() { let cointoss = arc4random_uniform(2) == 0 self = cointoss ? .heads : tails // mix and match leading dots } } This quirk produces a language inconsistency that can confuse developers and contravenes the guiding Principle of Least Astonishment. We propose to mandate a leading dot. This brings case mentions into lock-step with conventions used to reference them outside of enumeration type implementations. Detail Design Under this rule, the compiler will require a leading dot for all case members. The change will not affect other static members, which require fully qualified references from instance methods and infer self from static methods. enum Coin { case heads, tails static func doSomething() { print(&quot;Something&quot;) } static func staticFunc() { doSomething() } // does not require leading dot static func staticFunc2() { let foo = tails } // does not require leading dot, following static convention func instanceFunc() { self.dynamicType.doSomething() } // requires full qualification func otherFunc() { if self == .heads ... } // requires leading dot, also initializers /// ... } Alternatives Considered Other than leaving the status quo, the language could force instance members to refer to cases using a fully qualified type, as with other static members.",
    "url": "http://localhost:4000/docs/2019-08-26-0036-enum-dot.html",
    "relUrl": "/docs/2019-08-26-0036-enum-dot.html"
  },
  "36": {
    "id": "36",
    "title": "SE-0037 Clarify interaction between comments & operators",
    "content": "Clarify interaction between comments &amp; operators Proposal: SE-0037 Author: Jesse Rusak Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-960 Introduction There are several inconsistencies in how comments are treated when determining whether an operator is prefix, postfix, or infix. They are sometimes treated as whitespace, sometimes as non-whitespace, and this differs depending on whether they are to the left or right of an operator, and the contents of the comment itself. This proposal suggests a uniform set of rules for how these cases should be parsed. Swift-evolution thread: started here A draft implementation is available here. Review Motivation At the moment, comments next to operators are usually treated as non-whitespace for the purpose of determining whether an operator is prefix/postfix/binary, meaning that this fails to compile (SR-186): if /* comment */!foo { ... } Because the “!” is parsed as binary operator (no whitespace on either side), rather than as a prefix operator, which seems undesirable. This behavior is also not consistently applied. For example, this currently works: 1 +/* comment */2 Because the “+/*” is treated as one token and sees the whitespace to its right and left, and so is parsed as a binary operator. In order to resolve these and related issues, this proposes a general rule about the expected behavior. Proposed solution Comments should be treated as whitespace for all of the purposes in the “operators” section of the Swift language reference: determining whether an operator is binary, prefix, or postfix, as well as the special rules around the “!” and “?” predefined operators. This means that swapping a comment with whitespace should not change whether an adjacent operator token is treated as prefix, postfix, or binary (regardless of the contents of the comment). This also includes whitespace/comments between the operator and its operand. For example, these should be equivalent: if/* comment */!foo { ... } if !foo { ... } As should these: // whitespace on both sides 1 + 2 1 +/* comment */2 This model is easy to describe, and fits in with the general rule already present in the Swift language reference that comments are treated as whitespace. Detailed design When parsing an operator token and trying to determine whether it has a whitespace character to either the right or left, an adjacent slash-slash or slash-star comment should be treated as whitespace. The contents of these comments (e.g. whether they themselves include whitespace) should have no effect. The language reference should also be updated to make clear that comments are treated as whitespace for these purposes. Impact on existing code Only code with comments immediately next to operators will be affected. This is not expected to be very common, and could be fixed by adding whitespace or moving the comment outside of the expression. It would probably be possible to produce fix-its for these. Here are some examples of the changes. Some cases which would previously work will now produce an error (these are breaking changes): foo/* */?.description foo/* */! 1/**/+2 1+/**/2 Some cases which were previously errors will now work: /* */!foo 1/**/+ 2 1 /**/+ 2 1 +/**/2 Examples of things which will continue to be errors: !/* */foo 1+/* */2 And things which will continue to work: foo!// comment 1 +/**/ 2 1 +/* */2 Alternatives considered Treat comments as absent We could instead specify that comments are treated as though they are not present (i.e. we would look past comments to see whether whitespace follows). This more-closely matches some people’s mental model of comments. It is also more flexible; that is, there are places where this rule permits comments which are forbidden by the above proposal. (e.g. !/* */foo) However, this rule is harder to describe (the comments are not ignored entirely as they still separate tokens) and goes against the general rule in the language reference that comments are treated as whitespace. This also has the disadvantage that you have to look at the other side of a comment to determine if an operator has whitespace around it. For example: a = 1 +/* a very long comment */~x You can’t tell just by looking near the “+” whether it is a binary or prefix operator. (And, in fact, this would fail to parse if the comment was simply treated as absent.) A more general rule Another alternative is a more general rule about how comments are handled everywhere in the language (e.g. there must be no effect when replacing a comment with a space character). This has the advantage of possibly resolving other ambiguities, but has potentially far-reaching consequences in various edge cases which are hard to fully enumerate (e.g. multi-line comments, comments within interpolated sequences inside of string literals, comments in lines which contain “#” directives, etc).",
    "url": "http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html",
    "relUrl": "/docs/2019-08-26-0037-clarify-comments-and-operators.html"
  },
  "37": {
    "id": "37",
    "title": "SE-0038 Package Manager C Language Target Support",
    "content": "Package Manager C Language Target Support Proposal: SE-0038 Author: Daniel Dunbar Review Manager: Rick Ballard Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-821 Introduction This is a proposal for adding initial package manager support for the C, C++, Objective-C, and Objective-C++ languages (henceforth, simply referred to as “C” languages). This proposal is limited in scope to only supporting targets consisting entirely of C languages; there is no provision for supporting targets which include both C and Swift sources. Swift Evolution Review Thread Motivation Swift has easy interoperability with C based languages through the use of the Clang modules system. We would like Swift packages to be able to include C targets which can be exposed to Swift directly as part of a single package. This gives developers a simple mechanism for “falling back” to C when they need to access APIs which are inadequately or poorly bridged to Swift, or when they need to implement behavior which is better done in low-level C than Swift. Proposed solution Our proposed solution extends the convention based system to allow targets composed only of C sources. The conventions will be amended as follows: Any existing directory which defines a target will be allowed to contain a set of C sources, recognized by file extension. If a target contains any C sources, then all source code files must be C sources. Support for Objective-C and Objective-C++ source file extensions will be included, although those will be inherently less portable. C targets may have a special subdirectory named Includes or include (the include directory). Only one such name may be used. The headers in this directory are presumed to be the “exported” interface of the C target, and will be made available for use in other targets. The names Includes and include are somewhat unfortunate because they do not clearly communicate that these folders define public API. However, this is an established convention for organizing C language header files, and there does not seem to be a better alternative. If the include directory contains a header whose name matches that of the target, then that header will be treated as an “umbrella header” for the purposes of module map construction. If the include directory includes any file named “module.modulemap”, then those will be presumed to define the modules for the target, and no module maps will be synthesized. As with Swift targets, we will use the presence of a source file named main.c (or main.cpp, etc.) to indicate an executable versus a library. The following example layout would define a package containing a C library and a Swift target: example/src/foo/include/foo/foo.h example/src/foo/foo.c example/src/foo/util.h example/src/bar/bar.swift In this example, the util.h would be something internal to the implementation of the foo target, while include/foo/foo.h would be the exported API to the foo library. The package manager will naturally gain support for building these targets: The package manager will (a) construct a synthesized module map including all of the exported API headers, for use in Swift, and (b) will provide a header search path to this directory to any targets which transitively depend on this one. Module maps will only be synthesized for targets which either have a completely flat header layout (e.g., src/foo/include/*.h) or a single subdirectory (e.g., src/foo/include/foo/**.h). Any other structure requires the library author to provide explicit module maps. We may revisit this as we gain practical experience with it. Most packages are encouraged to include the package or target name as a subfolder of the include directory, to clarify use (e.g., src/foo/include/foo/). However, this is not required and it may be useful for legacy projects whose headers have traditionally been installed directly into /usr/include to not use this convention. This allows client code of those projects to be source compatible with versions which use the installed library. We expect C language targets to integrate with the other existing package manager features. For example, C language targets should be testable using the testing features (although such tests would initially need to be written in Swift until such time as a C language testing framework was usable by the package manager). There are several obvious features related to C language support which are not addressed with this proposal: We anticipate the need to declare that only particular targets should have their API exported to downstream packages (for example, the package above might want to export the bar target to clients, and keep the C target as an implementation detail). No provision is made in this proposal for controlling compiler arguments. We will support the existing debug and release configurations using a fixed set of compiler flags. We expect future proposals to accommodate the need to modify those flags. We intend for the feature to be built in such a way as to support any standard compliant C compiler, but our emphasis will largely be on supporting the use of Clang as that compiler (and of course our modules support will require Clang). We believe there may be a need for targets to define their own module map. If needed, we would expect this to go into the include directory as module.modulemap. However, we intend to defer implementation of this support until after the initial feature is implemented and the use cases become clear. Detailed design The package manager will undertake the following additional behaviors: The project model will be extended to discover C language targets and diagnose issues (e.g., mixed C and Swift source files). The build system will be extended to compile and link each C language target. We will make use of llbuild’s existing support for compiling C source code and gather GCC-compatible compiler style header dependency information for incremental rebuilds. When building a target, the package manager will automatically add an additional header search path argument to the include directory for each C language target in the transitive closure of the dependencies for the target being built. We should use -iquote as the header search argument for targets which are within the current package, and -I for targets which come from package dependencies. This allows projects to use #include &quot;foo/foo.h&quot; versus #include &lt;foo/foo.h&gt; syntax appropriately to distinguish between the inclusion of headers which are or are not within the package. We will synthesize module map files for each C language target with includes. Module maps will be constructed by explicitly enumerating all the headers in the include directory. To ensure deterministic behavior this will be done in lexicographic order, but the documentation will convey to users that each include header describing API is expected to be able to be included “standalone”, that is, in any order. When building Swift targets, we will explicitly pass the synthesized module map for each C language target in the dependency closure to Clang (using the -fmodule-map-file=&lt;PATH&gt; argument). This will allow the Swift Clang importer to find those modules without needing to find them via the header search mechanism. We explicitly have designed this support in such a way that it will be possible to support any GCC-compatible compiler for building the C target itself, not just Clang. Impact on existing packages There is no serious impact on existing packages, as this was previously unsupported. We will begin trying to build C family sources in existing packages, but this is likely to be desirable. It is worth considering the impact on existing C language projects which do not follow the conventions above. Most projects will not conform to these conventions. However, this is expected of any “simple” convention; we don’t think that there is any other straightforward convention that would allow a significant percentage of existing C language projects to “just work”. We do anticipate allowing certain overrides to be present in the manifest file describing a C target, to allow some projects to work with the package manager with only the addition of a correct Package.swift file. We will determine the exact overrides allowed once we are able to test options against existing C projects. The package manager already provides support for “system module” packages which is explicitly designed to support existing projects. The C language target support described in this proposal is targeted at new C code which is written in support of Swift projects, and believe that adopting a clean, simple convention is the best approach for supporting that goal. Existing source code using existing projects (e.g., a source file using libpng) may be able to use well formed packages without modification. This is viewed as a significant advantage, as it will potentially help upstream projects ingest proper package manager support into their main tree. Risk of non-modular headers As part of this proposal, we will be synthesizing module maps for C language targets, for use in Swift via the Clang AST importer. One risk with this proposal is when multiple C language targets are imported into a Swift module and those targets reference common C headers which have no defined module maps (i.e., they are “non-modular headers”). This situation can occur frequently on Linux, where the system does not typically have module maps for common headers, but can also occur on OS X if targets reference third-party headers not part of the package ecosystem. The current compiler behavior when this occurs is hard for users to understand. The model the compiler expects is that all content is modular. However, when this model is broken, and two modules contain duplicate content, these issues (a) sometimes behave correctly, due to the subtleties of the module implementation, and (b) are not diagnosed by the compiler. This can lead to confusing failures or expose us to unintended package breaking changes in the future if the compiler becomes more strict. Ultimately, the anticipated solution to these problem is to continue work to provide more module maps for all content used in Swift. Incorporation of this proposal may make that work a higher priority, and may expose additional issues which we need to tackle in the compiler implementation. Alternatives considered Avoid C language support We could avoid supporting C language targets directly, and rely on external build systems and features to integrate them into Swift packages. We may wish to add such features independently from this proposal, but we think it is worthwhile to have some native support for C targets. This will make it easy to integrate small amounts of C code into what are otherwise Swift projects, and is in line with a long term direction of making the Swift package manager useful for non-Swift projects. Restrictions on C language target header layout We considered requiring targets follow the naming convention that each include directory must have a subdirectory matching the name of the target. This has the advantage that all clients of that target always include its headers using the syntax #include &lt;foo/header.h&gt;. However, it reduces the usability of packages for traditional C libraries which do not install their headers in this format. It also reduces the ability of the project to impose additional organization on their own headers. For example, LLVM has a convention of laying out top-level headers into both llvm and llvm-c (for the C++ vs C API). Since we did not have other features or areas of development where we felt it was important to restrict the layout of the headers, we felt it was best to avoid imposing unnecessary restrictions, and instead simply treat it as a recommendation.",
    "url": "http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html",
    "relUrl": "/docs/2019-08-26-0038-swiftpm-c-language-targets.html"
  },
  "38": {
    "id": "38",
    "title": "SE-0039 Modernizing Playground Literals",
    "content": "Modernizing Playground Literals Proposal: SE-0039 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-917 Introduction Playground literals tokenize colors, files, and images. They provide drag-and-drop convenience and in-context visualizations that offer easy reference and manipulation when designing playground content. These literals are built using a simple square bracket syntax that, in the current form, conflicts with collection literals. This proposal redesigns playground literals to follow the precedent of #available and #selector. Discussion took place on the Swift Evolution mailing list in the [Discussion] Modernizing Playground Literals thread. Thanks to Chris Lattner for suggesting this enhancement. Review Motivation Color, image, and file literals are currently represented as: [#Color(colorLiteralRed: red, green: green, blue: blue, alpha: alpha)#] [#Image(imageLiteral: localResourceNameAsString)#] [#FileReference(fileReferenceLiteral: localResourceNameAsString)#] Playground literals present the following features: They appear within a container designated with [# #] endpoints. They are marked with a capital camel case role name. First label arguments use the word literal to punch the construction of each literal item. There are several issues with this approach: The enclosing square brackets conflict with collection literals, adding extra work for parsing. The construction syntax does not follow modern Swift conventions. The word literal describes the constructed items not the argument being passed to create the literal. It is misplaced in its current use. Detail Design Simplifying constructors to octothorpe-delineated identifiers cleans up the language, removes potential grammar conflicts, and follows precedent for other identifiers used in modern Swift. Our proposed identifiers are #colorLiteral, #imageLiteral, and #fileLiteral. color-literal → #colorLiteral(red: unit-floating-point-literal, green: unit-floating-point-literal, blue: unit-floating-point-literal, alpha: unit-floating-point-literal) unit-floating-point-literal → floating point number greater or equal to zero, less than or equal to one image-literal → #imageLiteral(resourceName: image-resource-name) image-resource-name → static-string-literal referring to image resource name file-literal → #fileLiteral(resourceName: file-resource-name) file-resource-name → static-string-literal referring to local resource name In this design: Each redesigned identifier uses lower case, to match existing Swift literals. Arguments use lower camel case labels, as is conventional. The word literal is added to identifiers denoting each item’s role. The arguments are simplified and standardized to red, green, blue, alpha, and resourceName. However, these argument labels are not appropriate for the actual initializers. Initializers in literal protocols should use argument labels that clearly mark their use in literals. This serves two ends. First, types may wish to provide specialized behavior for literals that would be inappropriate for a general-purpose initializer. Second, literal initializers must obey rigid naming and typing rules; giving them an “unusual” name avoids contaminating the standard interface to the type and reduces the risk of spurious ambiguity. With that in mind, Swift will interpret the syntax above as a use of the corresponding initializer below: protocol _ColorLiteralConvertible { init(colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float) } protocol _ImageLiteralConvertible { init(imageLiteralResourceName path: String) } protocol _FileReferenceLiteralConvertible { init(fileReferenceLiteralResourceName path: String) } Alternatives Considered #resourceliteral may better describe a file resource than #fileliteral.",
    "url": "http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html",
    "relUrl": "/docs/2019-08-26-0039-playgroundliterals.html"
  },
  "39": {
    "id": "39",
    "title": "SE-0040 Replacing Equal Signs with Colons For Attribute Arguments",
    "content": "Replacing Equal Signs with Colons For Attribute Arguments Proposal: SE-0040 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#1537 Introduction Attribute arguments are unlike other Swift language arguments. At the call site, they use = instead of colons to distinguish argument names from passed values. This proposal brings attributes into compliance with Swift standard practices by replacing the use of “=” with “:” in this one-off case. Discussion took place on the Swift Evolution mailing list in the [Discussion] Replacing Equal Signs with Colons For Attribute Arguments thread. Thanks to Doug Gregor for suggesting this enhancement. Motivation Attributes enable developers to annotate declarations and types with keywords that constrain behavior. Recognizable by their at-sign “@” prefix, attributes communicate features, characteristics, restrictions, and expectations of types and declarations to the Swift compiler. Common attributes include @noescape for parameters that cannot outlive the lifetime of a call, @convention, to indicates whether a type’s calling conventions follows a Swift, C, or (Objective-C) block model, and @available to enumerate a declaration’s compatibility with platform and OS versions. Swift currently offers about a dozen distinct attributes, and is likely to expand this vocabulary in future language updates. Some attributes accept arguments: @attribute-name(attribute-arguments) including, at this time, @available, @warn_unused_result and @swift3_migration. In the current grammar, an equal sign separates attribute argument keywords from values. introduced=version-number deprecated=version-number obsoleted=version-number message=message renamed=new-name mutable_variant=method-name Using = is out of step with other Swift parameterization call-site patterns. Although the scope of this proposal is quite small, tweaking the grammar to match the rest of Swift introduces a small change that adds consistency across the language. parameter name: parameter value Detail Design This proposal replaces the use of = with : in the balanced tokens used to compose an attribute argument clause along the following lines: attribute → @ attribute-name attribute-argument-clause&lt;sub&gt;opt&lt;/sub&gt; attribute-name → identifier attribute-argument-clause → ( balanced-tokens&lt;sub&gt;opt&lt;opt&gt; ) balanced-tokens → balanced-token balanced-tokens → balanced-token, balanced-tokens balanced-token → attribute-argument-label : attribute argument-value This design can be summarized as “wherever current Swift attributes use =, use : instead”, for example: @available(*, unavailable, renamed: &quot;MyRenamedProtocol&quot;) typealias MyProtocol = MyRenamedProtocol @warn_unused_result(mutable_variant: &quot;sortInPlace&quot;) public func sort() -&gt; [Self.Generator.Element] @available(*, deprecated, message: &quot;it will be removed in Swift 3. Use the &#39;generate()&#39; method on the collection.&quot;) public init(_ bounds: Range&lt;Element&gt;) Alternatives Considered There are no alternatives to put forth other than not accepting this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0040-attributecolons.html",
    "relUrl": "/docs/2019-08-26-0040-attributecolons.html"
  },
  "40": {
    "id": "40",
    "title": "SE-0041 Updating Protocol Naming Conventions for Conversions",
    "content": "Updating Protocol Naming Conventions for Conversions Proposal: SE-0041 Authors: Matthew Johnson, Erica Sadun Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction We propose to expand and improve the naming conventions established by the API Guidelines and the standard library with regard to conversion related protocols. We believe common protocol naming patterns should be clear, consistent, and meaningful. The Swift standard library includes slightly north of eighty protocols. Of these, about 15% concern themselves with type initialization and conversion. This proposal assigns specific conventional suffixes to these tasks. We present this proposal to improve overall language coherence. The Swift-evolution thread about this topic can be found here: Proposal: conversion protocol naming conventions Motivation The Swift standard library establishes conventional suffixes for protocol names. In most cases suffixes have clear and consistent meanings. Convertible, however, is used in two different senses. Most Convertible protocols convert from a type contained in the protocol name. Two protocols, CustomStringConvertible and CustomDebugStringConvertible convert to the type contained in the protocol name. A further protocol, RawRepresentable converts type to and from an associated raw type, but does not use the word “convert” in its protocol name. We propose to remove ambiguity and establish a practice of clear and consistent naming conventions. The Swift team has updated protocol names in the past, always moving towards clearer naming. Here are a few examples where standard library protocols were affected. LogicValue became BooleanType Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible ExtensibleCollectionType was folded into RangeReplaceableCollectionType The conventions proposed in this document offer similar logical naming enhancements. Proposed solution This proposal establishes precise conventional meanings for three protocol suffixes. They describe requirements where conforming instances convert from a type, to a type, or perform bi-directional conversion both to and from a type. We propose updating the API Guidelines to document these conventions and we propose renaming affected protocols in the standard library. The following conventions communicate the kinds of functionality required from conforming types. This naming scheme excludes any implementation details, such as whether an initializer or static factory method is used to create an instance or how members must be named. Creatable The Creatable suffix designates protocols that convert from a type or associated type mentioned in the protocol name such as IntegerLiteralConvertible, StringLiteralConvertible, etc. The standard library currently includes many examples. Convertible The Convertible suffix designates protocols that both project to and convert from a type or associated type mentioned in the protocol name. The standard library currently includes RawRepresentable. Representable The Representable suffix designates protocols that project to a type or associated type mentioned in the protocol name. The standard library currently includes CustomStringConvertible and CustomDebugStringConvertible. We believe these conventions better convey protocol conversion roles to Swift developers. Detailed design This proposal affects the following standard library protocols. Current protocols fulfilling the new Creatable convention: ArrayLiteralConvertible BooleanLiteralConvertible DictionaryLiteralConvertible ExtendedGraphemeClusterLiteralConvertible FloatLiteralConvertible IntegerLiteralConvertible NilLiteralConvertible StringInterpolationConvertible Current protocols fulfilling the new Convertible convention: RawRepresentable Current protocols fulfilling the new Representable convention: CustomStringConvertible CustomDebugStringConvertible Impact on existing code If accepted, this proposal will create the following impacts. Code mentioning renamed protocols won’t compile until updated to the new conventions or will need deprecation warnings and fixits. Code that only mentions members of these protocols will not be affected. A simple mechanical transformation can migrate existing code to use the new names. There is ample precedent from earlier Swift language updates to guide this change. Existing user code that includes Convertible, Representable, and Creatable protocol suffixes should be evaluated. These code bases are unlikely to follow the exact conventions newly established in the API Guidelines. While this code will continue to compile and work as intended, it will be out of step with the new API Guidelines. In addition: Xcode may be able to detect user-sourced protocols following the old Representable or Convertible conventions and offer a fixit to rename them. A warning could be offered for protocols that engage in conversion tasks and do not appear to follow any of the three conventions. Alternatively, users who wished to stay in step with the API Guidelines could manually update protocols names to follow these conventions. Alternatives considered The original draft of this proposal suggested the following convention: Convertible when converting from the type mentioned in the protocol name. Representable for bidirectional conversion. Projectable when converting to the type mentioned in the protocol name. These choices minimize the changes needed to establish a clear and consistent convention. This modified proposal presents what the authors believe is the best convention among the possibilities discussed on the mailing list. Additional names considered for each class of protocol include: can be created from: Instantiable, Initializable, Establishable, Constructable, Creatable can be converted to: Representable, Expressible, Presentable, Projectable can be represented as and instantiated by: Convertible, Representable We also considered proposing separate conventions for instantiation by initializer and instantiation by factory method. Names potentially applicable to the latter include Building, Producer/Producing and Establishable. We rejected this approach for being too implementation oriented. Response to Design Team Feedback The Standard Library design team raises the following concerns: While we agree with the basic intention of the proposal, we don’t agree with the proposed answer. In particular, we think the “LiteralConvertible” names are the only ones that can be improved upon by anything we’ve seen proposed or have been able to think of. In particular, swapping “Representable” and “Convertible” doesn’t do anything to clarify directionality, and for us, “XXXConvertible” has exactly the connotation of “convertibility to XXX” Our Response We picked these names after significant research and consideration: Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. To create means to produce something new and cause it to exist. While semantically distant from initializing, the terms overlap in practical use. The current (badly named) IntegerLiteralConvertible means “a conforming construct can use an integer literal to establish an instance of itself”. For the “Literalconvertible” names, we think the optimal answer would be to sink them into a subnamespace of Swift called “Swift.Syntax” and rename them by dropping “Convertible” (and changing StringInterpolationConvertible to InterpolatedStringLiteral). Lacking that language feature, we’d propose to underscore the canonical names of these protocols and create typealiases in an empty enum called “Syntax.” That would lead to, e.g. extension ArraySlice : Syntax.ArrayLiteral, ... { } Our Response These are implementation details that fall outside the scope of our proposal. This proposal concerns itself with core semantic conventions for protocol names and does not address how those names are otherwise formed, structured, or applied. We don’t think there are enough real examples of outside the “Literal” category to start nailing down conventions for them. We only have 3 of those, and only 2 of them are particularly similar to one another. Our Response The semantics cover “converting to a type”, “converting from a type”, and “converting to and from a type”. We have examples from our own code and from third party code on GitHub that suggest conversion tasks are common enough that standardizing API naming conventions will be valuable. Updated Approach Our updated approach further incorporates design team feedback and focuses on the two most important conventions: one for initialization and one for representation. Initializable Initializable designates protocols that convert from a type or from an associated type mentioned in the protocol name, such as the current &lt;Type &gt;LiteralConvertible protocols. This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type. For example, conforming to ArrayLiteralInitializable would allow a set to be created with Set(arrayLiteral: &lt;some array &gt;) and var set: Set &lt;T &gt; = []. This phrase replaces the Creatable form from our original proposal. Representable Representable designates protocols whose primary purpose is to project to a type or associated type mentioned in the protocol name. Items in the standard library that would be subsumed into this naming include CustomStringConvertible, CustomDebugStringConvertible, and RawRepresentable, which we imagine would become CustomStringRepresentable, CustomDebugStringRepresentable, and (as current) RawRepresentable. This second category groups together the Convertible and Representable categories from our original proposal and is predicated on the feedback from the design team review. The Representable designation does not promise bidirectional conversion although some Representable protocols may include requirements to allow attempted initialization from the type of the representation. Doing so falls outside the naming contract we are proposing. Future Directions We do not include a third category for bidirectional conversion in this update. We recognize that style of contract is rare in Swift. Lossless conversion does not appear in the standard library outside of RawRepresentable, which we agreed was better covered by Representable. If such a convention is needed or adopted, we reserve the Isomorphic designation for future use.",
    "url": "http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html",
    "relUrl": "/docs/2019-08-26-0041-conversion-protocol-conventions.html"
  },
  "41": {
    "id": "41",
    "title": "SE-0042 Flattening the function type of unapplied method references",
    "content": "Flattening the function type of unapplied method references Proposal: SE-0042 Author: Joe Groff Review Manager: Chris Lattner Status: Accepted Decision Notes: Rationale Bug: SR-1051 Introduction An unapplied method reference, such as Type.instanceMethod in the following example, currently produces a curried function value of type (Self) -&gt; (Args...) -&gt; Ret: struct Type { var x: Int func instanceMethod(y y: Int) -&gt; Int { return x + y } } let f = Type.instanceMethod // f : (Type) -&gt; (y: Int) -&gt; Int f(Type(x: 1))(y: 2) // ==&gt; 3 In order to make unapplied method references more useful and consistent with idiomatic Swift, and to make them workable for mutating methods, we should change them to produce a function with a flat function type, (Self, Args...) -&gt; Ret: let f = Type.instanceMethod // f: (Type, y: Int) -&gt; Int f(Type(x: 1), y: 2) // ==&gt; 3 Swift-evolution thread: Flattening the function type of unapplied instance methods Motivation Currying hasn’t proven itself to be used much in idiomatic Swift. Standard library collection transforms such as reduce and sort prefer “flat” function arguments, and Cocoa APIs that use blocks are imported into Swift with flat function types as well. By producing curried types, unapplied method references simply aren’t very useful as-is compared to free functions or closure literals. For instance, though you can pass the global + operator readily to reduce to sum a sequence of numbers: func sumOfInts(ints: [Int]) -&gt; Int { return ints.reduce(0, combine: +) } you can’t do the same with a binary method, such as Set.union: func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; { // Error: `combine` expects (Set&lt;T&gt;, Set&lt;T&gt;) -&gt; Set&lt;T&gt;, but // `Set.union` has type (Set&lt;T&gt;) -&gt; (Set&lt;T&gt;) -&gt; Set&lt;T&gt; return sets.reduce([], combine: Set.union) } Even unary methods are referenced as type (Self) -&gt; () -&gt; Ret, meaning they can’t be readily used with transforms like map: func sortedArrays&lt;T: Comparable&gt;(arrays: [[T]]) -&gt; [T] { // Error: `map` expects [T] -&gt; [T], but // `Array.sort` has type ([T]) -&gt; () -&gt; [T] return arrays.map(Array.sort) } This currying is also incompatible with mutating methods due to the semantics of inout parameters. In a chained call such as f(&amp;x)(y), the mutation window for x only lasts as long as the first call. The second application of y is no longer allowed to mutate x. We currently miscompile unapplied references to mutating methods, capturing a dangling pointer when the reference is partially applied and leading to undefined behavior when the full application occurs. Proposed solution We should change the type of an unapplied method reference to produce a flattened function value, instead of a curried one. This will make unapplied methods more readily useful with real Swift libraries, and make them supportable for mutating methods. Detailed design When an instance method is found by name lookup into a type reference or metatype value, a function value is produced that takes the self instance followed by the method arguments of the referenced method. If the method is mutating, then the first parameter of the resulting function value is inout. For example: struct Type { func instanceMethod(x: Int) -&gt; Float {} mutating func mutatingMethod(x: String) -&gt; Double {} } Type.instanceMethod // : (Type, Int) -&gt; Float Type.mutatingMethod // : (inout Type, String) -&gt; Double This proposal does not propose changing the behavior of method partial applications instance.instanceMethod. It should remain possible to partially bind a nonmutating method to its self parameter in this fashion. Impact on existing code This will break existing code that uses unapplied method references for their curried signatures today. A blunt migration would be to replace existing type references with nested closure literals, substituting: let x = y.map(flip(Type.method)) with: let x = y.map(flip({ instance in { arg in instance.method(arg) } })) However, unapplied method references are currently rare in practice, due to the limited usefulness of their curried signature today. Alternatives considered If we do nothing else, we should close the undefined behavior hole by banning unapplied references to mutating methods: struct Type { mutating func mutatingMethod() {} } let f: Type.mutatingMethod // This should become an error However, as discussed above, there are good systemic reasons to change the behavior of all unapplied method references; not only would this fix the undefined behavior hole, but also makes them a more generally useful feature.",
    "url": "http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html",
    "relUrl": "/docs/2019-08-26-0042-flatten-method-types.html"
  },
  "42": {
    "id": "42",
    "title": "SE-0043 Declare variables in 'case' labels with multiple patterns ",
    "content": "Declare variables in ‘case’ labels with multiple patterns Proposal: SE-0043 Author: Andrew Bennett Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#1383 Introduction In Swift 2, it is possible to match multiple patterns in cases. However cases cannot contain multiple patterns if the case declares variables. The following code currently produces an error: enum MyEnum { case Case1(Int,Float) case Case2(Float,Int) } switch value { case let .Case1(x, 2), let .Case2(2, x): print(x) case .Case1, .Case2: break } The error is: `case` labels with multiple patterns cannot declare variables. This proposal aims to remove this error when each pattern declares the same variables with the same types. Swift-evolution thread: here Motivation This change reduces repetitive code, and therefore reduces mistakes. It’s consistent with multi-pattern matching when variables aren’t defined. Proposed solution Allow case labels with multiple patterns to declare patterns by matching variable names in each pattern. Using the following enum: enum MyEnum { case Case1(Int,Float) case Case2(Float,Int) } These cases should be possible: case let .Case1(x, _), let .Case2(_, x): case let .Case1(y, x), let .Case2(x, y): case let .Case1(x), let .Case2(x): case .Case1(let x, _), .Case2(_, let x): Likewise for other uses of patterns: let value = MyEnum.Case1(1, 2) if case let .Case1(x, _), let .Case2(_, x) = value { ... } Detailed design Allow case labels with multiple patterns if the case labels match the following constraints: All patterns declare exactly the same variables. The same variable has the same type in each pattern. Therefore each pattern is able to produce the same variables for the case label. In the case of if case let usage the syntax is the same, the only issue is whether this can be combined with other variables, and whether it is unambiguous. The pattern grammar gets the following change: + enum-case-pattern-list → enum-case-pattern | + enum-case-pattern , enum-case-pattern-list + pattern → enum-case-pattern-list - pattern → enum-case-pattern Impact on existing code This should have no impact on existing code, although it should offer many opportunities for existing code to be simplified. Alternatives considered Using a closure or inline function Code repetition can be reduced with one pattern per ‘case’ and handling the result with an inline function. func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int { func handleX(x: Int) -&gt; Int { return apply(x) + 1 } let out: Int switch value { case .Case1(let x, 2): out = handleX(x) case .Case2(2, let x): out = handleX(x) case .Case1, .Case2: out = -1 } return out } This syntax is much more verbose, makes control flow more confusing, and has the limitations of what the inline function may capture. In the above example apply cannot be @noescape because handleX captures it. Also in the above example if out is captured and assigned by handleX then it must be var, not let. This can produce shorter syntax, but is not as safe; out may accidentally be assigned more than once, additionally out also needs to be initialized (which may not be possible or desirable). Extending the fallthrough syntax A similar reduction in code repetition can be achieved if fallthrough allowed variables to be mapped onto the next case, for example: switch test { case .Case1(let x, 2): fallthrough .Case2(_, x) case .Case2(3, .let x): print(&quot;x: (x)&quot;) } This is not as intuitive, is a hack, and fallthrough should probably be discouraged. It is much more flexible, a programmer could adjust the value of x before fallthrough. Flexibility increases the chances of programmer error, perhaps not as much as code-repetition though. Chainable pattern matching In my opinion if case let syntax is a little clumsy. It’s good that it’s consistent with a switch statement, but it’s not easy to chain. I think a different syntax may be nicer, if a few things existed: A case-compare syntax that returns an optional tuple: let x = MyEnum.Case1(1,2) let y: (Int,Int)? = (x case? MyEnum.Case1) assert(y == Optional.Some(1,2)) multiple field getters (similar to swizzling in GLSL). It returns multiple named fields/properties of a type as a tuple: let x = (a: 1, b: 2, c: 3) let y = x.(a,c,b,b) assert(y == (1,3,2,2)) You could compose them like this: enum MyNewEnum { case MyCase1(Int,Float), MyCase2(Float,Int) } let x = MyNewEnum.Case1(1,2,3) let y: (Int,Float)? = (x case? MyNewEnum.Case1) ?? (x case! MyNewEnum.Case2).(1,0) This is not a true alternative, it does not work in switch statements, but I think it still has value. Future Considerations It would be nice to use the if case let syntax to define variables of optional type. Something like this: case let .Case1(x,_) = MyEnum.Case1(1,2) Which would be the equivalent of this: let x: Int? if case let .Case1(t) = MyEnum.Case1(1,2) { x = t.0 } else { x = nil } It would support multiple patterns like so: case let .Case1(x,_), .Case2(_,x) = MyEnum.Case1(1,2) This is not necessary if chainable pattern matching was possible, but I’ve made sure this proposal is compatible.",
    "url": "http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html",
    "relUrl": "/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html"
  },
  "43": {
    "id": "43",
    "title": "SE-0044 Import as member",
    "content": "Import as member Proposal: SE-0044 Author: Michael Ilseman Status: Implemented (Swift 3) Review Manager: Doug Gregor Decision Notes: Rationale Bug: SR-1053 Introduction Swift imports C declarations, allowing Swift code to natively interact with C libraries and frameworks. But, such imported APIs do not feel natural to interact with in Swift. This proposal seeks to provide a mechanism for C API authors to specify the capability of importing functions and variables as members on imported Swift types. It also seeks to provide an automatic inference option for APIs that follow a consistent, disciplined naming convention. Swift-evolution thread Review Motivation C APIs and frameworks currently import into Swift as global functions and global variables. Interacting with these can feel awkward in Swift. Here’s an example of programmatic drawing using the Core Graphics C API: override func drawRect(rect: CGRect) { let context: CGContext = UIGraphicsGetCurrentContext()! let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0) let angle = CGFloat(M_PI / 16) var transform = CGAffineTransformIdentity for _ in 0..&lt;32 { triangulateRect(bounds, inputTransform: transform, context: context) transform = CGAffineTransformTranslate(transform, toCenter.x, toCenter.y) transform = CGAffineTransformRotate(transform, angle) transform = CGAffineTransformTranslate(transform, -toCenter.x, -toCenter.y) } CGContextSetLineWidth(context, bounds.size.width / 100) CGContextSetGrayStrokeColor(context, 0.5, 1.0) CGContextDrawPath(context, .Stroke) } func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, context: CGContext) { var transform = inputTransform // Triangle from top left corner, to bottom middle, to top right, and then // draw the boundary let topLeft = bounds.origin let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height) let path = CGPathCreateMutable() CGPathMoveToPoint(path, &amp;transform, topLeft.x, topLeft.y) CGPathAddLineToPoint(path, &amp;transform, CGRectGetMidX(bounds), bottomRight.y) CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y) CGPathAddLineToPoint(path, &amp;transform, topLeft.x, topLeft.y) CGPathAddLineToPoint(path, &amp;transform, topLeft.x, bottomRight.y) CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, bottomRight.y) CGPathAddLineToPoint(path, &amp;transform, bottomRight.x, topLeft.y) CGContextAddPath(context, path) } A much more natural expression of this in Swift, would be something more like: override func drawRect(rect: CGRect) { let context: CGContext = UIGraphicsGetCurrentContext()! let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0) let angle = CGFloat(M_PI / 16) var transform = CGAffineTransform.identity for _ in 0..&lt;32 { triangulateRect(bounds, inputTransform: transform, context: context) transform = transform.translate(toX: toCenter.x, toY: toCenter.y) .rotate(angle: angle) .translate(toX: -toCenter.x, toY: -toCenter.y) } context.lineWidth = bounds.size.width / 100 context.strokeColor = CGColor(gray: 0.5, alpha: 1.0) context.drawPath(mode: .Stroke) } func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform, context: CGContext) { var transform = inputTransform // Triangle from top left corner, to bottom middle, to top right, and then // draw the boundary let topLeft = bounds.origin let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height) let path = CGMutablePath() path.move(transform: &amp;transform, x: topLeft.x, y: topLeft.y) path.addLine(transform: &amp;transform, x: bounds.midX, y: bottomRight.y) path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y) path.addLine(transform: &amp;transform, x: topLeft.x, y: topLeft.y) path.addLine(transform: &amp;transform, x: topLeft.x, y: bottomRight.y) path.addLine(transform: &amp;transform, x: bottomRight.x, y: bottomRight.y) path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y) context.addPath(path) } Currently, the only way for a C framework to provide a natural Swift experience is to author large overlays or Swift wrappers. Proposed solution Manual specification C framework authors should have a way to manually specify how their APIs appear in Swift beyond the limited functionality currently provided with NS_SWIFT_NAME. This includes the ability to specify a type on which a given variable or function should be imported. This also includes the ability to specify when a function should be imported as a computed getter or setter of a property on that type. The goal is for developers using a C framework, which has these manual annotations applied, to develop in Swift as naturally as if they were working with a native object-oriented interface. Automatic inference Coupled with this manual specification ability is an automatic inference system. The inference system analyzes C global names and types, attempting to find an imported Swift type to extend with a method, initializer, or property from this global. This inference system’s goal is to be able to automatically handle the majority of global variables and functions in CF-style frameworks, and in the future be extensible to benefit other well structured, disciplined APIs. Amendment: Automatic inference will not be used by default for all C APIs, but will be opt-in. Maps directly onto C calling convention Wrappers and overlays have the downside that they result in an extra function call hop in order to reach the underlying C API (though fragility controls may somewhat alleviate this in the future). This proposal calls for imported APIs to map directly onto the original C APIs, without calling through intermediary wrappers or overlaid definitions. For instance members, this means supplying a reference to self in the appropriate parameter slot. Detailed design swift_name attribute The primary mechanism of manually communicating to the Swift compiler how an API should be imported is the swift_name attribute (e.g. through the CF_SWIFT_NAME macro). swift_name will be expanded to allow the user to provide a type on which the imported function will be a member of, and allow for specifying a function as a computed getter or setter for a type. Examples: // Import as init struct Point3D createPoint3D(float x, float y, float z) __attribute__((swift_name(&quot;Point3D.init(x:y:z:)&quot;))); // Import as method struct Point3D rotatePoint3D(Point3D point, float radians) __attribute__((swift_name(&quot;Point3D.rotate(self:radians:)&quot;))); // Import as instance computed property float Point3DGetRadius(Point3D point) __attribute__((swift_name(&quot;getter:Point3D.radius(self:)&quot;))); void Point3DSetRadius(Point3D point, float radius) __attribute__((swift_name(&quot;setter:Point3D.radius(self:_:)&quot;))); // Import as static property extern struct Point3D identityPoint __attribute__((swift_name(&quot;Point3D.identity&quot;))); // Import as static computed property Point3D getZeroPoint(void) __attribute__((swift_name(&quot;getter:Point3D.zero()&quot;))); void setZeroPoint(Point3D point) __attribute__((swift_name(&quot;setter:Point3D.zero(_:)&quot;))); Amendment: Also allow for importing as subscript. // Import as subscript float Point3DGetPointAtIndex(int idx, Point3D point) __attribute__((swift_name(&quot;getter:subscript(_:self:)&quot;))) void Point3DSetPointAtIndex(int idx, Point3D point, float val) __attribute__((swift_name(&quot;getter:subscript(_:self:newValue:)&quot;))) The string present in swift_name will additionally support the following: A type name proceeded by . to denote the context to import onto self to denote which parameter to treat as self for an instance method/property, otherwise this will be a static method/property getter: and setter: to denote the function as a property getter/setter Amendment: newValue to denote which parameter to treat as a subscript setter’s new value Amendment: swift_name is not valid on non-prototyped function declarations. Amendment: swift_name can be used to add instance members onto an extension of the named protocol, but they are limited to instance members. Importing as static method or init is not supported. Instance members are imported into a protocol extension, enforcing static dispatch. Automatic inference heuristics The following are some techniques and heuristics that can be useful for consistently named C APIs, e.g. CF-style frameworks. These heuristics are based off of the variable/function’s name and type. Identify init by return type diff func CGColorCreate(space: CGColorSpace?, _ components: UnsafePointer) -&gt; CGColor? // extension CGColor { … init?(space: CGColorSpace?, components: UnsafePointer) Identify computed properties by finding “get” / “set” pairs diff func CGContextGetInterpolationQuality(c: CGContext?) -&gt; CGInterpolationQuality func CGContextSetInterpolationQuality(c: CGContext?, _ quality: CGInterpolationQuality) // extension CGContext { … final var interpolationQuality: CGInterpolationQuality Identify boolean predicates and other computed property patterns diff func CGDisplayModeIsUsableForDesktopGUI(mode: CGDisplayMode?) -&gt; Bool // extension CGDisplayMode { final var isUsableForDesktopGUI: Bool { get } Identify methods by finding a self parameter diff func CGAffineTransformInvert(t: CGAffineTransform) -&gt; CGAffineTransform // extension CGAffineTransformation { … func invert() -&gt; CGAffineTransform Various special cases, fuzzy name matching, etc. diff func CGDisplayStreamUpdateGetTypeID() -&gt; CFTypeID // extension CGDisplayStreamUpdate { … final class var typeID: CFTypeID { get } … func CGBitmapContextGetData(context: CGContext?) -&gt; UnsafeMutablePointer // extension CGContext { … final var bitmapData: UnsafeMutablePointer { get } Underlying infrastructure The Clang Importer will be extended to support importing function and variable declarations onto different effective contexts than they appear in Clang. Additionally, the Clang Importer will want to create a single extension point per submodule/type pair on which to add these members. SILGen will need to be extended to map calls to these members directly to the original C API calls, passing self in the appropriate parameter location for instance members. Migration Projects using old style APIs will need to migrate to any new API. Since the proposed imports are done programmatically in the importer, migration attributes can be attached to the new decls, allowing the Swift migrator to automatically migrate user code. Impact on existing code Any Swift code using a C framework that uses this functionality will be massively affected, though in ways that the Swift migrator can alleviate. Alternatives considered Wrap everything One alternative, which is the only option available currently to framework authors, is to require C APIs to provide Swift wrapper APIs or overlays in order to call into the underlying C functionality. This has the disadvantage of having to maintain separate APIs in addition to the C headers themselves. This proposal allows for the C header to specify how the name should appear when imported into Swift. Additionally, if a C API follows consistent, CF-like naming, most of it can be imported automatically",
    "url": "http://localhost:4000/docs/2019-08-26-0044-import-as-member.html",
    "relUrl": "/docs/2019-08-26-0044-import-as-member.html"
  },
  "44": {
    "id": "44",
    "title": "SE-0045 Add prefix(while:) and drop(while:) to the stdlib",
    "content": "Add prefix(while:) and drop(while:) to the stdlib Proposal: SE-0045 Author: Lily Ballard Review Manager: Chris Lattner Status: Implemented (Swift 3.1) Decision Notes: Rationale Bug: SR-1516 Previous Revisions: 1, 2, 3 Introduction Add 2 new Sequence functions prefix(while:) and drop(while:), with overrides as appropriate on Collection, LazySequenceProtocol, and LazyCollectionProtocol. Swift-evolution thread: Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib Review Motivation The Swift standard library provides many useful sequence manipulators like dropFirst(_:), filter(_:), etc. but it’s missing a few common methods that are quite useful. Proposed solution Modify the declaration of Sequence with two new members: protocol Sequence { // ... /// Returns a subsequence by skipping elements while `predicate` returns /// `true` and returning the remainder. func drop(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence /// Returns a subsequence containing the initial elements until `predicate` /// returns `false` and skipping the remainder. func prefix(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence } Also provide default implementations on Sequence that return AnySequence, and default implementations on Collection that return a slice. LazySequenceProtocol and LazyCollectionProtocol will also be extended with implementations of drop(while:) and prefix(while:) that return lazy sequence/collection types. Like the lazy filter(_:), drop(while:) will perform the filtering when startIndex is accessed. Detailed design In addition to the above declarations, provide default implementations based on AnySequence, similarly to how functions like dropFirst(_:) and prefix(_:) are handled: extension Sequence where SubSequence : Sequence, SubSequence.Iterator.Element == Iterator.Element, SubSequence.SubSequence == SubSequence { public func drop(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Iterator.Element&gt; public func prefix(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Iterator.Element&gt; } These default implementations produce an AnySequence that wraps an Array (as the functions must be implemented eagerly so as preserve the convention of not holding onto a user-provided closure past the function call without the explicit appearance of .lazy). Provide default implementations on Collection as well: extension Collection { func drop(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence func prefix(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence } Also provide overrides as needed on AnySequence, AnyCollection, AnyBidirectionalCollection, and AnyRandomAccessCollection. Extend LazySequenceProtocol with lazy versions of the functions: extension LazySequenceProtocol { func drop(while predicate: (Self.Iterator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt; func prefix(while predicate: (Self.Iterator.Element) -&gt; Bool) -&gt; LazyPrefixWhileSequence&lt;Self.Elements&gt; } The types LazyDropWhileSequence and LazyPrefixWhileSequence conform to LazySequenceProtocol. Extend LazyCollectionProtocol with collection variants for the functions: extension LazyCollectionProtocol { func drop(while predicate: (Self.Iterator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt; func prefix(while predicate: (Self.Iterator.Element) -&gt; Bool) -&gt; LazyPrefixWhileCollection&lt;Self.Elements&gt; } The types LazyDropWhileCollection and LazyPrefixWhileCollection conform to LazyCollectionProtocol. Impact on existing code None, this feature is purely additive. Alternatives considered Naming The names here are likely to cause some bikeshedding. Here are some alternatives I’ve heard proposed: suffixFrom(firstElementSatisfying:) instead of drop(while:) – Not only is it rather long, it’s also focusing on taking a suffix while the actual expected usage of the function is focused around skipping elements at the start. There’s also the potential confusion around whether it’s the first element from the beginning or the first element from the end (since the term “suffix” implies working from the end backwards). skip(while:) instead of drop(while:) – I’m actually partial to this one, but we’d need to rename dropFirst(_:) as well. The benefit of this is it removes the potential confusion around whether the method is mutating. take(while:) instead of prefix(while:) – This was actually the original name proposed, and it matches precedent from other languages, but I eventually decided that consistency with prefix(_:) was desired. However, there is an argument to be made that prefix(while:) is using the term “prefix” like a verb instead of a noun, and the verb form means something different. prefix(to:) instead of prefix(while:) – The name here doesn’t make it obvious that the argument is a predicate, and this also requires inverting the meaning of the predicate which I don’t like. The focus of this function is on retaining the initial elements that have a desired characteristic, which suggests that the predicate should describe the characteristic the desired elements have, not the inverse. prefix(having:) instead of prefix(while:) – Reasonable. I chose prefix(while:) for consistency with drop(while:) but prefix(having:) makes more grammatical sense (since we’re using the noun meaning of prefix rather than the verb meaning). Previous versions Previous versions of this proposal included global functions scan(_:combine:) and unfold(_:applying:) (see [revision 3][rev-3]). This proposal was partially accepted, with scan(_:combine:) rejected on grounds of low utility and unfold(_:applying:) rejected on grounds of poor naming (see rationale).",
    "url": "http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html",
    "relUrl": "/docs/2019-08-26-0045-scan-takewhile-dropwhile.html"
  },
  "45": {
    "id": "45",
    "title": "SE-0046 Establish consistent label behavior across all parameters including first labels",
    "content": "Establish consistent label behavior across all parameters including first labels Proposal: SE-0046 Authors: Jake Carter, Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-961 Introduction We propose to normalize the first parameter declaration in methods and functions. In this proposal, first parameter declarations will match the existing behavior of the second and later parameters. All parameters, regardless of position, will behave uniformly. This will create a simple, consistent approach to parameter declaration throughout the Swift programming language and bring method and function declarations in-sync with initializers, which already use this standard. Discussion took place on the Swift Evolution mailing list in the Make the first parameter in a function declaration follow the same rules as the others thread. Motivation In the current state of the art, Swift 2 methods and functions combine local and external names to label parameters. These differentiated symbols distinguish names for internal implementation and external consumption. By default, a Swift 2 parameter declaration that appears first in the parameter list omits its external name. Second and later parameters duplicate local names as external labels. Under these Swift 2 rules, a declaration that looks like this: func foo(a: T, b: U, c: V) declares foo(_:b:c:) and not foo(a:b:c:). Historically, this label behavior was normalized in Swift 2, unifying parameter naming rules for methods and functions, which had previously used separate defaults behaviors. The new unified approach approximated Objective-C naming conventions where first parameter labels were subsumed into the first part of a method signature. For the most part, Swift 2 developers were encouraged to mimic this approach and build calls that moved the label name out of the parameter list and into the function or method name. Swift 3’s newly accepted API naming guidelines shook up this approach. They more thoroughly embraced method and function first argument labels. The updated naming guidance is further supported by the automated Objective-C API translation rules recently accepted for Swift 3. Under these revised guidelines, first argument labels are encouraged for but are not limited to: methods and functions where the first parameter of a method is defaulted methods and functions where the first argument uses a prepositional phrase methods and functions that implement factory methods methods and functions where method arguments represent a split form of a single abstraction First argument labels are also the standard for initializers. This expanded guidance creates a greater reach of first argument label usage and weakens justification for a first-parameter exception. Ensuring that parameter declarations behave uniformly supports Swift’s goals of clarity and consistency. This change produces the simplest and most predictable usage, simplifying naming tasks, reducing confusion, and easing transition to the language. Detail Design Under this proposal, first parameters names automatically create matching external labels, mimicking the second and later parameters. For example func foo(x: Int, y: Int) will declare foo(x:y:) and not foo(_:,y:). Developers will no longer need to double the first label to expose it to consuming API calls. The existing external label overrides will continue to apply to first parameters. You establish external parameter names before the local parameter name it supports, separated by a space. For example, func foo(xx x: Int, yy y: Int) declares foo(xx:yy:) and func foo(_ x: Int, y: Int) explicitly declares foo(_:y:) Impact on Existing Code This proposal will impact existing code, requiring migration support from Xcode. We propose the following solution: Function declarations that do not include explicit first item external labels will explicitly remove the first argument’s label (e.g. func foo(x: Int, y: Int) will translate to func foo(_ x: Int, y: Int)). Function call sites (e.g. foo(2, y: 3)) will remain unaffected. Selector mentions (e.g. #selector(ViewController.foo(_:y:))) will remain unaffected We do not recommend swapping the fixit behavior. Functions are more often called and mentioned than declared. Under a swap, the callsite would update to foo(x:2, y:3), selector mentions would update to #selector(ViewController.foo(x:y:) and the declaration left as is, to be interpreted as an explicitly named first label. Ideally the migrator will locate patterns where the last letters of a function name match the first parameter name, for example tintWithColor(color: UIColor), and insert a FIXME: warning suggesting manual migration. Swift’s automatic Objective-C import code might be repurposed to detect a prepositional phrase and parameter match to automate a fixit for tint(color: UIColor) or tint(withColor: UIColor) but this would involve a more complicated implementation. Note This proposal does not affect the behavior of Swift subscripts in any way. Subscripts act as an indexing shortcut for accessing the member elements of a type. Although subscripts can use optional labels, there is no parallel between their use of labels and the function and method parameters discussed in this proposal. You remain free to implement subscripts in the most appropriate way for your particular type’s functionality, with or without labels. Alternatives Considered There are no alternatives considered at this time.",
    "url": "http://localhost:4000/docs/2019-08-26-0046-first-label.html",
    "relUrl": "/docs/2019-08-26-0046-first-label.html"
  },
  "46": {
    "id": "46",
    "title": "SE-0047 Defaulting non-Void functions so they warn on unused results",
    "content": "Defaulting non-Void functions so they warn on unused results Proposal: SE-0047 Authors: Erica Sadun, Adrian Kashivskyy Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1052 Introduction In Swift’s current incarnation, annotating methods and functions with @warn_unused_result informs the compiler that a non-void return type should be consumed. It is an affirmative declaration. In its absence, ignored results do not raise warnings or errors. In its present form, this declaration attribute primarily differentiate between mutating and non-mutating pairs. It offers an optional mutable_variant for when an expected return value is not consumed. For example, when sort is called with an unused result, the compiler suggests using sortInPlace for unused results. @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;) public func sort() -&gt; [Self.Generator.Element] This proposal flips this default behavior. Unused results are more likely to indicate programmer error than confusion between mutating and non-mutating function pairs. This proposal makes “warn on unused result” the default behavior for Swift methods and functions. Developers must override this default to enable the compiler to ignore unconsumed values. This proposal was discussed on-list in a variety of threads, most recently Make non-void functions @warn_unused_result by default. Acceptance Notes The Core Team and much of the community agreed that this proposal directly aligns with the spirit of the Swift language, enabling the compiler to warn about obvious omissions in code that may be bugs. The @discardableResult attribute enables API authors to indicate when their functions and methods produce a non-essential result and should not produce a warning. Clients of unannotated APIs may employ the simple and local solution to silence the warning and willfully ignore the result. This code (the _ = pattern) expresses thoughtful intent and communicates this intent to future maintainers of a codebase. The Core Team requested the proposal be revised to update the Detail Design section to add the default import scheme for the Clang importer. “Once the basic pure-Swift implementation of this lands, we can evaluate extending these rules to imported declarations as well, but that discussion should include empirical evidence that evaluates the impact on real-world code.” Motivation In current Swift, the following code compiles and runs without warning: 4 + 5 Outside of a playground, where evaluation results are of interest in and of themselves, it’s unlikely any programmer would write this code intending to execute an addition and then discard the result. Inverting Swift’s default warning polarity ensures that developers can locate and inspect unconventional uses. If they approve the code, they can silence warnings by adding a _= pattern. This should significantly reduce real-world bugs due to the accidental omission of code that consumes results. Real world situations where it makes sense from a compiler point of view to discard non-Void results are rare. Examples of these API calls include NSUserDefaults’ synchronize function (returns Bool) and mutating collection methods that return elements upon removing them. These examples belongs to a subset of methods that are primarily executed for their side effects although they also provide a return value. These methods should not generate a warning or require _= as return value use is truly optional. /// Remove an element from the end of the ArraySlice in O(1). /// /// - Requires: `count &gt; 0`. public mutating func removeLast() -&gt; Element To solve this problem, we propose introducing a @discardableResult attribute to automatically silence compiler warnings, enabling calling functions for side effects. The proposed change enables developers to intentionally permit discarded results by annotating their declarations. Detail Design Under this proposal, the Swift compiler emits a warning when any method or function that returns a non-void value is called without using its result. To suppress this warning, the developer must affirmatively mark a function or method, allowing the result to be ignored. It can be argued that adding an override is unnecessary as Swift offers a mechanism to discard the result: _ = discardableResult() While this workaround makes it clear that the consumption of the result is intentionally discarded, it offers no traceable intent as to whether the API designer meant for this use to be valid. Including an explicit attribute ensures the discardable return value use is one that has been considered and approved by the API author. The approach takes the following form: @discardableResult func f() -&gt; T {} // may be called as a procedure as f() // without emitting a compiler warning func g() -&gt; T {} // defaults to warn on unused result func h() {} // Void return type, does not fall under the umbrella of this proposal The following examples demonstrate the @discardableResult behavior: let c1: () -&gt; T = f // no compiler warning let c2: () -&gt; Void = f // compiler error, invalid conversion let c3 = f // assignment does not preserve @discardableResult attribute c3() // compiler warning, unused result _ = c3() // no compiler warning Review Period Notes During the review period on Swift Evolution, the term @discardable was preferred over @discardableResult. Community members encouraged picking a shorter keyword. Alternative names considered included: @allowUnusedResult, @optionalResult, @suppressUnusedResultWarning, @noWarnUnusedResult, @ignorableResult, @incidentalResult, @discretionaryResult, @discardable, @ignorable, @incidental, @elective, @discretionary, @voluntary, @voidable, @throwaway, and @_ (underscore). Mutating Variants The original design for @warn_unused_result provides optional arguments for message and mutable_variant parameters. These parameters customize warnings when a method or function is called without consuming a result. This proposal introduces two new document comment fields, MutatingCounterpart and NonmutatingCounterpart. These replace the roles of the former mutable_variant and message arguments. Under this scheme, @discardableResult will not use arguments. Documentation comment fields will, instead, supply usage recommendations in both directions. We hope these keywords will cooperate with the code completion engine the same way that Swift currently handles Recommended and RecommendedOver. Documentation-based cross referencing provides a valuable tool for developers seeking correspondence between two related functions. By adding a highlighted field to documentation, both the mutating and non-mutating variations can direct developer attention to their counterpart. Named keywords instantly identify why the documentation is calling these items out rather than establishing some general relationship with the more generic SeeAlso documentation field. QuickHelp highlighted keywords support the expert and guide the beginner. Mutation pair keywords add value in a way SeeAlso cannot. Being a documentation expansion, this approach excludes compile-time verification of method/function signatures. Default Migration Behavior While @discardableResult and a “warn on unused result” default seems like a great direction for the standard library and other pure-Swift code, its impact on imported C and Objective-C APIs remains less clear. The Core Team expressed significant concern that warnings would be widespread and overwhelm users with a flurry of confusing, useless cautions. As such, the Core Team decided that the Clang importer will default to automatically add the @discardableResult attribute to all non-Void imported declarations (specifically, ones that are not marked with the Clang ((warn_unused_result)) attribute) upon adoption of this proposal. Once the basic pure-Swift implementation of this lands, the Core Team and the extended Swift community can evaluate extending these rules to imported declarations as well. That discussion should and will include empirical evidence that evaluates impact on real-world code. Future directions Decorating Type The Swift Evolution community discussed decorating the type rather than the declaration. Decorating the return type makes it clear that it’s the result that can be optionally treated as discardable rather than the function whose role it is to police its use. func f() -&gt; @discardable T {} // may be called as a procedure as f() // without emitting a compiler warning This approach was discarded to reduce the type system impact and complexity of the proposal. When not coordinated with the base function type, currying or “taking the address” of a function could effectively remove the @discardableResult attribute. This means some use of an otherwise @discardable function value would have to use _ =. While this approach was considered more elegant, the additional implementation costs means that it’s best to delay adopting type decoration until such time as there’s a strong motivation to use such an approach. Objective-C Annotation During review, some community members requested a new attribute enabling exceptional imported functions to be properly annotated from Objective-C source. Swift Type Annotation Another topic raised during review requested that the attribute annotate types as well as functions. This would allow “the default behavior to be changed on a per-type basis, as this would be useful for types that are specifically designed with method chaining for example (where most results are discardable as standard). While the choice of default will never satisfy everyone, this would make it easy to tweak for your own needs.” Snake Case Upon acceptance, this proposal removes two of the last remaining instances of snake_case in the Swift language. This further brings the language into a coherent and universal use of lowercase and camel case variants. Acknowledgements Changing the behavior of non-void functions to use default warnings for unused results was initially introduced by Adrian Kashivskyy. Additional thanks go out to Chris Lattner, Gwendal Roué, Dmitri Gribenko, Jeff Kelley, David Owens, Jed Lewison, Stephen Cellis, Ankit Aggarwal, Paul Ossenbruggen,Brent Royal-Gordon, Tino Heth, Haravikk, Félix Cloutier,Yuta Koshizawa, for their feedback on this topic.",
    "url": "http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html",
    "relUrl": "/docs/2019-08-26-0047-nonvoid-warn.html"
  },
  "47": {
    "id": "47",
    "title": "SE-0048 Generic Type Aliases",
    "content": "Generic Type Aliases Proposal: SE-0048 Author: Chris Lattner Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Introduction This proposal aims to add generic typealiases to Swift. Swift-evolution thread: here Motivation Generic typealiases are an obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters. Proposed Solution The solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition. This allows one to express things like: typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt; typealias DictionaryOfStrings&lt;T : Hashable&gt; = Dictionary&lt;T, String&gt; typealias IntFunction&lt;T&gt; = (T) -&gt; Int typealias Vec3&lt;T&gt; = (T, T, T) typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1) This is consistent with the rest of Swift’s approach to generics, and slots directly into the model. Detail Design This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”. These aliases are required to declare the constraints of the aliasee (e.g. the DictionaryOfStrings example above redeclares the Hashable constraint) to make the requirements of the declaration obvious. Leaving off the constraint would produce the expected error (potentially with a Fixit hint to add it): typealias DictionaryOfStrings&lt;T&gt; = Dictionary&lt;T, String&gt; // error: type &#39;T&#39; does not conform to protocol &#39;Hashable&#39; However, because this proposal is targeted at supporting aliases, it does not allow additional constraints to be added to type parameters. For example, you can’t write: typealias ComparableArray&lt;T where T : Comparable&gt; = Array&lt;T&gt; If there is a compelling reason to add this, we can consider extending the model to support them in the future, based on the merits of those reasons. Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift. For example, they allow the usual access control features that type aliases support. Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”. Impact on existing code This is a new feature, so there is no impact on existing code.",
    "url": "http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html",
    "relUrl": "/docs/2019-08-26-0048-generic-typealias.html"
  },
  "48": {
    "id": "48",
    "title": "SE-0049 Move @noescape and @autoclosure to be type attributes",
    "content": "Move @noescape and @autoclosure to be type attributes Proposal: SE-0049 Author: Chris Lattner Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1235 Introduction This proposal suggests moving the existing @noescape and @autoclosure attributes from being declaration attributes on a parameter to being type attributes. This improves consistency and reduces redundancy within the language, e.g. aligning with SE-0031, which moved inout, making declaration and type syntax more consistent. Swift-evolution thread: here Motivation Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type. This meant that manually curried code like this: func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] { return { f in x.flatMap(f) } } Was rejected. Fixing this was straight-forward, but required @noescape being allowed on arbitrary function types. Now that we have that, these two declarations are equivalent: func f(@noescape fn : () -&gt; ()) {} // declaration attribute func f(fn : @noescape () -&gt; ()) {} // type attribute. Further evaluation of the situation found that @autoclosure (while less pressing) has the exact same problem. That said, it is currently in a worse place than @noescape because you cannot actually spell the type of a function that involves it. Consider an autoclosure-taking function like this: func f2(@autoclosure a : () -&gt; ()) {} You can use it as you’d expect, e.g.: f2(print(&quot;hello”)) Of course, f2 is a first class value, so you can assign it: let x = f2 x(print(&quot;hello&quot;)) This works, because x has type (@autoclosure () -&gt; ()) -&gt; (). You can see this if you force a type error: let y : Int = x // error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39; However, you can’t write this out explicitly: let x2 : (@autoclosure () -&gt; ()) -&gt; () = f2 // error: attribute can only be applied to declarations, not types This is unfortunate because it is an arbitrary inconsistency in the language, and seems silly that you can use type inference but not manual specification for the declaration of x2. Proposed Solution The solution solution is straight-forward: disallow @noescape and @autoclosure on declarations, and instead require them on the types. This means that only the type-attribute syntax is supported: func f(fn : @noescape () -&gt; ()) {} // type attribute. func f2(a : @autoclosure () -&gt; ()) {} // type attribute. This aligns with the syntax used for types, since the type of f is (_: @noescape () -&gt; ()) -&gt; (), and the type of f2 is (_ : @autoclosure () -&gt; ()) -&gt; (). This fixes the problem with x2, and eliminates the redundancy between the @noescape forms. Impact on existing code This breaks existing code that uses these in the old position, so it would be great to roll this out with the other disruptive changes happening in Swift 3. The Swift 3 migrator should move these over, and has the information it needs to do a perfect migration in this case. For the compiler behavior, given that Swift 2.2 code will be source incompatible with Swift 3 code in general, it seems best to make these a hard error in the final Swift 3 release. It would make sense to have a deprecation warning period for swift.org projects like corelibs and swiftpm, and other open source users tracking the public releases.",
    "url": "http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html",
    "relUrl": "/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html"
  },
  "49": {
    "id": "49",
    "title": "SE-0050 Decoupling Floating Point Strides from Generic Implementations",
    "content": "Decoupling Floating Point Strides from Generic Implementations Proposal: SE-0050 Authors: Erica Sadun, Xiaodi Wu Review Manager: Chris Lattner Status: Withdrawn Decision Notes: Rationale Swift strides create progressions along “notionally continuous one-dimensional values” using a series of offset values. This proposal supplements Swift’s generic stride implementation with separate algorithms for floating point strides that avoid error accumulation. This proposal was discussed on-list in the ”[Discussion] stride behavior and a little bit of a call-back to digital numbers” thread. Motivation Strideable is genericized across both integer and floating point types. Writing a single piece of code to operate on both integer and floating point types is rarely a good idea. Swift’s current implementation causes floating point strides to accumulate errors when repeatedly adding by intervals. Floating point types deserve a separate floating point-aware implementation that minimizes errors. Current Art A StrideTo sequence returns a sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression that is less than end. A StrideThrough sequence returns a sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. While floating point calls present an extremely common use case, they use integer-style math that accumulates errors during execution. Consider this example (using Swift 2.2 syntax): let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0] print(zip(Array(1.0.stride(through: 2.01, by: 0.1)), ideal).map(-)) // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, // 4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, // 6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16, // 8.8817841970012523e-16] To create an array containing values from 1.0 to 2.0, the developer must add an epsilon value to the through argument. Otherwise the stride progression ends near 1.9. Increasing the argument from 2.0 to 2.01 is sufficient to include the end value. The errors in the sequence increase over time. You see this as errors become larger towards the end of the progress. This is an artifact of the generic implementation. The same issues occur with C-style for loops. This problem is a fundamental artifact of floating point math and is not specific to Swift statements. Detailed Design Floating point strides are inherently dissimilar to and should not be genericized with integer strides. We propose that FloatingPointStrideTo and FloatingPointStrideThrough should each return a sequence of values (self, self + 1.0 * stride, self + 2.0 * stride, … last). The following example provides a rough sketch at what a revamp for FloatingPointStrideTo might look like (incorporating the FloatingPoint protocol as adopted in SE-0067): /// An iterator for the result of `stride(to:...)` that advances without /// accumulating error for floating point types. public struct FloatingPointStrideToIterator&lt; Element : Strideable where Element.Stride : FloatingPoint &gt; : IteratorProtocol { internal var _step: Element.Stride = 0 internal let _start: Element internal let _end: Element internal let _stride: Element.Stride /// Advance to the next element and return it, or `nil` if no next /// element exists. public mutating func next() -&gt; Element? { let current = _start + _step * _stride if _stride &gt; 0 ? current &gt;= _end : current &lt;= _end { return nil } _step += 1 return current } internal init(_start: Element, end: Element, stride: Element.Stride) { let quotient = (end - _start) / stride // FIXME: Maximum supported number of steps could be slightly larger _precondition( quotient &gt;= 0 &amp;&amp; quotient.ulp &lt;= 1, &quot;can&#39;t construct FloatingPointStrideToIterator: maximum supported number of steps exceeded&quot;) self._start = _start self._end = end self._stride = stride } } /// A `Sequence` of values formed by striding over a floating point /// half-open interval without accumulating error. public struct FloatingPointStrideTo&lt; Element : Strideable where Element.Stride : FloatingPoint &gt; : Sequence, CustomReflectable { // FIXME: should really be a CollectionType, as it is multipass /// Returns an iterator over the elements of this sequence. /// /// - Complexity: O(1). public func makeIterator() -&gt; FloatingPointStrideToIterator&lt;Element&gt; { return FloatingPointStrideToIterator( _start: _start, end: _end, stride: _stride) } internal init(_start: Element, end: Element, stride: Element.Stride) { // The endpoint is constrained by a step counter of type Element.Stride // in FloatingPointStrideToIterator, but it does not otherwise need to // be finite. _precondition( stride.isFinite &amp;&amp; !stride.isZero, &quot;stride size must be finite and non-zero&quot;) self._start = _start self._end = end self._stride = stride } internal let _start: Element internal let _end: Element internal let _stride: Element.Stride public var customMirror: Mirror { return Mirror(self, children: [&quot;from&quot;: _start, &quot;to&quot;: _end, &quot;by&quot;: _stride]) } } /// Returns the sequence of values (`self`, `self + 1.0 * stride`, `self + /// 2.0 * stride`, ... *last*) where *last* is the last value in /// the progression that is less than `end`. @warn_unused_result public func stride&lt;T : Strideable where T.Stride : FloatingPoint&gt;( from start: T, to end: T, by stride: T.Stride ) -&gt; FloatingPointStrideTo&lt;T&gt; { return FloatingPointStrideTo(_start: start, end: end, stride: stride) } Some salient design points deserve mention: We propose that only floating point types use this slightly more computationally intensive “new” stride; all other types retain the “classic” stride. If accepted, this new code could be appended to Stride.swift.gyb and exist alongside current code, which does not need to be modified. It has become clear (based on some of Dave Abrahams’s insights) that what determines whether a StrideTo&lt;T&gt; accumulates error isn’t T but rather T.Stride; thus, we determine that “new” stride applies where T.Stride : FloatingPoint. With newly adopted FloatingPoint protocols, Float80 will conform to FloatingPoint and so will be opted into “new” stride. We have considered Dave Abrahams’s suggestion to explore whether we could avoid introducing new types, instead modifying the existing StrideToIterator and StrideThroughIterator and relying on compiler optimization to transform “new” stride into “classic” stride for StrideTo&lt;Int&gt;; however, because the differences between “classic” stride and “new” stride extend beyond the iterator’s next() method (see below), we determined it would be best to keep the floating point logic in distinct types. This “new” stride algorithm must take a different approach to handling the edge case of strides requiring an excessively large number of iterations. Consensus feedback has been that such strides should not devolve into infinite loops. As a result, the number of steps required to stride from start to end is computed during initialization. A “BigInt” step counter could remove this limitation, but use of such a type would degrade performance for more common use cases, and of course no such type exists in the Standard Library. Thus, we have settled on the use of a floating point step counter. One implication of using a floating point step counter is that the maximum supported number of iterations for endpoints of type Double is 253 − 1. That number of steps should be indistinguishable from an infinite loop for currently available consumer systems. Alternatives include a step counter of type Int, but as Stephen Canon has pointed out, there is a performance hit involved in performing an integer-to-floating point conversion at every iteration and in using multi-word arithmetic on 32-bit systems. For endpoints of type Float, meaningful loops may exist with more than 224 − 1 iterations and catastrophic cancellation is a realistic concern; therefore, it is a decision to be made on review if it is advisable to implement Float-specific versions of these algorithms where internal state is represented using Double, thus improving precision beyond that obtainable by manually computing (self, self + 1.0 * stride, self + 2.0 * stride, … last) using Float. Out of Scope We (and others) intend to propose further changes to striding under separate cover. The following topics remain under discussion but are orthogonal to this proposal: Adding a method to be named striding(by:) or by(_:) to Range Conforming strides to Collection rather than Sequence, and enabling striding over all types conforming to Collection (or even all types conforming to Sequence) Other out-of-scope suggestions that may no longer apply to Swift 3 include: Changing the name of parameter labels to: and through: to clarify their meaning Changing internal implementation details of StrideToIterator and StrideThroughIterator to reduce the number of branches without relying on compiler optimizations to elide them Merging Range and stride types Alternatives Considered Converting floating point values to integer math can produce more precise results. This approach works by calculating a precision multiplier. The multiplier is derived from the whole and fractional parts of the start value, end value, and stride value, enabling fully integer math that guards against lost precision. We do not recommend this solution because it introduces significant overhead both during initialization and at each step. This overhead limits real-world utility beyond trivial stride progressions. A fast, well-implemented decimal type would be a better fit than this jerry-rigged alternative. Integer Math /// An `Iterator` for `DoubleStrideThrough`. public struct DoubleStrideThroughIterator : Iterator { let start: Int let end: Int let stride: Int let multiplier: Int var iteration: Int = 0 var done: Bool = false public init(start: Double, end: Double, stride: Double) { // Calculate the number of places needed // Account for zero whole or fractions let wholes = [abs(start), abs(end), abs(stride)].map(floor) let fracs = zip([start, end, stride], wholes).map(-) let wholeplaces = wholes .filter({$0 &gt; 0}) // drop all zeros .map({log10($0)}) // count places .map(ceil) // round up let fracplaces = fracs .filter({$0 &gt; 0.0}) // drop all zeroes .map({log10($0)}) // count places .map(abs) // flip negative log for fractions .map(ceil) // round up // Extend precision by 10^2 let places = 2.0 + (wholeplaces.maxElement() ?? 0.0) + (fracplaces.maxElement() ?? 0.0) // Compute floating point multiplier let fpMultiplier = pow(10.0, places) // Convert all values to Int self.multiplier = lrint(fpMultiplier) let adjusted = [start, end, stride] .map({$0 * fpMultiplier}) .map(lrint) (self.start, self.end, self.stride) = (adjusted[0], adjusted[1], adjusted[2]) } /// Advance to the next element and return it, or `nil` if no next /// element exists. public mutating func next() -&gt; Double? { if done { return nil } let current = start + iteration * stride; iteration += 1 if stride &gt; 0 ? current &gt;= end : current &lt;= end { if current == end { done = true // Convert back from Int to Double return Double(current) / Double(multiplier) } return nil } // Convert back from Int to Double return Double(current) / Double(multiplier) } } Computed Epsilon Values Computed epsilon values help compare a current value to a floating-point endpoint. The following code tests whether the current value lies within 5% of the stride of the endpoint. /// An `Iterator` for `DoubleStrideThrough`. public struct DoubleStrideThroughIterator : Iterator { let start: Double let end: Double let stride: Double var iteration: Int = 0 var done: Bool = false let epsilon: Double public init(start: Double, end: Double, stride: Double) { (self.start, self.end, self.stride) = (start, end, stride) epsilon = self.stride * 0.05 // an arbitrary epsilon of 5% of stride } /// Advance to the next element and return it, or `nil` if no next /// element exists. public mutating func next() -&gt; Double? { if done { return nil } let current = start + Double(iteration) * stride; iteration += 1 if abs(current - end) &lt; epsilon { done = true return current } if signbit(current - end) == signbit(stride) { done = true return nil } return current } } Other Solutions While precision math for decimal numbers would be better addressed by introducing a decimal type and/or warnings for at-risk floating point numbers, those features lie outside the scope of this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html",
    "relUrl": "/docs/2019-08-26-0050-floating-point-stride.html"
  },
  "50": {
    "id": "50",
    "title": "SE-0051 Conventionalizing `stride` semantics",
    "content": "Conventionalizing stride semantics Proposal: SE-0051 Author: Erica Sadun Review Manager: N/A Status: Withdrawn Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). This proposal introduces a third style and renames the existing to and through styles. This proposal was discussed on-list in the ”[Discussion] stride behavior and a little bit of a call-back to digital numbers” thread. Motivation Strideable’s function names do not semantically match the progressions they generate. Values produced by through do not pass through an end point; they stop at or before that fence. For example, 1.stride(through: 10, by: 8) returns the progress (1, 9), not (1, 9, 17). Similarly, its to function values reaches its end point. 1.stride(to:4, by:1) returns 1, 2, and 3. It never makes it to 4: The current Swift definition of to returns values in [start, end) and will never reach end. In other words, you will never get to end. The current Swift definition of through returns values in [start, end]. It may never reach end and certainly never goes through that value. Some definitions with the help of the New Oxford American Dictionary Moving to a value expresses “a point reached at the end of a range”. To pass through a value, you should move beyond “the position or location of something beyond or at the far end of (an opening or an obstacle)”. To move towards a value is to get “close or closer” or “getting closer to achieving (a goal)”. Current Art A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, … last) where last is the last value in the progression that is less than end. A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, … last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence. The name of the calling function through suggests the progression will pass through the end point before stopping. It does not. The name to suggests a progression will attempt to arrive at an end point. It does not. Detail Design When striding to or through a number, the behavior does not match the meaning of the word. Swift should provide three stride styles not two. Style 1: [start, end) by intervalThis style is currently called to. I propose to rename it towards as each value works towards end. The final value in the progression is less than end. Other suggested names include approaching, movingTowards, advancedTowards. Style 2: [start, end] by intervalThis style is currently called through. I propose to rename it to. The progression concludes with a value that is less than or equal to end. Swift provides no guarantee that end is an element of the sequence. Other suggested names include movingTo, advancingTo. Style 3: [start, &gt;=end] by intervalI propose to introduce a new style called through. The final value is guaranteed to pass through end, either by finishing on end or past end. The final value is strictly less than end + interval. Other suggested names include beyond, past. Canonical Use Cases Canonical use-cases for all three styles: Style 1: towards This style mimics a..&lt;b but allows non-unit and negative progressions 1 towards 5 by 1: [1, 2, 3, 4] Style 1 ensures that the range of the from and to values fully includes the range of the progression: [from…through] subsumes [first..&lt;last]. Example, standard index references, either progressing in iterative units or by leaps, without introducing array bounds errors. Style 2: to This style mimics a...b but allows non-unit and negative progressions 1 to 5 by 1: [1, 2, 3, 4, 5] 1 to 10 by 8: [1, 9] Style 2 ensures that the range of the from and to values fully includes the range of the progression: [from…through] subsumes [first…last]. Example: a simple inclusive count, or a range-limited sequence. Style 3: through This style introduces a..&gt;=b, a..=&gt;b, or a...&gt;b and allows non-unit and negative progressions 1 through 10 by 8: [1, 9, 17] Style 3 ensures that the range of the progression fully includes the range of the from and to values: [first…last] subsumes [from…through]. Example: mapping out a graph axis, where the extent must be greater to or correspond to the underlying sequence. Implementing Style 3 A Style 3 implementation works as follows: /// A `Strideable through` sequence currently returns the sequence of values /// (`self`, `self + stride`, `self + stride + stride`, ... *last*) where *last* /// is the first value in the progression **greater than or equal to** `end`. /// There is no guarantee that `end` is an element of the sequence. /// Advance to the next element and return it, or `nil` if no next /// element exists. public mutating func next() -&gt; Element? { if done { return nil } if stride &gt; 0 ? current &gt;= end : current &lt;= end { done = true return current } let result = current current = current.advancedBy(stride) return result } } This solution is minimally disruptive to developers, respectful to existing code bases, and introduces a more complete semantic set of progressions that better matches progression names to developer expectations. (For example, “this argument says it goes through a value but it never even reaches that value”.) Upon adopting this change, out-of-sync strides now pass through end values: // Unit stride print(Array(1.stride(through: 10, by: 1))) // prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], no change // Old out-of-sync stride print(Array(1.stride(through: 10, by: 8))) // prints [1, 9] // New out-of-sync stride print(Array(1.stride(through: 10, by: 8))) // prints[1, 9, 17] There are no functional changes existing stride implementations. Only their names change. print(Array(1.stride(towards: 10, by: 8))) // was `to` // prints [1, 9] print(Array(1.stride(to: 10, by: 8))) // was `through` // prints [1, 9] Although floating point arithmetic presents a separate and orthogonal challenge, its behavior changes if this proposal is implemented under the current generic system. For example, through now includes a value at (or at least close to) 2.0 instead of stopping at 1.9 due to accumulated floating point errors. // Old print(Array(1.0.stride(through: 2.0, by: 0.1))) // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9] // New print(Array(1.0.stride(through: 2.0, by: 0.1))) // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0] // Old, does not pass through 1.9 print(Array(1.0.stride(through: 1.9, by: 0.25))) // prints [1.0, 1.25, 1.5, 1.75] // New, passes through 1.9 print(Array(1.0.stride(through: 1.9, by: 0.25))) // prints [1.0, 1.25, 1.5, 1.75, 2.0] Impact on Existing Code Renaming two stride functions and adding a third does not change or break existing code. The Swift 3 migrator can easily update the names for the two existing styles. That said, the migrator will not find in-place workarounds like a through: 2.01 epsilon adjustment to correct for floating-point fences. By adding FIXME: notes wherever through: is found and renamed to to:, the migrator could warn against continued use without a full inspection and could offer links to information about the semantic changes. Alternatives Considered The only alternative at this time is “no change” to existing semantics.",
    "url": "http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html",
    "relUrl": "/docs/2019-08-26-0051-stride-semantics.html"
  },
  "51": {
    "id": "51",
    "title": "SE-0052 Change IteratorType post-nil guarantee",
    "content": "Change IteratorType post-nil guarantee Proposal: SE-0052 Author: Patrick Pijnappel Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#1702 Introduction Currently, the documentation for IteratorType.next() has the precondition that when calling next(), no preceding call to next() should have returned nil, and in fact encourages implementations to raise a preconditionFailure() for violations of this requirement. However, all current 27 IteratorType implementations in the standard library return nil indefinitely. Many users are likely unaware of the precondition, expecting all iterators to return nil indefinitely and writing code that might rely on this assumption. Such code will usually run fine, until someone does in fact pass in an iterator not repeating nil (it’s a silent corner case). Swift-evolution thread: [Proposal] Change guarantee for GeneratorType.next() to always return nil past end Motivation While not overwhelmingly common, it is relatively easy to write code based on the assumption nil will be returned indefinitely: // Example based on standard library code (Sequence.swift) while let element = iterator.next() { if condition(element) { foo(element) // call foo on first element satisfying condition break } } while let element = iterator.next() { bar(element) // call bar on remaining elements } // Another example switch (iterator.next(), iterator.next()) { // ... } Even though this can be trivially rewritten to not rely on post-nil behavior, the user won’t perform this rewrite if they are unaware of the precondition. In their testing the code will work fine, and likely will in almost every case, except when passing the rare iterator that doesn’t repeat nil. Proposed solution Bring the guarantee in line with the common expectation, and require iterators to return nil indefinitely. The rest of this section will compare the current guarantee (post-nil unspecified) with the proposed guarantee (post-nil always nil) on a few different areas. Safety In both cases, there is someone that could make a mistake with post-nil behavior: Current: Callers could be unaware that iterators don’t always keep returning nil. Proposed: Implementors of custom iterators could be unaware they should keep returning nil. Both cases are silent, i.e. they don’t show with most usage. However the mistake is less likely in the proposed case: Iterators returning nil indefinitely is probably what most people expect, especially since all iterators in the standard library do this (and likely many custom iterators as well). Implementors are probably more likely than callers to check the API contract. Some have argued that it’s risky to rely on people adhering to the API contract, an argument that can be made for either case: a) “Writing an iterator that doesn’t repeat nil is risky as the caller might not adhere to the API contract, so just make all iterators repeat nil anyway.” b) “Writing code that relies on the iterator repeating nil is risky as the implementor might not adhere to the API contract, so just track state and branch in that code anyway.” This however kind of defeats the purpose of having an API contract. Frequency In both cases, sometimes code needs to track extra state and branch: Current: Callers sometimes need to track a bool and branch. The standard library currently has 3 occurrences of this being necessary (#1, #2, #3). Proposed: Iterator implementations sometimes need to track a bool and branch. The standard library currently has no occurrences of this being necessary. If SE-0045 is accepted, it will introduce the first case (out of 30 iterators), TakeWhileIterator. Performance considerations In both cases, the extra state and branching that is sometimes needed has potential for performance implications. Though performance is not the key concern, iterators are often used in tight loops and can affect very commonly used algorithms. The original rationale for introducing the precondition was in fact because of concerns it might add storage and performance burden to some implementations of IteratorType. However in light of implementation experience, it appears including the guarantee would likely be beneficial for performance: Current: Callers sometimes need to track a bool and branch, which can usually not be optimized away. This can be somewhat significant, for example UTF-8 decoding would be ~25% faster on ASCII input with the proposed guarantee (see here). Proposed: Iterator implementations sometimes need to track a bool and branch, which can usually be optimized away when not needed by the caller (e.g. in a for in loop). Note that when post-nil behavior is relied upon, the caller would have had to track state and branch already if the iterator didn’t. Detailed design Original guarantee: /// Advance to the next element and return it, or `nil` if no next /// element exists. /// /// - Precondition: `next()` has not been applied to a copy of `self` /// since the copy was made, and no preceding call to `self.next()` /// has returned `nil`. Specific implementations of this protocol /// are encouraged to respond to violations of this requirement by /// calling `preconditionFailure(&quot;...&quot;)`. Proposed guarantee: /// Advance to the next element and return it, or `nil` if no next element /// exists. Once `nil` has been returned, all subsequent calls return `nil`. /// /// - Precondition: `next()` has not been applied to a copy of `self` /// since the copy was made. Impact on existing code All IteratorType implementations in the standard library already comply with the new guarantee. It is likely most existing custom iterators will as well, however some might be rendered in violation of their guarantee by the change. Alternatives considered Add a FuseIterator type to the standard library that can wrap any iterator to make it return nil indefinitely (constructed using .fuse()), and leave the guarantee for next() as is. This however doesn’t really solve most problems described in this proposal and adds a rarely used type to the standard library. Require IteratorType to not crash but keep the return value up to specific implementations. This allows them to use it for other behavior e.g. repeating the sequence after nil is returned. This however retains most of the problems of the original guaranteee described in this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html",
    "relUrl": "/docs/2019-08-26-0052-iterator-post-nil-guarantee.html"
  },
  "52": {
    "id": "52",
    "title": "SE-0053 Remove explicit use of `let` from Function Parameters",
    "content": "Remove explicit use of let from Function Parameters Proposal: SE-0053 Author: Nicholas Maccharoli Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#1812 Introduction Since function parameters are immutable by default, allowing function parameters to be explicitly labeled as let is a bit of a syntactic redundancy that would best be removed. Not allowing function parameters to be explicitly declared as let would permit a more simple and uniform function declaration syntax for swift. Furthermore proposal SE-0003​: “Removing var from Function Parameters” removes var from function parameters removing any possible ambiguity as to whether a function parameter is immutable or not. Swift-evolution thread: Removing explicit use of let from Function Parameters Motivation Now that proposal SE-0003​: “Removing var from Function Parameters” has been accepted, it would make sense that the syntax for function parameters being explicitly declared as let would be removed as well. Since prepending let to an argument label does not modify behavior, leaving it as part of the language would only add redundancy and complexity to Swift’s syntax at no added benefit. Furthermore SE-0001 allowed the use of all keywords as argument labels except for inout, var and let. Proposal SE-0031 made inout a type modifier freeing inout to be used as an argument label and proposal SE-0003 prohibits declaring function parameters as var freeing var to be used as an argument label. The only keyword still in use that is preventing any keyword from being used as an argument label is let which if removed from function parameter syntax would permit SE-0001 to allow all keywords as argument labels with no exceptions. Proposed solution Make functions with parameters declared with an explicit let prohibited and a compile time error. Basically make functions declared like this a compile time error: func foo(let x: Int) { ... } In favor of omitting let like this: func foo(x: Int) { ... } Impact on existing code In code that is migrating to this newer proposed syntax the let keyword should be deleted if placed before a function parameter or else it will be treated as an external label. This should not be too disruptive since the common convention is already to not label function parameters as let. Alternatives considered Leave the redundant syntax in place, but I personally don’t see any merit in that.",
    "url": "http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html",
    "relUrl": "/docs/2019-08-26-0053-remove-let-from-function-parameters.html"
  },
  "53": {
    "id": "53",
    "title": "SE-0054 Abolish `ImplicitlyUnwrappedOptional` type",
    "content": "Abolish ImplicitlyUnwrappedOptional type Proposal: SE-0054 Author: Chris Willmore Review Manager: Chris Lattner Status: Implemented (Swift 4.2) Decision Notes: Rationale Implementation: apple/swift#14299 Introduction This proposal seeks to remove the ImplicitlyUnwrappedOptional type from the Swift type system and replace it with an IUO attribute on declarations. Appending ! to the type of a Swift declaration will give it optional type and annotate the declaration with an attribute stating that it may be implicitly unwrapped when used. Swift-evolution thread: “Abolish IUO Type” Motivation The ImplicitlyUnwrappedOptional (“IUO”) type is a valuable tool for importing Objective-C APIs where the nullability of a parameter or return type is unspecified. It also represents a convenient mechanism for working through definite initialization problems in initializers. However, IUOs are a transitional technology; they represent an easy way to work around un-annotated APIs, or the lack of language features that could more elegantly handle certain patterns of code. As such, we would like to limit their usage moving forward, and introduce more specific language features to take their place. Except for a few specific scenarios, optionals are always the safer bet, and we’d like to encourage people to use them instead of IUOs. This proposal seeks to limit the adoption of IUOs to places where they are actually required, and put the Swift language on the path to removing implicitly unwrapped optionals from the system entirely when other technologies render them unnecessary. It also completely abolishes any notion of IUOs below the type-checker level of the compiler, which will substantially simplify the compiler implementation. Proposed solution In this proposal, we continue to use the syntax T! for declaring implicitly unwrapped optional values in the following locations: property and variable declarations initializer declarations function and method declarations subscript declarations parameter declarations (with the exception of vararg parameters) However, the appearance of ! at the end of a property or variable declaration’s type no longer indicates that the declaration has IUO type; rather, it indicates that (1) the declaration has optional type, and (2) the declaration has an attribute indicating that its value may be implicitly forced. (No human would ever write or observe this attribute, but we will refer to it as @_autounwrapped.) Such a declaration is referred to henceforth as an IUO declaration. Likewise, the appearance of ! at the end of the return type of a function indicates that the function has optional return type and its return value may be implicitly unwrapped. The use of init! in an initializer declaration indicates that the initializer is failable and the result of the initializer may be implicitly unwrapped. In both of these cases, the @_autounwrapped attribute is attached to the declaration. A reference to an IUO variable or property prefers to bind to an optional, but may be implicitly forced (i.e. converted to the underlying type) when being type-checked; this replicates the current behavior of a declaration with IUO type. Likewise, the result of a function application or initialization where the callee is a reference to an IUO function declaration prefers to retain its optional type, but may be implicitly forced if necessary. If the expression can be explicitly type checked with a strong optional type, it will be. However, the type checker will fall back to forcing the optional if necessary. The effect of this behavior is that the result of any expression that refers to a value declared as T! will either have type T or type T?. For example, in the following code: let x: Int! = 5 let y = x let z = x + 0 … x is declared as an IUO, but because the initializer for y type checks correctly as an optional, y will be bound as type Int?. However, the initializer for z does not type check with x declared as an optional (there’s no overload of + that takes an optional), so the compiler forces the optional and type checks the initializer as Int. This model is more predictable because it prevents IUOs from propagating implicitly through the codebase, and converts them to strong optionals, the safer option, by default. An IUO variable may still be converted to a value with non-optional type, through either evaluating it in a context which requires the non-optional type, explicitly converting it to a non-optional type using the as operator, binding it to a variable with explicit optional type, or using the force operator (!). Because IUOs are an attribute on declarations rather than on types, the ImplicitlyUnwrappedOptional type, as well as the long form ImplicitlyUnwrappedOptional&lt;T&gt; syntax, is removed. Types with nested IUOs are no longer allowed. This includes types such as [Int!] and (Int!, Int!). Type aliases may not have IUO information associated with them. Thus the statement typealias X = Int! is illegal. This includes type aliases resulting from imported typedef statements. For example, the Objective-C type declaration typedef void (^ViewHandler)(NSView *); … is imported as the Swift type declaration typealias ViewHandler = (NSView?) -&gt; () Note that the parameter type is NSView?, not NSView!. Examples func f() -&gt; Int! { return 3 } // f: () -&gt; Int?, has IUO attribute let x1 = f() // succeeds; x1: Int? = 3 let x2: Int? = f() // succeeds; x2: Int? = .some(3) let x3: Int! = f() // succeeds; x3: Int? = .some(3), has IUO attribute let x4: Int = f() // succeeds; x4: Int = 3 let a1 = [f()] // succeeds; a: [Int?] = [.some(3)] let a2: [Int!] = [f()] // illegal, nested IUO type let a3: [Int] = [f()] // succeeds; a: [Int] = [3] func g() -&gt; Int! { return nil } // f: () -&gt; Int?, has IUO attribute let y1 = g() // succeeds; y1: Int? = .none let y2: Int? = g() // succeeds; y2: Int? = .none let y3: Int! = g() // succeeds; y3: Int? = .none, has IUO attribute let y4: Int = g() // traps let b1 = [g()] // succeeds; b: [Int?] = [.none] let b2: [Int!] = [g()] // illegal, nested IUO type let b3: [Int] = [g()] // traps func p&lt;T&gt;(x: T) { print(x) } p(f()) // prints &quot;Optional(3)&quot;; p is instantiated with T = Int? if let x5 = f() { // executes, with x5: Int = 3 } if let y5 = g() { // does not execute } Impact on existing code These changes will break existing code; as a result, I would like for them to be considered for inclusion in Swift 3. This breakage will come in two forms: Variable bindings which previously had inferred type T! from their binding on the right-hand side will now have type T?. The compiler will emit an error at sites where those bound variables are used in a context that demands a non-optional type and suggest that the value be forced with the ! operator. Explicitly written nested IUO types (like [Int!]) will have to be rewritten to use the corresponding optional type ([Int?]) or non-optional type ([Int]) depending on what’s more appropriate for the context. However, most declarations with non-nested IUO type will continue to work as they did before. Unsugared use of the ImplicitlyUnwrappedOptional type will have to be replaced with the postfix ! notation. It will still be possible to declare IUO properties, so the following deferred initialization pattern will still be possible: struct S { var x: Int! init() {} func initLater(x someX: Int) { x = someX } } I consider the level of breakage resulting from this change acceptable. Types imported from Objective-C APIs change frequently as those APIs gain nullability annotations, and that occasionally breaks existing code too; this change will have similar effect. Alternatives considered Continue to allow IUO type, but don’t propagate it to variables and intermediate values without explicit type annotation. This resolves the issue of IUO propagation but still allows nested IUO types, and doesn’t address the complexity of handling IUOs below the Sema level of the compiler. Remove IUOs completely. Untenable due to the prevalence of deferred initialization and unannotated Objective-C API in today’s Swift ecosystem.",
    "url": "http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html",
    "relUrl": "/docs/2019-08-26-0054-abolish-iuo.html"
  },
  "54": {
    "id": "54",
    "title": "SE-0055 Make unsafe pointer nullability explicit using Optional",
    "content": "Make unsafe pointer nullability explicit using Optional Proposal: SE-0055 Author: Jordan Rose Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#1878 Introduction In Objective-C, pointers (whether to objects or to a non-object type) can be marked as nullable or nonnull, depending on whether the pointer value can ever be null. In Swift, however, there is no such way to make this distinction for pointers to non-object types: an UnsafePointer&lt;Int&gt; might be null, or it might never be. We already have a way to describe this: Optionals. This proposal makes UnsafePointer&lt;Int&gt; represent a non-nullable pointer, and UnsafePointer&lt;Int&gt;? a nullable pointer. This also allows us to preserve information about pointer nullability available in header files for imported C and Objective-C APIs. swift-evolution thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160314/012918.html Motivation Today, UnsafePointer and friends suffer from a problem inherited from C: every pointer value could potentially be null, and code that works with pointers may or may not expect this. Failing to take the null pointer case into account can lead to assertion failures or crashes. For example, pretty much every operation on UnsafePointer itself requires a valid pointer (reading, writing, and initializing the pointee or performing arithmetic operations). Fortunately, when a type has a single invalid value for which no operations are valid, Swift already has a solution: Optionals. Applying this to pointer types makes things very clear: if the type is non-optional, the pointer will never be null, and if it is optional, the developer must take the “null pointer” case into account. This clarity has already been appreciated in Apple’s Objective-C headers, which include nullability annotations for all pointer types (not just object pointers). This change also allows developers working with pointers to take advantage of the many syntactic conveniences already built around optionals. For example, the standard library currently has a helper method on UnsafeMutablePointer called _setIfNonNil; with “optional pointers” this can be written simply and clearly: ptr?.pointee = newValue Finally, this change also reduces the number of types that conform to NilLiteralConvertible, a source of confusion for newcomers who (reasonably) associate nil directly with optionals. Currently the standard library includes the following NilLiteralConvertible types: Optional ImplicitlyUnwrappedOptional (subject of a separate proposal by Chris Willmore) _OptionalNilComparisonType (used for optionalValue == nil) UnsafePointer UnsafeMutablePointer AutoreleasingUnsafeMutablePointer OpaquePointer plus these Objective-C-specific types: Selector NSZone (only used to pass nil in Swift) All of the italicized types would drop their conformance to NilLiteralConvertible; the “null pointer” would be represented by a nil optional of a particular type. Proposed solution Have the compiler assume that all values with pointer type (the italicized types listed above) are non-null. This allows the representation of Optional.none for a pointer type to be a null pointer value. Drop NilLiteralConvertible conformance for all pointer types. Teach the Clang importer to treat _Nullable pointers as Optional (and _Null_unspecified pointers as ImplicitlyUnwrappedOptional). Deal with the fallout, i.e. adjust the compiler and the standard library to handle this new behavior. Test migration and improve the migrator as necessary. This proposal does not include the removal of the NilLiteralConvertible protocol altogether; besides still having two distinct optional types, we’ve seen people wanting to use nil for their own types (e.g. JSON values). (Changing this in the future is not out of the question; it’s just out of scope for this proposal.) Detailed design API Changes Conformance to NilLiteralConvertible is removed from all types except Optional, ImplicitlyUnwrappedOptional, and _OptionalNilComparisonType, along with the implementation of init(nilLiteral:). init(bitPattern: Int) and init(bitPattern: UInt) on all pointer types become failable; if the bit pattern represents a null pointer, nil is returned. Should SE-0016 be accepted, the init(bitPattern:) initializers on Int and UInt will be changed to take optional pointers. New initializers will be added to all pointer types to convert between optional pointer types (see below). UnsafeBufferPointer’s baseAddress property becomes nullable, along with its initializer parameter (see below). Process.unsafeArgv is a pointer to a null-terminated C array of C strings, so its type changes from UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;&gt; to UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;, i.e. the inner pointer type becomes optional. NSErrorPointer becomes optional: -public typealias NSErrorPointer = AutoreleasingUnsafeMutablePointer&lt;NSError?&gt; +public typealias NSErrorPointer = AutoreleasingUnsafeMutablePointer&lt;NSError?&gt;? A number of methods on String that came from NSString now have optional parameters: public func completePathIntoString( - outputName: UnsafeMutablePointer&lt;String&gt; = nil, + outputName: UnsafeMutablePointer&lt;String&gt;? = nil, caseSensitive: Bool, - matchesIntoArray: UnsafeMutablePointer&lt;[String]&gt; = nil, + matchesIntoArray: UnsafeMutablePointer&lt;[String]&gt;? = nil, filterTypes: [String]? = nil ) -&gt; Int { public init( contentsOfFile path: String, - usedEncoding: UnsafeMutablePointer&lt;NSStringEncoding&gt; = nil + usedEncoding: UnsafeMutablePointer&lt;NSStringEncoding&gt;? = nil ) throws { public init( contentsOfURL url: NSURL, - usedEncoding enc: UnsafeMutablePointer&lt;NSStringEncoding&gt; = nil + usedEncoding enc: UnsafeMutablePointer&lt;NSStringEncoding&gt;? = nil ) throws { public func linguisticTags( in range: Range&lt;Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions = [], orthography: NSOrthography? = nil, - tokenRanges: UnsafeMutablePointer&lt;[Range&lt;Index&gt;]&gt; = nil + tokenRanges: UnsafeMutablePointer&lt;[Range&lt;Index&gt;]&gt;? = nil ) -&gt; [String] { NSZone’s no-argument initializer is gone. (It probably should have been removed already as part of the Swift 3 naming cleanup.) A small regression: optional pointers can no longer be passed using withVaList because it would require a conditional conformance to the CVarArg protocol. For now, using unsafeBitCast to reinterpret the optional pointer as an Int is the best alternative; Int has the same C variadic calling conventions as a pointer on all supported platforms. Conversion between pointers Currently each pointer type has initializers of this form: init&lt;OtherPointee&gt;(_ otherPointer: UnsafePointer&lt;OtherPointee&gt;) This simply makes a pointer with a different type but the same address as otherPointer. However, in making pointer nullability explicit, this now only converts non-nil pointers to non-nil pointers. In my experiments, this has led to this idiom becoming very common: // Before: let untypedPointer = UnsafePointer&lt;Void&gt;(ptr) // After: let untypedPointer = ptr.map(UnsafePointer&lt;Void&gt;.init) // Usually the pointee type is actually inferred: foo(ptr.map(UnsafePointer.init)) I consider this a bit more difficult to understand than the original code, at least at a glance. We should therefore add new initializers of the following form: init?&lt;OtherPointee&gt;(_ otherPointer: UnsafePointer&lt;OtherPointee&gt;?) { guard let nonnullPointer = otherPointer else { return nil } self.init(nonnullPointer) } The body is for explanation purposes only; we’ll make sure the actual implementation does not require an extra comparison. (This would need to be an overload rather than replacing the previous initializer because the “non-null-ness” should be preserved through the type conversion.) Note: It is very likely the existing initializers described here will be renamed (perhaps to init(bitPattern:)). In this case, the new initializers should adopt the same argument labels. UnsafeBufferPointer The type UnsafeBufferPointer represents a bounded typed memory region with no ownership or lifetime semantics; it is made up of a bare typed pointer (its baseAddress) and a length (count) and conforms to Collection. There is also a variant with mutable contents named UnsafeMutableBufferPointer. For a buffer with 0 elements, there’s no need to provide the address of allocated memory, since it can’t be read from. This case is represented as a nil base address and a count of 0. With this proposal, the baseAddress property becomes optional: /// Construct an Unsafe${Mutable}Pointer over the `count` contiguous /// `Element` instances beginning at `start`. - public init(start: Unsafe${Mutable}Pointer&lt;Element&gt;, count: Int) { + /// + /// If `start` is nil, `count` must be 0. However, `count` may be 0 even for + /// a nonzero `start`. + public init(start: Unsafe${Mutable}Pointer&lt;Element&gt;?, count: Int) { - public var baseAddress: Unsafe${Mutable}Pointer&lt;Element&gt; { + public var baseAddress: Unsafe${Mutable}Pointer&lt;Element&gt;? { This does force clients using baseAddress to consider the possibility that the buffer does not represent allocated memory. However, we believe that most clients are either using the Collection conformance and ignoring the baseAddress property, or are immediately passing the pointer (and perhaps also the count) to a C API, most of which accept null pointers with a 0 count. In either case a null pointer should be treated no differently from any other address with a count of 0. This API also allows converting to and from a pair of (UnsafePointer?, Int) without losing information and without needing to explicitly handle the nil case. Here is some data on standard library uses of UnsafeBuffer: Used as Collection: 4 (mostly String operations) Passed to C-style APIs (pointer and length): 1 Explicitly extracting the base address: 3 (all related to C strings) A “use” here is roughly “mentioned at least once in a function body”. Impact on existing code Any code that uses a pointer type (including Selector or NSZone) may be affected by this change. For the most part our existing logic to handle last year’s nullability audit should cover this, but the implementer should test migration of several projects to see what issues might arise. Anecdotally, in migrating the standard library to use this new logic I’ve been quite happy with nullability being made explicit. There are many places where a pointer really can’t be nil. Alternatives considered The primary alternative here would be to leave everything as it is today, with UnsafePointer and friends including the null pointer as one of their normal values. This has obviously worked just fine for nearly two years of Swift, but it is leaving information on the table that can help avoid bugs, and is strange in a language that makes fluent use of Optional. As a fairly major source-breaking change, it is also something that we probably should do sooner rather than later in the language’s evolution. Félix Cloutier also noted that this may prove problematic for porting Swift to a platform where there are no invalid pointer values (usually an embedded platform). However, Chris Lattner thinks this potential future issue should not limit the improvements that can be made to Swift today (especially given the lack of several other features necessary for low-level system programming, such as volatile), and Doug Gregor pointed out that Clang and LLVM have the assumption that “0 is an invalid pointer” hardcoded in many places already. This is not an entirely satisfactory answer, but I agree that we should go ahead with the language change regardless. Alternatives for UnsafeBufferPointer The chosen API change for UnsafeBufferPointer does impose a cost on clients that want to access and use the base address themselves: they need to consider the nil case explicitly, where previously they wouldn’t have had to. We considered several alternatives, including: Using an arbitrary address with proper alignment whenever we would have used nil as a base address. Eliminating nil from the withUnsafeBufferPointer APIs and then making the baseAddress property non-optional; clients that need to deal with nil could use an Optional UnsafeBufferPointer. The ultimate consensus (both on the list and in off-list discussion with the Swift core team) was that neither of these behave well when using UnsafeBufferPointer to interoperate with C APIs, even if we could make withUnsafeBufferPointer. We do eliminate the possibility of using the type system to distinguish between “buffers that may have a null base address” and “buffers known to have a non-null base address”, but we’re expecting that distinction to not be a useful one anyway.",
    "url": "http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html",
    "relUrl": "/docs/2019-08-26-0055-optional-unsafe-pointers.html"
  },
  "55": {
    "id": "55",
    "title": "SE-0056 Allow trailing closures in `guard` conditions",
    "content": "Allow trailing closures in guard conditions Proposal: SE-0056 Author: Chris Lattner Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction and Motivation Swift-evolution thread: “Allow trailing closures in ‘guard’ conditions” The three statements if, while, and guard form a family that all take a rich form of conditions that can include one or more boolean conditions, #available clauses, and let/case pattern bindings. These are described by the condition-clause production in the TSPL reference section and as a stmt-condition in the compiler source code. Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement: if foo { // start of trailing closure, or start of the if body? While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler. As such, we’ve opted keep the parser simple and disallow this. Unrelated to this proposal, a recent patch in Swift 3 greatly improves the error messages in some of the most common cases where a developer accidentally tries to do this. However, while this approach makes sense for if and while statements, it does not make sense for guard: The body of a guard statement is delineated by the else keyword, so there is no ambiguity. A brace is always the start of a trailing closure. From a historical perspective, the current situation was an oversight. An earlier design for guard did not include the else keyword (it used the unless keyword), and I forgot to eliminate this requirement when we decided to resyntax it to guard/else. Proposed solution The solution is simple: allow trailing closures in guard bodies. As one example, it would allow this example (adapted from the “Advanced Swift” book) to compile correctly: guard let object = someSequence.findElement { $0.passesTest() } else { return } Detailed design The compiler change to do this is extremely straight-forward, the patch is available here. Impact on existing code There is no impact on existing code. This only makes formerly invalid code start being accepted. Alternatives considered There are four primary alternatives: Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of if and while and that inconsistency would be confusing. On the other hand, I am arguing that this is an arbitrary restriction. Expand the scope of if and while statements: Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on if and while statements as well. While this could be interesting, it raises several ambiguity questions, which makes it non-obvious that it is the right thing to do. In any case, since this expansion would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal. Change the syntax of guard: I only list this for completeness, but we could eliminate the else keyword, making guard more similar to if and while. I personally think that this is a really bad idea though: the guard statement is not a general unless statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe. I feel that it has stood the test of time well since then. Change the syntax of if and while: Brent Royal-Gordon points out that we could change if and while to use a keyword after their condition as well, e.g.: if expr then { while expr do { for elem in expr do { code } switch expr among { code } This would make it easy to support trailing closures in if and while, but it has some disadvantages: it takes a new keyword (then), it diverges unnecessarily from the rest of the C family of languages. Rationale On April 20, 2016, the core team decided to reject this proposal. The core team felt that the benefits from this change were outweighed by the inconsistency it would introduce with if and while.",
    "url": "http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html",
    "relUrl": "/docs/2019-08-26-0056-trailing-closures-in-guard.html"
  },
  "56": {
    "id": "56",
    "title": "SE-0057 Importing Objective-C Lightweight Generics",
    "content": "Importing Objective-C Lightweight Generics Proposal: SE-0057 Author: Doug Gregor Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction Objective-C’s lightweight generics feature allows Objective-C classes to be parameterized on the types they work with, similarly to Swift’s generics syntax. Their adoption in Foundation’s collection classes allow Objective-C APIs to be bridged more effectively into Swift. For example, an NSArray&lt;NSString *&gt; * bridges to [String] rather than the far-weaker [AnyObject]. However, parameterized Objective-C classes lose their type parameters when they are imported into Swift, so uses of type parameters outside of bridged, typed collections (NSArray, NSDictionary, NSSet) don’t benefit in Swift. This proposal introduces a way to import the type parameters of Objective-C classes into Swift. Swift-evolution thread: here Motivation Cocoa and Cocoa Touch include a number of APIs that have adopted Objective-C lightweight generics to improve static type safety and expressiveness. However, because the type parameters are lost when these APIs are imported into Swift, they are effectively less type safe in Swift than in Objective-C, a situation we clearly cannot abide. This proposal aims to improve the projection of these Objective-C APIs in Swift. Proposed solution A parameterized class written in Objective-C will be imported into Swift as a generic class with the same number of type parameters. The bounds on the type parameters in Objective-C will be translated into requirements on the generic type parameters in Swift: The generic type parameters in Swift will always be class-bound, i.e., the generic class will have the requirement T : AnyObject. If the bound includes a class type (e.g., T : NSValue * in Objective-C), the generic Swift class will have the corresponding superclass requirement (T : NSValue). If the bound includes protocol qualification (e.g., T : id&lt;NSCopying&gt; in Objective-C), each protocol bound is turned into a conformance requirement (T : NSCopying) on the generic Swift class. The following Objective-C code: @interface MySet&lt;T : id&lt;NSCopying&gt;&gt; : NSObject -(MySet&lt;T&gt; *)unionWithSet:(MySet&lt;T&gt; *)otherSet; @end @interface MySomething : NSObject - (MySet&lt;NSValue *&gt; *)valueSet; @end will be imported as: class MySet&lt;T : NSCopying&gt; : NSObject { func unionWithSet(otherSet: MySet&lt;T&gt;) -&gt; MySet&lt;T&gt; } class MySomething : NSObject { func valueSet() -&gt; MySet&lt;NSValue&gt; } Importing unspecialized types When importing an unspecialized Objective-C type into Swift, we will substitute the bounds for the type arguments. For example: @interface MySomething (ObjectSet) - (MySet *)objectSet; // note: no type arguments to MySet @end will be imported as: extension MySomething { func objectSet() -&gt; MySet&lt;NSCopying&gt; // note: uses the type bound } Restrictions on uses of Objective-C parameterized classes While the Swift and Objective-C generics systems look similar on the surface, they use fundamentally different semantic models. Specifically, Objective-C lightweight generics are based on type erasure, so we cannot in general recover the type arguments from the metaclass of an Objective-C parameterized class (i.e., because MySet, MySet&lt;NSString *&gt;, and MySet&lt;NSNumber *&gt; all share a metaclass). This leads to several restrictions: Downcasting to an instance or metatype of a parameterized Objective-C class is inherently uncheckable, so we place limits on such casts. For example, let obj: AnyObject = ... if let set1 = obj as? MySet&lt;NSCopying&gt; { // okay: every MySet is a MySet&lt;NSCopying&gt; by construction, so // we&#39;re just checking that this is a &#39;MySet&#39;. } if let set2 = obj as? MySet&lt;NSNumber&gt; { // error: conditional cast to specialized Objective-C instance // doesn&#39;t check type argument &#39;NSNumber&#39; } let set3 = obj as! MySet&lt;NSNumber&gt; // okay: we assert that it is safe if let set4 = obj as? MySet&lt;NSCopying&gt; { let set5 = set4 as! MySet&lt;NSNumber&gt; // here&#39;s how to get a MySet&lt;NSNumber&gt; } By default, extensions of parameterized Objective-C classes cannot reference the type parameters in any way. For example: extension MySet { func someNewMethod(x: T) { ... } // error: cannot use `T`. } Opting in to type argument discovery Some Objective-C parameterized classes do carry information about their type arguments. When this is the case, it is possible to lift some of the restrictions described in the above section. There are two distinct cases: Abstract parameterized classes whose concrete subclasses are not parameterized: NSLayoutAnchor is one such example: it is parameterized on the anchor type, but there is a fixed set of such anchor types that are represented by subclasses: NSLayoutXAxisAnchor subclasses NSLayoutAnchor&lt;NSLayoutXAxisAnchor *&gt;, NSLayoutDimension subclasses NSLayoutAnchor&lt;NSLayoutDimension *&gt;, etc. Therefore, the type arguments can be recovered by looking at the actual metaclass. Parameterized classes that store their type arguments in instances: GKComponentSystem is one such example: it is parameterized on the component type it stores, but it’s initializer (-initWithComponentClass:) requires one to pass the component type’s metaclass. Therefore, every instance of GKComponentSystem knows its type arguments. A parameterized Objective-C class can opt in to providing information about its type argument by implementing a method classForGenericArgumentAtIndex: either as a class method (for the first case described above) or as an instance method (for the second case described above). The method returns the metaclass for the type argument at the given, zero-based index. For example, NSLayoutAnchor would provide a class method classForGenericArgumentAtIndex: that must be implemented by each of its subclasses: @interface NSLayoutAnchor&lt;AnchorType&gt; (SwiftSupport) /// Note: must be implemented by each subclass +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index; @end @implementation NSLayoutAnchor +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index { NSAssert(false, @&quot;subclass must override +classForGenericArgumentAtIndex:&quot;); } @end @implementation NSLayoutXAxisAnchor (SwiftSupport) +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index { return [NSLayoutXAxisAnchor class]; } @end @implementation NSLayoutYAxisAnchor (SwiftSupport) +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index { return [NSLayoutYAxisAnchor class]; } @end @implementation NSLayoutDimension (SwiftSupport) +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index { return [NSLayoutDimension class]; } @end On the other hand, GKComponentSystem would implement an instance method classForGenericArgumentAtIndex:: @interface GKComponentSystem&lt;ComponentType : GKComponent *&gt; (SwiftSupport) - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index; @end @implementation GKComponentSystem (SwiftSupport) - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index { return self.componentClass; } @end Note that many parameterized Objective-C classes cannot provide either of these methods, because they don’t carry enough information in their instances. For example, an NSMutableArray has no record of what the element type of the array is intended to be. However, when a parameterized class does provide this information, we can lift some of the restrictions from the previous section: If the parameterized class provides an instance method classForGenericArgumentAtIndex:, the extension can use the type arguments in its instance methods, including accessors for instance properties and subscripts. For example: extension GKComponentSystem { var reversedComponents: [ComponentType] { return components.reversed() } static func notifyComponents(components: [ComponentType]) { // error: cannot use `ComponentType` in a static method } } If the parametized class provides a class method classForGenericArgumentAtIndex:, the extension can use type arguments anywhere. extension NSLayoutAnchor { func doSomething(x: AnchorType) { ... } class func doSomethingClassy(x: AnchorType) { ... } } Subclassing parameterized Objective-C classes from Swift When subclassing a parameterized Objective-C class from Swift, the Swift compiler will define +classForGenericArgumentAtIndex: and -classForGenericArgumentAtIndex:. The Swift compiler has the complete type metadata required, because it is stored in the (Swift) type metadata, so these definitions will be correct. For example: class Employee : NSObject { ... } class EmployeeArray : NSMutableArray&lt;Employee&gt; { // +[EmployeeArray classForGenericArgumentAtIndex:] always returns // ObjC type metadata for Employee } class MyMutableArray&lt;T : AnyObject&gt; : NSMutableArray&lt;T&gt; { // +[MyMutableArray classForGenericArgumentAtIndex:] returns the // ObjC type metadata for T, extracted from the Swift metatype for // `self`. } Impact on existing code In Swift 2, parameterized Objective-C classes are imported as non-parameterized classes. Importing them as parameterized classes will break any existing references to the affecting APIs. There are a handful of cases where type inference may paper over the problems: let array: NSArray = [&quot;hello&quot;, &quot;world&quot;] // okay, infer NSArray&lt;NSString&gt; // old var mutArray = NSMutableArray() // error: need type arguments for NSMutableArray A migrator could introduce the type bounds as arguments, e.g., NSArray would get migrated to NSArray&lt;AnyObject&gt;. It is not the best migration—many developers would likely want to tighten up the bounds to improve their Swift code—but it should migrate existing code. Alternatives considered The only major alternative design involves bringing type erasure into the Swift generics system as an alternative implementation. It would lift the restrictions on extensions of parameterized Objective-C classes by treating type parameters in such contexts as the type bounds: extension MySet { func someNewMethod(x: T) { ... } // okay: `T` is treated like `NSCopying` } Doing so could allow the use of “unspecialized” generic types within Swift, e.g., NSMutableArray with no type bounds (possibly spelled NSMutableArray&lt;*&gt;), which would more accurately represent Objective-C semantics in Swift. However, doing so comes at the cost of having two incompatible generics models implemented in Swift, which produces both a high conceptual burden as well as a high implementation cost. The proposed solution implies less implementation cost and puts the limitations on what one can express when working with parameterized Objective-C classes without fundamentally changing the Swift model.",
    "url": "http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html",
    "relUrl": "/docs/2019-08-26-0057-importing-objc-generics.html"
  },
  "57": {
    "id": "57",
    "title": "SE-0058 Allow Swift types to provide custom Objective-C representations",
    "content": "Allow Swift types to provide custom Objective-C representations Proposal: SE-0058 Authors: Russ Bishop, Doug Gregor Review Manager: Joe Groff Status: Deferred Decision Notes: Rationale Introduction Provide an ObjectiveCBridgeable protocol that allows a Swift type to control how it is represented in Objective-C by converting into and back from an entirely separate @objc type. This frees library authors to create truly native Swift APIs while still supporting Objective-C. Swift-evolution thread: [Idea] ObjectiveCBridgeable Motivation There is currently no good way to define a Swift-y API that makes use of generics, enums with associated values, structs, protocols with associated types, and other Swift features while still exposing that API to Objective-C. This is especially prevelent in a mixed codebase. Often an API must be dumbed-down or Swift features eschewed because rewriting the entire codebase is impractical and Objective-C code must be able to call the new Swift code. This results in a situation where new code or refactored code adopts an Objective-C compatible API which is compromised, less type safe, and isn’t as nice to work with as a truly native Swift API. The cascading effect is even worse because when the last vestiges of Objective-C have been swept away, you’re left with a mountain of Swift code that essentially looks like a direct port of Objective-C code and doesn’t take advantage of any of Swift’s modern features. For framework and library authors it presents an awful choice: Write mountains of glue code to convert between Swift and Objective-C versions of your types. Write your shiny new framework in Swift, but in an Objective-C style using only @objc types. Write your shiny new framework in Objective-C. Choice #1 is not practical in the real world with ship dates, resulting in most teams choosing #2 or #3. Proposed Solution Today you can adopt the private protocol _ObjectiveCBridgeable and when a bridged collection (like Array &lt;–&gt; NSArray) is passed between Swift and Objective-C, Swift will automatically call the appropriate functions to control the way the type bridges. This allows a Swift type to have a completely different representation in Objective-C. The solution proposed is to expose a new protocol ObjectiveCBridgeable and have the compiler generate the appropriate Objective-C bridging thunks for any function or property of an @objc type, not just for values inside collections. ObjectiveCBridgeable Protocol /// A type adopting `ObjectiveCBridgeable` will be exposed /// to Objective-C as the type `ObjectiveCType` (or one of its /// subclasses). public protocol ObjectiveCBridgeable { /// The `@objc` class (or base class) type /// representing `Self` in Objective-C. associatedtype ObjectiveCType : AnyObject /// Returns `true` iff instances of `Self` can be converted to /// Objective-C. Even if this property returns `true`, a given /// instance of `Self.ObjectiveCType` may, or may not, convert /// successfully to `Self`. /// /// A default implementation returns `true`. If a Swift type is /// generic and should only be bridged for some type arguments, /// provide your own implementation that returns `false` for /// non-bridged type parameters. /// /// struct Foo&lt;T&gt;: ObjectiveCBridgeable { /// static var isBridgedToObjectiveC: Bool { /// return !(T is NonBridgedType) /// } /// } /// static var isBridgedToObjectiveC: Bool { get } /// Convert `self` to an instance of /// `ObjectiveCType` (or one of its subclasses) @warn_unused_result func bridgeToObjectiveC() -&gt; ObjectiveCType /// Attempt to construct a value of the `Self` type from /// an Objective-C object of the bridged class type /// /// This bridging initializer is used for bridging when /// interoperating with Objective-C code, either in the body of an /// Objective-C thunk or when calling Objective-C code. /// /// - note: This initializer should eagerly perform the /// conversion without defering any work for later, /// returning `nil` if the conversion fails. init?(bridgedFromObjectiveC: ObjectiveCType) /// Bridge from an Objective-C object of the bridged class type to a /// value of the Self type. /// /// This bridging initializer is used for unconditional bridging when /// interoperating with Objective-C code, either in the body of an /// Objective-C thunk or when calling Objective-C code, and may /// defer complete checking until later. For example, when bridging /// from `NSArray` to `Array&lt;Element&gt;`, we can defer the checking /// for the individual elements of the array. /// /// - parameter unconditionallyBridgedFromObjectiveC: /// The Objective-C object from which we are bridging. /// This optional value will only be `nil` in cases where /// an Objective-C method has returned a `nil` despite being marked /// as `_Nonnull`/`nonnull`. In most such cases, bridging will /// generally force the value immediately. However, this gives /// bridging the flexibility to substitute a default value to cope /// with historical decisions, e.g., an existing Objective-C method /// that returns `nil` for an &quot;empty result&quot; rather than (say) an /// empty array. In such cases, when `nil` does occur, the /// implementation of `Swift.Array`&#39;s conformance to /// `ObjectiveCBridgeable` will produce an empty array rather than /// dynamically failing. /// /// A default implementation calls `init?(bridgedFromObjectiveC:)` /// and aborts if the conversion fails. init(unconditionallyBridgedFromObjectiveC: ObjectiveCType?) } public extension ObjectiveCBridgeable { static var isBridgedToObjectiveC: Bool { return true } init(unconditionallyBridgedFromObjectiveC source: ObjectiveCType?) { self.init(bridgedFromObjectiveC: source!)! } } Detailed Design Expose the protocol ObjectiveCBridgeable. This protocol will replace the old private protocol _ObjectiveCBridgeable. When generating an Objective-C interface for an @objc class type: When a function contains parameters or return types that are @nonobjc but those types adopt ObjectiveCBridgeable: Create @objc thunks that call the Swift functions but substitute the corresponding ObjectiveCType. The thunks will call the appropriate protocol functions to perform the conversion. If any @nonobjc types do not adopt ObjectiveCBridgeable, the function itself is not exposed to Objective-C (current behavior). Swift Standard library types like String, Array, Dictionary, and Set will adopt the new protocol, thus demoting their bridging behavior from magic to regular behavior. A clang attribute will be provided to indicate which Swift type bridges to an Objective-C class. A convenience SWIFT_BRIDGED() macro will be provided. If the ObjectiveCType is defined in Objective-C, the programmer should annotate the @interface declaration with SWIFT_BRIDGED(&quot;SwiftTypeName&quot;). If the ObjectiveCType is defined in Swift, it must be an @objc class type. The compiler will annotate the generated bridging header with SWIFT_BRIDGED() automatically. The Swift type and ObjectiveCType must be defined in the same module. If the ObjectiveCType is defined in Objective-C then it must come from the same-named Objective-C module. Ambiguity and Casting The compiler generates automatic thunks only when there is no ambiguity, while explicit casts and bridged collection types always use the protocol implementation. For ObjectiveCTypes defined in Objective-C: Omitting the SWIFT_BRIDGED() attribute causes Objective-C APIs using the ObjectiveCType to import without automatic bridging. There are no implicit conversions from the Swift type to its Objective-C bridged type; if an Objective-C parameter imports as SomeObjectiveCType, attempting to pass Foo&lt;T&gt; is an error. However a user may explicitly cast to an ObjectiveCBridgeable Swift type (eg: funcTakingObjCObject(Foo&lt;T&gt; as! SomeObjectiveCType). Bridged collection types will still observe the protocol conformance if cast to a Swift type (eg: NSArray as? [Int] will call the ObjectiveCBridgeable implementation on Array, which itself will call the implementation on Int for the elements) A Swift type may bridge to an Objective-C base class then provide different subclass instances at runtime, but no other Swift type may bridge to that base class or any of its subclasses. The compiler should emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType. An exception to these rules exists for trivially convertable built-in types like NSInteger &lt;–&gt; Int when specified outside of a bridged collection type. In those cases the compiler will continue the existing behavior, bypassing the ObjectiveCBridgeable protocol. The effect is that types like Int will not bridge to NSNumber unless contained inside a collection type (see BuiltInBridgeable below). Resiliance Adding or removing conformance to ObjectiveCBridgeable, or changing the ObjectiveCType is a fragile (breaking) change. Example Here is an enum with associated values that adopts the protocol and bridges by converting itself into an object representation. Note: The ways you can represent the type in Objective-C are endless; I’d prefer not to bikeshed that particular bit :) The Objective-C type is merely one representation you could choose to allow getting and setting the enum’s associated values enum Fizzer { case Case1(String) case Case2(Int, Int) } extension Fizzer: ObjectiveCBridgeable { func bridgeToObjectiveC() -&gt; ObjCFizzer { let bridge = ObjCFizzer() switch self { case let .Case1(x): bridge._case1 = x case let .Case2(x, y): bridge._case2 = (x, y) } return bridge } init?(bridgedFromObjectiveC source: ObjCFizzer) { if let stringValue = source._case1 { self = Fizzer.Case1(stringValue) } else if let tupleValue = source._case2 { self = Fizzer.Case2(tupleValue.0, tupleValue.1) } else { return nil } } } class ObjCFizzer: NSObject { private var _case1: String? private var _case2: (Int, Int)? var fizzyString: String? { return _case1 } var fizzyX: Int? { return _case2?.0 } var fizzyY: Int? { return _case2?.1 } func setTupleCase(x: Int, y: Int) { _case1 = nil _case2 = (x, y) } func setStringCase(string: String) { _case1 = string _case2 = nil } } Impact on existing code None. There are no breaking changes and adoption is opt-in. Alternatives considered The main alternative, as stated above, is not to adopt Swift features that cannot be expressed in Objective-C. The less feasible alternative is to provide bridging manually by segmenting methods and properties into @objc and @nonobjc variants, then manually converting at all the touch points. In practice I don’t expect this to be very common due to the painful overhead it imposes. Developers are much more likely to avoid using Swift features (even subconsciously). Ambiguity The idea of allowing multiple Swift types to bridge to the same Objective-C type was discussed. It should technically be possible since the same-module rule wouldn’t allow the shape of an imported API to vary based on which modules you imported. The compiler could skip generating the thunks in this case and the user would need to provide @objc equivalent members that performed casting to resolve the ambiguity. However there doesn’t appear to be a convincing case to support such complex behavior so in the interests of simplicity this proposal keeps this kind of ambiguity an error. It can always be relaxed in the future if desired. BuiltInBridgeable On the mailing list the idea of a protocol to supersede ObjectiveCBridgeable for built-in types like Int was brought up but not considered essential for this proposal. (The protocol would be decorative only, not having any functions or properties). These types are special because they bridge differently inside collections vs outside. The compiler already has magic knowledge of these types and I don’t anticipate the list of types will ever get any longer. The only benefit of a BuiltInBridgeable protocol would be to explicitly declare which types have this “magic”. This can always be implemented in the future if it is desired. Future Directions Conditional Conformance It is intended that when and if Swift 3 adopts conditional protocol conformance that the standard library types such as Array and Dictionary will declare conditional conformance to ObjectiveCBridgeable if their element types are ObjectiveCBridgeable (with explicitly declared conformance for built-ins like Int). Rationale On April 12, 2016, the core team decided to defer this proposal from Swift 3. We agree that it would be valuable to give library authors the ability to bridge their own types from Objective-C into Swift using the same mechanisms as Foundation. However, we lack the confidence and implementation experience to commit to _ObjectiveCBridgeable in its current form as public API. In its current form, as its name suggests, the protocol was designed to accommodate the specific needs of bridging Objective-C object types to Swift value types. In the future, we may want to bridge with other platforms, including C++ value types or other object systems such as COM, GObject, JVM, or CLR. It isn’t clear at this point whether these would be served by a generalization of the existing mechanism, or by bespoke bridging protocols tailored to each case. This is a valuable area to explore, but we feel that it is too early at this point to accept our current design as public API.",
    "url": "http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html",
    "relUrl": "/docs/2019-08-26-0058-objectivecbridgeable.html"
  },
  "58": {
    "id": "58",
    "title": "SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly",
    "content": "Update API Naming Guidelines and Rewrite Set APIs Accordingly Proposal: SE-0059 Author: Dave Abrahams Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Introduction When SE-0006, Apply API Guidelines to the Standard Library was proposed, the lack of an acceptable naming convention for some mutating/nonmutating method pairs meant that the APIs of SetAlgebra, Set&lt;T&gt; and OptionSet&lt;T&gt; were not adjusted accordingly. This proposal remedies both problems by: establishing the necessary naming conventions and applying the corresponding changes to the Set APIs. A few other issues in these APIs are cleaned up along the way (details below). For reference as you read this proposal, you may be interested in the following links: Updated API guidelines (corresponding diff) Updated SetAlgebra API (corresponding diff) Fixing the API Guidelines The guidelines say that method calls with side-effects should read as verb phrases, and those without side-effects should read as noun phrases. They also describe how to name mutating/nonmutating method pairs accordingly: starting with the assumption that the fundamental operation can be described by a verb, we are to use the ed or ing suffix to create a noun phrase for the nonmutating operation. The problem is that in some cases, the operation’s only natural description is as a noun. Consider the union of two sets, or the remainder when dividing two integers. In these cases, we have a suitable name for the non-mutating operation, and we need to create a name that reads as a verb phrase for its mutating counterpart. The proposed solution is to use the form prefix, so that x.formUnion(y) is equivalent to x = x.union(y) Changes to the Set APIs This proposal changes APIs of the SetAlgebra protocol, which propagate into the library’s models of those protocols, Set&lt;T&gt; and OptionSet&lt;T&gt;. Most of the changes amount to a straightforward application of the new guidelines. Usage Example: x = y.union(z) y.formUnion(z) // y = y.union(z) x = y.intersection(z) y.formIntersection(z) // y = y.intersection(z) x = y.subtracting(z) y.subtract(z) // y = y.subtracting(z) x = y.symmetricDifference(z) y.formSymmetricDifference(z) // y = y.symmetricDifference(z) if x.contains(c) { ... } y.insert(a) y.remove(b) y.update(with: c) if x.isSubset(of: y) &amp;&amp; y.isStrictSubset(of: z) &amp;&amp; z.isDisjoint(with: x) &amp;&amp; y.isSuperset(of: z) &amp;&amp; x.isStrictSuperset(of: z) &amp;&amp; !y.isEmpty { ... } Other Changes There are a few notable changes to SetAlgebra that go beyond simple renaming: The concept of elements subsuming or being disjoint with other elements has been dropped from the documentation, along with the corresponding static methods of SetAlgebra. The idea was only used in describing the semantics of the remove method, but we have found a simpler way to describe those semantics. The semantics of remove’s return value have changed slightly, to make them more useful for OptionSets. When e is a “compound option” with several bits set in its rawValue, and option set s has a strict subset of those bits set in its raw value, s.remove(e) no longer returns nil. Instead, it returns s.intersection(e). This change only affects OptionSet, not Set. The semantics of someSet.insert(newMember) method have been changed slightly, so that if newMember was already a member of someSet, it has no effect. This change in behavior is unnoticeable under most circumstances, but can be observed if equal Element instances can be distinguished. For example, when Element is a class, instances may be distinguished using the === operator. The new behavior matches that of NSMutableSet.insert, and is also likely to be more efficient. Users needing the old behavior can always use the new update(with:) method, described below. In practice this change only affects Set, not OptionSet. someSet.insert(newMember) now returns a (discardable) pair containing an indication of whether the insertion took place and the Element equal to newMember that is a member of the set after the insertion. This change is an expression of the principle that the library shouldn’t discard potentially useful and information that may have a non-trivial cost to compute. A new update(with: newMember) API was added, to provide the previous unconditional insertion semantics of the insert API. Detailed Changes You can follow this link to see exactly how SetAlgebra has changed. As noted earlier, all other API changes proposed here are a consequence of applying exactly the same changes to Set and OptionSet. Impact on existing code Like all renamings, this is a source-breaking change that can be largely automated by a migrator. To avoid any semantic change one could consider automatically migrating uses of someSet.insert(newMember) to someSet.update(with: newMember), though the chances that a user actually wants the semantics of update(with:_) where she has used insert(_) seem quite slim. The slight change to the result of remove is unlikely to affect anyone, but one could consider issuing a warning during migration to inspect the usage if the returned value from someOptionSet.remove(x) is not discarded. Alternatives considered Naming Guidelines So many alternatives to the form prefix convention were considered that it’s impossible to enumerate them all, but only one candidate stands out as being particularly worthy of mention: the InPlace suffix that was previously used in the standard library. InPlace has one major advantage over form: the fact that it is a suffix benefits grouping in alphabetical catalogs of method names and tools that do code completion by prefix. However, the InPlace suffix has a few major weaknesses: Reading someNounInPlace as a verb phrase requires reading someNoun as a verb. A willingness to pretend that nouns are verbs undermines some basic principles of the API guidelines, which prescribe different uses for different parts of speech. InPlace could more grammatically be applied to a verb, which means you’d really need to read the guidelines carefully to understand how to use it properly. A knowledge of common English doesn’t lead toward properly applying it. InPlace is visually heavyweight when compared to form, and quite distasteful to some. Set API Since operation nouns tend to arise in mathematical domains, we considered avoiding math terms and instead using a more “container-like” API for sets: x = y.insertingContents(of: z) y.insertContents(of: z) x = y.removingContents(notInCommonWith: z) y.removeContents(notInCommonWith: z) x = y.removingContents(inCommonWith: z) y.removeContents(inCommonWith: z) x = y.insertingContents(removingCommonContents: z) y.insertContents(removingCommonContents: z) if x.contains(c) { ... } y.insert(a) y.remove(b) if x.allContentsAreContained(in: y) &amp;&amp; y.allContentsAndMoreAreContained(in: z) &amp;&amp; z.hasNoContentsInCommon(with: x) &amp;&amp; y.containsAllContents(of: z) &amp;&amp; x.containsAllContentsAndMore(of: z) &amp;&amp; !y.isEmpty { ... } Aside from the obvious awkwardness of some of the resulting code, we felt that the loss of the immediately-recognizable semantics of terms-of-art such as union and intersection was too great a cost. We also considered being much more explicit about the semantics of the insert(_) / remove(_) / update(with:) suite of methods, leading to usage like: s.insertIfAbsent(x) s.removeIfPresent(x) s.insert(replacingIfPresent: x) In the end, we thought, the extra words would not add clarity to typical uses of these APIs, where equal set elements are treated as indistinguishable.",
    "url": "http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html",
    "relUrl": "/docs/2019-08-26-0059-updated-set-apis.html"
  },
  "59": {
    "id": "59",
    "title": "SE-0060 Enforcing order of defaulted parameters",
    "content": "Enforcing order of defaulted parameters Proposal: SE-0060 Author: Joe Groff Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1489 Introduction Swift generally follows in the Smalltalk/Objective-C tradition of compound method names with significant, order-sensitive argument labels, but an exception is made for parameters with default arguments. We should remove this exception. Swift-evolution thread: Enforce argument order for defaulted parameters Motivation The ability to reorder arguments with defaulted parameters is a vestige of prerelease builds of Swift that had a more Python-like keyword argument model, allowing arbitrary argument reordering in call sites. Our trend since those early days has been shaped by the Cocoa frameworks, which put a lot of thought into argument labels and ordering as part of API design, to be stricter about argument keywords. This encourages readability as well as predictability, ensuring that the same API call looks similar in different users’ code. We held onto reordering of default arguments as a potentially useful convenience, but few users know this is possible, and many have expressed surprise or disgust that it’s possible. In modern Swift, it’s arguably a corner case that complicates the language for little benefit. Proposed solution I propose that we require the order of arguments used at a call site to always match a function’s declared parameter order, regardless of whether they have default arguments. This makes the language simpler and more consistent. Detailed design A call site must always supply the arguments it provides to a function in their declared order: func requiredArguments(a: Int, b: Int, c: Int) {} func defaultArguments(a: Int = 0, b: Int = 0, c: Int = 0) {} requiredArguments(a: 0, b: 1, c: 2) requiredArguments(b: 0, a: 1, c: 2) // error defaultArguments(a: 0, b: 1, c: 2) defaultArguments(b: 0, a: 1, c: 2) // error Arbitrary labeled parameters with default arguments may still be elided, as long as the specified arguments follow declaration order: defaultArguments(a: 0) // ok defaultArguments(b: 1) // ok defaultArguments(c: 2) // ok defaultArguments(a: 1, c: 2) // ok defaultArguments(b: 1, c: 2) // ok defaultArguments(c: 1, b: 2) // error Impact on existing code Code that takes advantage of reordering will need to be migrated to reorder the arguments. This should be easy to automate. Alternatives considered Matthew Johnson raises an interesting point in favor of our current behavior. For memberwise initializers, it makes sense to allow reordering, because declared member order is not usually significant otherwise: One place where I believe argument re-ordering is useful is with memberwise arguments when you are initializing an instance. Order usually plays no significant role with these arguments which are in some sense similar to assignment statements (which are inherently re-orderable). In fact, I have found myself wishing non-defaulted memberwise initializer parameters were re-orderable at times, especially when using the implicit memberwise initializer for a struct. Source order for property declarations does not always match what makes the most sense at the initialization site (something that was pointed out numerous times during the review of my memberwise init proposal). Erica Sadun notes that defaulted arguments are useful to simulate an ad-hoc sum type parameter: While I do take advantage of this feature, it would be less than honest to point out that a large portion of such usage is to point out how cool the ability is. That said, what I’m really doing is treating them in code like an ad hoc set of enumerated cases with associated values. Perhaps rethinking about them in that light would be better than simply removing them from the language?",
    "url": "http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html",
    "relUrl": "/docs/2019-08-26-0060-defaulted-parameter-order.html"
  },
  "60": {
    "id": "60",
    "title": "SE-0061 Add Generic Result and Error Handling to autoreleasepool()",
    "content": "Add Generic Result and Error Handling to autoreleasepool() Proposal: SE-0061 Author: Timothy J. Wood Review Manager: Dave Abrahams Status: Implemented (Swift 3) Decision Notes: Rationale Bugs: SR-842, SR-1394 Introduction The autoreleasepool function in the standard library does not currently support a return value or error handling, making it difficult and error-prone to pass results or errors from the body to the calling context. Swift-evolution thread: A first call for discussion was made here. Dmitri Gribenko pointed out that adding a generic return type would be useful (first in my premature pull request) and then also here. Jordan Rose pointed out that care was needed to avoid inferring an incorrect return type for the body block, but after testing we confirmed that this is handled correctly by the compiler. Motivation The current signature for autoreleasepool forces the creation of temporary variables to capture any results of the inner computation, as well as any error to eventually throw, in the case they are needed in the calling code. This extra boilerplate clutters up the intent, as well as introduces the risk of accidentally unwrapping a nil value. For example: func doWork() throws -&gt; Result { var result: Result? = nil var error: ErrorProtocol? = nil autoreleasepool { do { ... actual computation which hopefully assigns to result but might not ... } catch let e { error = e } } guard let result = result else { throw error! } return result! } Proposed solution I’d like to propose altering the signature of the standard library autoreleasepool function to allow for a generic return type, as well as allowing a throw of an error: public func autoreleasepool&lt;Result&gt;(@noescape body: () throws -&gt; Result) rethrows -&gt; Result The case above becomes much more clear and less error-prone since the compiler can enforce that exactly one of the error and result are used: func doWork() throws -&gt; Result { return try autoreleasepool { ... actual computation which either returns or throws ... } } As an aside, since this proposes changing the signature already, I would like to further propose changing the argument label from code to body. This seems more in line with the parameter name used in the rest of the standard library, but isn’t central to this proposal. Detailed design The updated standard library function would read: public func autoreleasepool&lt;Result&gt;(@noescape body: () throws -&gt; Result) rethrows -&gt; Result { let pool = __pushAutoreleasePool() defer { __popAutoreleasePool(pool) } return try body() } Impact on existing code No impact expected. Alternatives considered The original request, SR-842 only suggested adding throws, but Dmitri Gribenko pointed out that adding a generic return type would be better. Further discussion raised the question of whether autoreleasepool should behave like a statement in the future, or whether it should behave like an expression by returning the result of the passed in body, with some weighing in on either side. Chris Lattner drew an analogy to forEach and pointed out that @autoreleasepool is a statement in Objective-C, while Jordan Rose found this case more like withCString, or withUnsafeMutablePointer, where having them return a value yields nice simplifications and avoids optional vars. I also explored whether third-party code could wrap autoreleasepool themselves with something like: func autoreleasepool_generic&lt;ResultType&gt;(@noescape code: Void throws -&gt; ResultType) rethrows -&gt; ResultType { var result:ResultType? var error:ErrorProtocol? autoreleasepool { do { result = try code() } catch let e { error = e } } if let result = result { return result } throw error! // Doesn&#39;t compile. } but this doesn’t compile, since in a function with rethrows, only the call to the passed in function that is marked as throws is allowed to throw. Even if it was possible to create a rethrows wrapper from the non-throwing function, it is better to add the safety to the standard library in the first place.",
    "url": "http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html",
    "relUrl": "/docs/2019-08-26-0061-autoreleasepool-signature.html"
  },
  "61": {
    "id": "61",
    "title": "SE-0062 Referencing Objective-C key-paths",
    "content": "Referencing Objective-C key-paths Proposal: SE-0062 Author: David Hart Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1237 Introduction In Objective-C and Swift, key-paths used by KVC and KVO are represented as string literals (e.g., &quot;friend.address.streetName&quot;). This proposal seeks to improve the safety and resilience to modification of code using key-paths by introducing a compiler-checked expression. SE Draft, Review thread Motivation The use of string literals for key paths is extremely error-prone: there is no compile-time assurance that the string corresponds to a valid key-path. In a similar manner to the proposal for the Objective-C selector expression SE-0022, this proposal introduces syntax for referencing compiler-checked key-paths. When the referenced properties and methods are renamed or deleted, the programmer will be notified by a compiler error. Proposed solution Introduce a new expression #keyPath() that allows one to build a compile-time valid key-path string literal (to allow it be used as StaticString and StringLiteralConvertible): class Person: NSObject { dynamic var firstName: String = &quot;&quot; dynamic var lastName: String = &quot;&quot; dynamic var friends: [Person] = [] dynamic var bestFriend: Person? init(firstName: String, lastName: String) { self.firstName = firstName self.lastName = lastName } } let chris = Person(firstName: &quot;Chris&quot;, lastName: &quot;Lattner&quot;) let joe = Person(firstName: &quot;Joe&quot;, lastName: &quot;Groff&quot;) let douglas = Person(firstName: &quot;Douglas&quot;, lastName: &quot;Gregor&quot;) chris.friends = [joe, douglas] chris.bestFriend = joe #keyPath(Person.firstName) // =&gt; &quot;firstName&quot; chris.valueForKey(#keyPath(Person.firstName)) // =&gt; Chris #keyPath(Person.bestFriend.lastName) // =&gt; &quot;bestFriend.lastName&quot; chris.valueForKeyPath(#keyPath(Person.bestFriend.lastName)) // =&gt; Groff #keyPath(Person.friends.firstName) // =&gt; &quot;friends.firstName&quot; chris.valueForKeyPath(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;] By having the #keyPath expression do the work to form the Objective-C key-path string, we free the developer from having to do the manual typing and get static checking that the key-path exists and is exposed to Objective-C. It would also be very convenient for the #keyPath to accept value (instead of static) expressions: extension Person { class func find(name: String) -&gt; [Person] { return DB.execute(&quot;SELECT * FROM Person WHERE (#keyPath(firstName)) LIKE &#39;%s&#39;&quot;, name) } } In this case, #keyPath(firstName) is understood to represent #keyPath(Person.firstName). Collection Keypaths As Foundation types are not strongly-typed, the key-path expression should only accept traversing SequenceType conforming types: let swiftArray = [&quot;Chris&quot;, &quot;Joe&quot;, &quot;Douglas&quot;] let nsArray = NSArray(array: swiftArray) swiftArray.valueForKeyPath(#keyPath(swiftArray.count)) // =&gt; 3 swiftArray.valueForKeyPath(#keyPath(swiftArray.uppercased)) // =&gt; [&quot;CHRIS&quot;, &quot;JOE&quot;, &quot;DOUGLAS&quot;] swiftArray.valueForKeyPath(#keyPath(nsArray.count)) // =&gt; 3 swiftArray.valueForKeyPath(#keyPath(nsArray.uppercaseString)) // compiler error There is some implicit bridging going on here that could use some detailed design. If I refer to Person.lastName.uppercased, that’s a method on the value type String. At runtime, we’re depending on getting the uppercaseString method on NSString. This may be as simple as saying that we follow the _ObjectiveCBridgeable conformance for any value type encountered along the way. Collection Operators This proposal purposely does not attempt to implement Collection Operators as the current functionality stands on its own and is useful even without the Objective-C runtime (as can be seen in the previous example). On the contrary, collection operators will require more design, and are only useable with valueForKeyPath: which is not available on Linux. Impact on existing code The introduction of the #keyPath expression has no impact on existing code, and is simply a modification-safe alternative to using strings literal for referencing key-paths. Alternatives considered There does not seem to be any obvious alternatives. The only point of discussion was on the name of the expression. #key was proposed: it is shorter but does not seem to express that the expression accepts paths.",
    "url": "http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html",
    "relUrl": "/docs/2019-08-26-0062-objc-keypaths.html"
  },
  "62": {
    "id": "62",
    "title": "SE-0063 SwiftPM System Module Search Paths",
    "content": "SwiftPM System Module Search Paths Proposal: SE-0063 Author: Max Howell Review Manager: Anders Bertelrud Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift-package-manager#257 Introduction Swift is able to import C libraries in the same manner as Swift libraries. For this to occur the library must be represented by a clang module-map file. The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed. swift-evolution thread Terminology SwiftPM Source Package: A package consumed by SwiftPM that comes with sources that SwiftPM builds into modules SwiftPM System Package: A package consumed by SwiftPM that refers to a modular system library not installed by SwiftPM System Package: A package provided by a system packager like, eg. apt, pacman or brew. System Packager: A system package manager like, eg. apt, pacman or brew. Motivation The current implementation of SwiftPM System Packages have a number of problems: Install locations vary across platforms and .modulemap files require absolute paths /usr/lib:/usr/local/lib is not always a sufficient -L linker search path /usr/include:/usr/local/include is not always a sufficient -I C compiler search path Installing the system library is left up to the end-user to figure out For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK. For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this System Package is libgtk-3-0-dev which is not entirely intuitive. For example, Homebrew and MacPorts on OS X install to prefixes other than /usr. .modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts. Proposed Solution We propose that SwiftPM gains the ability to read .pc files written for the cross-platform pkg-config tool. These files describe the missing search paths that SwiftPM requires. They also specify the install location of system libraries and will allow SwiftPM to preprocess the modulemap changing the specified header prefixes. We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms. Detailed Design Solving Path/Flags Issues A system library should provide a pkg-config file (.pc) which describes: Its install location Supplementary flags that should be used when compiling against this library Supplementary flags that should be used when linking against this library If SwiftPM read the .pc file that comes with System Packages, this solves problems 1 through 3. Of the tickets we currently have open describing issues using SwiftPM System Packages, reading the .pc file would fix all of them. It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-config for by parsing the .modulemap file in the SwiftPM Package. However sometimes this is not true, (eg. GTK-3 on Ubuntu), so we will allow an override in the Package.swift file, for example: let package = Package( name: &quot;CFoo&quot;, pkgConfigName: &quot;gtk-3&quot; ) Thus we would search for a filename: gtk-3.pc. We don’t want to introduce a new dependency (on pkg-config) to Swift, so we will implement the reading of .pc files according to the pkg-config specification, including: Obeying the correct search .pc file search paths Following overrides due to any PKG_CONFIG_PATH environment variable Hinting At System-Package Install-Names Package.swift would be supplemented like so: let package = Package( name: &quot;CFoo&quot;, pkgConfigName: &quot;foo&quot;, providers: [ .Brew(installName: &quot;foo&quot;), .Apt(installName: &quot;libfoo-dev&quot;), ], ) Thus, in the event of build failure for modules that depend on this SwiftPM Package we would output additional help to the user: error: failed to build module `bar&#39; note: you may need to install `foo&#39; using your system-packager: apt-get install libfoo-dev Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific system-packager requires additional parameters, they can be added on a per enum basis. Install-names are not standard apt is used across multiple distirbutions and the install-names for tools vary. Even for the same distribution install-names may vary across releases (eg. from Ubuntu 15.04 to Ubuntu 15.10) or even on occasion at finer granularity. We will not add explicit handling for this, but one can imagine the enums for different system packagers could be supplemented in a backwards compatible way to provide specific handling as real-world uses emerge, eg: case Apt(installName: String) // …could be adapted to: struct Debian: Linux {} struct Ubuntu: Debian { enum Variant { case Gubuntu case Kubuntu(Version) } enum Version { case v1510 case v1504 } } case Apt(installName: String, distribution: Linux? = nil) Impact on Existing Code There will be no impact on existing code as this feature simply improves an existing feature making new code possible. Alternatives Considered A clear alternative is allowing additional flags to be specified in a SwiftPM System Package’s Package.swift. However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the System Package itself, and in fact almost all System Packages nowadays provide it in a .pc pkg-config file. Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”. Unsolved Problems Some (usually more legacy) system libraries do not provide .pc files instead they may provide a tool named eg. foo-config that can be queried for compile and link flags. We do not yet support these tools, and would prefer to take a wait and see approach to determine how important supporting them may be. Some libraries on OS X do not come with .pc files. Again we’d like to see which libraries are affected before potentially offering a solution here. Future Directions The build system could be made more reliable by having the specific system packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up. If this was done pkg-config could become just one option for providing this data, and be used only as a fallback. We do not wish to provide a flag to automatically install dependencies via the system packager. We feel this opens us up to security implications beyond the scope of this tool. Instead we can provide JSON output that can be parsed and executed by some other tooling developed outside of Apple.",
    "url": "http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html",
    "relUrl": "/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html"
  },
  "63": {
    "id": "63",
    "title": "SE-0064 Referencing the Objective-C selector of property getters and setters",
    "content": "Referencing the Objective-C selector of property getters and setters Proposal: SE-0064 Author: David Hart Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1239 Introduction Proposal SE-0022 was accepted and implemented to provide a #selector expression to reference Objective-C method selectors. Unfortunately, it does not allow referencing the getter and setter methods of properties. This proposal seeks to provide a design to reference those methods for the Swift 3.0 timeframe. Original swift-evolution thread Follow-up swift-evolution thread Motivation The #selector expression is very useful but does not yet cover all cases. Accessing property getter and setters requires to drop down to the string syntax and forgo type-safety. This proposal supports this special case without introducing new syntax, but by introducing new overloads to the #selector compiler expression. Proposed solution Introduce two new overrides to the #selector expression that allows building a selector which points to the getter or the setter of a property. class Person: NSObject { dynamic var firstName: String dynamic let lastName: String dynamic var fullName: String { return &quot; (firstName) (lastName)&quot; } init(firstName: String, lastName: String) { self.firstName = firstName self.lastName = lastName } } let firstNameGetter = #selector(getter: Person.firstName) let firstNameSetter = #selector(setter: Person.firstName) Both overrides expect a property and the setter requires a variable property. For example, the following line of code would produce an error because the lastName property is defined with let. let lastNameSetter = #selector(setter: Person.lastName) // Argument of #selector(setter:) must refer to a variable property Impact on existing code The introduction of the new #selector overrides has no impact on existing code and could improve the string-literal-as-selector to #selector migrator. Alternatives considered A long term alternative could arise from the design of lenses in Swift. But as this is purely hypothetical and out of scope for Swift 3, this proposal fixes the need for referencing property selectors in a type-safe way straight-away.",
    "url": "http://localhost:4000/docs/2019-08-26-0064-property-selectors.html",
    "relUrl": "/docs/2019-08-26-0064-property-selectors.html"
  },
  "64": {
    "id": "64",
    "title": "SE-0065 A New Model for Collections and Indices",
    "content": "A New Model for Collections and Indices Proposal: SE-0065 Authors: Dmitri Gribenko, Dave Abrahams, Maxim Moiseev Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale, Swift-evolution thread Implementation: apple/swift#2108 Previous Revisions: 1, 2, 3, 4 Summary We propose a new model for Collections wherein responsibility for index traversal is moved from the index to the collection itself. For example, instead of writing i.successor(), one would write c.index(after: i). We also propose the following changes as a consequence of the new model: A collection’s Index can be any Comparable type. The distinction between intervals and ranges disappears, leaving only ranges. A closed range that includes the maximal value of its Bound type is now representable and does not trap. Existing “private” in-place index traversal methods are now available publicly. Motivation In collections that don’t support random access, (string views, sets, dictionaries, trees, etc.) it’s very common that deriving one index value from another requires somehow inspecting the collection’s data. For example, you could represent an index into a hash table as an offset into the underlying storage, except that one needs to actually look at structure of the hash table to reach the next bucket. In the current model, supporting i.successor() means that the index must additionally store not just an offset, but a reference to the collection’s structure. The consequences for performance aren’t pretty: Code that handles indices has to perform atomic reference counting, which has significant overhead and can prevent the optimizer from making other improvements. Additional references to a collection’s storage block the library-level copy-on-write optimization: in-place mutation of uniquely-referenced data. A live index makes underlying storage non-uniquely referenced, forcing unnecessary copies when the collection is mutated. In the standard library, Dictionary and Set use a double-indirection trick to work around this issue. Unfortunately, even this trick is not a solution, because (as we have recently realized) it isn’t threadsafe. 1 By giving responsibility for traversal to the collection, we ensure that operations that need the collection’s structure always have it, without the costs of holding references in indices. Other Benefits Although this change is primarily motivated by performance, it has other significant benefits: Simplifies implementation of non-trivial indices. Allows us to eliminate the Range/Interval distinction. Making traversal a direct property of the Collection protocol, rather than its associated Index type, is closer to most peoples’ mental model for collections, and simplifies the writing of many generic constraints. Makes it feasible to fix existing concurrency issues in Set and Dictionary indices. Allows String views to share a single index type, letting us eliminate the need for cumbersome index conversion functions (not part of this proposal, but planned). Out of Scope This proposal intentionally does not: Expand the set of concrete collections provided by the standard library. Expand the set of collection protocols to provide functionality beyond what is already provided (for example, protocols for sorted collections, queues etc.) Discussing how other concrete collections fit into the current protocol hierarchy is in scope, though. Limitations of the Model Ideally, our collection model would allow us to implement every interesting data structure with memory safety, optimal performance, value semantics, and a variety of other useful properties such as minimal invalidation of indexes upon mutation. In practice, these goals and the Swift language model interact in complicated ways, preventing some designs altogether, and suggesting a variety of implementation strategies for others that can be selected based on one’s priorities. We’ve done some in-depth investigation of these implications, but presenting and explaining them is well beyond the scope of this proposal. We can, however, be fairly sure that this change does not regress our ability to build any Collections that could have been built in Swift 2.2. After all, it is still possible to implement indices that store references and have the old traversal methods (the collection’s traversal methods would simply forward to those of the index), so we haven’t lost the ability to express anything. Overview of Type And Protocol Changes This section covers the proposed structural changes to the library at a high level. Details such as protocols introduced purely to work around compiler limitations (e.g. Indexable or IndexableBase) have been omitted. For a complete view of the code and documentation changes implementing this proposal, please see this pull request. Collection Protocol Hierarchy In the proposed model, indices don’t have any requirements beyond Comparable, so the ForwardIndex, BidirectionalIndex, and RandomAccessIndex protocols are eliminated. Instead, we introduce BidirectionalCollection and RandomAccessCollection to provide the same traversal distinctions, as shown here: +--+ |Sequence| ++-+ | +-+--+ |Collection| +-+--+ | +--+-+ | | | | +--+--+ | | |MutableCollection| | | +--+ | | | ++-+ ++-+ |BidirectionalCollection| |RangeReplaceableCollection| ++-+ +--+ | +--+-+ |RandomAccessCollection| +-+ These protocols compose naturally with the existing protocols MutableCollection and RangeReplaceableCollection to describe a collection’s capabilities, e.g. struct Array&lt;Element&gt; : RandomAccessCollection, MutableCollection, RangeReplaceableCollection { ... } struct UnicodeScalarView : BidirectionalCollection { ... } Range Types The proposal adds several new types to support ranges: The old Range&lt;T&gt;, ClosedInterval&lt;T&gt;, and OpenInterval&lt;T&gt; are replaced with four new generic range types: Two for general ranges (whose bounds are Comparable): Range&lt;T&gt; and ClosedRange&lt;T&gt;. Having a separate ClosedRange type allows us to address the vexing inability of the old Range to represent a range containing the maximal value of its bound. Two for ranges that additionally conform to RandomAccessCollection (requiring bounds that are Strideable with Stride conforming to Integer): CountableRange&lt;T&gt; and CountableClosedRange&lt;T&gt;. These types can be folded into Range and ClosedRange when Swift acquires conditional conformance capability. The Associated Indices Type The following code iterates over the indices of all elements in collection: for index in collection.indices { ... } In Swift 2, collection.indices returned a Range&lt;Index&gt;, but because a range is a simple pair of indices and indices can no longer be advanced on their own, Range&lt;Index&gt; is no longer iterable. In order to keep code like the above working, Collection has acquired an associated Indices type that is always iterable, and three generic types were introduced to provide a default Indices for each Collection traversal category: DefaultIndices&lt;C&gt;, DefaultBidirectionalIndices&lt;C&gt;, and DefaultRandomAccessIndices&lt;C&gt;. These types store the underlying collection as a means of traversal. Collections like Array whose Indices don’t need the collection simply use typealias Indices = CountableRange&lt;Index&gt;. Expanded Default Slice Types Because Swift doesn’t support conditional protocol conformances and the three traversal distinctions have been moved into the Collection hierarchy, the four generic types Slice, MutableSlice, RangeReplaceableSlice, and MutableRangeReplaceableSlice have become twelve, with the addition of variations such as RangeReplaceableBidirectionalSlice. The Comparable Requirement on Indices In this model indices store the minimal amount of information required to describe an element’s position. Usually an index can be represented with one or two Ints that efficiently encode the path to the element from the root of a data structure. Since one is free to choose the encoding of the “path”, we think it is possible to choose it in such a way that indices are cheaply comparable. That has been the case for all of the indices required to implement the standard library, and a few others we investigated while researching this change. It’s worth noting that this requirement isn’t strictly necessary. Without it, though, indices would have no requirements beyond Equatable, and creation of a Range&lt;T&gt; would have to be allowed for any T conforming to Equatable. As a consequence, most interesting range operations, such as containment checks, would be unavailable unless T were also Comparable, and we’d be unable to provide bounds-checking in the general case. That said, the requirement has real benefits. For example, it allows us to support distance measurement between arbitrary indices, even in collections without random access traversal. In the old model, x.distance(to: y) for these collections had the undetectable precondition that x precede y, with unpredictable consequences for violation in the general case. Detailed API Changes This section describes changes to methods, properties, and associated types at a high level. Details related to working around compiler limitations have been omitted. For a complete view of the code and documentation changes implementing this proposal, please see this pull request. Collections The following APIs were added: protocol Collection { ... /// A type that can represent the number of steps between pairs of /// `Index` values where one value is reachable from the other. /// /// Reachability is defined by the ability to produce one value from /// the other via zero or more applications of `index(after: _)`. associatedtype IndexDistance : SignedInteger = Int /// A collection type whose elements are the indices of `self` that /// are valid for subscripting, in ascending order. associatedtype Indices : Collection = DefaultIndices&lt;Self&gt; /// The indices that are valid for subscripting `self`, in ascending order. /// /// - Note: `indices` can hold a strong reference to the collection itself, /// causing the collection to be non-uniquely referenced. If you need to /// mutate the collection while iterating over its indices, use the /// `index(after: _)` method starting with `startIndex` to produce indices /// instead. /// /// /// var c = [10, 20, 30, 40, 50] /// var i = c.startIndex /// while i != c.endIndex { /// c[i] /= 5 /// i = c.index(after: i) /// } /// // c == [2, 4, 6, 8, 10] /// var indices: Indices { get } /// Returns the position immediately after `i`. /// /// - Precondition: `(startIndex..&lt;endIndex).contains(i)` @warn_unused_result func index(after i: Index) -&gt; Index /// Replaces `i` with its successor. func formIndex(after i: inout Index) /// Returns the result of advancing `i` by `n` positions. /// /// - Returns: /// - If `n &gt; 0`, the `n`th index after `i`. /// - If `n &lt; 0`, the `n`th index before `i`. /// - Otherwise, `i` unmodified. /// /// - Precondition: `n &gt;= 0` unless `Self` conforms to /// `BidirectionalCollection`. /// - Precondition: /// - If `n &gt; 0`, `n &lt;= self.distance(from: i, to: self.endIndex)` /// - If `n &lt; 0`, `n &gt;= self.distance(from: i, to: self.startIndex)` /// /// - Complexity: /// - O(1) if `Self` conforms to `RandomAccessCollection`. /// - O(`abs(n)`) otherwise. func index(_ i: Index, offsetBy n: IndexDistance) -&gt; Index /// Returns the result of advancing `i` by `n` positions, or until it /// equals `limit`. /// /// - Returns: /// - If `n &gt; 0`, the `n`th index after `i` or `limit`, whichever /// is reached first. /// - If `n &lt; 0`, the `n`th index before `i` or `limit`, whichever /// is reached first. /// - Otherwise, `i` unmodified. /// /// - Precondition: `n &gt;= 0` unless `Self` conforms to /// `BidirectionalCollection`. /// /// - Complexity: /// - O(1) if `Self` conforms to `RandomAccessCollection`. /// - O(`abs(n)`) otherwise. func index( _ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index) -&gt; Index /// Advances `i` by `n` positions. /// /// - Precondition: `n &gt;= 0` unless `Self` conforms to /// `BidirectionalCollection`. /// - Precondition: /// - If `n &gt; 0`, `n &lt;= self.distance(from: i, to: self.endIndex)` /// - If `n &lt; 0`, `n &gt;= self.distance(from: i, to: self.startIndex)` /// /// - Complexity: /// - O(1) if `Self` conforms to `RandomAccessCollection`. /// - O(`abs(n)`) otherwise. func formIndex(_ i: inout Index, offsetBy n: IndexDistance) /// Advances `i` by `n` positions, or until it equals `limit`. /// /// - Precondition: `n &gt;= 0` unless `Self` conforms to /// `BidirectionalCollection`. /// /// - Complexity: /// - O(1) if `Self` conforms to `RandomAccessCollection`. /// - O(`abs(n)`) otherwise. func formIndex( _ i: inout Index, offsetBy n: IndexDistance, limitedBy limit: Index) /// Returns the distance between `start` and `end`. /// /// - Precondition: `start &lt;= end` unless `Self` conforms to /// `BidirectionalCollection`. /// - Complexity: /// - O(1) if `Self` conforms to `RandomAccessCollection`. /// - O(`n`) otherwise, where `n` is the method&#39;s result. func distance(from start: Index, to end: Index) -&gt; IndexDistance } protocol BidirectionalCollection { /// Returns the position immediately preceding `i`. /// /// - Precondition: `i &gt; startIndex &amp;&amp; i &lt;= endIndex` func index(before i: Index) -&gt; Index /// Replaces `i` with its predecessor. /// /// - Precondition: `i &gt; startIndex &amp;&amp; i &lt;= endIndex` func formIndex(before i: inout Index) } Note: The formIndex overloads essentially enshrine the previously-hidden _successorInPlace et al., which can be important for performance when handling the rare heavyweight index type such as AnyIndex. RandomAccessCollection does not add any syntactic requirements beyond those of BidirectionalCollection. Instead, it places tighter performance bounds on operations such as c.index(i, offsetBy: n) (O(1) instead of O(n)). Ranges The four range Range Types share the common interface shown below: public struct Range&lt;Bound: Comparable&gt; : Equatable { /// Creates an instance with the given bounds. /// /// - Note: As this initializer does not check its precondition, it /// should be used as an optimization only, when one is absolutely /// certain that `lower &lt;= upper`. In general, the `..&lt;` and `...` /// operators are to be preferred for forming ranges. /// /// - Precondition: `lower &lt;= upper` init(uncheckedBounds: (lower: Bound, upper: Bound)) /// Returns `true` if the range contains the `value`. func contains(_ value: Bound) -&gt; Bool /// Returns `true` iff `self` and `other` contain a value in common. func overlaps(_ other: Self) -&gt; Bool /// Returns `true` iff `self.contains(x)` is `false` for all values of `x`. var isEmpty: Bool { get } /// The range&#39;s lower bound. var lowerBound: Bound { get } /// The range&#39;s upper bound. var upperBound: Bound { get } /// Returns `self` clamped to `limits`. /// /// The bounds of the result, even if it is empty, are always /// limited to the bounds of `limits`. func clamped(to limits: Self) -&gt; Self } In addition, every implementable lossless conversion between range types is provided as a label-less init with one argument: let a = 1..&lt;10 let b = ClosedRange(a) // &lt;=== Here Note in particular: In Range&lt;T&gt;, T is Comparable rather than an index type that can be advanced, so a generalized range is no longer a Collection, and startIndex/endIndex have become lowerBound/upperBound. The semantic order of Interval’s clamp method, which was unclear at its use-site, has been inverted and updated with a preposition for clarity. Downsides The proposed approach has several disadvantages, which we explore here in the interest of full disclosure: In Swift 2, RandomAccessIndex has operations like + that provide easy access to arbitrary position offsets in some collections. That could also be seen as discouragement from trying to do random access operations with less-refined index protocols, because in those cases one has to resort to constructs like i.advancedBy(n). In this proposal, there is only c.index(i, offsetBy: n), which makes random access equally (in)convenient for all collections, and there is no particular syntactic penalty for doing things that might turn out to be inefficient. Index movement is more complex in principle, since it now involves not only the index, but the collection as well. The impact of this complexity is limited somewhat because it’s very common that code moving indices occurs in a method of the collection type, where “implicit self” kicks in. The net result is that index manipulations end up looking like free function calls: let j = index(after: i) // self.index(after: i) let k = index(j, offsetBy: 5) // self.index(j, offsetBy: 5) The new index manipulation methods increase the API surface area of Collection, which is already quite large since algorithms are implemented as extensions. Because Swift is unable to express conditional protocol conformances, implementing this change has required us to create a great deal of complexity in the standard library API. Aside from the two excess “Countable” range types, there are new overloads for slicing and twelve distinct slice types that capture all the combinations of traversal, mutability, and range-replaceability. While these costs are probably temporary, they are very real in the meantime. The API complexity mentioned above stresses the type checker, requiring several changes just to get our test code to type-check in reasonable time. Again, an ostensibly temporary—but still real—cost. Impact on existing code Code that does not need to change: Code that works with Array, ArraySlice, ContiguousArray, and their indices. Code that operates on arbitrary collections and indices (on concrete instances or in generic context), but does no index traversal. Iteration over collections’ indices with c.indices does not change. APIs of high-level collection algorithms don’t change, even for algorithms that accept indices as parameters or return indices (e.g., index(of:), min(), sort(), prefix(), prefix(upTo:) etc.) Code that needs to change: Code that advances indices (i.successor(), i.predecessor(), i.advanced(by:) etc.) or calculates distances between indices (i.distance(to:)) now needs to call a method on the collection instead. // Before: var i = c.index { $0 % 2 == 0 } let j = i.successor() print(c[j]) // After: var i = c.index { $0 % 2 == 0 } // No change in algorithm API. let j = c.index(after: i) // Advancing an index requires a collection instance. print(c[j]) // No change in subscripting. The transformation from i.successor() to c.index(after: i) is non-trivial. Performing it correctly requires knowing how to get the corresponding collection. In general, it is not possible to perform this migration automatically. A very sophisticated migrator could handle some easy cases. Custom collection implementations need to change. A simple fix would be to just move the methods from indices to collections to satisfy new protocol requirements. This is a more or less mechanical fix that does not require design work. This fix would allow the code to compile and run. In order to take advantage of performance improvements in the new model, and remove reference-counted stored properties from indices, the representation of the index might need to be redesigned. Implementing custom collections, as compared to using collections, is a niche case. We believe that for custom collection types it is sufficient to provide clear steps for manual migration that don’t require a redesign. Implementing this in an automated migrator might be possible, but would be a heroic migration for a rare case. Implementation Status This pull request contains a complete implementation. Alternatives considered We considered index-less models, for example, D’s std.range (see also On Iteration by Andrei Alexandrescu). Ranges work well for reference-typed collections, but it is not clear how to adjust the concept of D’s range (similar to Slice in Swift) for mutable value-typed collections. In D, you process a collection by repeatedly slicing off elements. Once you have found an element that you would like to mutate, it is not clear how to actually change the original collection, if the collection and its slice are value types. disturbing the reference count of the storage with indices. +--+ class struct |RC|+ +--+ +--+ Storage |&lt;| DictionaryIndex | | | | value | +-+ +--+ ^ +--+ | class struct |RC|-+ ++ +--+ Indirection |&lt;-| Dictionary | | (&quot;owner&quot;) | | value | +--+ ++ Instances of Dictionary point to an indirection, while instances of DictionaryIndex point to the storage itself. This allows us to have two separate reference counts. One of the refcounts tracks just the live Dictionary instances, which allows us to perform precise uniqueness checks. The issue that we were previously unaware of is that this scheme is not thread-safe. When uniquely-referenced storage is being mutated in place, indices can be concurrently being incremented (on a different thread). This would be a read/write data race. Fixing this data race (to provide memory safety) would require locking dictionary storage on every access, which would be an unacceptable performance penalty. Dictionary and Set use a double-indirection trick to avoid &#8617;",
    "url": "http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html",
    "relUrl": "/docs/2019-08-26-0065-collections-move-indices.html"
  },
  "65": {
    "id": "65",
    "title": "SE-0066 Standardize function type argument syntax to require parentheses",
    "content": "Standardize function type argument syntax to require parentheses Proposal: SE-0066 Author: Chris Lattner Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift@3d2b5bc Introduction Function types in Swift use parentheses around their parameter list (aligning with the function declaration syntax, as well as the syntax used to call a function). However, in the degenerate case of a single non-variadic, unlabeled argument with no attributes, Swift allows the parentheses to be omitted. For example, these types: (Int) -&gt; Float (String) -&gt; Int (T) -&gt; U (Int) -&gt; (Float) -&gt; String May be written as: Int -&gt; Float String -&gt; Int T -&gt; U Int -&gt; Float -&gt; String While this saves some parentheses, it introduces some minor problems, is not consistent with other parts of the Swift grammar, reduces consistency within function types themselves, and offers no additional expressive capability (this is just syntactic sugar). This proposal suggests that we simply eliminate the special case and require parentheses on all argument lists for function types. Swift-evolution thread: [pitch] Eliminate the “T1 -&gt; T2” syntax, require “(T1) -&gt; T2” Motivation Allowing this sugar introduces ambiguities in the language that require special rules to disambiguate. For example: () -&gt; Int // Takes zero arguments, or takes one zero-argument parameter? (Int, Float) -&gt; Int // Takes two arguments, or takes one two-argument tuple? This syntactic sugar reduces consistency with other parts of the language, since declarations always require parentheses, and calls requires parentheses as well. For example: func f(a : Int) { ... } // ok func f a : Int { ... } // my eyes! Finally, while it is straight-forward to remove this in Swift 3 (given the other migration that will be necessary to move Swift 2 code to Swift 3), removing this after Swift 3 will be much harder since we won’t want to break code then. It is now or never. History The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a single value (which was sometimes a tuple, in the case of void and multiple return values). However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, internal vs API labels, etc), we removed implicit tuple splat, and the compiler has long ago stopped modeling function parameters this way. Proposed solution Parentheses will be required in function types. Examples: Int -&gt; Int // error (Int) -&gt; Int // function from Int to Int ((Int)) -&gt; Int // also function from Int to Int Int, Int -&gt; Int // error (Int, Int) -&gt; Int // function from Int and Int to Int ((Int, Int)) -&gt; Int // function from tuple (Int, Int) to Int let f: () -&gt; Int // function with no parameters let g: (()) -&gt; Int // function taking a single () parameter let h: ((())) -&gt; Int // function taking a single () parameter f(); g(()); h(()) // correct f(()); g(); h() // errors Function type grammar Parentheses will become a part of function type grammar: function-type → ( function-type-parametersopt ) throws-annotationopt -&gt; type function-type-parameters → function-type-parameter , function-type-parameters function-type-parameters → function-type-parameter ...opt function-type-parameter → attributesopt inoutopt type throws-annotation → throws rethrows Impact on existing code The migrator will automatically add parentheses to existing code when moving from Swift 2 to Swift 3. Related questions This proposal is very simple and well scoped, but in discussion, several follow-on questions have asked about what precedent this sets - if we change this, then what else would align to it. While we cannot predict the future of where the Swift community will want to go, this section states the opinion of the author on these topics. Should function return types be parenthesized? In my opinion, no. Unlike arguments, there is no precedent already in Swift that leads to the result type of functions being parenthesized (e.g. in declarations). The result of a function also does not have any of the magic and complexity of parameter lists: it really is just a type. Finally, in terms of ergonomics, the return type of a function is very commonly written in code - almost every function and method has one. In contrast, function types are very rarely written - typically only when writing higher order functions. Should we require parentheses in closure expression parameter lists? In my opinion, no. Swift currently supports a number of syntactic shortcuts in closure parameter lists, which are important for expressiveness of simple functional algorithms. For example, very few people write out this long-form expression to sort an array of integers backward: y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs } Many people use: y = x.sorted { lhs, rhs in rhs &lt; lhs } Or they use the even shorter form of { $1 &lt; $0 }. Some folks have asked whether it would make sense to start requiring the parentheses around the parameter lists for consistency with function types. However, note that this is structurally a different kind of syntactic sugar: you are allowed to elide the parens even when you have multiple arguments, you are allowed to omit the return type, you are allowed to omit the types, and you’re even allowed to omit the parameter list in its entirety. Short of a complete rethink of closure syntax (something that I’m not suggesting - I’m personally very happy with our closure syntax!), requiring parentheses here would not improve the language in an apparent way. Common objection The most common objection to this proposal cites a reduction in clarity for higher order functions that take one parameter. Consider a (simplified) implementation of map for example, written with the parentheses: extension LazySequenceProtocol { /// Returns a `LazyMapSequence` over this `Sequence`. The elements of /// the result are computed lazily, each time they are read, by /// calling `transform` function on a base element. func map&lt;U&gt;(_ transform: (Elements.Iterator.Element) -&gt; U) -&gt; LazyMapSequence&lt;Self.Elements, U&gt; } The author is unconvinced by the claims that requiring parentheses on the transform parameter unacceptably reduce readability. Consider: Many higher order functions are generic, which mean that they often take long names like Element (where the parens do not add much clutter), or an excessively short name (e.g. T) where the parentheses add structure. The claims of “parentheses blindness” are a possible issue, but they help offset the similar issue of “arrow blindness”, as demonstrated by the example above. Further, the declaration of a higher order functions is very rare (use of one is much more common, and is unaffected by this proposal), so it is not worth deploying sugar to syntax optimize. If Swift 1 required parentheses on function types, we would almost certainly reject a proposal to syntax optimize them away.",
    "url": "http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html",
    "relUrl": "/docs/2019-08-26-0066-standardize-function-type-syntax.html"
  },
  "66": {
    "id": "66",
    "title": "SE-0067 Enhanced Floating Point Protocols",
    "content": "Enhanced Floating Point Protocols Proposal: SE-0067 Author: Stephen Canon Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#2453 Previous Revision: 1 Introduction The current FloatingPoint protocol is quite limited, and provides only a small subset of the features expected of an IEEE 754 conforming type. This proposal expands the protocol to cover most of the expected basic operations, and adds a second protocol, BinaryFloatingPoint, that provides a number of useful tools for generic programming with the most commonly used types. Revision 2 reintroduces some of the details of the Arithmetic protocol from earlier drafts of this proposal, but as methods in the FloatingPoint API, with the goal of reducing the number of overloads for basic operations. This change was requested by some members of the core langauge team. Revision 2 also incorporates a number of suggestions from the review list and corrects some typos; thanks especially to Xiaodi Wu for thoughtful feedback. Consult the changelog at the end of this document for full details. Proposal draft Review #1 Review #2 Motivation Beside the high-level motivation provided by the introduction, the proposed prototypes address a number of pain points that we’ve heard about from developers: FloatingPoint should conform to Equatable, and Comparable FloatingPoint should conform to FloatLiteralConvertible Deprecate the % operator for floating-point types Provide basic constants (analogues of C’s DBL_MAX, etc.) Make Float80 conform to FloatingPoint Detailed design The FloatingPoint protocol is split into two parts; FloatingPoint and BinaryFloatingPoint, which conforms to FloatingPoint. If decimal types were added at some future point, they would conform to DecimalFloatingPoint. FloatingPoint is expanded to contain most of the IEEE 754 basic operations, as well as conformance to Comparable (which implies Equatable), and IntegerLiteralConvertible (BinaryFloatingPoint includes conformance to FloatLiteralConvertible). /// A floating-point type that provides most of the IEEE 754 basic (clause 5) /// operations. The base, precision, and exponent range are not fixed in /// any way by this protocol, but it enforces the basic requirements of /// any IEEE 754 floating-point type. /// /// The BinaryFloatingPoint protocol refines these requirements, adds some /// additional operations that only make sense for a fixed radix, and also /// provides default implementations of some of the FloatingPoint APIs. public protocol FloatingPoint: Comparable, IntegerLiteralConvertible, SignedNumber { /// An integer type that can represent any written exponent. associatedtype Exponent: SignedInteger /// Initialize to zero init() /// Initialize from sign, exponent, and significand. /// /// The result is: /// /// ~~~ /// (sign == .Minus ? -1 : 1) * significand * radix**exponent /// ~~~ /// /// (where `**` is exponentiation) computed as if by a single correctly- /// rounded floating-point operation. If this value is outside the /// representable range of the type, overflow or underflow occurs, and zero, /// a subnormal value, or infinity may result, as with any basic operation. /// Other edge cases: /// /// - If `significand` is zero or infinite, the result is zero or infinite, /// regardless of the value of `exponent`. /// /// - If `significand` is NaN, the result is NaN. /// /// Note that for any floating-point `x` the result of /// /// `Self(sign: x.sign, /// exponent: x.exponent, /// significand: x.significand)` /// /// is &quot;the same&quot; as `x`; it is `x` canonicalized. /// /// This initializer implements the IEEE 754 `scaleB` operation. init(sign: Sign, exponent: Exponent, significand: Self) /// A floating point value whose exponent and signficand are taken from /// `magnitude` and whose sign is taken from `signOf`. Implements the /// IEEE 754 `copysign` operation. init(signOf: Self, magnitudeOf other: Self) // NOTE: -- // The next two APIs are not implementable without a revised integer // protocol. Nonetheless, I believe that it makes sense to consider them // with the rest of this proposal, with the understanding that they will // be implemented when it becomes possible to do so. /// The closest representable value to the argument. init&lt;Source: Integer&gt;(_ value: Source) /// Fails if the argument cannot be exactly represented. init?&lt;Source: Integer&gt;(exactly value: Source) // -- /// 2 for binary floating-point types, 10 for decimal. /// /// A conforming type may use any integer radix, but values other than /// 2 or 10 are extraordinarily rare in practice. static var radix: Int { get } /// A quiet NaN (not-a-number). Compares not equal to every value, /// including itself. static var nan: Self { get } /// A signaling NaN (not-a-number). /// /// The default IEEE 754 behavior of operations involving a signaling NaN /// is to raise the Invalid flag in the floating-point environment and /// return a quiet NaN. Operations on types conforming to FloatingPoint /// should support this behavior, but they might also support other options; /// for example, it would be reasonable to implement alternative operations /// in which operating on a signaling NaN is a `fatalError()` or results in /// a diagnostic for debugging purposes. static var signalingNaN: Self { get } /// Positive infinity. Compares greater than all finite numbers. static var infinity: Self { get } /// The greatest finite number. /// /// Compares greater than or equal to all finite numbers, but less than /// infinity. Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc. /// The naming of those macros is slightly misleading, because infinity /// is greater than this value. static var greatestFiniteMagnitude: Self { get } /// The mathematical constant π = 3.14159... /// /// Extensible floating-point types might provide additional APIs to obtain /// this value to caller-specified precision. static var pi: Self { get } // NOTE: Rationale for &quot;ulp&quot; instead of &quot;epsilon&quot;: // We do not use that name because it is ambiguous at best and misleading // at worst: // // - Historically several definitions of &quot;machine epsilon&quot; have commonly // been used, which differ by up to a factor of two or so. By contrast // &quot;ulp&quot; is a term with a specific unambiguous definition. // // - Some languages have used &quot;epsilon&quot; to refer to wildly different values, // such as `leastNonzeroMagnitude`. // // - Inexperienced users often believe that &quot;epsilon&quot; should be used as a // tolerance for floating-point comparisons, because of the name. It is // nearly always the wrong value to use for this purpose. /// The unit in the last place of `self`. /// /// This is the unit of the least significant digit in the significand of /// `self`. For most numbers `x`, this is the difference between `x` and /// the next greater (in magnitude) representable number. There are some /// edge cases to be aware of: /// /// - `greatestFiniteMagnitude.ulp` is a finite number, even though /// the next greater representable value is `infinity`. /// - `x.ulp` is `NaN` if `x` is not a finite number. /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal /// number. On targets that do not support subnormals, `x.ulp` may be /// flushed to zero. /// /// This quantity, or a related quantity is sometimes called &quot;epsilon&quot; or /// &quot;machine epsilon&quot;. We avoid that name because it has different meanings /// in different languages, which can lead to confusion, and because it /// suggests that it is a good tolerance to use for comparisons, /// which is almost never is. /// /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail) var ulp: Self { get } /// The unit in the last place of 1.0. /// /// The positive difference between 1.0 and the next greater representable /// number. Corresponds to the C macros `FLT_EPSILON`, `DBL_EPSILON`, etc. static var ulpOfOne: Self { get } /// The least positive normal number. /// /// Compares less than or equal to all positive normal numbers. There may /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that /// they are represented with less precision than normal numbers. /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc. The naming of /// those macros is slightly misleading, because subnormals, zeros, and /// negative numbers are smaller than this value. static var leastNormalMagnitude: Self { get } /// The least positive number. /// /// Compares less than or equal to all positive numbers, but greater than /// zero. If the target supports subnormal values, this is smaller than /// `leastNormalMagnitude`; otherwise they are equal. static var leastNonzeroMagnitude: Self { get } /// `Minus` if the signbit of `self` is set, and `Plus` otherwise. /// Implements the IEEE 754 `signbit` operation. /// /// Note that the property `x.sign == .Minus` is not the same as `x &lt; 0`. /// In particular, `x &lt; 0` while `x.sign == .Minus` if `x` is -0, and while /// `x &lt; 0` is always false if `x` is NaN, `x.sign` could be either `.Plus` /// or `.Minus`. var sign: Sign { get } /// The integer part of the base-r logarithm of the magnitude of `self`, /// where r is the radix (2 for binary, 10 for decimal). Implements the /// IEEE 754 `logB` operation. /// /// Edge cases: /// /// - If `x` is zero, then `x.exponent` is `Int.min`. /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max` var exponent: Exponent { get } /// The significand satisfies: /// /// ~~~ /// self = (sign == .Minus ? -1 : 1) * significand * radix**exponent /// ~~~ /// /// (where `**` is exponentiation). If radix is 2, then for finite non-zero /// numbers `1 &lt;= significand` and `significand &lt; 2`. For other values of /// `x`, `x.significand` is defined as follows: /// /// - If `x` is zero, then `x.significand` is 0.0. /// - If `x` is infinity, then `x.significand` is 1.0. /// - If `x` is NaN, then `x.significand` is NaN. /// /// For all floating-point `x`, if we define y by: /// /// ~~~ /// let y = Self(sign: x.sign, exponent: x.exponent, /// significand: x.significand) /// ~~~ /// /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized. var significand: Self { get } /// Sum of `self` and `other` rounded to a representable value. The IEEE /// 754 addition operation. /// /// A default implementation is provided in terms of `add()`. @warn_unused_result func adding(other: Self) -&gt; Self /// Replace `self` with the sum of `self` and `other` rounded to a /// representable value. mutating func add(other: Self) /// Additive inverse of `self`. Always exact. @warn_unused_result func negated() -&gt; Self /// Replace `self` with its additive inverse. mutating func negate() /// Sum of `self` and the additive inverse of `other` rounded to a /// representable value. The IEEE 754 subtraction operation. /// /// A default implementation is provided in terms of `subtract()`. @warn_unused_result func subtracting(other: Self) -&gt; Self /// Replace `self` with the sum of `self` and the additive inverse of `other` /// rounded to a representable value. mutating func subtract(other: Self) /// Product of `self` and `other` rounded to a representable value. The /// IEEE 754 multiply operation. /// /// A default implementation is provided in terms of `multiply(by:)`. @warn_unused_result func multiplied(by other: Self) -&gt; Self /// Replace `self` with the product of `self` and `other` rounded to a /// representable value. mutating func multiply(by other: Self) /// Quotient of `self` and `other` rounded to a representable value. The /// IEEE 754 divide operation. /// /// A default implementation is provided in terms of `divide(by:)`. @warn_unused_result func divided(by other: Self) -&gt; Self /// Replace `self` with the quotient of `self` and `other` rounded to a /// representable value. mutating func divide(by other: Self) /// Remainder of `self` divided by `other`. This is the IEEE 754 remainder /// operation. /// /// For finite `self` and `other`, the remainder `r` is defined by /// `r = self - other*n`, where `n` is the integer nearest to `self/other`. /// (Note that `n` is *not* `self/other` computed in floating-point /// arithmetic, and that `n` may not even be representable in any available /// integer type). If `self/other` is exactly halfway between two integers, /// `n` is chosen to be even. /// /// It follows that if `self` and `other` are finite numbers, the remainder /// `r` satisfies `-|other|/2 &lt;= r` and `r &lt;= |other|/2`. /// /// `remainder` is always exact. @warn_unused_result func remainder(dividingBy other: Self) -&gt; Self /// Mutating form of `remainder`. mutating func formRemainder(dividingBy other: Self) /// Remainder of `self` divided by `other` using truncating division. /// Equivalent to the C standard library function `fmod`. /// /// If `self` and `other` are finite numbers, the truncating remainder /// `r` has the same sign as `other` and is strictly smaller in magnitude. /// It satisfies `r = self - other*n`, where `n` is the integral part /// of `self/other`. /// /// `truncatingRemainder` is always exact. @warn_unused_result func truncatingRemainder(dividingBy other: Self) -&gt; Self /// Mutating form of `truncatingRemainder`. mutating func formTruncatingRemainder(dividingBy other: Self) /// Square root of `self`. @warn_unused_result func squareRoot() -&gt; Self /// Mutating form of square root. mutating func formSquareRoot() /// `self + lhs*rhs` computed without intermediate rounding. Implements the /// IEEE 754 `fusedMultiplyAdd` operation. @warn_unused_result func addingProduct(lhs: Self, _ rhs: Self) -&gt; Self /// Fused multiply-add, accumulating the product of `lhs` and `rhs` to `self`. mutating func addProduct(lhs: Self, _ rhs: Self) /// The minimum of `x` and `y`. Implements the IEEE 754 `minNum` operation. /// /// Returns `x` if `x &lt;= y`, `y` if `y &lt; x`, and whichever of `x` or `y` /// is a number if the other is NaN. The result is NaN only if both /// arguments are NaN. /// /// This function is an implementation hook to be used by the free function /// min(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard /// to NaNs. @warn_unused_result static func minimum(x: Self, _ y: Self) -&gt; Self /// The maximum of `x` and `y`. Implements the IEEE 754 `maxNum` operation. /// /// Returns `x` if `x &gt;= y`, `y` if `y &gt; x`, and whichever of `x` or `y` /// is a number if the other is NaN. The result is NaN only if both /// arguments are NaN. /// /// This function is an implementation hook to be used by the free function /// max(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard /// to NaNs. @warn_unused_result static func maximum(x: Self, _ y: Self) -&gt; Self /// Whichever of `x` or `y` has lesser magnitude. Implements the IEEE 754 /// `minNumMag` operation. /// /// Returns `x` if abs(x) &lt;= abs(y), `y` if abs(y) &lt; abs(x), and whichever of /// `x` or `y` is a number if the other is NaN. The result is NaN /// only if both arguments are NaN. @warn_unused_result static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self /// Whichever of `x` or `y` has greater magnitude. Implements the IEEE 754 /// `maxNumMag` operation. /// /// Returns `x` if abs(x) &gt;= abs(y), `y` if abs(y) &gt; abs(x), and whichever of /// `x` or `y` is a number if the other is NaN. The result is NaN /// only if both arguments are NaN. @warn_unused_result static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self /// The least representable value that compares greater than `self`. /// /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`. /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`. /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`. /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`. /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`. var nextUp: Self { get } /// The greatest representable value that compares less than `self`. /// /// `x.nextDown` is equivalent to `-(-x).nextUp` var nextDown: Self { get } /// IEEE 754 equality predicate. /// /// -0 compares equal to +0, and NaN compares not equal to anything, /// including itself. @warn_unused_result func isEqual(to other: Self) -&gt; Bool /// IEEE 754 less-than predicate. /// /// NaN compares not less than anything. -infinity compares less than /// all values except for itself and NaN. Everything except for NaN and /// +infinity compares less than +infinity. @warn_unused_result func isLess(than other: Self) -&gt; Bool /// IEEE 754 less-than-or-equal predicate. /// /// NaN compares not less than or equal to anything, including itself. /// -infinity compares less than or equal to everything except NaN. /// Everything except NaN compares less than or equal to +infinity. /// /// Because of the existence of NaN in FloatingPoint types, trichotomy does /// not hold, which means that `x &lt; y` and `!(y &lt;= x)` are not equivalent. /// This is why `isLessThanOrEqual(to:)` is a separate implementation hook /// in the protocol. /// /// Note that this predicate does not impose a total order. The /// `isTotallyOrdered` predicate refines this relation so that all values /// are totally ordered. @warn_unused_result func isLessThanOrEqualTo(_ other: Self) -&gt; Bool /// True if and only if `self` precedes `other` in the IEEE 754 total order /// relation. /// /// This relation is a refinement of `&lt;=` that provides a total order on all /// values of type `Self`, including non-canonical encodings, signed zeros, /// and NaNs. Because it is used much less frequently than the usual /// comparisons, there is no operator form of this relation. @warn_unused_result func isTotallyOrdered(below other: Self) -&gt; Bool /// True if and only if `self` is normal. /// /// A normal number uses the full precision available in the format. Zero /// is not a normal number. var isNormal: Bool { get } /// True if and only if `self` is finite. /// /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNaN` are /// `false`. var isFinite: Bool { get } /// True iff `self` is zero. Equivalent to `self == 0`. var isZero: Bool { get } /// True if and only if `self` is subnormal. /// /// A subnormal number does not use the full precision available to normal /// numbers of the same format. Zero is not a subnormal number. /// /// Subnormal numbers are often called &quot;denormal&quot; or &quot;denormalized&quot;. These /// are simply different names for the same concept. IEEE 754 prefers the /// name &quot;subnormal&quot;, and we follow that usage. var isSubnormal: Bool { get } /// True if and only if `self` is infinite. /// /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because /// they are not total. If `x` is `NaN`, then both properties are `false`. var isInfinite: Bool { get } /// True if and only if `self` is NaN (&quot;not a number&quot;); this property is /// true for both quiet and signaling NaNs. var isNaN: Bool { get } /// True if and only if `self` is a signaling NaN. var isSignalingNaN: Bool { get } /// The IEEE 754 &quot;class&quot; of this type. var floatingPointClass: FloatingPointClassification { get } /// True if and only if `self` is canonical. /// /// Every floating-point value of type Float or Double is canonical, but /// non-canonical values of type Float80 exist, and non-canonical values /// may exist for other types that conform to FloatingPoint. /// /// The non-canonical Float80 values are known as &quot;pseudo-denormal&quot;, /// &quot;unnormal&quot;, &quot;pseudo-infinity&quot;, and &quot;pseudo-NaN&quot;. /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format) var isCanonical: Bool { get } } public enum Sign: Int { case Plus case Minus } public enum FloatingPointClassification { case signalingNaN case quietNaN case negativeInfinity case negativeNormal case negativeSubnormal case negativeZero case positiveZero case positiveSubnormal case positiveNormal case positiveInfinity } The usual arithmetic and comparison operators are defined in terms of the method hooks from the protocol: @warn_unused_result prefix func +&lt;T: FloatingPoint&gt;(x: T) -&gt; T { return x } @warn_unused_result func +&lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T { return lhs.adding(rhs) } func +=&lt;T: FloatingPoint&gt;(inout lhs: T, rhs: T) { lhs.add(rhs) } @warn_unused_result prefix func -&lt;T: FloatingPoint&gt;(x: T) -&gt; T { return x.negated() } @warn_unused_result func -&lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T { return lhs.subtracting(rhs) } func -=&lt;T: FloatingPoint&gt;(inout lhs: T, rhs: T) { lhs.subtract(rhs) } @warn_unused_result func *&lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T { return lhs.multiplied(by: rhs) } func *=&lt;T: FloatingPoint&gt;(inout lhs: T, rhs: T) { lhs.multiply(by: rhs) } @warn_unused_result func /&lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T { return lhs.divided(by: rhs) } func /=&lt;T: FloatingPoint&gt;(inout lhs: T, rhs: T) { lhs.divide(by: rhs) } func sqrt&lt;T: FloatingPoint&gt;(_ rhs: T) -&gt; T { return rhs.squareRoot() } func ==&lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool { return lhs.isEqual(to: rhs) } func &lt; &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool { return lhs.isLess(than: rhs) } func &lt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool { return lhs.isLessThanOrEqualTo(rhs) } func &gt; &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool { return rhs.isLess(than: lhs) } func &gt;= &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Bool { return rhs.isLessThanOrEqualTo(lhs) } The BinaryFloatingPoint protocol provides a number of additional APIs that only make sense for types with fixed radix 2: /// A radix-2 (binary) floating-point type that follows the IEEE 754 encoding /// conventions. public protocol BinaryFloatingPoint: FloatingPoint, FloatLiteralConvertible { /// An unsigned integer type that can represent the significand of any value. /// /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently /// also called the &quot;mantissa&quot;, but this terminology is slightly incorrect /// (see the &quot;Use of &#39;mantissa&#39;&quot; section on the linked Wikipedia page for /// more details). &quot;Significand&quot; is the preferred terminology in IEEE 754. associatedtype RawSignificand: UnsignedInteger /// An unsigned integer type that can represent the exponent encoding of any /// value. associatedtype RawExponent: UnsignedInteger /// Combines `sign`, `exponent` and `significand` bit patterns to produce /// a floating-point value. init(sign: Sign, exponentBitPattern: RawExponent, significandBitPattern: RawSignificand) // NOTE: -- // The next two APIs are not implementable without a revised integer // protocol. Nonetheless, I believe that it makes sense to consider them // with the rest of this proposal, with the understanding that they will // be implemented when it becomes possible to do so. /// `value` rounded to the closest representable value. init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source) /// Fails if `value` cannot be represented exactly as `Self`. init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source) // -- /// The number of bits used to represent the exponent. /// /// Following IEEE 754 encoding convention, the exponent bias is: /// /// ~~~ /// bias = 2**(exponentBitCount-1) - 1 /// ~~~ /// /// (where `**` is exponentiation). The least normal exponent is `1-bias` /// and the largest finite exponent is `bias`. The all-zeros exponent is /// reserved for subnormals and zeros, and the all-ones exponent is reserved /// for infinities and NaNs. static var exponentBitCount: Int { get } /// For fixed-width floating-point types, this is the number of fractional /// significand bits. /// /// For extensible floating-point types, `significandBitCount` should be /// the maximum allowed significand width (without counting any leading /// integral bit of the significand). If there is no upper limit, then /// `significandBitCount` should be `Int.max`. /// /// Note that `Float80.significandBitCount` is 63, even though 64 bits /// are used to store the significand in the memory representation of a /// `Float80` (unlike other floating-point types, `Float80` explicitly /// stores the leading integral significand bit, but the /// `BinaryFloatingPoint` APIs provide an abstraction so that users don&#39;t /// need to be aware of this detail). static var significandBitCount: Int { get } /// The raw encoding of the exponent field of the floating-point value. var exponentBitPattern: RawExponent { get } /// The raw encoding of the significand field of the floating-point value. /// /// `significandBitPattern` does *not* include the leading integral bit of /// the significand, even for types like `Float80` that store it explicitly. var significandBitPattern: RawSignificand { get } /// The least-magnitude member of the binade of `self`. /// /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is /// `+/- 2**exponent`; i.e. the floating point number with the same sign /// and exponent, but with a significand of 1.0. var binade: Self { get } /// The number of bits required to represent significand. /// /// If `self` is not a finite non-zero number, `significandWidth` is /// `-1`. Otherwise, it is the number of fractional bits required to /// represent `self.significand`, which is an integer between zero and /// `significandBitCount`. Some examples: /// /// - For any representable power of two, `significandWidth` is zero, /// because `significand` is `1.0`. /// - If `x` is 10, then `x.significand` is `1.01` in binary, so /// `x.significandWidth` is 2. /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011`, /// and `x.significandWidth` is 23. var significandWidth: Int { get } // NOTE: -- // These APIs are not implementable without the generic inits, which in turn // depend on a revised Integer protocol. Nonetheless, I believe that it // makes sense to consider them with the rest of this proposal, with the // understanding that they will be implemented when it becomes possible to // do so. @warn_unused_result func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool @warn_unused_result func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool @warn_unused_result func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool @warn_unused_result func isTotallyOrdered&lt;Other: BinaryFloatingPoint&gt;(below other: Other) -&gt; Bool // -- } Float, Double, Float80 and CGFloat conform to both of these protocols. Additionally, an initializer will be added to each of those types to construct a NaN with specified payload: /// NaN with specified `payload`. /// /// Compares not equal to every value, including itself. Most operations /// with a NaN operand will produce a NaN result. init(nan payload: Self.RawSignificand, signaling: Bool) This initializer is not attached to either of the protocols because it may not actually make sense or have consistent behavior for all possible types conforming to the protocols. Impact on existing code The % operator is no longer available for FloatingPoint types. We don’t believe that it was widely used correctly, and the operation is still available via the formTruncatingRemainder method for people who need it. To follow the naming guidelines, NaN and isNaN are replaced with nan and isNaN. The redundant property quietNaN is removed. isSignaling is renamed isSignalingNaN. Changes from the draft proposal Removed the Arithmetic protocol; it may be circulated again in the future as an independent proposal, or as part of a new model for integers. Removed the add[ing], subtract[ing], etc methods, which were hooks for Arithmetic. This proposal now includes only the existing operator forms. Removed static nan(payload: signaling:) method from protocols. This will exist as an initializer on concrete types, but not be part of the protocol. Added the static signalingNaN property to the protocol to make up for #3. Added the static pi property in response to popular demand. Renamed the static ulp property ulpOfOne to avoid ambiguity with the member property ulp. Renamed totalOrder to isTotallyOrdered to be consistent with the other comparison methods. Additional clarifications and comments. Changes from revision 1 Reinstated add, subtract, etc from the draft of Arithmetic as methods on FloatingPoint. Operators moved out of protocol, mapped to method hooks. Moved the associated type RawSignificand from FloatingPoint to the BinaryFloatingPoint protocol. Additional documentation added to some operations. leastMagnitude –&gt; leastNonzeroMagnitude. Removed isUnordered(with:), renamed isTotallyOrdered(with:) argument label to below:. Nan –&gt; NaN; nan stays the same, as suggested by Jordan Rose. isLessThanOrEqual(to:) –&gt; isLessThanOrEqualTo(_:). I’m still not totally convinced that this is an improvement, so I’d love to hear further suggestions on how to handle this case. Added associated types Exponent and RawExponent to allow for soft-float types with stupendously large range. Fixed (some) typos. Implementation status Everything that does not depend on SE-0104 is implemented. Some related operations were added in SE-0113.",
    "url": "http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html",
    "relUrl": "/docs/2019-08-26-0067-floating-point-protocols.html"
  },
  "67": {
    "id": "67",
    "title": "SE-0068 Expanding Swift `Self` to class members and value types",
    "content": "Expanding Swift Self to class members and value types Proposal: SE-0068 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 5.1) Implementation: apple/swift#22863 Decision Notes: Rationale Bug: SR-1340 Previous Revisions: 1, 2 Introduction Within a class scope, Self means “the dynamic class of self”. This proposal extends that courtesy to value types and to the bodies of class members by renaming dynamicType to Self. This establishes a universal and consistent way to refer to the dynamic type of the current receiver. This proposal was discussed on the Swift Evolution list in the [Pitch] Adding a Self type name shortcut for static member access thread. Motivation It is common in Swift to reference an instance’s type, whether accessing a static member or passing types for unsafe bitcasts, among other uses. You can either specify a type by its full name or use self.dynamicType to access an instance’s dynamic runtime type as a value. struct MyStruct { static func staticMethod() { ... } func instanceMethod() { MyStruct.staticMethod() self.dynamicType.staticMethod() } } Introducing Self addresses the following issues: dynamicType remains an exception to Swift’s lowercased keywords rule. This change eliminates a special case that’s out of step with Swift’s new standards. Self is shorter and clearer in its intent. It mirrors self, which refers to the current instance. It provides an easier way to access static members. As type names grow large, readability suffers. MyExtremelyLargeTypeName.staticMember is unwieldy to type and read. Code using hardwired type names is less portable than code that automatically knows its type. Renaming a type means updating any TypeName references in code. Using self.dynamicType fights against Swift’s goals of concision and clarity in that it is both noisy and esoteric. Note that self.dynamicType.classMember and TypeName.classMember may not be synonyms in class types with non-final members. Detail Design This proposal introduces Self, which equates to and replaces self.dynamicType. You will continue to specify full type names for any other use. Joe Groff writes, “I don’t think it’s all that onerous to have to write ClassName.foo if that’s really what you specifically mean.” Alternatives Considered Not at this time Acknowledgements Thanks Sean Heber, Lily Ballard, Joe Groff, Timothy Wood, Brent Royal-Gordon, Andrey Tarantsov, Austin Zheng Rationale On April 27, 2016, the core team decided to accept a subset of this proposal. This proposal had light discussion in the community review process, but the core team heavily debated it. It includes two pieces: Expanding the existing support for Self to work in value types, and in the bodies of classes. Replacing the x.dynamicType expression with x.Self, a purely syntactic change that eliminates the “dynamicType” keyword. The core team has accepted the first half for this proposal. This allows the use of “Self” as shorthand for referring to the containing type (in the case of structs, enums, and final class) or the dynamic type (in the case of non-final classes). Most of the discussion in the core team centered around whether people familiar with the former behavior would be surprised by the (more general) behavior when using it in a class, but they came to agree that this is actually a simple and general model, and a helpful point of consistency. In contrast, there are still a number of concerns with rebranding x.dynamicType as x.Self. This may (or may not) be the right ultimate direction to go, but it should be split out of this proposal. There is another outstanding proposal that would eliminate the “Type.self” syntax as being necessary, and the core team would like to resolve that discussion before tackling x.dynamicType.",
    "url": "http://localhost:4000/docs/2019-08-26-0068-universal-self.html",
    "relUrl": "/docs/2019-08-26-0068-universal-self.html"
  },
  "68": {
    "id": "68",
    "title": "SE-0069 Mutability and Foundation Value Types",
    "content": "Mutability and Foundation Value Types Proposal: SE-0069 Author: Tony Parker Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction One of the core principles of Swift is “mutability when you need it.” This is espoused by Apple’s official documentation about Swift: Value and Reference Types - Swift Developer Blog Building Better Apps with Value Types in Swift - WWDC 2015 (Doug Gregor) Swift Programming Language - Classes and Structures Swift Evolution Discussion, Swift Evolution Review This concept is so important that it is literally the second thing taught in The Swift Programming Language, right after print(&quot;Hello, world!&quot;): Simple Values Use let to make a constant and var to make a variable. The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once. Excerpt From: Apple Inc. “The Swift Programming Language (Swift 3.0.1).” When certain Foundation types are imported into Swift, they do not fully take advantage of the features that Swift has to offer developers for controlling mutability of their objects. This proposal describes a straightforward concept for providing this capability. It describes a set of new Foundation value types which wrap their corresponding reference types. This is a technique used by the standard library. This allows us to: Improve the developer experience, Increase performance for small types like Date Preserve the ability for developers to customize the behavior of most types. This proposal describes the fundamental ideas and provides general justification. Motivation Foundation itself already uses many value types in Objective-C and Swift: Primitive C types (double, long, int64_t, and more) Architecture-hiding integer types (NSUInteger, NSInteger) Enumerations (276 in Foundation) Option sets (51 in Foundation) C structure types (18 in Foundation, including Point, Rect, EdgeInsets, Decimal) In C, developers can control the mutability of these value types by using the const keyword: const NSPoint p = {1, 2}; p.x = 3; // Error: error: cannot assign to variable &#39;p&#39; with const-qualified type &#39;const NSPoint&#39; In Swift, developers control the mutability of these value types by using let instead of var: let p = NSPoint(x: 1, y: 2) p.x = 3 // Error: cannot assign to property: &#39;p&#39; is a &#39;let&#39; constant However, struct types in Swift have far more functionality available to them than their primitive C ancestors: Methods Initializers Access control (private, public, internal) on both methods and ivars Conformance to protocols, including default implementations from those protocols Generics support Ability to modify without sacrificing binary compatibility The Swift standard library takes full advantage of these new capabilities for String, Array, Dictionary, Set, and others. In fact, we go as far as to automatically bridge these Foundation types to the standard library struct type when API using them is imported into Swift. Fixing a Mutability Impedance Mismatch The public API of the Swift standard library itself is composed of almost entirely value types (109 struct, 6 class, as of Swift 2.2). The pervasive presence of struct types in the standard library, plus the aforementioned automatic bridging of all Cocoa SDK API when imported into Swift, leads to the feeling of an API impedance mismatch for key unbridged Foundation reference types. This is because in our Objective-C API, we sometimes provide mutability via methods that return a new version of an immutable receiver: // NSDate - (instancetype)dateByAddingTimeInterval:(NSTimeInterval)ti; // NSURL - (nullable NSURL *)URLByAppendingPathExtension:(NSString *)pathExtension; And sometimes via mutable properties: @interface NSDateComponents : NSObject &lt;NSCopying, NSSecureCoding&gt; @property (nullable, copy) NSCalendar *calendar; @property (nullable, copy) NSTimeZone *timeZone; @property NSInteger era; @property NSInteger year; // etc. @end However, we do not use the C const keyword for controlling mutable behavior on Objective-C classes. Focusing on the NSDate example, let’s translate the existing design pattern directly into Swift: let myDate = Date() let myLaterDate = myDate.dateByAddingTimeInterval(60) Unfortunately, this feels awkward for two reasons: The var or let keywords mean almost nothing. The code above behaves exactly the same if it uses var instead of let. This is a major language feature we are dropping on the floor. The only way to mutate Date is to create a new one. This does not match with the idea of “mutability when you need it.” The following code is a more natural match for the way Swift developers would expect this to work: var myDate = Date() myDate.addTimeInterval(60) // OK let myOtherDate = Date() myOtherDate.addTimeInterval(60) // Error, as expected It is important to remember that the Date API author still controls the methods available on the type, and does not have to provide mutability for every property (as they would in a C struct). For types where we want to provide limited mutability, we can make all properties get only and add mutating methods to tightly control state and maintain internal consistency. For example, in the case of Date the NSTimeInterval ivar is still private to the implementation while we provide a mutating func to add a time interval. Predictable Composition Swift provides automatic and natural support for copying value types just by using assignment. However, when a value type contains a reference type, the developer must take special care to ensure that the reference type is copied correctly. For some Foundation types, this means calling copy(). If this is not done correctly, then the failure will be found at runtime. As an example, let’s borrow the Barcode example from the official Swift documentation. enum Barcode { case UPCA(Int, Int, Int, Int) case QRCode(String) case SpecialCode(IncrementingCode) } SpecialCode is a new kind of mutable barcode that contains an incrementing counter. Let’s say that this counter is backed by mutable data. // Simplified for clarity struct IncrementingCode { private var data : NSMutableData init() { /* Store a value of 0 in our Data */ } func increment() { // Retrieve the value, increment, and set it back } } This code has an error that is not obvious at first. To see what it is, let’s look at some example code: var aCode = IncrementingCode() aCode.increment() // value == 1 // Compose this incrementing code (appears to be a value type) into another value type (an enum) let barcode = Barcode.SpecialCode(aCode) // BarCode.SpecialCode, value 1 aCode.increment() // barcode is now a BarCode.SpecialCode with value 2 -- but barcode was &quot;let&quot; and should have been immutable. The error is that the IncrementingCode type should have implemented copy-on write behavior when containing a reference type. Without that, “copies” of the value type are actually sharing all underlying data through the NSMutableData reference. Today, developers using basic mutable Foundation types like MutableData must fix this themselves by re-implementing the same box/unbox logic each time they use the reference type. If Data were instead a value type, then the Data struct itself handles the copying and developers do not have to manually box it. Meaningful Mutable Keywords The error above would have been obvious with a value type. Plus, that error would be found at compile time instead of runtime. As an example, let’s use an Integer instead: struct IncrementingCode_Value { var val : Int8 init() { val = 0 } func increment() { val += 1 // error: &#39;self&#39; is immutable } } The compiler correctly told us that a mutating operation must be marked as such on the structure type. When val was a mutable reference type, the mutation was unknown to the compiler and it could not help. mutating func increment() { val += 1 // ok } Proposed solution Value types which hold more than a trivial amount of data in Swift are implemented using a copy on write technique. In this case, the value type is effectively a pointer to a shared reference type 1. The reference type is traditionally private to the implementation. However, by publishing the reference type, we can allow customization of its behavior via subclassing while simultaneously providing value semantics. In the case of Foundation value types, the published reference type is the current class type. New Value Types The following value types will be added in the Swift overlay. Immutable/mutable pairs (e.g. Data and MutableData) will become one mutable struct type: Value Type Class Type AffineTransform NSAffineTransform CharacterSet NSCharacterSet, NSMutableCharacterSet Date NSDate DateComponents NSDateComponents Data NSData, NSMutableData IndexSet NSIndexSet, NSMutableIndexSet IndexPath NSIndexPath Notification NSNotification PersonNameComponents NSPersonNameComponents URL NSURL URLComponents NSURLComponents URLQueryItem NSURLQueryItem UUID NSUUID These types will have the same functionality as their corresponding NS type. In some cases, we will add new functionality if it is directly related to the new type becoming “more Swifty”. However, we want API changes to remain focused on the task of converting these to value types and avoid feature creep by considering too much new API. The overlay is deployed back to the first supported release for Swift, so the implementation of these types will use the existing reference type API. For a small number of these types, we will copy the contents and not hold a reference. This set of types is: AffineTransform Date Notification The criteria for inclusion in this list is primarily a small memory footprint or a requirement for rapid mutation to avoid reference counting or bridging cost. Some of the struct types will gain mutating methods. In general, the implementation of the struct type will forward to the underlying reference type, so as to allow a subclass to customize the behavior. If the struct is not initialized with a reference type (using a cast), then it is free to implement as much or as little behavior as it chooses either by delegation to the standard Foundation reference type or via a customized Swift implementation. However, our first version will rely heavily on the existing logic in the Objective-C Foundation framework. This approach is important to reduce the risk. Detailed design The class types will be marked with an attribute that annotates them as Swift struct types 2. The struct types will be implemented in the Swift overlay. This re-implementation may either simply contain the Foundation reference type or reimplement functionality from Objective-C in Swift. Extremely simple types such as Date do not contain complicated logic, and writing their implementation in Swift will provide a performance benefit to all Swift users as well as a shared implementation for Swift Open Source. When these types are returned from Objective-C methods, they will be automatically bridged into the equivalent struct type. When these types are passed into Objective-C methods, they will be automatically bridged into the equivalent class type. The Bridging section below contains more information. Larger value types (for example, Data, DateComponents, and URLComponents) will be implemented with copy on write behavior. This preserves the performance characteristics of a reference type while maintaining conformance with the Swift mutability model. In the Swift overlay, each struct type adopts a new protocol that describes its behavior as a bridged type, along with common behavior of Equatable, Hashable, etc. The name of the protocol is ReferenceConvertible: /// Decorates types which are backed by a Foundation reference type. public protocol ReferenceConvertible : _ObjectiveCBridgeable, CustomStringConvertible, CustomDebugStringConvertible, Hashable, Equatable { associatedtype ReferenceType : NSObject } Type Conversion Each reference type may be cast to its corresponding struct type. This may be used to wrap a custom subclass of the reference type. For example, in Data: class MyData : NSMutableData { } func myData() -&gt; Data { return MyData() as Data } It is also possible to get the reference type from the struct type (myData as? NSData) 3. Custom Behavior The most obvious drawback to using a struct is that the type can no longer be subclassed. At first glance, this would seem to prevent the customization of behavior of these types. However, by publicizing the reference type and providing a mechanism to wrap it (mySubclassInstance as ValueType), we enable subclasses to provide customized behavior. As a case study, we will look at the Foundation Data type. Developer Experience / API The following is a simplified example of how the Foundation-provided struct Data would be used by developers. It is the same as today, except that we can take advantage of Swift’s built-in support for mutability via let and var: // We have already setup two buffers with some data let d = Data(bytes: buffer1, length: buffer1Size) print(&quot; (d)&quot;) // &lt;68656c6c 6f00&gt; // Note: d2 does not copy the data here var d2 = d // ... it copies it here, on mutation, automatically when needed d2.appendBytes(buffer2, length: buffer2Size) print(&quot; (d) (d2)&quot;) // &lt;68656c6c 6f00&gt; &lt;68656c6c 6f002077 6f726c64 00&gt; Implementation Details The methods and properties we want Data to have are defined on the structure itself. The reference type has similar (but not exactly the same) API 4. Data can adopt Swift standard library protocols like MutableCollectionType. The implementation calls through to the stored reference type. If we add API to NSData in the future, then we will also add it to Data. Here is an over-simplified look at the Data structure 5: public struct Data : Equatable, Hashable, Coding, MutableCollectionType { private var _box : _DataBox // Holds an NSData pointer public var count : Int { let reference = ... // Get reference out of the box return reference.length } // Etc. } Note that this structure is only 1 word in size, the same as a class Data pointer would be. The _DataBox type is an internal class type which holds a reference to the actual storage of the data. This is the key to both class clusters and copy-on-write behavior. The implementation of the storage is abstracted from the struct Data itself, and therefore from users of struct Data. The struct Data may be initialized with any NSData: /// Create Data with a custom backing reference type. class MyData : NSData { } let dataReference = MyData() let dataValue = dataReference as Data // dataValue copies dataReference This allows anyone to create their own kind of Data without exposing the implementation details or even existence of that new type. Just like in Objective-C, when we store a reference type we must call copy(). If the reference type is immutable then this copy will be cheap (calling retain). In the most common case where a developer does not provide a custom reference type, then the backing store is our existing NSData and NSMutableData implementations. This consolidates logic into one place and provides cheap bridging in many cases (see Bridging for more information). Over time, struct Data may choose to move some of the logic from the Objective-C implementation into Swift to provide bridge-free behavior. This is mostly predicated on our ability to ship Swift framework code. We want to maintain as much capability to add new functionality and fix bugs as possible, without requiring apps to update. This means that most logic should be in the dynamic library instead of the embedded standard library. Customization Example Here is a simple Data that holds bytes initialized to 0x01 instead of 0, and lazily creates backing storage when required. It can customize the default superclass implementation in NSData. For example, it can provide a more efficient implementation of getBytes(_:length:): class AllOnesData : NSMutableData { var _pointer : UnsafeMutableBufferPointer&lt;Void&gt;? override func getBytes(buffer: UnsafeMutablePointer&lt;Void&gt;, length: Int) { if let d = _pointer { // Get the real data from the buffer memmove(buffer, d.baseAddress, length) } else { // A more efficient implementation of getBytes in the case where no one has asked for our backing bytes memset(buffer, 1, length) } } // ... Other implementations } To test the abstraction, here is a simple function which treats all Data equally: func printFirstByte(of data : Data) { print(&quot;It&#39;s (UnsafePointer&lt;UInt8&gt;(data.bytes).pointee)&quot;) } And here is how a developer would use it: // Create a custom Data type and pass it to the same function let allOnesData = AllOnesData(length: 5) as Data printFirstByte(of: allOnesData) // It&#39;s 1 The abstraction of our custom AllOnesData class from all API that deals with Data demonstrates the key feature of Foundation’s class cluster types. Performance It is important to maintain a high bar for performance while making this transition. Note: The final design of the resilience feature for Swift will have an impact on these numbers. Memory Using Swift structures for our smallest types can be as effective as using tagged pointers in Objective-C. For example, struct Date is the same size as an NSDate pointer: public struct Date { // All methods, properties, etc. left out here, but they make no difference to the size of each Date instance private var _time : NSTimeInterval } print(&quot;Date is (sizeof(Date)) bytes&quot;) // Date is 8 bytes print(&quot;NSDate is (sizeof(NSDate)) bytes&quot;) // NSDate is 8 bytes For larger struct types, implementation is based on a copy-on-write mechanism. This means the structure itself is still just one word. For Foundation reference types which are always immutable, the structure holds the reference directly 6: public struct URL { private var _url : NSURL // Methods go here } As long as the struct is not mutated, instances share the same pointer to _url. When the struct is mutated, then the ivar is assigned to a new instance: mutating public func appendPathComponent(pathComponent: String) { _url = _url.URLByAppendingPathComponent(pathComponent) } For types which support mutation (e.g. Data), a box is used to hold a pointer to the reference. A Swift standard library function is used to check reference counts, allowing us to skip a copy when it is not necessary: // Simplified; assume _box holds a NSMutableData public mutating func appendBytes(bytes: UnsafePointer&lt;UInt8&gt;, count: Int) { if !isUniquelyReferencedNonObjC(&amp;_box) { // Make a mutable copy first with original bytes and length let copy = _box.reference.mutableCopy() as! NSMutableData copy.appendBytes(bytes, length: count) _box = _DataBox(copy) } else { _box.reference.appendBytes(bytes, length: count) } } This provides about the same memory usage as a class in Objective-C, because these structures are a single pointer. However, there is an additional pointer dereference required to get the reference type pointer. CPU When the Swift compiler has knowledge about the layout of the structure, it can sometimes make optimizations that are otherwise unavailable. There are two cases we should consider here: Extremely small value types like Date (1 pointer size). Larger value types like URL. These are actually also 1 pointer size, because they would be implemented with copy-on-write, and therefore share storage unless mutated. This is the same approach as we use in Objective-C and therefore the performance characteristics are approximately equal. Access to Member Data In microbenchmarks designed to test access time for Date.timeIntervalSinceReferenceDate, the Swift struct consistently performed about 15% faster. Although the NSDate was tagged, the overhead of calling through objc_msgSend was enough to make a difference versus more direct access. Mutation In microbenchmarks designed to test mutation for a new Date.addTimeInterval versus creating new NSDate objects with dateByAddingTimeInterval, the mutation approach was consistently about 40 times faster. The Objective-C code becomes slow when falling off the tagged pointer path which results in significant overhead from calling into malloc and free. Passing to Function In microbenchmarks designed to test performance of passing the struct to a function versus passing the NSDate reference to a function, the Swift struct consistently performed about twice as fast. Part of the reason for the additional overhead is that the Swift compiler knows it can omit calls to retain and release when working with a Swift structure. Bridging Swift has an existing mechanism to support bridging of Swift struct types to Objective-C reference types. It is used for NSNumber, NSString, NSArray, and more. Although it has some performance limitations (especially around eager copying of collection types), these new struct types will use the same functionality for two reasons: We do not have block important improvements to our API on the invention of a new bridging system. If and when the existing bridging system is improved, we will also be able to take advantage of those improvements. Bridged struct types adopt a compiler-defined protocol called _ObjectiveCBridgeable. This protocol defines methods that convert Swift to Objective-C and vice-versa 7. From Objective-C to Swift When a bridged object is returned from an Objective-C method to Swift, the compiler automatically inserts a call to a function in the protocol that performs whatever work is necessary to return the correct result. For a simple struct type like Date, we simply construct the right structure by getting the value out of the class: return Date(timeIntervalSinceReferenceDate: input.timeIntervalSinceReferenceDate) For the more complex types, both bridging and casting (myReference as Struct) use a private initializers for the value types that accept references. This creates a new struct with the Objective-C pointer: // Simplified public struct Data { // For use by bridging code only. private init(dataReference: NSData) { self.dataReference = dataReference.copy() } } Just as in Objective-C, when we store a value type we must call copy to protect ourselves from mutation to that reference after the initializer returns. In almost all API in the SDK, the returned value type is immutable. In these cases, the copy is simply a retain and this operation is cheap. If the returned type is mutable, then we must pay the full cost of the copy. From Swift to Objective-C For simple struct types like Date, we will create a new NSDate when the value is bridged. return NSDate(timeIntervalSinceReferenceDate: _time) For reference-holding types like Data, we simply pass our interior NSData pointer back to Objective-C. The underlying data is not copied at bridging time. If the receiver of that data wishes to store it, then they should call copy as usual. In some cases, we can use a technique employed by other bridge types to actually share a reference count between Swift and Objective-C, therefore preserving the value semantics of the type on the Swift side if the Objective-C code retains the reference. Archiving Encoding any of the new value types is possible by bridging them to their corresponding reference type and using all of the usual NSCoding mechanisms. An improved archiving system for Swift is a future goal and out of scope for this proposal. Copying In Swift, there is no need to conform to the NSCopying protocol. Copies are made by the implementation automatically and on-demand via a copy-on-write implementation. When a Swift value type is sent to Objective-C, then it is converted into the corresponding reference type (see Bridging above). In this case, the receiver may want to perform a copy in order to isolate itself from mutations that may happen to the object after the method call returns. This is the same as what is required in frameworks today. If a custom subclass of a reference type is used, then that subclass must implement copyWithZone as per the usual rules. The struct type will call copy and mutableCopy on it when it determines it needs to copy. Existing Objective-C API that uses Reference Types In the vast majority of cases, reference type API will appear as the bridged type. However, if a reference type is used as a pointer-to-pointer (e.g., NSData **) then it will appear in Swift API as a reference type (AutoreleasingUnsafeMutablePointer&lt;NSData&gt;). These cases are rare in our SDK for the proposed Foundation value types. Binary Compatibility The Swift team is developing an extensive proposal for binary compatibility. Details are are in the LibraryEvolution.rst document. The current draft allows the following modifications for struct types in future versions of Foundation: Swift structs are a little more flexible than their C counterparts. By default, the following changes are permitted: Reordering any existing members, including stored properties. Adding any new members, including stored properties. Changing existing properties from stored to computed or vice versa. Changing the body of any methods, initializers, or accessors. Adding or removing an observing accessor (willSet or didSet) to/from an existing property. This is effectively the same as modifying the body of a setter. Removing any non-public, non-versioned members, including stored properties. Adding a new protocol conformance (with proper availability annotations). Removing conformances to non-public protocols. Impact on existing code There is no impact on existing Objective-C clients, either for source or binary compatibility. The impact on existing Swift code will be much higher: Existing Swift code that uses the reference types will be calling SDK code that uses value types We do not propose to automatically migrate uses of NSData to the new API vended by Data. The migrator will do the minimum amount of change possible. This will prevent new or changed behavior from surprising developers (for example, the more important distinction of let vs var for these types). Existing Swift subclasses of the reference types will remain as-is. Developers will be required to manually switch to the new API, if they choose to do so. In some cases, this may be more than a simple renaming of a method. They may choose to take advantage of the new, meaningful difference between let and var. Potential Future Directions This proposal uses the existing NS classes as the customization point for the value types which store a reference. A future proposal could introduce a new Swift protocol, removing the requirement to subclass. This would be a great way to express the requirements of Foundation’s class clusters. Implementing this approach would require quite a bit of new code to provide default implementations, which is why we defer it from this proposal. Alternatives considered Do Nothing We know from our experience with Swift so far that if we do not provide these value types then others will, often by wrapping our types. It would be better if we provide one canonical API for greater consistency across all Swift code. This is, after all, the purpose of the Foundation framework. Here are some of the most popular Swift projects on GitHub. For comparison purposes, at the time of writing, Foundation itself has 1,500+ stars on GitHub. Alamofire - A networking library, 14,000+ stars on GitHub 4 struct types, including a key Response type Carthage - A package manager, 5,800+ stars on GitHub 35 struct types, including command pattern objects, URLs, modules and submodules, errors, build arguments, build settings Perfect - A server-side app library, 5,000+ stars on GitHub 6 struct types, including configuration types, database queries, route map and socket types RxSwift - Reactive programming library, 2,900+ stars on GitHub 14 struct types, including logging, events, observers, and a Bag collection type Hide Reference Types Completely This was our first approach, but it has several downsides: A tremendous amount of risk, because there is no fallback if we miss an API or if we do not consider an esoteric use case. Requires more boilerplate in the overlay (introduction of a protocol, dummy subclass which calls through to Swift code, etc.), which introduces more opportunity for error. Considered to be extremely difficult to implement for the migrator. This means that most Swift code would have to be manually fixed up. If implementing the struct types requires changes to the frameworks that ship on the OS, we may be in a very difficult situation as the overlay has to run as far back as OS X 10.9 and iOS 7. Change the Name of the Reference Types We considered changing the name of the reference types (e.g., NSData to DataReference), but decided to simply leave the NS prefix in place. This allows for a more natural transition to the value type without causing a lot of churn on existing code. It also avoids introducing a new name. We will have to document carefully what the difference is between the reference type and the value type, so developers can become familiar with our convention. Other Potential Foundation Value Types Several criteria were used to develop the list of proposed value types: The type must not rely upon object identity. The reference type most likely already implements NSCopying and NSCoding. The most interesting value types can provide new mutable API. If there are no mutations possible, it may still make sense as a value type but it is lower priority. The following classes were considered and rejected or deferred for the described reasons: Locale: This class has API for an automatically updating current locale. It would be surprising for a let value to change based on user preferences. It may be reconsidered in the future. Progress: Progress objects are meant to be mutated, so the idea of a constant one (with let) does not make much sense. Additionally, NSProgress has object identity via the concept of becomeCurrent and resignCurrent. Operation: This class is designed to be subclassed and overridden to provide customized behavior. Calendar: This class has API for an automatically updating current calendar. It may be reconsidered in the future. Port: This class has a delegate, which would make for confusing value semantics as delegates require identity for their callbacks to make sense. Number and Value: These are already partially bridged. Some improvements could be made but we wish to consider them separately from this proposal. Predicate: We will consider this type in a future proposal. OrderedSet, CountedSet: We will consider these types in a future proposal. NSError: NSError is already partially bridged to the Swift ErrorProtocol type, which makes introducing a concrete value type difficult. We will consider improvements in this area in a future proposal. NSAttributedString: This is an obvious candidate for a value type. However, we want to take more time to get this one right, since it is the fundamental class for the entire text system. We will address it in a future proposal. NSURLSession and related networking types: We will consider these types in a future proposal. This proposal describes a high-level approach to implementation; the details may be more complex. For example, we use a custom subclass of the abstract NSData class to enable Swift reference counting even when bridged back to Objective-C. These details are out of the scope of this proposal. &#8617; In the short term, a compiler attribute that can be applied via API notes will be used. This avoids a lock-step dependency between the framework code and overlay. &#8617; In practice, we will use a custom subclass of the reference type where possible. This custom NSObject subclass uses the same Swift reference counting mechanism as a Swift class, which should maintain the correct behavior for uniqueness-checking. &#8617; We will remove deprecated API from the value type. We will also remove API that is expressed differently via adoption of a Swift protocol. &#8617; Exact implementation is out of scope for this proposal. This example is provided to help clarify the intended behavior, not as a reference for implementation. &#8617; In some cases, we may choose to use some of Swift’s unmanaged ref count features to reduce the overhead of calling retain/release. &#8617; See also SE-0058. Although the public version of the feature has been deferred from Swift 3, we will still use the internal mechanism for now. &#8617;",
    "url": "http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html",
    "relUrl": "/docs/2019-08-26-0069-swift-mutability-for-foundation.html"
  },
  "69": {
    "id": "69",
    "title": "SE-0070 Make Optional Requirements Objective-C-only",
    "content": "Make Optional Requirements Objective-C-only Proposal: SE-0070 Author: Doug Gregor Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1395 Introduction Swift currently has support for “optional” requirements in Objective-C protocols, to match with the corresponding feature of Objective-C. We don’t want to make optional requirements a feature of Swift protocols (for reasons described below), nor can we completely eliminate the notion of the language (for different reasons also described below). Therefore, to prevent confusion about our direction, this proposal requires an explicit ‘@objc’ attribute on each optional requirement to indicate that this is an Objective-C compatibility feature. Swift-evolution threads: Is there an underlying reason why optional protocol requirements need @objc? [Proposal] Make optional protocol methods first class citizens [Idea] How to eliminate ‘optional’ protocol requirements [Proposal draft] Make Optional Requirements Objective-C-only [Review] SE-0070: Make Optional Requirements Objective-C only Motivation Having optional only work for Objective-C requirements is very weird: it feels like a general feature with a compiler bug that prevents it from working generally. However, we don’t want to make it a feature of Swift protocols and we can’t eliminate it (see alternatives considered), so we propose to rename the keyword to make it clear that this feature is intended only for compatibility with Objective-C. Proposed solution Require an explicit @objc attribute on each optional requirement: @objc protocol NSTableViewDelegate { @objc optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? // correct optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat // error: &#39;optional&#39; requirements are an Objective-C compatibility feature; add &#39;@objc&#39; } Impact on existing code Code that declares @objc protocols with optional requirements will need to be changed to add the @objc attribute. However, it is trivial for the migrator to update the code and for the compiler to provide Fix-Its, so the actual impact on users should be small. Moreover, explicitly writing @objc on optional requirements has always been permitted. Alternatives considered It’s a fairly common request to make optional requirements work in Swift protocols (as in the aforementioned threads). However, such proposals have generally met with resistance because optional requirements have significant overlap with other protocol features: “default” implementations via protocol extensions and protocol inheritance. For the former case, the author of the protocol can provide a “default” implementation via a protocol extension that encodes the default case (rather than putting it at the call site). In the latter case, the protocol author can separate the optional requirements into a different protocol that a type can adopt to opt-in to whatever behavior they customize. While not exactly the same as optional requirements, which allow one to perform per-requirement checking to determine whether the type implemented that requirement, the gist of the threads is that doing so is generally considered an anti-pattern: one would be better off factoring the protocol in a different way. Therefore, we do not propose to make optional requirements work for Swift protocols. The second alternative would be to eliminate optional requirements entirely from the language. The primary challenge here is Cocoa interoperability, because Cocoa’s protocols (primarily delegates and data sources) have a large number of optional requirements that would have to be handled somehow in Swift. These optional requirements would have to be mapped to some other construct in Swift, but the code generation model must remain the same because the Cocoa frameworks rely on the ability to ask the question “was this requirement implemented by the type?” in Objective-C code at run time. The most popular approach to try to map optional requirements into existing Swift constructs is to turn an optional method requirement into a property of optional closure type. For example, this Objective-C protocol: @protocol NSTableViewDelegate @optional - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row; @end which currently imports into Swift as: @objc protocol NSTableViewDelegate { optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat } would become, e.g., @objc protocol NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get } var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } } Unfortunately, this introduces an overloaded property named tableView. To really make this work, we would need to introduce the ability for a property to have a compound name, which would also let us take the labels out of the function type: @objc protocol NSTableViewDelegate { var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt; NSView?)? { get } var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { get } } By itself, that is a good feature. However, we’re not done, because we would need yet another extension to the language: one would want to be able to provide a method in a class that is used to conform to a property in the protocol, e.g., class MyDelegate : NSObject, NSTableViewDelegate { func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { ... } func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { ... } } Indeed, the Objective-C implementation model effectively requires us to satisfy these property-of-optional-closure requirements with methods so that Objective-C clients can use -respondsToSelector:. In other words, one would not be able to implement these requirements in by copy-pasting from the protocol to the implementing class: class MyDelegate : NSObject, NSTableViewDelegate { // Note: The Objective-C entry points for these would return blocks, which is incorrect var tableView(_:viewFor:row:): ((NSTableView, NSTableColumn, Int) -&gt; NSView?)? { return ... } var tableView(_:heightOfRow:): ((NSTableView, Int) -&gt; CGFloat)? { return ... } } That is both a strange technical restriction that would be limited to Objective-C protocols and a serious usability problem: the easiest way to stub out the contents of your type when it conforms to a given protocol is to copy the declarations from the protocol into your type, then fill in the details. This change would break that usage scenario badly. There have been other ideas to eliminate optional requirements. For example, Objective-C protocols could be annotated with attributes that say what the default implementation for each optional requirement is (to be used only in Swift), but such a massive auditing effort is impractical. There is a related notion of caller-site default implementations that was not well-received due to its complexity. Initially, this proposal introduce a new keyword objcoptional. However, that keyword was really ugly. Thank you to Xiaodi Wu for the suggestion to require an explicit @objc!",
    "url": "http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html",
    "relUrl": "/docs/2019-08-26-0070-optional-requirements.html"
  },
  "70": {
    "id": "70",
    "title": "SE-0071 Allow (most) keywords in member references",
    "content": "Allow (most) keywords in member references Proposal: SE-0071 Author: Doug Gregor Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction The Swift API Design Guidelines consider enum cases as values that use the lowerCamelCase naming conventions. This means that case names that previously did not conflict with keywords (such as Default, Private, Repeat) now cause conflicts, a problem that is particularly acute when the naming conventions are applied by the Clang importer (per SE-0005). To mitigate this issue, this proposal allows the use of most keywords after a “.”, similarly to how SE-0001 allows keywords are argument labels. [Idea] Allowing most keywords after “.” [Review] SE-0071: Allow (most) keywords in member references Motivation SE-0005 started lower-camel-casing importer enum cases, which created a number of enum types whose names conflict with keywords. For example: enum UITableViewCellStyle : Int { case `default ` case value1 case value2 case subtitle } enum SCNParticleImageSequenceAnimationMode : Int { case `repeat ` case clamp case autoReverse } The need to use back-ticks to declare the enumeration is not terribly onerous, especially given that these are Objective-C APIs with very-long names (UITableViewCellStyleDefault, SCNParticleImageSequenceAnimationModeRepeat). However, at the use site, the back-ticks are messy: let cell = UITableViewCell(style: .`default`, reuseIdentifier: nil) particleSystem.imageSequenceAnimationMode = SCNParticleImageSequenceAnimationMode.`repeat` Proposed solution Allow the use of keywords after the . in a member access, except for those keywords that have special meaning in the language: self, dynamicType, Type, Protocol, (note: this list should track the evolution of the actual language). For example, the above example would become: let cell = UITableViewCell(style: .default, reuseIdentifier: nil) particleSystem.imageSequenceAnimationMode = SCNParticleImageSequenceAnimationMode.repeat Impact on existing code This change doesn’t break any existing code; the back-ticks will continue to work as they always have. As we did with SE-0001, we can provide warnings with Fix-Its that remove spurious back-ticks at use sites. While not semantically interesting, this helps developers clean up their code.",
    "url": "http://localhost:4000/docs/2019-08-26-0071-member-keywords.html",
    "relUrl": "/docs/2019-08-26-0071-member-keywords.html"
  },
  "71": {
    "id": "71",
    "title": "SE-0072 Fully eliminate implicit bridging conversions from Swift",
    "content": "Fully eliminate implicit bridging conversions from Swift Proposal: SE-0072 Author: Joe Pamer Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#2419 Introduction In Swift 1.2, we attempted to remove all implicit bridging conversions from the language. Unfortunately, problems with how the v1.2 compiler imported various un-annotated Objective-C APIs caused us to scale back on our ambitions. In the interest of further simplifying our type system and our user model, we would like to complete this work and fully remove implicit bridging conversions from the language in Swift 3. This was discussed in this swift-evolution thread. Motivation Prior to Swift 1.2, conversions between bridged Swift value types and their associated Objective-C types could be implicitly inferred in both directions. For example, you could pass an NSString object to a function expecting a String value, and vice versa. In time we found this model to be less than perfect for a variety of reasons: Allowing implicit conversions between types that lack a subtype relationship felt wrong in the context of our type system. Importing Foundation would lead to subtle changes in how seemingly simple bodies of code were type checked. The specific rules implemented by the compiler to support implicit bridging conversions were complex and ad-hoc. Looking at the Swift code that had been written up until 1.2, these kinds of implicit conversions did not appear terribly common. (And where they were present, it wasn’t clear if users actually knew they were taking place.) In short, these conversions generally lead to a more confusing and unpredictable user model. So, for Swift 1.2, we sought to eliminate implicit bridging conversions entirely, and instead direct users to use explicit bridging casts in their place. (E.g., “nsStrObj as String”.) Unfortunately, when it came time to roll out these changes, we noticed that some native Objective-C APIs were now more difficult to work with in Swift 1.2. Specifically, because global Objective-C NSString* constants are imported into Swift as having type String, APIs that relied on string-constant lookups into dictionaries imported as [NSObject : AnyObject] failed to compile. For example: var s : NSAttributedString let SomeNSFontAttributeName : String // As per the importer. let attrs = s.attributesAtIndex(0, effectiveRange:nil) // In Swift 2, ‘attrs’ has type [NSObject : AnyObject] let fontName = attrs[SomeNSFontAttributeName] // This will fail to compile without an implicit conversion from String to NSString. For this reason, we decided to make a compromise. We would require explicit bridging casts when converting from a bridged Objective-C type to its associated Swift value type (E.g., NSString -&gt; String), but not the other way around. This would improve the status quo somewhat, and would also avoid breaking user code in a needless/painful fashion until we could get better API annotations in place. With the introduction of Objective-C generics last year, along with all of the awesome improvements to API importing happening for Swift 3, I think it’s time that we take another look at completing this work. Taking a look back at last year’s “problematic” APIs, all of them now surface richer type information when imported into Swift 3. As a result, the remaining implicit bridging conversions now feel far less necessary, since Objective-C APIs are now more commonly exposed in terms of their appropriate bridged Swift value types. (For instance, in Swift 3, the above reference to attrs will import as [String : AnyObject].) Proposed solution I propose that we fully eliminate implicit bridging conversions in Swift 3. This would mean that some users might have to introduce more explicit casts in their code, but we would remove another special case from Swift’s type system and be able to further simplify the compiler. Impact on existing code Code that previously relied on implicit conversions between Swift value types and their associated bridged Objective-C type will now require a manual coercion via an as cast.",
    "url": "http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html",
    "relUrl": "/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html"
  },
  "72": {
    "id": "72",
    "title": "SE-0073 Marking closures as executing exactly once",
    "content": "Marking closures as executing exactly once Proposal: SE-0073 Authors: Félix Cloutier, Gwendal Roué Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction This proposal introduces an optional once argument to the @noescape attribute. The @noescape(once) attribute enforces that the closure does not escape, and that it is run exactly once on any code path returning from the function. For clients, it allows the compiler to relax initialization requirements and close the gap between closure and “inline code” a little bit. Swift-evolution thread: Guaranteed closure execution Motivation In Swift, multiple functions execute a closure to temporarily grant code special guarantees. For instance, the standard library’s withUnsafePointer affords the closure with a pointer to an object’s representation, and the autoreleasepool function wraps a closure with code that creates (and later destroys) an autorelease pool. Currently, if you want to initialize a variable inside such a closure, you need to make it mutable and initially assign it a dummy value, because the compiler can’t prove that the function will execute the closure exactly once. For instance: var x: Int = 0 // `var` declaration, with some irrelevant value f { x = 1 } print(x) Proposed solution By adding the @noescape(once) attribute to the closure parameter, we tell the compiler that the function will be executed exactly once on any code path that leaves the function’s scope: func f(closure: @noescape(once) () -&gt; ()) { closure() } With this information, the compiler can now realize that the x variable will be written to exactly once. It can now be marked as a let variable: let x: Int // Not initialized f { x = 1 } print(x) // Guaranteed to be initialized This new form is safer and cleaner. @noescape(once) can also be seen as a natural extension to SE-0061 in that we go from: // Current Swift: var x: Int = 0 // `var` declaration, with some irrelevant value autoreleasepool { x = 1 } // Should SE-0061 be accepted: let x = autoreleasepool { return 1 } // Should this proposal be accepted: let x: Int let y: String autoreleasepool { x = 1 y = &quot;foo&quot; } Detailed design In addition to the regular advantages and constraints applied to @noescape parameters, @noescape(once) parameters must be called exactly once on any code path where the function returns. Specifically: it must either be called or passed as a @noescape(once) parameter to another function on any code path that returns normally; it must not be executed on any path that throws; there is no requirement for paths that lead to a function that does not return; passing it to another function that accepts a @noescape(once) closure of the same type is allowed and counts as executing it. A @noescape(once) closure may only read from variables that were initialized before it was formed. For instance, in an example with two @noescape(once) closures, the compiler cannot assume that one closure runs before the other. func f(a: @noescape(once) () -&gt; (), b: @noescape(once) () -&gt; ()) { /* snip */ } let x: Int f(a: {x = 1}, b: {print(x)}) // invalid: x has not been initialized A @noescape(once) closure may only be passed as a parameter to another function that accepts a @noescape(once) closure. In that case, it counts as having been called. A @noescape(once) closure may initialize let or var variables from its parent scope as if it was executed at the call site. Since SE-0049, @noescape is a type attribute. The @noescape(once) modifier marks the closure type as noescape. Impact on existing code This feature is purely additive. Existing code will continue to work as expected. Alternatives considered Not requiring exactly one execution Assuming that the main goal of this proposal is to relax initialization requirements, a unique invocation of the closure is not stricly required. However the requirement of unique invocation makes the proposal simpler to understand. A @once parameter It was mentioned in the discussion that the “once” behavior and @noescape look orthogonal, and the “once” behavior could be useful on closures that escape. However, it is only possible to verify that a closure has been executed exactly once if it does not escape. Because of this, “once” and @noescape are better left together. Calling on paths that throw It must either be guaranteed that the closure will be executed, or that it will not be executed, on a path that throws. It appears best to guarantee that it will not, since this allows the function to bail out without calling the closure in the event that it can’t provide the guarantee that it’s trying to get. For instance: do { let foo: Int try withLock(someLock, timeout: 0.5) { foo = sharedThing.foo } } catch { print(&quot;couldn&#39;t acquire lock fast enough&quot;) } A function like this would be awkward to express if the closure had to test a parameter to tell if the lock was acquired or not. Future directions As soon as a method does not provide the @noescape(once) guarantee, it prevents all functions that call it from providing it (see detailed design above). The value of this proposal will thus be hampered until methods and functions in the standard and core libraries that can provide this guarantee adopt @noescape(once). This includes (full list to be done): autoreleasepool withUnsafeBufferPointer dispatch_sync et al. Those modifications to standard and core libraries will however be part of future proposals. Rationale On May 11, 2016, the core team decided to Reject this proposal for Swift 3. The feedback on the proposal was generally positive both from the community and core team. That said, it is being rejected for Swift 3 two reasons: 1) The surface level syntax of @noescape needs to be reconsidered. At the minimum, we need to rename @noescape to @nonescaping for consistency with our previously agreed attribute naming scheme. However, it is also work discussing whether @nonescaping should be the default: if so, the attribute should actually become @escaping, and the functionality proposed in SE-0073 would be named @once. 2) Separate from the surface level issues, the implementation underlying this work has some significant challenges that are doable but would require major engineering work. Specifically, the definite initialization pass needs to “codegen” booleans in some cases for conditional initialization/overwrite cases, and these state values would have to be added to closure capture lists. This would require enough engineering work that it seems unlikely that it would happen in the Swift 3 timeframe, and beyond that this could theoretically be subsumed into a more general system that allowed control-flow-like functions to have closures that break/continue/throw/return out of their enclosing function, or a general macro system. Overall, everyone desires the ability to produce more control-flow like functions, but Swift 3 isn’t in a place where it can make sense to tackle this work.",
    "url": "http://localhost:4000/docs/2019-08-26-0073-noescape-once.html",
    "relUrl": "/docs/2019-08-26-0073-noescape-once.html"
  },
  "73": {
    "id": "73",
    "title": "SE-0074 Implementation of Binary Search functions",
    "content": "Implementation of Binary Search functions Proposal: SE-0074 Authors: Lorenzo Racca, Jeff Hajewski, Nate Cook Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction Swift does not offer any way to efficiently search sorted collections. This proposal seeks to add a few different functions that implement the binary search algorithm. Swift-evolution thread: [Proposal] Add Binary Search functions to SequenceType JIRA: Swift/SR-368 Motivation Searching through wide arrays (more than 100k elements) is inherently inefficient as the existing Sequence.contains(_:) performs a linear search that has to test the given condition for every element of the array. Storing data in a sorted array would typically improve the efficiency of this search from O(n) to O(log n) by allowing a binary search algorithm that cuts the search space in half with each iteration. Unfortunately, the standard library has no built-in ability to search on a collection that is known to be sorted. Proposed solution The proposed solution is to add three new methods that implement the binary search algorithm, called partitionedIndex(where:), sortedIndex(of:), and sortedRange(of:), as well as a partitioning method called partition(where:). These methods would be added to the Collection protocol as default implementations. To support future sorted collections, this proposal also suggests the addition of customization points for contains(_:) and index(of:) for collections with Comparable elements: Sequence._customContainsComparableElement(_:) and Collection._customIndexOfComparableElement(_:). Finally, this proposal suggests the removal of the two existing partition() methods from public API, as they are not as generally useful as the proposed partition(where:) method and are subsumed by the new functionality. The following arrays will be used in the examples below: let a = [10, 20, 30, 30, 30, 40, 60] let r = [60, 40, 30, 30, 30, 20, 10] // i.e., a.reversed() partitionedIndex(where:) accepts a unary predicate and returns the index of the first value in the collection that does not satisfy the predicate. The elements of the collection must already be partitioned by the predicate. This method corresponds with partition_point in the C++11 STL. a.partitionedIndex(where: { $0 &lt; 20 }) // 1 If you have a binary (two-argument) predicate, like &lt;, you can construct unary predicates for partitionedIndex(where:) that find the lower and upper bound for a given value: a.partitionedIndex(where: { $0 &lt; 30 }) // 2 - lower bound a.partitionedIndex(where: { !(30 &lt; $0) }) // 5 - upper bound sortedIndex(of:) finds the position of a given value in a sorted collection. If the value isn’t found, the method returns nil. An additional version of the method takes a value and a binary isOrderedBefore closure. This method loosely corresponds with binary_search in the C++ STL, but returns the value’s index if found, rather than just true. a.sortedIndex(of: 30) // 2 a.sortedIndex(of: 60) // 6 a.sortedIndex(of: 100) // nil r.sortedIndex(of: 60, isOrderedBefore: &gt;) // 0 sortedRange(of:) finds the range of all consecutive elements that are equivalent to a given value. If the value isn’t found, the range is empty with lowerBound(value) as its startIndex. An additional version of the method takes a value and a binary isOrderedBefore closure. This method corresponds with equal_range in the C++ STL. a.sortedRange(of: 30) // 2..&lt;5 a.sortedRange(of: 50) // 6..&lt;6 partition(where:) is a mutating method that accepts a unary (one-argument) predicate. The elements of the collection are partitioned according to the predicate, so that there is a pivot index p where every element before p matches the predicate and every element at and after p doesn’t match the predicate. This method corresponds with partition in the C++ STL. var n = [30, 40, 20, 30, 30, 60, 10] let p = n.partition(where: { $0 &lt; 30 }) // n == [30, 20, 30, 30, 10, 40, 60] // p == 5 After partitioning, the predicate returns true for every element in n.prefix(upTo: p) and false for every element in n.suffix(from: p). Detailed design The proposed APIs are collected here: extension MutableCollection { /// Reorders the elements of the collection such that all the /// elements that match the predicate are ordered before all the /// elements that do not match the predicate. /// /// - Returns: The index of the first element in the reordered /// collection that does not match the predicate. @discardableResult mutating func partition( where predicate: @noescape (Iterator.Element) throws-&gt; Bool ) rethrows -&gt; Index } extension Collection { /// Returns the index of the first element in the collection /// that doesn&#39;t match the predicate. /// /// The collection must already be partitioned according to the /// predicate, as if `x.partition(where: predicate)` had already /// been called. func partitionedIndex( where predicate: @noescape (Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Index var low = self.startIndex, high = self.endIndex while low != high { let mid = index(low, offsetBy: distance(from: low, to: high) / 2) if try predicate(self[mid]) { low = index(after: mid) } else { high = mid } } return low } /// Returns the index of `element`, using `isOrderedBefore` as the /// comparison predicate while performing a binary search. /// /// The elements of the collection must already be sorted according /// to `isOrderedBefore`, or at least partitioned by `element`. /// /// - Returns: The index of `element`, or `nil` if `element` isn&#39;t /// found. func sortedIndex(of element: Iterator.Element, isOrderedBefore: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Index? { let index = try self.partitionedIndex({ try isOrderedBefore($0, element) }) return try (index != self.endIndex) &amp;&amp; !isOrderedBefore(element, self[index]) ? index : nil } /// Returns the range of elements equivalent to `element`, using /// `isOrderedBefore` as the comparison predicate while performing /// a binary search. /// /// The elements of the collection must already be sorted according /// to `isOrderedBefore`, or at least partitioned by `element`. /// /// - Returns: The range of indices corresponding with elements /// equivalent to `element`, or an empty range with its /// `startIndex` equal to the insertion point for `element`. func sortedRange(of element: Iterator.Element, isOrderedBefore: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Range&lt;Index&gt; } extension Collection where Iterator.Element: Comparable { /// Returns the index of `element`, performing a binary search. /// /// The elements of the collection must already be sorted, or at /// least partitioned by `element`. /// /// - Returns: The index of `element`, or `nil` if `element` isn&#39;t /// found. func sortedIndex(of element: Iterator.Element) -&gt; Index? /// Returns the range of elements equal to `element`, performing /// a binary search. /// /// The elements of the collection must already be sorted, or at /// least partitioned by `element`. /// /// - Returns: The range of indices corresponding with elements /// equal to `element`, or an empty range with its `startIndex` /// equal to the insertion point for `element`. func sortedRange(of element: Iterator.Element) -&gt; Range&lt;Index&gt; } The customization points will need to be added to the protocol declarations for Sequence and Collection, with default implementations that simply return nil. protocol Sequence { // existing Sequence declarations... /// Returns `Optional(true)` if an element was found; /// `Optional(false)` if an element was searched for but not found; /// `nil` otherwise. func _customContainsComparableElement(element: Iterator.Element) -&gt; Bool? } extension Sequence { func _customContainsComparableElement(element: Iterator.Element) -&gt; Bool? { return nil } } protocol Collection { // existing Collection declarations... /// Returns `Optional(Optional(index))` if an element was found; /// `Optional(nil)` if an element was searched for but not found; /// `nil` otherwise. func _customIndexOfComparableElement(element: Iterator.Element) -&gt; Index?? } extension Collection { func _customIndexOfComparableElement(element: Iterator.Element) -&gt; Index?? { return nil } } Example usage As an example of how the partitionedIndex(of:) method enables heterogeneous binary search, this SortedDictionary type uses an array of (Word, Definition) tuples as its storage, sorted by Word. Better explained examples can be found in the Swift playground available here to download. struct SortedDictionary&lt;Word: Comparable, Definition&gt;: Collection, DictionaryLiteralConvertible { var _storage: [(word: Word, definition: Definition)] // Collection var startIndex: Int { return _storage.startIndex } var endIndex: Int { return _storage.endIndex } subscript(index: Int) -&gt; (word: Word, definition: Definition) { return _storage[index] } // DictionaryLiteralConvertible init(dictionaryLiteral elements: (Word, Definition)...) { self._storage = elements .sorted { $0.0 &lt; $1.0 } .map { (word: $0, definition: $1) } } // key/value access subscript(word: Word) -&gt; Definition? { get { let i = _storage.partitionedIndex(where: { $0.word &lt; word }) if i != endIndex &amp;&amp; _storage[i].word == word { return _storage[i].definition } return nil } set { // find insertion point let i = _storage.partitionedIndex(where: { $0.word &lt; word }) if i != endIndex &amp;&amp; _storage[i].word == word { // update or delete if let newValue = newValue { _storage[i].definition = newValue } else { _storage.remove(at: i) } } else if let newValue = newValue { // insert _storage.insert((word, newValue), at: i) } } } } Impact on existing code The impact of the change will be the availability of four (plus overloads) functions implementing partitioning and binary search and the removal of the existing partition methods. Removal of partition() / partition(isOrderedBefore:) The current partition() methods, which partition on the value of the first element of a collection, are used by the standard library’s current sorting algorithm but don’t offer the more general partitioning functionality of the proposed partition(where:) method. If this proposal is accepted without removing the existing methods, there would be three partition methods available, which seems excessive: partition(isOrderedBefore:) partition() (an overload of partition(isOrderedBefore:) for Comparable elements) partition(where:) Uses of the existing partition() methods could be flagged or in theory be replaced programmatically. The replacement code, on a mutable collection c: // old c.partition() // new if let first = c.first { c.partition(where: { $0 &lt; first }) } A thorough, though not exhaustive, search of GitHub for the existing partition method found no real evidence of its use. The discovered uses of a partition method were mainly tests from the Swift project and third-party implementations similar to the one proposed. Alternatives considered The authors considered a few alternatives to the current proposal: lower_bound / upper_bound: The C++ STL includes two functions that help when searching sorted collections and when sorting or merging. However, both are subsumed by the functionality of partition_point and its unary predicate, and as such are not needed. Whether these methods should accept unary or binary predicates was also a matter of discussion. binary_search: The STL function analogous to the proposed sortedIndex(of:) method returns only a Boolean value. We determined that a method returning an optional index was more useful: the .none case conveys “not found”, and the returned index (when found) provides easy access to the matched element. Rationale On May 11, 2016, the core team decided to Reject this proposal. The feedback on the proposal was generally positive about the concept of adding binary search functionality, but negative about the proposal as written, with feedback that it was adding too much complexity to the API.",
    "url": "http://localhost:4000/docs/2019-08-26-0074-binary-search.html",
    "relUrl": "/docs/2019-08-26-0074-binary-search.html"
  },
  "74": {
    "id": "74",
    "title": "SE-0075 Adding a Build Configuration Import Test",
    "content": "Adding a Build Configuration Import Test Proposal: SE-0075 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 4.1) Decision Notes: Rationale Bug: SR-1560 Introduction Expanding the build configuration suite to test for the ability to import certain modules was first introduced on the Swift-Evolution list by Lily Ballard. Although her initial idea (checking for Darwin to differentiate Apple targets from non-Apple targets) proved problematic, developers warmly greeted the notion of an import-based configuration test. Dmitri Gribenko wrote, “There’s a direction that we want to move to a unified name for the libc module for all platform, so ‘can import Darwin’ might not be a viable long-term strategy.” Testing for imports offers advantages that stand apart from this one use-case: to test for API availability before use. Swift Evolution Review Thread Motivation Swift’s existing set of build configurations specify platform differences, not module commonalities. For example, UIKit enables you to write view code supported on both iOS and tvOS. SpriteKit allows common code to render on OS X, iOS, and tvOS that would require an alternate UI on Linux. Testing for Metal support or Media Player would guard code that will not function on the simulator. If the simulator adopted these modules at some future time, the code would naturally expand to provide compatible execution without source modification. #if canImport(UIKit) // UIKit-based code #elseif canImport(Cocoa) // OSX code #elseif // Workaround/text, whatever #endif Guarding code with operating system tests can be less future-proofed than testing for module support. Excluding OS X to use UIColor creates code that might eventually find its way to a Linux plaform. Targeting Apple platforms by inverting a test for Linux essentially broke after the introduction of Windows and FreeBSD build configurations: // Exclusive os tests are brittle #if !os(Linux) // Matches OSX, iOS, watchOS, tvOS, Windows, FreeBSD #endif Inclusive OS tests (if os1 || os2 || os3…) must be audited each time the set of possible platforms expands. In addition, compound build statements are harder to write, to validate, and are more confusing to read. They are more prone to errors than a single test that’s tied to the API capabilities used by the code it guards. Evan Maloney writes, “Being able to test for the importability of a given module/framework at runtime would be extremely helpful. We use several frameworks that are only available in a subset of the platforms we support, and on only certain OS versions. To work around this problem now, we dynamically load frameworks from Obj-C only when we’re running on an OS version we know is supported by the framework(s) in question. We can’t dynamically load them from Swift because if they’re included in an import, the runtime tries to load it right away, leading to a crash on any unsupported platform. The only way to selectively load dynamic frameworks at runtime is to do it via Obj-C. Some sort of check like the ones you propose should let us avoid this.” Detail Design #if canImport(module-name) tests for module support by name. My proposed name uses lower camelCase, which is not currently used in the current build configuration vocabulary but is (in my opinion) clearer in intention than the other two terms brought up on the evolution list, #if imports() and #if supports(). This build configuration does not import the module it names. A test whose body performs the import may be separated from other tests whose code use the framework. This is why the call does not import. This build configuration is intended to differentiate API access and not to detect platforms. The supplied module token is an arbitrary string. It does not belong to an enumerated set of known members as this configuration test is intended for use with both first and third party modules for the greatest flexibility. At compile time, Swift determines whether the module can or cannot be linked and builds accordingly. #if canImport(module) import module // use module APIs safely #endif #if canImport(module) // provide solution with module APIs #else // provide alternative solution that does not depend on that module #endif Current Art Swift currently supports the following configuration tests: The literals true and false The os() function that tests for OSX, iOS, watchOS, tvOS, Linux, Windows, and FreeBSD The arch() function that tests for x86_64, arm, arm64, i386, powerpc64, and powerpc64le The swift() function that tests for specific Swift language releases, e.g. swift(&gt;=2.2) Chris Lattner writes, “[T]his is directly analogous to the Clang extension __has_include. __has_include has been useful, and the C++ committee is discussing standardizing the functionality there.” Further details about include file checking can be found on the clang.llvm.org site. Alternatives Considered There are no alternatives considered.",
    "url": "http://localhost:4000/docs/2019-08-26-0075-import-test.html",
    "relUrl": "/docs/2019-08-26-0075-import-test.html"
  },
  "75": {
    "id": "75",
    "title": "SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer",
    "content": "Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer Proposal: SE-0076 Author: Janosch Hildebrand Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1490 Introduction UnsafeMutablePointer includes several methods to non-destructively copy elements from memory pointed to by another UnsafeMutablePointer instance. I propose adding overloads of these methods to UnsafeMutablePointer that allow an UnsafePointer source. Swift-evolution thread: [Pitch] Add overrides with UnsafePointer sources to non-destructive copying methods on UnsafeMutablePointer Motivation To copy values from memory pointed to by an UnsafePointer it is currently necessary to perform a cast to UnsafeMutablePointer beforehand: let source: UnsafePointer&lt;Int&gt; = ... let destination: UnsafeMutablePointer&lt;Int&gt; = ... // Today: destination.assignFrom(UnsafeMutablePointer(source), count: count) These casts are unnecessary visual noise as non-destructively copying from an UnsafePointer source is perfectly safe. Furthermore, these casts are a source of confusion and increased cognitive load on a reader since any such cast is likely to throw up a red flag at first. Proposed solution In addition to these existing methods on UnsafeMutablePointer: func assignBackwardFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int) func assignFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int) func initializeFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int) I propose adding the following overloads: func assignBackwardFrom(source: UnsafePointer&lt;Pointee&gt;, count: Int) func assignFrom(source: UnsafePointer&lt;Pointee&gt;, count: Int) func initializeFrom(source: UnsafePointer&lt;Pointee&gt;, count: Int) This would transform the given example as follows: let source: UnsafePointer&lt;Int&gt; = ... let destination: UnsafeMutablePointer&lt;Int&gt; = ... // Today: destination.assignFrom(UnsafeMutablePointer(source), count: count) // This proposal: destination.assignFrom(source, count: count) Detailed design The following methods are added to UnsafeMutablePointer: /// Assign from `count` values beginning at source into initialized /// memory, proceeding from the first element to the last. public func assignFrom(source: UnsafePointer&lt;Pointee&gt;, count: Int) /// Assign from `count` values beginning at `source` into /// initialized memory, proceeding from the last value to the first. /// Use this for assigning ranges into later memory that may overlap /// with the source range. /// /// - Requires: Either `source` precedes `self` or follows `self + count`. public func assignBackwardFrom(source: UnsafePointer&lt;Pointee&gt;, count: Int) /// Copy `count` values beginning at source into raw memory. /// /// - Precondition: The memory is not initialized. /// /// - Requires: `self` and `source` may not overlap. public func initializeFrom(source: UnsafePointer&lt;Pointee&gt;, count: Int) Impact on existing code This proposal is additive and does not impact existing code. Alternatives considered Keep the status quo: I’d argue that they provide enough benefit to justify their existence while only minimally increasing the stdlib surface area, especially by merit of being overloads. Introduce a PointerProtocol protocol: A common protocol could be used to avoid the need for overloads in this case. However, without additional use cases this seems like severe over-engineering for this simple issue. This would also require a lot more design work, performance considerations, etc… Leverage implicit conversions: The implicit conversions from UnsafeMutablePointer to UnsafePointer could be leveraged to work around the need for overloads by dropping the existing methods taking UnsafeMutablePointer source arguments. Adding explicit overloads seems a better solution than depending on compiler magic and is clearer from a documentation and auto-completion perspective.",
    "url": "http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html",
    "relUrl": "/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html"
  },
  "76": {
    "id": "76",
    "title": "SE-0077 Improved operator declarations",
    "content": "Improved operator declarations Proposal: SE-0077 Author: Anton Zhilin Review Manager: Joe Groff Status: Implemented (Swift 3) Decision Notes: Rationale Revision history v1 Initial version v2 After the first review v3 After the second review Introduction Replace syntax of operator declaration, and replace numerical precedence with partial ordering of operators: // Before infix operator &lt;&gt; { precedence 100 associativity left } // After precedencegroup ComparisonPrecedence { associativity: left higherThan: LogicalConjunctionPrecedence } infix operator &lt;&gt; : ComparisonPrecedence Swift-evolution discussion thread Motivation Problems with numeric definition of precedence In the beginning, operators had nice precedence values: 90, 100, 110, 120, 130, 140, 150, 160. As time went, new and new operators were introduced. Precedence could not be simply changed, as this would be a breaking change. Ranges got precedence 135, as got precedence 132. ?? had precedence greater than &lt;, but less than as, so it had to be given precedence 131. Now it is not possible to insert any custom operator between &lt; and ??. It is an inevitable consequence of current design: it will be impossible to insert an operator between two existing ones at some point. Problems with a single precedence hierarchy Currently, if an operator needs to define precedence by comparison to one operator, it must do so for all other operators. In many cases, this is undesirable. For example, a &amp; b &lt; c and a / b as Double are common error patterns. C++ compilers sometimes emit warnings on these, but Swift does not. The root of the problem is that precedence is currently defined for any pair of operators. If &amp; had its precedence defined only in relation to other bitwise operators and / – only to arithmetic operators, we would have to use parentheses in the preceding examples. This would avoid subtle bugs. Problems with current operator declaration syntax Current operator declaration syntax is basically an unstructured bag of words. This proposal appempts to make it at least partially consistent with other Swift declarations. Proposed solution Syntax for declaration of operators and groups Operator declarations no longer have body: prefix operator ! infix operator + Precedence groups declare optional associativity (left or right). Infix operators can be included in a single precedence group using inheritance-like syntax: precedencegroup Additive { associativity: left } infix operator + : Additive infix operator - : Additive Precedence mechanism Concept of a single precedence hierarchy is removed. Instead, to omit parentheses in expression with two neighbouring infix operators, precedence relationship must be defined between their precedence groups. It is performed by adding higherThan clause, see example: precedencegroup Additive { associativity: left } precedencegroup Multiplicative { associativity: left higherThan: Additive } precedencegroup BitwiseAnd { associativity: left } infix operator + : Additive infix operator * : Multiplicative infix operator &amp; : BitwiseAnd 1 + 2 * 3 // ok, precedence of * is greater than precedence of + 1 + 2 &amp; 3 // error, precedence between + and &amp; is not defined Only one declaration of the same operator / precedence group is allowed, meaning that new precedence relationships between existing groups cannot be added. Transitive precedence propagation Compiler will apply transitivity axiom to compare precedence of two given precedence groups. Example: precedencegroup Exponentiative { associativity: left higherThan: Multiplicative } infix operator ** : Exponentiative 1 + 2 ** 3 // same as 1 + (2 ** 3) Here, Exponentiative &gt; Multiplicative and Multiplicative &gt; Additive imply Exponentiative &gt; Additive. Multiple precedence relationships can be stated for a single precedence group. DefaultPrecedence If infix operator does not state group that it belongs to, it is assigned to DefaultPrecedence group, which is defined as follows: precedencegroup DefaultPrecedence { higherThan: Ternary } The following two statements are equivalent: infix operator |&gt; : DefaultPrecedence infix operator |&gt; assignment Swift 2.2 has assignment modifier that works as follows: an operator marked assignment gets folded into an optional chain, allowing foo?.bar += 2 to work as foo?(.bar += 2) instead of failing to type-check as (foo?.bar) += 2. This behavior will be passed to assignment: true on precedence groups. lowerThan relationship There are times when we want to insert an operator below an existing one. If that existing operator resides in another module, we can use lowerThan relationship. Example: // module Swift precedencegroup Additive { higherThan: Range } precedencegroup Multiplicative { higherThan: Additive } // module A precedencegroup Equivalence { higherThan: Comparative lowerThan: Additive // possible, because Additive lies in another module } infix operator ~ : Equivalence 1 + 2 ~ 3 // same as (1 + 2) ~ 3, because Additive &gt; Equivalence 1 * 2 ~ 3 // same as (1 * 2) ~ 3, because Multiplicative &gt; Additive &gt; Equivalence 1 &lt; 2 ~ 3 // same as 1 &lt; (2 ~ 3), because Equivalence &gt; Comparative 1 += 2 ~ 3 // same as 1 += (2 ~ 3), because Equivalence &gt; Comparative &gt; Assignment 1 ... 2 ~ 3 // error, because Range and Equivalence are unrelated Detailed design Precedence rules Relationships between precedence groups form a Directed Acyclic Graph. Fetching precedence relationship between given operators is equivalent to problem of Reachability. Transitivity check All precedence relationships must be transitive. If we define A &lt; B, B &lt; C and A &gt; C, it will be a compilation error. Two examples: precedencegroup A { higherThan: B } precedencegroup B { higherThan: A } // A &gt; B &gt; A precedencegroup A { } precedencegroup B { higherThan: A } precedencegroup C { higherThan: B lowerThan: A } // C &gt; B &gt; A &gt; C Checking for such situations is equivalent to checking whether DAG of precedence groups contains directed loops. Joining unrelated precedence groups Precedence relationships that, by transitivity rule, create relationship between two imported groups, is an error. Example: // Module X precedencegroup A { } precedencegroup C { } // Module Y import X precedencegroup B { higherThan: A lowerThan: C } This results in compilation error “B uses transitivity to define relationship between imported groups A and C”. The rationale behind this is that otherwise one can create relationships between standard precedence groups that are confusing for the reader. Special operators Built-ins is, as, as?, as!, =, ?: have stated precedence, but cannot be declared using Swift syntax. They will be hardcoded in the compiler and assigned to appropriate precedence groups, as if the following declarations took place: // NOT valid Swift infix operator is : CastingPrecedence infix operator as : CastingPrecedence infix operator as? : CastingPrecedence infix operator as! : CastingPrecedence infix operator ?: : TernaryPrecedence infix operator = : AssignmentPrecedence Grammar assignment and precedence local keywords will be removed. precedencegroup keyword, and higherThan, lowerThan local keywords will be added. operator-declaration → prefix-operator-declaration postfix-operator-declaration infix-operator-declaration prefix-operator-declaration → prefix operator operator postfix-operator-declaration → postfix operator operator infix-operator-declaration → infix operator operator infix-operator-groupopt infix-operator-group → : precedence-group-name precedence-group-declaration → precedencegroup precedence-group-name { precedence-group-attributes } precedence-group-attributes → precedence-group-assignmentopt precedence-group-associativityopt precedence-group-relationsopt precedence-group-assignment → assignment : boolean-literal precedence-group-associativity → associativity : precedence-group-associativity-option precedence-group-associativity-option → left right precedence-group-relations → precedence-group-relation precedence-group-relation precedence-group-relations precedence-group-relation → higherThan : precedence-group-name precedence-group-relation → lowerThan : precedence-group-name precedence-group-name → identifier Standard library changes precedencegroup AssignmentPrecedence { assignment: true associativity: right } precedencegroup TernaryPrecedence { associativity: right higherThan: AssignmentPrecedence } precedencegroup DefaultPrecedence { higherThan: TernaryPrecedence } precedencegroup LogicalDisjunctionPrecedence { associativity: left higherThan: TernaryPrecedence } precedencegroup LogicalConjunctionPrecedence { associativity: left higherThan: LogicalDisjunctionPrecedence } precedencegroup ComparisonPrecedence { higherThan: LogicalConjunctionPrecedence } precedencegroup NilCoalescingPrecedence { associativity: right higherThan: ComparisonPrecedence } precedencegroup CastingPrecedence { higherThan: NilCoalescingPrecedence } precedencegroup RangeFormationPrecedence { higherThan: CastingPrecedence } precedencegroup AdditionPrecedence { associativity: left higherThan: RangeFormationPrecedence } precedencegroup MultiplicationPrecedence { associativity: left higherThan: AdditionPrecedence } precedencegroup BitwiseShiftPrecedence { higherThan: MultiplicationPrecedence } postfix operator ++ postfix operator -- // postfix operator ! prefix operator ++ prefix operator -- prefix operator ! prefix operator ~ prefix operator + prefix operator - // infix operator = : AssignmentPrecedence infix operator *= : AssignmentPrecedence infix operator /= : AssignmentPrecedence infix operator %= : AssignmentPrecedence infix operator += : AssignmentPrecedence infix operator -= : AssignmentPrecedence infix operator &lt;&lt;= : AssignmentPrecedence infix operator &gt;&gt;= : AssignmentPrecedence infix operator &amp;= : AssignmentPrecedence infix operator ^= : AssignmentPrecedence infix operator |= : AssignmentPrecedence // infix operator ?: : TernaryPrecedence infix operator || : LogicalDisjunctionPrecedence infix operator &amp;&amp; : LogicalConjunctionPrecedence infix operator &lt; : ComparisonPrecedence infix operator &lt;= : ComparisonPrecedence infix operator &gt; : ComparisonPrecedence infix operator &gt;= : ComparisonPrecedence infix operator == : ComparisonPrecedence infix operator != : ComparisonPrecedence infix operator === : ComparisonPrecedence infix operator !== : ComparisonPrecedence infix operator ~= : ComparisonPrecedence infix operator ?? : NilCoalescingPrecedence // infix operator as : CastingPrecedence // infix operator as? : CastingPrecedence // infix operator as! : CastingPrecedence // infix operator is : CastingPrecedence infix operator ..&lt; : RangeFormationPrecedence infix operator ... : RangeFormationPrecedence infix operator + : AdditionPrecedence infix operator - : AdditionPrecedence infix operator &amp;+ : AdditionPrecedence infix operator &amp;- : AdditionPrecedence infix operator | : AdditionPrecedence infix operator ^ : AdditionPrecedence infix operator * : MultiplicationPrecedence infix operator / : MultiplicationPrecedence infix operator % : MultiplicationPrecedence infix operator &amp;* : MultiplicationPrecedence infix operator &amp; : MultiplicationPrecedence infix operator &lt;&lt; : BitwiseShiftPrecedence infix operator &gt;&gt; : BitwiseShiftPrecedence Impact on existing code Standard library operator declarations will be rewritten, and precedence groups will be added. User defined operators will need to be rewritten as well. Migration tool will remove bodies of operator declarations. infix operators will be implicitly added to DefaultPrecedence group. Code, which relies on precedence relations of user-defined operators being implicitly defined, may be broken. This will need to be fixed manually by adding them to desired precedence group. Future directions Change precedence of the Standard Library operators Actually, this is one of the main reasons why this proposal was created: break single hierarchy of operators from Standard Library. But this will be the topic of another proposal, because separate discussion is needed. Alternatives considered Declare associativity and precedence separately associativity Multiplicative left precedence Multiplicative &gt; Additive precedence Exponentiative &gt; Multiplicative Appearance of precedence group name in any of these “declarations” would mean declaration of the precedence group. Precedence relationship declaration would only allow &gt; sign for consistency. Limitations on connecting unrelated imported groups could still hold. Do not use precedence groups It would make each operator define precedence relationships. The graph of relationships would be considerably larger and less understandable in this case. Precedence groups concept would still be present, but it would make one operator in each group “privileged”: precedence - = + precedence &amp;+ = + precedence / = * precedence % = * precedence * &gt; + Use meta-circular syntax That is, if a constant is of special type, then it will be used only at compile time: struct PrecedenceGroup { enum Associativity { case left, right, none } let associativity: Associativity let higherThan: [StaticString] let lowerThan: [StaticString] } let Multiplicative = PrecedenceGroup(.left, [Associativity], []) This is already strongly library-determined. The library defines what operators exist and defines their precedence w.r.t. each other and a small number of built-in operators. Operator precedence has to be communicated to the compiler somehow in order to parse code. This proposal is just deciding the syntax of that communication. I see no reason to use a more conceptually complex approach when a simple declaration will do. – John McCall Replace error with warning in “joining unrelated precedence groups” Simplify language model and reduce burden on compilers When a precedence hierarchy is broken by some update, developers can use “a quick hack” to join all the groups together and get their code up-and-running immediately Replace precedencegroup with precedence Pros: Looks shorter, less bulky Declarations use same naming style as protocols Cons: Need to take precedence as a keyword precedencegroup more precisely represents what it declares Possible syntax variations Instead of higherThan and lowerThan, there could be: above and below upper and lower greaterThan and lessThan strongerThan and weakerThan gt and lt before and after Instead of associativity, there could be associate. precedence Multiplicative { associativity(left) precedence(&gt; Additive) precedence(&lt; Exponentiative) } precedence Multiplicative { associativity: left precedence: higherThan(Additive) precedence: lowerThan(Exponentiative) } precedence Multiplicative { associativity(left) higherThan(Additive) lowerThan(Exponentiative) } precedence Multiplicative { associativity: left, higherThan: Additive, lowerThan: Exponentiative } precedence Multiplicative { associativity left higherThan Additive lowerThan Exponentiative } precedence Multiplicative { associativity left &gt; Additive &lt; Exponentiative } precedence Multiplicative : associativity(left), higherThan(Additive), lowerThan(Exponentiative) precedence Multiplicative : associativity left, higherThan Additive, lowerThan Exponentiative precedence Multiplicative &gt; Additive, &lt; Exponentiative, associativity left precedence left Multiplicative &gt; Additive, &lt; Exponentiative precedence associativity(left) Multiplicative &gt; Additive, &lt; Exponentiative // Only `&gt;` relationships, associativity goes last precedence Multiplicative : Additive, left // Full syntax for complex cases precedence Multiplicative { associativity left higherThan Additive lowerThan Exponentiative } // Only `&gt;` relationships, associativity goes last precedence Multiplicative &gt; Additive, left // Full syntax for complex cases precedence Multiplicative { associativity left &gt; Additive &lt; Exponentiative }",
    "url": "http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html",
    "relUrl": "/docs/2019-08-26-0077-operator-precedence.html"
  },
  "77": {
    "id": "77",
    "title": "SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++",
    "content": "Implement a rotate algorithm, equivalent to std::rotate() in C++ Proposal: SE-0078 Authors: Nate Cook, Sergey Bolshedvorsky Review Manager: Chris Lattner Status: Deferred Decision Notes: Rationale Previous Revisions: 1, 2 Introduction This proposal is to add rotation and in-place reversing methods to Swift’s standard library collections. Swift-evolution thread, Proposal review feedback Motivation Rotation is one of the most important algorithms. It is a fundamental tool used in many other algorithms with applications even in GUI programming. The “rotate” algorithm performs a left rotation on a range of elements. Specifically, it swaps the elements in the range startIndex..&lt;endIndex according to a middle index in such a way that the element at middle becomes the first element of the new range and middle - 1 becomes the last element. The result of the algorithm is the new index of the element that was originally first in the collection. var a = [10, 20, 30, 40, 50, 60, 70] let i = a.rotate(shiftingToStart: 2) // a == [30, 40, 50, 60, 70, 10, 20] // i == 5 The index returned from a rotation can be used as the middle argument in a second rotation to return the collection to its original state, like this: a.rotate(shiftingToStart: i) // a == [10, 20, 30, 40, 50, 60, 70] There are three different versions of the rotate algorithm, optimized for collections with forward, bidirectional, and random access indices. The complexity of the implementation of these algorithms makes the generic rotate algorithm a perfect candidate for the standard library. **Example C++ Implementations** **Forward indices** are the simplest and most general type of index and support only one-directional traversal. The C++ implementation of the rotate algorithm for the `ForwardIterator` (`ForwardIndex` in Swift) may look like this: c++ template I rotate(I f, I m, I l, std::forward_iterator_tag) { if (f == m) return l; if (m == l) return f; pair&lt;I, I&gt; p = swap_ranges(f, m, m, l); while (p.first != m || p.second != l) { if (p.second == l) { rotate_unguarded(p.first, m, l); return p.first; } f = m; m = p.second; p = swap_ranges(f, m, m, l); } return m; } **Bidirectional indices** are a refinement of forward indices that additionally support reverse traversal. The C++ implementation of the rotate algorithm for the `BidirectionalIterator` (`BidirectionalIndex` in Swift) may look like this: c++ template I rotate(I f, I m, I l, bidirectional_iterator_tag) { reverse(f, m); reverse(m, l); pair&lt;I, I&gt; p = reverse_until(f, m, l); reverse(p.first, p.second); if (m == p.first) return p.second; return p.first; } **Random access indices** access to any element in constant time (both far and fast). The C++ implementation of the rotate algorithm for the `RandomAccessIterator` (`RandomAccessIndex` in Swift) may look like this: c++ template I rotate(I f, I m, I l, std::random_access_iterator_tag) { if (f == m) return l; if (m == l) return f; DifferenceType cycles = gcd(m - f, l - m); rotate_transform rotator(f, m, l); while (cycles-- &gt; 0) rotate_cycle_from(f + cycles, rotator); return rotator.m1; } &lt;/details&gt; ## Proposed solution The Swift standard library should provide generic implementations of the &quot;rotate&quot; algorithm for all three index types, in both mutating and nonmutating forms. The mutating form is called `rotate(shiftingToStart:)` and rotates the elements of a collection in-place. The nonmutating form of the &quot;rotate&quot; algorithm is called `rotated(shiftingToStart:)` and returns views onto the original collection with the elements rotated, preserving the level of the original collection&#39;s index type. In addition, since the rotate algorithm for bidirectional collections depends on reversing the collection&#39;s elements in-place, the standard library should also provide an in-place `reverse()` method to complement the existing nonmutating `reversed()` collection method. ## Detailed design #### `rotate(shiftingToStart:)` and `rotated(shiftingToStart:)` The mutating rotation method will be added to the `MutableCollection` protocol requirements, with traversal-specific default implementations. This will allow the correct algorithm to be selected even in a generic context. These methods will have the following declarations: swift protocol MutableCollection { // existing declarations /// Rotates the elements of the collection so that the element /// at `middle` ends up first. /// /// - Returns: The new index of the element that was first /// pre-rotation. /// - Complexity: O(*n*) @discardableResult public mutating func rotate(shiftingToStart middle: Index) -&gt; Index } extension MutableCollection { /// Rotates the elements of the collection so that the element /// at `middle` ends up first. /// /// - Returns: The new index of the element that was first /// pre-rotation. /// - Complexity: O(*n*) @discardableResult public mutating func rotate(shiftingToStart middle: Index) -&gt; Index } extension MutableCollection where Self: BidirectionalCollection { /// Rotates the elements of the collection so that the element /// at `middle` ends up first. /// /// - Returns: The new index of the element that was first /// pre-rotation. /// - Complexity: O(*n*) @discardableResult public mutating func rotate(shiftingToStart middle: Index) -&gt; Index } extension MutableCollection where Self: RandomAccessCollection { /// Reverses the elements of the collection in-place. public mutating func reverse() /// Rotates the elements of the collection so that the element /// at `middle` ends up first. /// /// - Returns: The new index of the element that was first /// pre-rotation. /// - Complexity: O(*n*) @discardableResult public mutating func rotate(shiftingToStart middle: Index) -&gt; Index } The nonmutating methods depend on three new specialized types: `RotatedCollection`, `RotatedBidirectionalCollection`, and `RotatedRandomAccessCollection`. These collections present a rotated view onto the elements of a collection without reallocating storage, and thus are able to do so in O(1) time. In addition to the standard `Collection` requirements, the rotated collections also define a `shiftedStartIndex` property that holds the rotated position of the base collection&#39;s `startIndex`. The three collections can share a single index type, `RotatedCollectionIndex`. swift /// A rotated view of an underlying collection. public struct RotatedCollection&lt;Base: Collection&gt;: Collection { // standard collection innards /// The shifted position of the base collection&#39;s `startIndex`. public var shiftedStartIndex: RotatedCollectionIndex } /// A rotated view of an underlying bidirectional collection. public struct RotatedBidirectionalCollection&lt;Base: BidirectionalCollection&gt;: BidirectionalCollection { // standard collection innards /// The shifted position of the base collection&#39;s `startIndex`. public var shiftedStartIndex: RotatedCollectionIndex } /// A rotated view of an underlying random-access collection. public struct RotatedRandomAccessCollection&lt;Base: RandomAccessCollection&gt;: RandomAccessCollection { // standard collection innards /// The shifted position of the base collection&#39;s `startIndex`. public var shiftedStartIndex: RotatedCollectionIndex } /// The index type for a `RotatedCollection`. public struct RotatedCollectionIndex&lt;Base: Comparable&gt;: Comparable { // standard index innards } extension Collection { /// Returns a rotated view of the elements of the collection, where the /// element at `middle` ends up first. /// /// - Complexity: O(1) func rotated(shiftingToStart middle: Index) -&gt; RotatedCollection } extension BidirectionalCollection { /// Returns a rotated view of the elements of the collection, where the /// element at `middle` ends up first. /// /// - Complexity: O(1) func rotated(shiftingToStart middle: Index) -&gt; RotatedBidirectionalCollection } extension RandomAccessCollection { /// Returns a rotated view of the elements of the collection, where the /// element at `middle` ends up first. /// /// - Complexity: O(1) func rotated(shiftingToStart middle: Index) -&gt; RotatedRandomAccessCollection } Lazy collections will also be extended with rotate methods that provide lazy rotation: swift extension LazyCollectionProtocol where Index == Elements.Index { /// Returns a lazy rotated view of the elements of the collection, where the /// element at `middle` ends up first. public func rotated(shiftingToStart middle: Elements.Index) -&gt; LazyCollection&lt;RotatedCollection&gt; } extension LazyCollectionProtocol where Index == Elements.Index, Self: BidirectionalCollection, Elements: BidirectionalCollection { /// Returns a lazy rotated view of the elements of the collection, where the /// element at `middle` ends up first. public func rotated(shiftingToStart middle: Elements.Index) -&gt; LazyBidirectionalCollection&lt;RotatedBidirectionalCollection&gt; } extension LazyCollectionProtocol where Index == Elements.Index, Self: RandomAccessCollection, Elements: RandomAccessCollection { /// Returns a lazy rotated view of the elements of the collection, where the /// element at `middle` ends up first. public func rotated(shiftingToStart middle: Elements.Index) -&gt; LazyRandomAccessCollection&lt;RotatedRandomAccessCollection&gt; } Rotation algorithms will be implemented in `stdlib/public/core/CollectionAlgorithms.swift`. The three rotated collection types and collection extensions will be implemented in `stdlib/public/core/Rotate.swift`. Tests will be implemented in `test/1_stdlib/Rotate.swift`. ## `reverse()` The new mutating `reverse()` method is added in an extension to `MutableCollection where Self: BidirectionalCollection`. swift extension MutableCollection where Self: BidirectionalCollection { /// Reverses the elements of the collection in place. /// /// - Complexity: O(*n*) public mutating func reverse() } ## Usage examples *In-place rotation:* swift var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] numbers.rotate(shiftingToStart: 3) expectEqual(numbers, [4, 5, 6, 7, 8, 9, 1, 2, 3]) var toMerge = [2, 4, 6, 8, 10, 3, 5, 7, 9] let i = toMerge[2..&lt;7].rotate(shiftingToStart: 5) expectEqual(toMerge, [2, 4, 3, 5, 6, 8, 10, 7, 9]) expectEqual(i, 4) *Nonmutating rotation:* swift let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] let r = numbers.rotated(shiftingToStart: 3) expectEqual(Array(r), [4, 5, 6, 7, 8, 9, 1, 2, 3]) expectEqual(r[r.shiftedStartIndex], 1) *Lazy rotation:* swift let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] let r = numbers.lazy.rotated(shiftingToStart: 3) expectEqual(r.first!, 4) *Reversing in place:* swift var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] numbers.reverse() expectEqual(numbers, [9, 8, 7, 6, 5, 4, 3, 2, 1]) numbers[0..&lt;5].reverse() expectEqual(numbers, [5, 6, 7, 8, 9, 4, 3, 2, 1]) ## Impact on existing code The rotation methods are an additive feature that doesn’t impact existing code. The addition of the mutating `reverse()` method makes it slightly more challenging to migrate from Swift 2, where `reverse()` is the nonmutating method. The renaming of the `sort()`/`sorted()`/`sortInPlace()` methods presents a similar challenge, and the compiler responses in that case (warning when assigning the result of a `Void` function, preventing mutating method calls on immutable instances) will help here as well. ## Alternatives considered The primary alternative is to not include these methods in the standard library, but the user will need to develop their custom implementation of the rotate algorithms tailored for their needs. The [first revision of this proposal][rev-1] used `firstFrom` as the parameter name for the `rotate` method and didn&#39;t add either `rotate` or `reverse` as protocol requirements. In addition, the `RotatedCollection` type was only used for random-access collections—other collections used the existing `FlattenCollection` instead. [Another version][rev-2] also made the `reverse()` method choose different algorithms for bidirectional and random-access collections. Without evidence that this would offer a significant performance benefit, this aspect of the proposal has been removed.",
    "url": "http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html",
    "relUrl": "/docs/2019-08-26-0078-rotate-algorithm.html"
  },
  "78": {
    "id": "78",
    "title": "SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference",
    "content": "Allow using optional binding to upgrade self from a weak to strong reference Proposal: SE-0079 Author: Evan Maloney Review Manager: TBD Status: Implemented (Swift 4.2) Implementation: apple/swift#15306 Introduction When working with escaping Swift closures, it is a common pattern to have the closure capture self weakly to avoid creating an object reference cycle. For example, let’s say you have a view controller that displays the result of a network operation. When the view controller is placed onscreen, it starts the operation and provides a closure to be executed upon completion. The fact that a network operation may be in-flight should not prevent user from navigating away from that view controller. Similarly, we don’t want a pending network operation to prevent our view controller from being deallocated after it goes offscreen. In other words, we only care about the network operation while the view controller is alive; once the view controller has been deallocated, we can safely ignore the result of any network request it initiated. To achieve this, the networking code might look something like: networkRequest.fetchData() { [weak self] result in guard let strongSelf = self else { return } switch result { case .Succeeded(let data): strongSelf.processData(data) case .Failed(let err): strongSelf.handleError(err) } } When it comes time to execute this closure, the guard statement effectively asks the question, “Is the view controller represented by self still alive?” If the answer is no, the guard forces a return and the rest of the closure does not execute. If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure’s execution. When the closure finishes, strongSelf goes away, once again making the view controller represented by self eligible for deallocation if no other references are held. The Problem The only available mechanism for upgrading a weak self to a strong reference requires the creation of a self-like variable with an arbitrary name—in the example above, strongSelf. Because there is no compiler-level mechanism for enforcing a consistent name across an entire codebase, in some instances strongSelf may be ss or it may be s or it may be a random sequence of characters that captures the developer’s mood of the moment. This lack of consistency adds noise to the codebase, and makes code harder to reason about, especially in cases where the strong reference is held by a variable with a name more cryptic than strongSelf. Being able to upgrade self from a weak reference to a strong reference while retaining the name self would be ideal, and it would be consistent with the existing Swift convention of optional binding that reuses the name of the optional variable, eg.: // foo is an optional here if let foo = foo { // foo is non-optional here; // the optional foo is masked within this scope } // foo is once again an optional here Proposed Solution The proposed solution entails allowing self to be upgraded from a weak reference to a strong reference using optional binding. In any scope where self is a weak reference, the compiler will accept an if or guard statement containing an optional binding that upgrades self to a strong reference. This would allow self to keep its meaningful name instead of being renamed to something arbitrary. With this feature, the code above could be rewritten as: networkRequest.fetchData() { [weak self] result in guard let self = self else { return } switch result { case .Succeeded(let data): self.processData(data) case .Failed(let err): self.handleError(err) } } The following would also be legal: networkRequest.fetchData() { [weak self] result in if let self = self { switch result { case .Succeeded(let data): self.processData(data) case .Failed(let err): self.handleError(err) } } } Behavior Regardless of which notation is used for this feature, the behavior is the same: The strong self can only be assigned from the optional self resulting from a weak capture in a closure. Once bound, the strong self follows the same scoping rules as any other optionally-bound variable. While the strong self is in scope, it masks the weak self variable. If the strong reference to self goes out of scope before the weak self reference does, the weak self will once again be visible to code. Restrictions To ensure safety, the compiler will enforce certain restrictions on the use of this feature: Attempting to use this feature in a context where self is not a weak reference will cause a compiler error. Binding of self may only be used with let; attempting to bind self to a var is an error. (Because this feature only works with object references and not value types, this restriction does not affect the mutability of self.) Impact on Existing Code None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage. Alternatives Considered Status quo The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually. As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code’s original intent, making it harder to reason about. Relying on a compiler bug There is a bug in current versions of the Swift compiler that allow self to be assigned when the word is surrounded by backticks. This bug causes the following code to compile and work: guard let `self` = self else { return } Apple’s Chris Lattner has stated that “this is a compiler bug”. Therefore, we should not rely on this “feature” to work in the future, because the bug will (presumably) be fixed eventually. Adding a new guard capture type An alternate to this proposal involves adding a new capture type, called guard, which would automatically handle upgrading self (and other references) from weak to strong. Although the alternate proposal received a favorable response from the Swift Evolution mailing list, the community seemed split between the approach outlined in that proposal, and the one outlined here. Citations Variations on this proposal were discussed earlier in the following swift-evolution threads: Wanted: syntactic sugar for [weak self] callbacks Allowing guard let self = self else { … } for weakly captured self in a closure. [Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists [Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists [Proposal] Allow upgrading weak self to strong self by assignment [Proposal] Allow using optional binding to upgrade self from a weak to strong reference [Last Call] Allow using optional binding to upgrade self from a weak to strong reference",
    "url": "http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html",
    "relUrl": "/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html"
  },
  "79": {
    "id": "79",
    "title": "SE-0080 Failable Numeric Conversion Initializers",
    "content": "Failable Numeric Conversion Initializers Proposal: SE-0080 Author: Matthew Johnson Review Manager: Chris Lattner Status: Implemented (Swift 3.1) Decision Notes: Rationale Bug: SR-1491 Introduction Swift numeric types all currently have a family of conversion initializers. In many use cases they leave a lot to be desired. Initializing an integer type with a floating point value will truncate any fractional portion of the number. Initializing with an out-of-range value traps. This proposal is to add a new family of conversion initializers to all numeric types that either complete successfully without loss of information or return nil. Swift-evolution thread: Proposal: failable numeric conversion initializers Motivation It is extremely common to receive loosely typed data from an external source such as json. This data usually has an expected schema with more precise types. When initializing model objects with such data runtime conversion must be performed. It is extremely desirable to be able to do so in a safe and recoverable manner. The best way to accomplish that is to support failable numeric conversions in the standard library. Proposed solution Add a new family of numeric conversion initializers with the following signatures to all numeric types: // Conversions from all integer types. init?(exactly value: Int8) init?(exactly value: Int16) init?(exactly value: Int32) init?(exactly value: Int64) init?(exactly value: Int) init?(exactly value: UInt8) init?(exactly value: UInt16) init?(exactly value: UInt32) init?(exactly value: UInt64) init?(exactly value: UInt) // Conversions from all floating-point types. init?(exactly value: Float) init?(exactly value: Double) #if arch(i386) || arch(x86_64) init?(exactly value: Float80) #endif Detailed design A small tolerance for floating point precision may or may not be desirable. This is an open question that should be resolved during review. Impact on existing code This is a strictly additive change and will not impact existing code. Alternatives considered An earlier version of this proposal used throwing initializer rather than failable initializers. This was changed based on community feedback. // Conversions from all integer types. init(exact value: Int8) throws init(exact value: Int16) throws init(exact value: Int32) throws init(exact value: Int64) throws init(exact value: Int) throws init(exact value: UInt8) throws init(exact value: UInt16) throws init(exact value: UInt32) throws init(exact value: UInt64) throws init(exact value: UInt) throws // Conversions from all floating-point types. init(exact value: Float) throws init(exact value: Double) throws #if arch(i386) || arch(x86_64) init(exact value: Float80) throws #endif",
    "url": "http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html",
    "relUrl": "/docs/2019-08-26-0080-failable-numeric-initializers.html"
  },
  "80": {
    "id": "80",
    "title": "SE-0081 Move `where` clause to end of declaration",
    "content": "Move where clause to end of declaration Proposal: SE-0081 Authors: David Hart, Robert Widmann, Pyry Jahkola Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1561 Introduction This proposal suggests moving the where clause to the end of the declaration syntax, but before the body, for readability reasons. It has been discussed at length on the following swift-evolution thread: [Pitch] Moving where Clauses Out Of Parameter Lists Motivation The where clause in declarations can become quite long. When that happens, it breaks the declaration syntax in two, hurting its readability. There is also no good way of formatting the declaration syntax to make it much better. Proposed solution The proposal suggests moving the where clause at the end of the declaration, but before the body of concerned declarations. With the proposed change, where clauses do not impede the main declaration and are also more easily formattable. For example, here is the same function declaration before and after the change: func anyCommonElements&lt;T : SequenceType, U : SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;(lhs: T, _ rhs: U) -&gt; Bool { ... } func anyCommonElements&lt;T : SequenceType, U : SequenceType&gt;(lhs: T, _ rhs: U) -&gt; Bool where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element { ... } This proposal has no impact on extension declarations with constraints because those declarations already have the where clauses right before the body. In that regard, the proposal makes the other declarations more consistent with extension declarations. Detailed design First of all, the grammar of generic-parameter-clause is modified to lose the requirement-clause: generic-parameter-clause → &lt; ­generic-parameter-list­­ &gt;­ The grammar of declarations are then amended to gain the requirement-clause: function-declaration → function-head­ function-name­ generic-parameter-clause­opt­ function-signature requirement-clause­opt ­function-body­opt union-style-enum → indirect­­opt­ ­enum ­enum-name ­generic-parameter-clause­­opt ­type-inheritance-clause­­opt­ requirement-clause­opt { ­union-style-enum-members­­opt­ } raw-value-style-enum → enum ­enum-name­ generic-parameter-clause­­opt ­type-inheritance-clause requirement-clause­opt ­{ ­raw-value-style-enum-members­ *}­* struct-declaration → attributes­­opt ­access-level-modifier­­opt ­struct ­struct-name ­generic-parameter-clause­­opt ­type-inheritance-clause­­opt requirement-clause­opt ­struct-body­ class-declaration → attributes­­opt ­access-level-modifier­opt ­final­opt ­class ­class-name ­generic-parameter-clause­opt ­type-inheritance-clause­opt requirement-clause­opt ­class-body­ protocol-method-declaration → function-head ­function-name ­generic-parameter-clause­­opt ­function-signature­ requirement-clause­opt protocol-initializer-declaration → initializer-head ­generic-parameter-clause­­opt ­parameter-clause ­throws­­opt­ requirement-clause­opt protocol-initializer-declaration → initializer-head ­generic-parameter-clause­opt ­parameter-clause­ rethrows­ requirement-clause­opt initializer-declaration → initializer-head ­generic-parameter-clause­­opt ­parameter-clause ­throws­opt requirement-clause­opt ­initializer-body­ initializer-declaration → initializer-head ­generic-parameter-clause­opt ­parameter-clause ­rethrows requirement-clause­opt ­initializer-body­ Impact on existing code This proposal impacts all declarations which contain where clauses (except for extension declarations) and will therefore require a Fix-It. Alternatives considered The first post in the swift-evolution thread originally proposed moving the where clause just after the generic type declaration. Since then, the original author and many other participants in the thread have agreed that the current proposal is superior. It was also proposed to remove the simple inheritance constraints from the generic parameter list, but several arguments were brought up that it would complicate declarations of simple generics which only needed inheritance constraints. Moreover, the current proposal allows moving simple constraints in the where clause: func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool where T : SequenceType, U : SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element { ... }",
    "url": "http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html",
    "relUrl": "/docs/2019-08-26-0081-move-where-expression.html"
  },
  "81": {
    "id": "81",
    "title": "SE-0082 Package Manager Editable Packages",
    "content": "Package Manager Editable Packages Proposal: SE-0082 Author: Daniel Dunbar Review Manager: Anders Bertelrud Status: Implemented (Swift 3.1) Decision Notes: Rationale Introduction This is a proposal for changing the behavior for iterative development of a group of packages. In particular, we will change the default location to which package dependency sources are cloned, the package managers behavior around those sources, and add a new feature for allowing iterative development. These features are tightly interrelated, which is why they are combined into one proposal. Proposal Announcement Review announcement Motivation We would like the package manager to support the following two workflows: In general, we would like to guarantee the most deterministic behavior possible when building a package, so that other users of the package or deployment scenarios see the same behavior as the developer. We would also like builds to be as efficient as possible, to improve developer productivity. For these reasons, it is desirable for the package manager to have a very strong default consistency model with regard to package dependencies, where it actively tries to ensure that the correct version of the sources is being used when a developer expects to be building against a particular tag of a package. For that reason, the default behavior should be an error or warning if a developer unintentionally tries to build against a modified version of a package, without otherwise specifying their intent. We would like to support productive development on projects which depend on a number of packages, including development of those upstream packages. This is important for projects whose authors directly control multiple packages, but also simply to encourage users to contribute changes back to the packages they are using, or factor their code into packages others can use. Currently, the package manager always checks out sources into a subdirectory adjacent to the project package called Packages, under a name combining the package name and tag. Users can directly edit the sources in that directory and they will be picked up by the build, but for a package author that is unlikely to be the directory they wish to edit their repository at (it will likely be checked out into a canonical location). In addition, the git repository at that point will be on a tag, which is an uncommon place to do iterative development. The user could choose to switch the branch they are working on, but then there is a confusing inconsistency between the directory name (which embeds the tag) and the content. In addition, the package manager naturally needs to support other operations which interact with the dependency package sources, such as updating them to a newer version. Directly supporting a user editing these sources requires the package manager to resolve difficult workflow questions about how to resolve the intended user action with the current contents of the tree. Proposed solution Our proposed solution is as follows: Move the default location for checked dependency sources to be “hidden” (an implementation detail). The package manager build system will by default try to ensure that any normal build always runs against the exact sources specified by the tag which was selected by dependency resolution. Introduce a new feature swift build --edit &lt;PACKAGE&gt; which takes an existing dependency, and converts it into an editable dependency (by moving it into the existing location within the Packages subdirectory). If a such an editable package is present in Packages, then swift build will always use the exact sources in this directory to build, regardless of its state, git repository status, tags, or the tag desired by dependency resolution. In other words, this will “just build” against the sources that are present. When an editable package is present, it will be used to satisfy all instances of that Package in the dependency graph. It should be possible to edit all, some, or none of the packages in a dependency graph, without restriction. This solution is intended to directly address the desired behaviors of the package manager: By hiding the sources by default, we minimize the distractions in the common case where a user is programming against a known, well-establised, library they do not need to modify. By adding a new, explicit workflow for switching to an “editable” package, we hope it is more explicit when a user is building against a canonical set of package versions versus a packages which may have been modified. We defined this feature in terms of behavior of swift build – as opposed to changes to a “lockfiles” or “package pinning” mechanism – because the expectation is that the decision to use an editable version of a Package versus the canonically resolved version is ultimately up to the individual developer. We do not yet have a clear feature for supporting the situation where a team of developers typically wants to edit the same group of packages (e.g., all the ones they own), but anticipate that this mechanism can evolve to support that. This feature also gives us a new place to add workflow behaviors to help make the interactions with editable packages safer or more flexible. For example, the following are possible features for future extension: We could infer (or allow user specification of) the next semantic version that the editable package will be. We could then build the package graph “as if” the package being edited had been tagged with this version. This would allow us to ensure that the package graph builds the same as it does for the developer when they commit and tag the package under development. We can provide additional features to leave editable mode, which could include a variety of safety checks that the changes had been committed, pushed, and tagged, in a way appropriate for the project under development. We could provide a feature to notify the developer when the editable packages have changes to the project metadata which may interact poorly with other editable packages. For example, trying to modify package dependency tags for a package which is in an editable state should most likely produce a warning, since the impact of those changes will not be reflected by the build. Detailed design Concretely, we will take the following steps: We will initially move the package clones into the existing .build directory, and provide a new explicit command line action swift build --get-package-path &lt;PACKAGE&gt; to get the package path in a supported manner. This allows us to transparently move the cache to a shared location if that becomes desirable. When resolving the package graph, we will load all of the repositories present in Packages, and use those repositories as replacements for any packages in the graph with the same package name. We will not audit the repository origin, initially, to allow for developing package graphs which are have not yet been pushed to any server. We will not load editable packages from any package other than the root package (i.e., we will ignore the presence of Packages anywhere except for the root package). We will introduce the --edit &lt;NAME&gt; subcommand. The package named must be an existing package in the graph. The behavior will be to take the exact tag that would have been chosen via dependency resolution, and clone that repository to Packages/&lt;NAME&gt; checked out to the tag. The desired invariant here is that the following sequence (starting from having no editable dependencies): swift build swift build --edit &lt;NAME&gt; swift build have the exact same results for each build step. We would like to introduce a --end-edit &lt;NAME&gt; subcommand (exact name is TBD), which will revert the package manager to the behavior of using the canonically resolved package. As described, this will require removing the Packages/&lt;NAME&gt; checkout. We need to be very careful about doing this, but this also gives us a good opportunity to communicate to the user if the state on the repository they are editing has not been pushed back into what would be the canonically resolved package. We will most likely defer this feature from the initial implementation and document that users can rm -rf Packages/&lt;NAME&gt; to stop editing, until the feature is introduced. We may introduce a metadata file to record the project state and what packages are editable. This would potentially allow us to provide better diagnostics to the user, it would also allow us to record an alternate location for the editable package. The latter would be useful when an author is developing multiple independent projects that they keep in a canonical location on their file system, and would like other packages to refer to for iterative development. Initially, that behavior can be emulated using symbolic links within the Packages directory. If such a file is introduced, the file system representation of the editable packages will always be the “canonical” source of data, and the metadata file will simply be used for additional diagnostics or information which cannot be inferred from the file system. We will consider a swift build --edit-all flag for immediately moving all packages to editable mode. Impact on existing packages This is a substantial behavior change for existing package checkouts, which will be seen by swift build as having a lot of editable packages with names not matching anything in the graph. We should consider detecting and warning about this situation as part of a transitional mechanism. In fact, this may motivate us to provide a way within the package manager to detect what the last version of the package manager used inside a project was, so that we can enable migration type behaviors automatically. Alternatives considered There has been discussion about using additional metadata from whatever mechanism we use to support package pinning/lockfiles to enable the iterative development workflows. The motivation for this proposal was in part based on the difficulties in defining the exact semantics for package pinning in conjunction with the existing semantics around the Packages directory. We have discussed whether or not hiding the sources for non-editable packages is the right default. The motivation for hiding the sources is that in a large, mature, stable ecosystem there are likely to be a large number of packages involved in any particular project build, and many of those are likely to be uninteresting to the package developer. In particular, while a project developer might be interested in the source of their direct dependencies, the sources of that packages own dependencies is an “implementation detail” from the perspective of the project developer. The downside of hiding sources by default is that it adds extra hoops for developers to go through to see those sources. In practice, we anticipate a workflow where a developer can easily transition between --edit and --end-edit efficiently if they need to easily inspect sources for one-off instances. For long-lived requirements (for example, needing to access a packages documentation), we anticipate that this problem will be solved by other mechanisms (for example, web hosted documentation or other mechanisms for browsing the source). We will revisit this default behavior if it proves problematic, and implement this feature with the flexibility to easily change the default.",
    "url": "http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html",
    "relUrl": "/docs/2019-08-26-0082-swiftpm-package-edit.html"
  },
  "82": {
    "id": "82",
    "title": "SE-0083 Remove bridging conversion behavior from dynamic casts",
    "content": "Remove bridging conversion behavior from dynamic casts Proposal: SE-0083 Author: Joe Groff Review Manager: Chris Lattner Status: Deferred Decision Notes: Rationale Introduction Dynamic casts using as?, as!, and is are currently able to dynamically perform Cocoa bridging conversions, such as from String to NSString or from an ErrorProtocol-conforming type to NSError. This functionality should be removed to make dynamic cast behavior simpler, more efficient, and easier to understand. To replace this functionality, initializers should be added to bridged types, providing an interface for these conversions that’s more consistent with the conventions of the standard library. Swift-evolution thread: Reducing the bridging magic in dynamic casts Motivation When we introduced Swift, we wanted to provide value types for common containers, with the safety and state isolation benefits they provide, while still working well with the reference-oriented world of Cocoa. To that end, we invested a lot of work into bridging between Swift’s value semantics containers and their analogous Cocoa container classes. This bridging consisted of several pieces in the language, the compiler, and the runtime: Importer bridging, importing Objective-C APIs that take and return NSString, NSArray, NSDictionary and NSSet so that they take and return Swift’s analogous value types instead. Originally, the language allowed implicit conversions in both directions between Swift value types and their analogous classes. We’ve been working on phasing the implicit conversions out–we removed the object-to-value implicit conversion in Swift 1.2, and propose to remove the other direction in SE-0072 –but the conversions can still be performed by an explicit coercion string as NSString. These required-explicit as coercions don’t otherwise exist in the language, since as generally is used to force coercions that can also happen implicitly, and value-preserving conversions are more idiomatically performed by constructors in the standard library. The runtime supports dynamic bridging casts. If you have a value that’s dynamically of a Swift value type, and try to as?, as!, or is-cast it to its bridged Cocoa class type, the cast will succeed, and the runtime will apply the bridging conversion: // An Any that dynamically contains a value &quot;foo&quot;: String let x: Any = &quot;foo&quot; // Cast succeeds and produces the bridged &quot;foo&quot;: NSString let y = x as! NSString Since Swift first came out, Cocoa has done a great job of “Swiftification”, aided by new Objective-C features like nullability and lightweight generics that have greatly improved the up-front quality of importer-bridged APIs. This has let us deemphasize and gradually remove the special case implicit conversions from the language. I think it’s time to consider extricating them from the dynamic type system as well, making it so that as?, as!, and is casts only concern themselves with typechecks, and transitioning to using standard initializers and methods for performing bridging conversions. The dynamic cast behavior has been a source of surprise for many users, and unfairly privileges bridged value types and classes with nonstandard behavior. Proposed solution I propose the following: Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes. Coercion syntax as should no longer be used to explicitly force certain bridging conversions. To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations. Background The Rules of as[?] Our original goal implementing this behavior into the dynamic casting machinery was to preserve some transitivity identities between implicit conversions and casts that users could reason about, including: x as! T as! U === x as! U, if x as! T succeeds. Casting to a type U should succeed and give the same result for any derived cast result. x as! T as U === x as! U. If T is coercible to U, then you should get the same result by casting to T and coercing to U as by casting to U directly. x as T as! U === x as! U. Likewise, coercing shouldn’t affect the result of any ensuing dynamic casts. x as T as U === x as U. The interaction of these identities with the bridging conversions, as well as with other type system features like implicit nonoptional-to-Optional conversion, occasionally requires surprising behavior, for instance the behavior of nil Optional values. These rules also inform the otherwise-inconsistent use of as to perform explicit bridging conversions, when as normally only forces implicit conversions. By simplifying the scope of dynamic casts, it becomes easier to preserve these rules without bugs and unfortunate edge cases. The Abilities of as? Today In discussing how to change the behavior of dynamic casts, it’s worth enumerating all the things dynamic casts are currently able to do: Check that an object is an instance of a specific class. class Base {}; class Derived: Base {} func isKindOfDerived(object: Base) -&gt; Bool { return object is Derived } isKindOfDerived(object: Derived()) // true isKindOfDerived(object: Base()) // false Check that an existential contains an instance of a type. protocol P {} extension Int: P {} extension Double: P {} func isKindOfInt(value: P) -&gt; Bool { return value is Int } isKindOfInt(value: 0) // true isKindOfInt(value: 0.0) // false Check that a generic value is also an instance of a different type. func is&lt;T, U&gt;(value: T, kindOf: U.Type) -&gt; Bool { return value is U } is(value: Derived(), kindOf: Derived.self) // true is(value: Derived(), kindOf: Base.self) // true is(value: Base(), kindOf: Derived.self) // false is(value: 0, kindOf: Int.self) // true Check whether the type of a value conforms to a protocol, and wrap it in an existential if so: protocol Fooable { func foo() } func fooIfYouCanFoo&lt;T&gt;(value: T) { if let fooable = value as? Fooable { fooable.foo() } } extension Int: Fooable { func foo() { print(&quot;foo!&quot;) } } fooIfYouCanFoo(value: 1) // Prints &quot;foo!&quot; fooIfYouCanFoo(value: &quot;bar&quot;) // No-op Check whether a value is _ObjectiveCBridgeable to a class, or conversely, that an object is _ObjectiveCBridgeable to a value type, and perform the bridging conversion if so: func getAsString&lt;T&gt;(value: T) -&gt; String? { return value as? String } func getAsNSString&lt;T&gt;(value: T) -&gt; NSString? { return value as? NSString } getAsString(value: &quot;string&quot;) // produces &quot;string&quot;: String getAsNSString(value: &quot;string&quot;) // produces &quot;string&quot;: NSString let ns = NSString(&quot;nsstring&quot;) getAsString(value: ns) // produces &quot;nsstring&quot;: String getAsNSString(value: ns) // produces &quot;nsstring&quot;: NSString Check whether a value conforms to ErrorProtocol, and bridge it to NSError if so: enum CommandmentError { case Killed, Stole, GravenImage, CovetedOx } func getAsNSError&lt;T&gt;(value: T) -&gt; NSError? { return value as? NSError } getAsNSError(CommandmentError.GravenImage) // produces bridged NSError This is what enables the use of catch let x as NSError pattern matching to catch Swift errors as NSError objects today. Check whether an NSError object has a domain and code matching a type conforming to _ObjectiveCBridgeableErrorProtocol, and extracting the Swift error if so: func getAsNSCocoaError(error: NSError) -&gt; NSCocoaError? { return error as? NSCocoaError } // Returns NSCocoaError.fileNoSuchFileError getAsNSCocoaError(error: NSError(domain: NSCocoaErrorDomain, code: NSFileNoSuchFileError, userInfo: [])) Drill through Optionals. If an Optional contains some value, it is extracted, and the cast is attempted on the contained value; the cast fails if the source value is none and the result type is not optional: var x: String? = &quot;optional string&quot; getAsNSString(value: x) // produces &quot;optional string&quot;: NSString x = nil getAsNSString(value: x) // fails If the result type is also Optional, a successful cast is wrapped as some value of the result Optional type. nil source values succeed and become nil values of the result Optional type: func getAsOptionalNSString&lt;T&gt;(value: T) -&gt; NSString?? { return value as? NSString? } var x: String? = &quot;optional string&quot; getAsOptionalNSString(value: x) // produces &quot;optional string&quot;: NSString? x = nil getAsOptionalNSString(value: x) // produces nil: NSString? Perform covariant container element checks and conversions for Array, Dictionary, and Set. There are roughly three categories of functionality intertwined here. (1) through (4) are straightforward dynamic type checks. ([4] is arguably a bit different from [1] through [3] in that protocol conformances are extrinsic to a type, whereas [1] through [3] check only the intrinsic type of the participating value.) (5) through (7) involve Cocoa bridging conversions. (8) and (9) reflect additional implicit conversions supported by the language at compile time into the runtime type system. Detailed Design Changes to dynamic cast behavior Within the scope of this proposal, I’d like to propose removing behaviors (5) through (7) from dynamic casting: (5) Dynamic casts will no longer check for _ObjectiveCBridgeable conformance in their source or destination types. &quot;string&quot; as Any as? NSString would fail. (6) Types that conform to ErrorProtocol will no longer dynamically cast to NSError. (7) NSError instances will no longer dynamically cast to ErrorProtocol- conforming types. Eliminating explicit as coercions With the bridging behavior removed from dynamic casting, we no longer have the transitivity justification for the special case behavior of as forcing bridging conversions, as in nsstring as String. This functionality should be removed, leaving as with only its core behavior of acting as a type annotation to force implicit conversions. Replacement API for bridging conversions To replace the removed language functionality, we should provide library APIs that follow the conventions set by the standard library. Bridging conversions are value-preserving, and the standard library uses unlabeled init(_:) initializers for value-preserving conversions. For nongeneric unconditionally- bridgeable types, such as String and NSString, this is straightforward (assuming we gain the ability to define factory initializers in Swift at some point): extension String { init(_ ns: NSString) { self = ._unconditionallyBridgeFromObjectiveC(ns) } } extension NSString { // Without a first-class factory init feature, this can be simulated with // a protocol extension factory init(_ string: String) { self = string._bridgeToObjectiveC() } } As an implementation detail, we could add a refinement of _ObjectiveCBridgeable for unconditionally-bridgeable types and implement these initializer pairs as protocol extensions. Similarly, we can provide NSError with a factory initializer in the Foundation overlay to handle bridging from ErrorProtocol: extension NSError { factory init(_ error: ErrorProtocol) { self = _bridgeErrorProtocolToNSError(error) } } and the inverse bridging of NSErrors to special ErrorProtocol types can be handled by modifying the internal _ObjectiveCBridgeableErrorProtocol to require an unlabeled failable initializer: public protocol _ObjectiveCBridgeableErrorProtocol : ErrorProtocol { /// Produce a value of the error type corresponding to the given NSError, /// or return nil if it cannot be bridged. init?(_ bridgedNSError: NSError) } For bridged generic containers like Array, Dictionary, and Set, the bridging conversions have to be failable, since not every element type is bridgeable, and the Objective-C classes come into Swift as untyped containers. (That may change if we’re able to extend the Objective-C generics importer support from SE-0057 to apply to Cocoa container classes, though bridging support makes that challenging.) extension Array { init?(_ ns: NSArray) { var result: Array? = nil if Array._conditionallyBridgeFromObjectiveC(ns, &amp;result) { self = result! return } return nil } } extension NSArray { init?&lt;T&gt;(_ array: Array&lt;T&gt;) { if !Array&lt;T&gt;.isBridgedToObjectiveC() { return nil } return array._bridgeToObjectiveC() } } Containers also support special force-bridging behavior, where the elements of the bridged value container are lazily type-checked and trap on access if there’s a type mismatch. This can still be exposed via a separate labeled initializer: extension Array { init(forcedLazyBridging object: NSArray) { var result: Array? = nil Array._forceBridgeFromObjectiveC(object, &amp;result) self = result! } } This seems to me like another improvement over our current behavior, where object as! Array&lt;T&gt; does lazy bridging whereas object as? Array&lt;T&gt; does eager bridging. This has been a common source of surprise, since in most other cases x as! T behaves equivalently to (x as? T)!. By changing to an interface defined within the language in terms of initializers, Array&lt;T&gt;(object)! performs eager bridging as one would normally expect, and Array&lt;T&gt;(forcedLazyBridging: object) explicitly asks for the lazy bridging. There are common use cases that deserve consideration beyond simple back-and- forth conversion. In Cocoa code, it’s common to work with heterogeneous containers of objects, which will come into Swift as [AnyObject] or [NSObject: AnyObject]. To extract typed data from these containers, it’s useful to convert from AnyObject to a bridged value type in one step, like you can do with object as? String today. We can provide a failable initializer for this purpose: extension _ObjectiveCBridgeable { init?(bridging object: AnyObject) { if let bridgeObject = object as? _ObjectiveCType { var result: Self? = nil if Self._conditionallyBridgeFromObjectiveC(bridgeObject, &amp;result) { self = result! return } } return nil } } Dynamic cast bridging of NSError is commonly used in the catch _ as NSError formulation, to catch an arbitrary Swift error and handle it as an NSError. This is done frequently because ErrorProtocol by itself provides no public API for presenting errors. The need to explicitly bridge to NSError could be avoided in most cases by extending ErrorProtocol to directly support NSError’s core API in the Foundation overlay: extension ErrorProtocol { var domain: String { return NSError(self).domain } var code: Int { return NSError(self).code } var userInfo: [NSObject: AnyObject] { return NSError(self).userInfo } } Impact on existing code Since dynamic behavior is involved, these changes cannot be automatically migrated with full fidelity. For example, if a value of type Any or generic T being cast to String or NSString, it’s impossible for the compiler to know whether the cast is being made with the intent of inducing the bridging conversion. However, at least some cases can be recognized by the compiler and migrated. For example, any cast from a value that’s statically of a value type to a class would now always fail, as would a cast from an object to a value type, so these cases can be warned about and fixits to use the new initializers can be offered. We can also recognize code that uses the catch &lt;pattern&gt; as NSError idiom and migrate away the as NSError cast if we make it unnecessary by extending ErrorProtocol. Alternatives considered Removing special-case Optional and container handling from dynamic casts As discussed above, in addition to dynamic type checks and bridging conversions, dynamic casting also has special-case behavior for (8) drilling through Optionals and (9) performing covariant Array, Dictionary, and Set conversions. This dynamic behavior matches the special implicit conversions supported statically in the language, but has also been a source of complexity and confusion. We could consider separating this functionality out of the runtime dynamic casting machinery too, but we should do so in tandem with discussions of removing or tightening the corresponding implicit conversion behavior for optionals and covariant containers as well. Replacing dynamic cast syntax with normal functions or methods If one wanted to get really reductionist, they could ask whether as? and related operations really need special syntax at all; they could in theory be fully expressed as global functions, or as extension methods on Any/AnyObject if we allowed such things.",
    "url": "http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html",
    "relUrl": "/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html"
  },
  "83": {
    "id": "83",
    "title": "SE-0084 Allow trailing commas in parameter lists and tuples",
    "content": "Allow trailing commas in parameter lists and tuples Proposal: SE-0084 Authors: Grant Paul, Erica Sadun Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction Swift permits trailing commas after the last element in array or dictionary literal. This proposal extends that to parameters and tuples. Original swift-evolution discussion: Allow trailing commas in argument lists Motivation Trailing commas offer linguistic sugar for flexible design. Ignored by the compiler, they enable developers to easily reorder elements and to comment out and uncomment in list-based features on an as-needed basis: let strings = [ &quot;abc&quot;, &quot;cde&quot;, &quot;fgh&quot;, // &quot;ijk&quot;, ] Parameter declarations would benefit from the same support. Complex declarations, especially those with defaults, could be moved around and commented without having to spend unnecessary time adjusting where the final comma should and should not appear. func padStringToLength( sourceString: String, destinationCount: Int, paddingStyle: StringPaddingStyle = .Left, paddingCharacter: Character = &quot; &quot;, ) -&gt; String { /* ... */ } padStringToLength( sourceString: &quot;source&quot;, destinationCount: 4, paddingStyle: .Right, paddingCharacter: &quot;&quot;, ) Tuples would see the same benefits. With trailing commas, reversing the order of this tuple would take just two line-level adjustments: let tuple: ( string: String, number: Int, ) = ( string: &quot;string&quot;, number: 0, ) Detailed Design With this design, the Swift compiler will simply ignore final parameter and tuple commas as it does in collections. This includes function calls, function declarations, tuple type definitions, and tuple literals. Zero-element tuples and parameter lists would not support trailing commas. Single-element tuples would not allow trailing commas but single-element parameter lists would, consistent with the existing prohibition on named single-element tuples. Advantages of Acceptance Trailing commas best offer support for situations that express variadic properties. All three of the following scenarios share this nature: Call sites with variadic arguments Call sites with defaulted arguments Definition sites with large complex multi-line argument lists or tuple members It’s easiest to make the case for call sites, the first two of these uses, as they exactly mirror the way collections parse members. Supporting the third style of trailing commas requires the consideration of real world modern Swift. Allowing cut and paste or commenting of entire parameter lines means simple changes do not ripple out to affect other lines. In this, trailing commas serve programmer intent and limit the effect in diff comparisons. As Joe Groff points out, one edit becomes one diff, without extra housekeeping for other affected lines. When considered together, the use cases for these scenarios are common enough to be considered something other than a “special case”. “Having used, more or less continuously for my 20 years as a professional programmer, both a language that allows trailing commas and one that does not, I come down pretty strongly on the side of allowing trailing commas (for all the reasons already stated in this thread). If it means requiring a newline after the last comma to make some people feel better about it, so be it.” - John Siracusa “I was skeptical of this until a week or two ago, when I had some code where I ended up commenting out certain parameters. Removing the now-trailing commas was an inconvenience. So, +1 from me.” - Brent Royal-Gordon “We should be consistent in either accepting or rejecting trailing commas everywhere we have comma-delimited syntax. I’m in favor of accepting it, since it’s popular in languages where it’s supported to enable a minimal-diff style, so that changes to code don’t impact neighboring lines for purely syntactic reasons. If you add an argument to a function, without trailing comma support, a comma has to be added to dirty the previous line In response to observations that tuples and function arguments are somehow different from collection literals because they generally have fixed arity, I’ll note that we have a very prominent variadic function in the standard library, “print”, and that adding or removing values to a “print” is a very common and natural thing to do We’ve generally shied away from legislating style; see our rationale behind not requiring self. (example) In languages where trailing commas are pervasively allowed, such as Perl, Python, Ruby, and modern Javascript, I haven’t seen any indication that this is a major problem. Less blood has definitely been shed over it than over bracing style and other style wars.” - Joe Groff Impact on Existing Code The acceptance of SE-0084 will not affect existing code. Alternatives Considered Chris Lattner: A narrower way to solve the same problem would be to allow a comma before the ), but only when there is a newline between them. Vlad S suggests introducing “newlines as separators for any comma-separated list, not limited by funcs/typles but also array/dicts/generic type list etc.”",
    "url": "http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html",
    "relUrl": "/docs/2019-08-26-0084-trailing-commas.html"
  },
  "84": {
    "id": "84",
    "title": "SE-0085 Package Manager Command Names",
    "content": "Package Manager Command Names Proposal: SE-0085 Authors: Rick Ballard, Daniel Dunbar Review Manager: Daniel Dunbar Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift-package-manager#364 Note This proposal underwent some minor changes from its original form. See the end of this document for historical information and why this proposal changed. Introduction This is a proposal for changing the command names used for invoking the Swift package manager. Instead of hanging all functionality off of swift build and swift test, we will introduce a new swift package command with multiple subcommands. swift build and swift test will remain as top-level commands due to their frequency of use. Swift Build Review Thread Swift Evolution Review Thread Motivation When we introduced the package manager, we exposed it with the swift build top-level command. This made clear its tight integration with Swift, and made it discoverable (it’s just a subcommand of Swift). We also added a top-level swift test command for running tests. As the functionality of the package manager has grown beyond basic build and test functionality, we’ve introduced other operations you can perform, such as initializing a new package or updating existing packages. These new commands have been supported via flags to swift build, but this is awkward; these are not really flags modifying a build, and should be full commands in their own right. The intent of this proposal is to establish a forward-looking syntax for supporting the full range of future package manager functionality in a clean, expressive, and clear manner, without using command-line flags (which should be modifiers on a commmand) to express commands. Proposed solution Our proposed solution is as follows: Introduce a new top-level swift package command. This command will have subcommands for the package manager functionality. Move existing package manager commands, such as swift build --init, to be subcommands of swift package, e.g. as swift package init. New commands we add, such as the update command, should also be added as subcommands, e.g. swift package update. Note that some current swift build flags are actually modifiers to a build command, such as --configuration; these will remain as flags instead of becoming swift package subcommands. Introduce swift package build and swift package test subcommands, for the existing build and test functionality, but retain swift build and swift test as top-level commands which alias to these subcommands. Detailed design Swift will remain a multitool whose package manager commands call through to a tool provided by the package manager. Currently there are two tools – swift-build and swift-test – but these will be replaced by a new swift-package tool. This tool is essentially an implementation detail of the package manager, as all use is expected to be invoked through the Swift multitool. The swift package command of the Swift muiltitool will call swift-package. The top- level commands swift build and swift test will call swift-package build and swift-package test respectively, although this is considered an implementation detail and the recommend way to invoke the build or test processes is always as a direct subcommand of swift. Subcommands of swift package will be passed to swift-package verbatim. The current --init, --fetch, --update, and --generate-xcodeproj flags to swift build will become subcommands of swift package. The other flags to swift build actually do modify the build, and will remain as flags on the build subcommand. New functionality added to the package manager will be added as subcommands of swift package if they are appropriate as standalone commands, or as a flag modifying an existing subcommand, such as build, if they modify the behavior of an existing command. The flags to swift build that are being removed will remain for a short time after the new swift package subcommands are added, as aliases to those subcommands, for compatibility. They will be removed before Swift 3 is released. We acknowledge the possible need for a shorter version of the swift package command, and believe we can revisit this to add a shorter alias for this in the future if necessary. See the alternatives section below. Impact on existing packages This has no impact on the existing packages themselves, but does have impact on any software which invokes the swift build flags which are moving to be subcommands of swift package. There will be a transitionary period where both old and new syntax is accepted, but any software invoking this functionality will need to move to the new swift package subcommands before Swift 3 is released. Alternatives considered This proposal originally suggested swift build and swift package build would be aliases. In order to avoid having multiple ways to run the same command, we updated the proposal to emphasize only swift build. We considered using swift build as the top level command for the package manager and moving the other verbs from being flags to being subcommands of swift build, instead of introducing a package command (e.g., swift build init). We think this reads poorly and is less clear than making them package subcommands. We considered adding a swift pm subcommand instead of using swift package. That requires less typing, but we think that spelling out the word package aligns better with Swift naming conventions. Furthermore, the most common subcommands (build and test) are exposed directly off of swift, limiting how often you will need to type package. We considered adding a spm command. However, this was regarded as too short to ever be the definitive name, when means it would only ever be an alias. This means that there would be two ways of doing things, which was something we wanted to strongly avoid. We also felt that the “shortcut” of spm over swiftpm was not in line with our overall goals, and so we focused on the swiftpm alternative as discussed below. Using swiftpm as the command name We considered adding a top-level swiftpm tool instead of keeping the package manager as a subcommand of Swift. We discussed this option at length, as it was regarded as the most compelling alternative to swift package. The perceived advantages of this approach were: It would cement the name of the package manager clearly (as swiftpm), and it gave a clear identity useful for web searches, documentation, internal naming, etc. It included “package manager” in the name (as an acronym), which makes commands which are exclusive to the “package management” part of the problem domain more clear. For example, the behavior of swiftpm install is intuitive once one understands the name. It is short and convenient to type. In the end, we rejected this alternative for several reasons: We felt very strongly that there needed to be only typical one way of doing things, and so we felt that we needed to choose between swiftpm and swift package (and not simply add it as an alias). Our belief was this was more important than any individual advantages or disadvantages to either name. While there was significant feedback requesting a shorter command name, we were concerned that the feedback was not necessarily representative of the overall user base we hope to impact. For example, we hope the Swift package manager will be widely used by less experienced developers who may only run the swift package commands rarely, and will benefit from the explicit nature of the commands over brevity. If we used this as the command, then it raises a difficult question of swift build versus swiftpm build. We wanted to retain the “natural” feel of the package manager as being integrated with the language, and keep swift build, but we had substantial difficulty articulating the exact reasons why it made sense for some commands (e.g., swift build and swift test) to be subcommands of swift, and others to be subcommands of swiftpm. In the end, we were unable to come to a consensus on this question, so we ended up regarding this as a reason to choose swift package instead, which side steps this question. We believe that the readability and clarity of using consistent, unabbreviated commands was more in line with the Swift language than attempting to use a “shorter” command name. Our belief is that swift package will primarily be used for commands which are not commonly executed, and we think that the package manager is more discoverable, and its role in the Swift ecosystem more clear, with it as a Swift subcommand. We believe that we can always choose to install a swiftpm alias for swift package if our needs or justification changes, whereas going in the other direction was considered undesirable.",
    "url": "http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html",
    "relUrl": "/docs/2019-08-26-0085-package-manager-command-name.html"
  },
  "85": {
    "id": "85",
    "title": "SE-0086 Drop NS Prefix in Swift Foundation",
    "content": "Drop NS Prefix in Swift Foundation Proposal: SE-0086 Authors: Tony Parker, Philippe Hausler Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Related radars or Swift bugs SE-0069: Swift Mutability for Foundation Revision history v1 Initial version v2 Updated with feedback, additional rules. Change to keep NS on future value types. Introduction As part of Swift 3 API Naming and the introduction of Swift Core Libraries, we are dropping the NS prefix from key Foundation types in Swift. Swift Evolution Discussion Thread Review Thread Motivation A large proportion of the value that comes from using many programming languages derives from the libraries that ship with the compiler. These libraries provide common functionality, which in turn establish common design patterns for software written in the language. When a strong foundation of patterns and types is established, all higher level libraries and applications benefit. Code can easily interact with other libraries without awkward translation layers or annoying impedance mismatches. With Swift, we established the most fundamental of these libraries as the Swift Standard Library. The standard library provides the most important and fundamental data structures and is intentionally kept small and focused. To provide a higher level of functionality than the standard library could (or should) include, we established another project called the Swift Core Libraries. These libraries are important enough to include on all platforms that Swift supports: Unit testing (swift-corelibs-xctest) Scheduling, multithreading, and locking primitives (swift-corelibs-dispatch) Internationalization, localization, additional model types, and portability (swift-corelibs-foundation) We believe that the best way to establish these libraries as fundamental and native Swift libraries is to work towards making their naming style match the convention established by the standard library. The first step was establishing naming conventions: Swift 3 API Naming Guidelines SE-0023: API Design Guidelines The second step was adjusting standard library API and importing the Cocoa SDK according to those conventions: SE-0006: Apply API Guidelines to the Standard Library SE-0005: Better Translation of Objective-C APIs Into Swift The next step is to adjust the API of the Swift Core Libraries. This proposal is focused on swift-corelibs-foundation. In addition to adopting the guidelines for method names, the names of the fundamental types should follow the spirit of the guidelines too. The type names should be clear, concise, and omit needless words or prefixes. In combination with adopting Swift semantics for many of these types (SE-0069), and continued improvement to the implementations, this will make core library API feel like it belongs to the Swift language instead of like a foreign invader. Note: All changes proposed are for Swift only; Objective-C has no change. Proposed solution We propose the following set of rules for deciding if the NS prefix should be dropped for current types, and for new types added in the future: If the class is specifically for Objective-C, or inherently tied to the Objective-C runtime and NS namespace, keep NS prefix. Examples: NSObject, NSAutoreleasePool, NSException, NSProxy. If the class is platform-specific, keep the NS prefix. Many of these types are located in Foundation, but actually belong to the namespace of a higher-level framework like AppKit or UIKit. The higher level frameworks are keeping their prefixes, so these types should match. Examples: NSUserNotification, NSBackgroundActivity, NSXPCConnection. If the class has a value-type equivalent, then keep the NS prefix, per SE-0069. Examples: NSArray, NSString, NSPersonNameComponents. We have an additional set of rules which we want to apply to the set of existing classes only. We recognize the unique transition that we are currently undergoing and want to take advantage of this opportunity in some specific cases. If the class is planned to have a value-type equivalent in the near future, then keep the NS prefix. Examples: NSAttributedString, NSRegularExpression, NSPredicate. The NSLock family of classes and protocols will likely be revisited as part of the general concurrency effort in the next release of Swift. Therefore we will keep the NS prefix. Additional collection types that are implemented in Foundation are usually generic over objects only and not the Any type. We intend to fix this, but the transition will likely also involve these collections becoming a struct type themselves. This is related to the “Specific to Objective-C” rule, as Objective-C collections could only contain objects. Examples: NSCache, NSMapTable, NSHashTable, NSOrderedSet. A few types are dropping the prefix but also changing names to something more descriptive of its desired role. Examples: NSTask -&gt; Process. It is important to note that the primary decision of dropping the NS is related to the type itself (including its name and if it is a struct or class). Some types have methods and properties which can be improved for Swift. We intend to fix those on a case-by-case basis, even if the name of the type is dropping the NS. Detailed design Drop NS prefix The following types and symbols will drop their NS prefix in Swift. Objective-C Name Swift Name Note NSBlockOperation BlockOperation   NSBundle Bundle   NSByteCountFormatter ByteCountFormatter   NSCachedURLResponse CachedURLResponse   NSComparisonResult ComparisonResult   NSDateComponentsFormatter DateComponentsFormatter   NSDateFormatter DateFormatter   NSDateIntervalFormatter DateIntervalFormatter   NSDistributedNotificationCenter DistributedNotificationCenter   NSEnergyFormatter EnergyFormatter   NSFileHandle FileHandle   NSFileManager FileManager   NSFileManagerDelegate FileManagerDelegate   NSFileWrapper FileWrapper   NSFormatter Formatter   NSHost Host   NSHTTPCookie HTTPCookie   NSHTTPCookieStorage HTTPCookieStorage   NSHTTPURLResponse HTTPURLResponse   NSInputStream InputStream   NSJSONSerialization JSONSerialization   NSLengthFormatter LengthFormatter   NSMassFormatter MassFormatter   NSMessagePort MessagePort   NSNetService NetService   NSNetServiceBrowser NetServiceBrowser   NSNetServiceBrowserDelegate NetServiceBrowserDelegate   NSNetServiceDelegate NetServiceDelegate   NSNotificationCenter NotificationCenter   NSNotificationName NotificationName   NSNotificationQueue NotificationQueue   NSNumberFormatter NumberFormatter   NSOperatingSystemVersion OperatingSystemVersion   NSOperation Operation   NSOperationQueue OperationQueue   NSOutputStream OutputStream The Swift standard library has a type named OutputStream which will be renamed to TextOutputStream. NSPersonNameComponentsFormatter PersonNameComponentsFormatter   NSPipe Pipe   NSPort Port   NSPortDelegate PortDelegate   NSPortMessage PortMessage   NSProcessInfo ProcessInfo   NSProgress Progress   NSProgressReporting ProgressReporting   NSPropertyListSerialization PropertyListSerialization   NSQualityOfService QualityOfService   NSRunLoop RunLoop   NSScanner Scanner   NSSocketPort SocketPort   NSStream Stream   NSStreamDelegate StreamDelegate   NSTask Process The standard library has a Process type. ProcessInfo will subsume the argument-fetching functionality from that enum, which will be removed. In the future, we will likely sink the basic ProcessInfo class into the standard library. NSThread Thread   NSTimeInterval TimeInterval   NSTimer Timer   NSUndoManager UndoManager   NSURLAuthenticationChallenge URLAuthenticationChallenge   NSURLAuthenticationChallengeSender URLAuthenticationChallengeSender   NSURLCache URLCache   NSURLCredential URLCredential   NSURLCredentialStorage URLCredentialStorage   NSURLProtectionSpace URLProtectionSpace   NSURLProtocol URLProtocol   NSURLProtocolClient URLProtocolClient   NSURLRequest URLRequest   NSURLResponse URLResponse   NSURLSession URLSession   NSURLSessionConfiguration URLSessionConfiguration   NSURLSessionDataDelegate URLSessionDataDelegate   NSURLSessionDataTask URLSessionDataTask   NSURLSessionDelegate URLSessionDelegate   NSURLSessionDownloadDelegate URLSessionDownloadDelegate   NSURLSessionDownloadTask URLSessionDownloadTask   NSURLSessionStreamDelegate URLSessionStreamDelegate   NSURLSessionStreamTask URLSessionStreamTask   NSURLSessionTask URLSessionTask   NSURLSessionTaskDelegate URLSessionTaskDelegate   NSURLSessionUploadTask URLSessionUploadTask   NSUserDefaults UserDefaults   NSXMLDocument XMLDocument   NSXMLDTD XMLDTD   NSXMLDTDNode XMLDTDNode   NSXMLElement XMLElement   NSXMLNode XMLNode   NSXMLParser XMLParser   NSXMLParserDelegate XMLParserDelegate   Hoisted types The following types will be lifted up into a class container as a sub-type. Old Name New Name Note NSActivityOptions ProcessInfo.ActivityOptions   NSAppleEventSendOptions NSAppleEventDescriptor.SendOptions   NSAttributedStringEnumerationOptions AttributedString.EnumerationOptions   NSBackgroundActivityResult NSBackgroundActivityScheduler.Result   NSByteCountFormatterCountStyle ByteCountFormatter.CountStyle   NSByteCountFormatterUnits ByteCountFormatter.Units   NSCalculationError Decimal.CalculationError   NSCalendarOptions Calendar.Options   NSCalendarUnit Calendar.Unit   NSComparisonPredicateModifier ComparisonPredicate.Modifier   NSComparisonPredicateOptions ComparisonPredicate.Options   NSCompoundPredicateType CompoundPredicate.LogicalType   NSDataBase64DecodingOptions NSData.Base64DecodingOptions Data will have a typealias NSDataBase64EncodingOptions NSData.Base64EncodingOptions Data will have a typealias NSDataReadingOptions NSData.ReadingOptions Data will have a typealias NSDataSearchOptions NSData.SearchOptions Data will have a typealias NSDataWritingOptions NSData.WritingOptions Data will have a typealias NSDateFormatterBehavior DateFormatter.Behavior   NSDateFormatterStyle DateFormatter.Style   NSDateIntervalFormatterStyle DateIntervalFormatter.Style   NSDecodingFailurePolicy Coder.DecodingFailurePolicy   NSDirectoryEnumerationOptions FileManager.DirectoryEnumerationOptions   NSDistributedNotificationOptions DistributedNotificationCenter.Options   NSEnergyFormatterUnit EnergyFormatter.Unit   NSExpressionType NSExpression.ExpressionType   NSFileCoordinatorReadingOptions FileCoordinator.ReadingOptions   NSFileCoordinatorWritingOptions FileCoordinator.WritingOptions   NSFileManagerItemReplacementOptions FileManager.ItemReplacementOptions   NSFileManagerUnmountOptions FileManager.UnmountOptions   NSFileVersionAddingOptions FileVersion.AddingOptions   NSFileVersionReplacingOptions FileVersion.ReplacingOptions   NSFileWrapperReadingOptions FileWrapper.ReadingOptions   NSFileWrapperWritingOptions FileWrapper.WritingOptions   NSFormattingContext Formatter.Context   NSFormattingUnitStyle Formatter.UnitStyle   NSHTTPCookieAcceptPolicy HTTPCookie.AcceptPolicy   NSInsertionPosition NSPositionalSpecifier.InsertionPosition   NSItemProviderErrorCode NSItemProvider.ErrorCode   NSJSONReadingOptions JSONSerialization.ReadingOptions   NSJSONWritingOptions JSONSerialization.WritingOptions   NSLengthFormatterUnit LengthFormatter.Unit   NSLinguisticTaggerOptions NSLinguisticTagger.Options   NSLocaleLanguageDirection Locale.LanguageDirection   NSMachPortOptions NSMachPort.Options   NSMassFormatterUnit MassFormatter.Unit   NSMatchingFlags RegularExpression.MatchingFlags   NSMatchingOptions RegularExpression.MatchingOptions   NSMeasurementFormatterUnitOptions MeasurementFormatter.UnitOptions   NSNetServiceOptions NetService.Options   NSNetServicesError NetService.ErrorCode   NSNotificationCoalescing NotificationQueue.NotificationCoalescing   NSNotificationSuspensionBehavior DistributedNotificationCenter.SuspensionBehavior   NSNumberFormatterBehavior NumberFormatter.Behavior   NSNumberFormatterPadPosition NumberFormatter.PadPosition   NSNumberFormatterRoundingMode NumberFormatter.RoundingMode   NSNumberFormatterStyle NumberFormatter.Style   NSOperationQueuePriority Operation.QueuePriority   NSPersonNameComponentsFormatterOptions PersonNameComponentsFormatter.Options   NSPersonNameComponentsFormatterStyle PersonNameComponentsFormatter.Style   NSPointerFunctionsOptions PointerFunctions.Options   NSPostingStyle NotificationQueue.PostingStyle   NSPredicateOperatorType ComparisonPredicate.Operator   NSProcessInfoThermalState ProcessInfo.ThermalState   NSPropertyListFormat PropertyListSerialization.PropertyListFormat   NSPropertyListMutabilityOptions PropertyListSerialization.MutabilityOptions   NSPropertyListReadOptions PropertyListSerialization.ReadOptions   NSPropertyListWriteOptions PropertyListSerialization.WriteOptions   NSRegularExpressionOptions RegularExpression.Options   NSRelativePosition NSRelativeSpecifier.RelativePosition   NSSearchPathDirectory FileManager.SearchPathDirectory   NSSearchPathDomainMask FileManager.SearchPathDomainMask   NSSocketNativeHandle Socket.NativeHandle   NSStreamEvent Stream.Event   NSStreamStatus Stream.Status   NSStringCompareOptions NSString.CompareOptions Also on String. See below for more information. NSStringEncoding NSString.Encoding Also on String. See below for more information. NSStringEncodingConversionOptions NSString.EncodingConversionOptions Also on String. See below for more information. NSStringEnumerationOptions NSString.EnumerationOptions   NSTaskTerminationReason Task.TerminationReason   NSTestComparisonOperation NSSpecifierTest.TestComparisonOperation   NSTextCheckingType TextCheckingResult.CheckingType   NSTimeZoneNameStyle TimeZone.NameStyle   NSURLCacheStoragePolicy URLCache.StoragePolicy   NSURLCredentialPersistence URLCredential.Persistence   NSURLRelationship FileManager.URLRelationship   NSURLRequestCachePolicy URLRequest.CachePolicy   NSURLRequestNetworkServiceType URLRequest.NetworkServiceType   NSURLSessionAuthChallengeDisposition URLSession.AuthChallengeDisposition   NSURLSessionResponseDisposition URLSession.ResponseDisposition   NSURLSessionTaskState URLSessionTask.State   NSURLSessionTaskMetricsResourceFetchType URLSessionTaskMetrics.ResourceFetchType   NSUserNotificationActivationType NSUserNotification.ActivationType   NSVolumeEnumerationOptions FileManager.VolumeEnumerationOptions   NSWhoseSubelementIdentifier NSWhoseSpecifier.SubelementIdentifier   NSXMLDocumentContentKind XMLDocument.ContentKind   NSXMLDTDNodeKind XMLDTDNode.Kind   NSXMLNodeKind XMLNode.Kind   NSXMLParserError XMLParser.ErrorCode   NSXMLParserExternalEntityResolvingPolicy XMLParser.ExternalEntityResolvingPolicy   NSXPCConnectionOptions NSXPCConnection.Options   Updated enumerations NSExpressionType enumeration members drop their suffix. extension Expression { public enum ExpressionType : UInt { case constantValue case evaluatedObject case variable case keyPath case function case unionSet case intersectSet case minusSet case subquery case aggregate case anyKey case block @available(OSX 10.11, iOS 9.0, *) case conditional } } Enumerations associated with ComparisonPredicate drop their suffix. extension ComparisonPredicate { public struct Options : OptionSet { public init(rawValue: UInt) public static var caseInsensitive: ComparisonPredicate.Options { get } public static var diacriticInsensitive: ComparisonPredicate.Options { get } public static var normalized: ComparisonPredicate.Options { get } } public enum Modifier : UInt { case direct case all case any } public enum Operator : UInt { case lessThan case lessThanOrEqualTo case greaterThan case greaterThanOrEqualTo case equalTo case notEqualTo case matches case like case beginsWith case endsWith case `in` case customSelector case contains case between } } NSDateFormatterStyle and NSDateIntervalFormatterStyle will drop the style suffix. no will be renamed to none. extension DateIntervalFormatter { @available(OSX 10.10, iOS 8.0, *) public enum Style : UInt { case none case short case medium case long case full } } NSNumberFormatterStyle will drop the style suffix. no will be renamed to none extension NumberFormatter { public enum Style : UInt { case none case decimal case currency case percent case scientific case spellOut @available(OSX 10.11, iOS 9.0, *) case ordinal @available(OSX 10.11, iOS 9.0, *) case currencyISOCode @available(OSX 10.11, iOS 9.0, *) case currencyPlural @available(OSX 10.11, iOS 9.0, *) case currencyAccounting } } NSXMLDocumentContentKind, NSXMLDTDNodeKind and NSXMLNodeKind will be renamed. extension XMLDocument { public enum ContentKind : UInt { case xml case xhtml case html case text } } extension XMLDTDNode { public enum Kind : UInt { case generalEntity case parsedEntity case unparsedEntity case parameterEntity case predefinedEntity case cdataAttribute case idAttribute case idRefAttribute case idRefsAttribute case entityAttribute case entitiesAttribute case nmTokenAttribute case nmTokensAttribute case enumerationAttribute case notationAttribute case undefinedElementDeclaration case emptyElementDeclaration case anyElementDeclaration case mixedElementDeclaration case elementDeclarationElement } } extension XMLNode { public enum Kind : UInt { case invalid case document case element case attribute case namespace case processingInstruction case comment case text case dtd case entityDeclaration case attributeDeclaration case elementDeclaration case notationDeclaration } } Keep NS prefix Classes and types not enumerated above will keep their NS prefix. Future API will be decided on a case-by-case basis following the rules outlined above. NSStringEncoding NSStringEncoding has a number of free floating constants which will be renamed into members of a RawRepresentable structure named String.Encoding. Previously the API was exposed as: public typealias NSStringEncoding = UInt public var NSASCIIStringEncoding: UInt { get } public var NSNEXTSTEPStringEncoding: UInt { get } public var NSJapaneseEUCStringEncoding: UInt { get } public var NSUTF8StringEncoding: UInt { get } public var NSISOLatin1StringEncoding: UInt { get } public var NSSymbolStringEncoding: UInt { get } public var NSNonLossyASCIIStringEncoding: UInt { get } public var NSShiftJISStringEncoding: UInt { get } public var NSISOLatin2StringEncoding: UInt { get } public var NSUnicodeStringEncoding: UInt { get } public var NSWindowsCP1251StringEncoding: UInt { get } public var NSWindowsCP1252StringEncoding: UInt { get } public var NSWindowsCP1253StringEncoding: UInt { get } public var NSWindowsCP1254StringEncoding: UInt { get } public var NSWindowsCP1250StringEncoding: UInt { get } public var NSISO2022JPStringEncoding: UInt { get } public var NSMacOSRomanStringEncoding: UInt { get } public var NSUTF16StringEncoding: UInt { get } public var NSUTF16BigEndianStringEncoding: UInt { get } public var NSUTF16LittleEndianStringEncoding: UInt { get } public var NSUTF32StringEncoding: UInt { get } public var NSUTF32BigEndianStringEncoding: UInt { get } public var NSUTF32LittleEndianStringEncoding: UInt { get } With the renaming change String.Encoding will be exposed as: extension String { public struct Encoding : RawRepresentable { public var rawValue: UInt public init(rawValue: UInt) public static var ascii { get } public static var nextstep { get } public static var japaneseEUC { get } public static var utf8 { get } public static var isoLatin1 { get } public static var symbol { get } public static var nonLossyASCII { get } public static var shiftJIS { get } public static var isoLatin2 { get } public static var unicode { get } public static var windowsCP1251 { get } public static var windowsCP1252 { get } public static var windowsCP1253 { get } public static var windowsCP1254 { get } public static var windowsCP1250 { get } public static var iso2022JP { get } public static var macOSRoman { get } public static var utf16 { get } public static var utf16BigEndian { get } public static var utf16LittleEndian { get } public static var utf32 { get } public static var utf32BigEndian { get } public static var utf32LittleEndian { get } } } Impact on existing code All Swift projects will have to run through a migration step to use the new names. Alternatives considered Drop every NS in Foundation We considered simply dropping the prefix from all types. However, this would cause quite a few conflicts with standard library types. Also, although Foundation’s framework boundary is an easy place to programmatically draw the line for the drop-prefix behavior, the reality is that Foundation has API that feels like it belongs to higher level frameworks as well. We believe this approach better identifies the best candidates for dropping the prefix.",
    "url": "http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html",
    "relUrl": "/docs/2019-08-26-0086-drop-foundation-ns.html"
  },
  "86": {
    "id": "86",
    "title": "SE-0087 Rename `lazy` to `@lazy`",
    "content": "Rename lazy to @lazy Proposal: SE-0087 Author: Anton3 Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction Make lazy declaration modifier an attribute by renaming it to @lazy. Example: struct ResourceManager { @lazy var resource: NSData = loadResource() } Swift-evolution thread: link to the discussion thread for that proposal Motivation Swift’s rule for attribues/keywords is that keywords usually modify type of variable; attributes do not. lazy clearly does not modify type of its variable, it only delays side effects of its initializer. Type of resource in the example above is still NSData. Many other similar declaration modifiers are already attributes: @available, @objc, @nonobjc, @NSCopying, @NSManaged, @IBOutlet, etc Detailed design Remove lazy keyword, add @lazy attribute and add migration rule to replace them. Future directions Many people look forward to “Property behaviours” proposal for Swift 4. It allows to create declaration modifiers using Swift language. @lazy is one of the main candidates for being extracted into standard library. But to do so, we must first make it an attribute. Because it is a breaking change, the earlier, the better. Impact on existing code This is a breaking change, but migration is trivial.",
    "url": "http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html",
    "relUrl": "/docs/2019-08-26-0087-lazy-attribute.html"
  },
  "87": {
    "id": "87",
    "title": "SE-0088 Modernize libdispatch for Swift 3 naming conventions",
    "content": "Modernize libdispatch for Swift 3 naming conventions Proposal: SE-0088 Author: Matt Wright Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Previous Revision: 1 Introduction The existing libdispatch module imports the C API almost verbatim. To move towards a more natural Swift interface and away from the C API, this proposal outlines changes to the libdispatch module and the motivation behind them. This discussion focuses on the transformation of the existing libdispatch API. Review thread Motivation libdispatch on Darwin already presents Objective-C compatible types to allow its objects to participate in automatic reference counting. We propose extending this support to present a design that feels “object-oriented” and inline with Swift 3’s API guidelines, all without adding runtime overhead. In Swift 2.2, libdispatch is exposed as a collection of functions imported from C. While trailing closure syntax does much to improve the basic usage of libdispatch, the experience in Swift still feels very C-like. As the introduction implies, we intend to transform the entire libdispatch API surface. Previously, typical dispatch usage in Swift would look like: let queue = dispatch_queue_create(&quot;com.test.myqueue&quot;, nil) dispatch_async(queue) { print(&quot;Hello World&quot;) } This proposal will transform that code into: let queue = DispatchQueue(label: &quot;com.test.myqueue&quot;) queue.asynchronously { print(&quot;Hello World&quot;) } Detailed design Type Naming All of the types used by libdispatch will be renamed to meet the Swift 3 naming guidelines. C type Swift type dispatch_object_t DispatchObject dispatch_queue_t DispatchQueue dispatch_group_t DispatchGroup dispatch_data_t DispatchData dispatch_io_t DispatchIO dispatch_semaphore_t DispatchSemaphore dispatch_source_t DispatchSource¹ dispatch_time_t DispatchTime, DispatchWalltime Several other libdispatch C types will be removed and replaced with their underlying type. These C typedefs serve to make the C API more clear as headerdoc, however in Swift these types are clearer when presented as their original type. Several other types will be replaced with OptionSet types, where appropriate. C type Swift type dispatch_fd_t Int32 dispatch_block_t () -&gt; () dispatch_queue_attr_t DispatchQueueAttributes [1] Additional DispatchSource sub-types have also been introduced, a more thorough explanation is included below. Queues Accessors to the main queue and global queues will be moved onto DispatchQueue as class properties. class DispatchQueue : DispatchObject { class var main: DispatchQueue class func global(attributes: GlobalAttributes) -&gt; DispatchQueue } Queue and group functions that are responsible for submitting work to dispatch queues will be transformed or replaced by Swift methods on DispatchQueue. These existing functions act on, or with, queues and form a more cohesive API surface when presented on DispatchQueue itself. Previously these functions took the following form: func dispatch_sync(queue: dispatch_queue_t, block: dispatch_block_t) func dispatch_async(queue: dispatch_queue_t, block: dispatch_block_t) func dispatch_group_async(group: dispatch_group_t, queue: dispatch_queue_t, block: dispatch_block_t) This proposal collects these APIs into two methods on DispatchQueue and also introduces default parameters that cover QoS and work item flags. In turn this allows for control over block and QoS inheritance behaviour: class DispatchQueue : DispatchObject { func synchronously(execute block: @noescape () -&gt; Void) func asynchronously( group: DispatchGroup? = nil, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], work: @convention(block) () -&gt; Void) } queue.asynchronously(group: group) { print(&quot;Hello World&quot;) } queue.synchronously { print(&quot;Hello World&quot;) } The existing dispatch_specific_* functions have a cumbersome interface when presented in Swift. These functions will also be refined in Swift, presenting a more typesafe API. The aim here is to provide the same underlying functionality but with additional type information, reducing the need for casting and opportunity for misuse. Before: func dispatch_get_specific(key: UnsafePointer&lt;Void&gt;) -&gt; UnsafeMutablePointer&lt;Void&gt; func dispatch_queue_get_specific(queue: dispatch_queue_t, _ key: UnsafePointer&lt;Void&gt;) -&gt; UnsafeMutablePointer&lt;Void&gt; func dispatch_queue_set_specific(queue: dispatch_queue_t, _ key: UnsafePointer&lt;Void&gt;, _ context: UnsafeMutablePointer&lt;Void&gt;, _ destructor: dispatch_function_t?) After: class DispatchSpecificKey&lt;T&gt; { init() {} } class DispatchQueue : DispatchObject { /// Return the Value? for a given DispatchSpecificKey object from /// the current dispatch queue hierarchy. class func getSpecific&lt;Value&gt;(key: DispatchSpecificKey&lt;Value&gt;) -&gt; Value? /// Get and set the DispatchSpecificKey for this queue, /// providing type information via the DispatchSpecificKey /// specialisation. func getSpecific&lt;Value&gt;(key: DispatchSpecificKey&lt;Value&gt;) -&gt; Value? func setSpecific&lt;Value&gt;(key: DispatchSpecificKey&lt;Value&gt;, value: Value?) } // Example usage, using a global key object let akey = DispatchSpecificKey&lt;Int&gt;() queue.setSpecific(key: akey, value: 42) Work Items The existing dispatch_block_* API group exposes functionality that produces dispatch_block_t blocks that are wrapped with additional metadata. That behaviour in C has multiple cases where this API group can be accidentally misused because the C types are ambiguously overloaded. This proposal will introduce a new explict class to cover this functionality, DispatchWorkItem that provides more explicit, safer typing. class DispatchWorkItem { init(group: DispatchGroup? = nil, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute: () -&gt; ()) func perform() func wait(timeout: DispatchTime = .forever) -&gt; Int func wait(timeout: DispatchWalltime) -&gt; Int func notify(queue: DispatchQueue, execute: @convention(block) () -&gt; Void) func cancel() var isCancelled: Bool } All dispatch methods that accept blocks also accept DispatchWorkItem: let item = DispatchWorkItem(qos: .qosUserInitiated) { print(&quot;Hello World&quot;) } queue.asynchronously(execute: item) Time libdispatch exposes a lightweight representation of time², focussing on deadlines and intervals for timers. However, the C interfaces for dispatch_time_t are very unfortunately imported in Swift 2.2, with type impedance problems that require unnecessary casting in order to use in Swift. This proposal will replace dispatch_time_t with two new time types and one interval type. DispatchTime, DispatchWalltime and DispatchTimeInterval. struct DispatchTime { static func now() -&gt; DispatchTime static let forever: DispatchTime } struct DispatchWalltime { static func now() -&gt; DispatchWalltime static let forever: DispatchWalltime init(time: timespec) } enum DispatchTimeInterval { case seconds(Int) case milliseconds(Int) case microseconds(Int) case nanoseconds(Int) } func +(time: DispatchTime, interval: DispatchTimeInterval) -&gt; DispatchTime func -(time: DispatchTime, interval: DispatchTimeInterval) -&gt; DispatchTime func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime func -(time: DispatchTime, seconds: Double) -&gt; DispatchTime func +(time: DispatchWalltime, interval: DispatchTimeInterval) -&gt; DispatchWalltime func -(time: DispatchWalltime, interval: DispatchTimeInterval) -&gt; DispatchWalltime func +(time: DispatchWalltime, seconds: Double) -&gt; DispatchWalltime func -(time: DispatchWalltime, seconds: Double) -&gt; DispatchWalltime The aim here is to continue to provide a lightweight representation of time, while distinguishing between time and interval quantities. Time, to be used to set deadlines, and intervals used to represent the period of repeating events. This model also allows for the expression of time and intervals either as natural second-addition, or with explicit sub-second quantities. let a = DispatchTime.now() + 3.5 // 3.5 seconds in the future let b = DispatchTime.now() + .microseconds(350) // Modify a DispatchSourceTimer with new start time and interval timer.setTimer(start: .now(), interval: .milliseconds(500)) [2] Note that libdispatch is unable to use Date from Foundation due to layering restrictions Data dispatch_data_t will be transformed into a value type, DispatchData. Data objects in libdispatch have always been immutable objects, so these objects are natural candidates for value semantics in Swift. struct DispatchData : RandomAccessCollection, _ObjectiveCBridgeable { enum Deallocator { /// Use `free` case free /// Use `munmap` case unmap /// A custom deallocator case custom(DispatchQueue?, @convention(block) () -&gt; Void) } /// Initialize a `Data` with copied memory content. init(bytes buffer: UnsafeBufferPointer&lt;UInt8&gt;) /// Initialize a `Data` without copying the bytes. init(bytesNoCopy bytes: UnsafeBufferPointer&lt;UInt8&gt;, deallocator: Deallocator = .free) mutating func append(_ bytes: UnsafePointer&lt;UInt8&gt;, count: Int) mutating func append(_ other: DispatchData) mutating func append&lt;SourceType&gt;(_ buffer: UnsafeBufferPointer&lt;SourceType&gt;) func subdata(in range: CountableRange&lt;Index&gt;) -&gt; DispatchData func region(location: Int) -&gt; (DispatchData, Int) } This proposal will introduce new accessor methods to access the bytes in a Data object. Along with becoming iteratable, several methods will be introduced that replace the dispatch_data_create_map approach used in C: struct DispatchData : RandomAccessCollection, _ObjectiveCBridgeable { func withUnsafeBytes&lt;Result, ContentType&gt;( body: @noescape (UnsafePointer&lt;ContentType&gt;) throws -&gt; Result) rethrows -&gt; Result func enumerateBytes( block: @noescape (buffer: UnsafeBufferPointer&lt;UInt8&gt;, byteIndex: Int, stop: inout Bool) -&gt; Void) func copyBytes(to pointer: UnsafeMutablePointer&lt;UInt8&gt;, count: Int) func copyBytes( to pointer: UnsafeMutablePointer&lt;UInt8&gt;, from range: Range&lt;Index&gt;) func copyBytes&lt;DestinationType&gt;( to buffer: UnsafeMutableBufferPointer&lt;DestinationType&gt;, from range: Range&lt;Index&gt;? = nil) -&gt; Int subscript(index: Index) -&gt; UInt8 } Sources Finally, this proposal will introduce additional type safety to dispatch sources. While adding additional DispatchSource subclasses is out of scope for this proposal, it will introduce a new constructor for each dispatch source type. Kind of Source Protocol DISPATCH_SOURCE_TYPE_DATA_ADD DispatchSourceUserDataAdd DISPATCH_SOURCE_TYPE_DATA_OR DispatchSourceUserDataOr DISPATCH_SOURCE_TYPE_MACH_SEND DispatchSourceMachSend DISPATCH_SOURCE_TYPE_MACH_RECV DispatchSourceMachReceive DISPATCH_SOURCE_TYPE_MEMORYPRESSURE DispatchSourceMemoryPressure DISPATCH_SOURCE_TYPE_PROC DispatchSourceProcess DISPATCH_SOURCE_TYPE_READ DispatchSourceRead DISPATCH_SOURCE_TYPE_SIGNAL DispatchSourceSignal DISPATCH_SOURCE_TYPE_TIMER DispatchSourceTimer DISPATCH_SOURCE_TYPE_VNODE DispatchSourceFileSystemObject DISPATCH_SOURCE_TYPE_WRITE DispatchSourceWrite Introducing protocols for each source allows DispatchSource to return protocols that are more strongly typed then their C equivalent. Furthermore, this proposal also adds stronger typing to return types of dispatch source accessors, where appropriate: class DispatchSource { class func machSend(port: mach_port_t, eventMask: DispatchSource.MachSendEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceMachSend class func machReceive(port: mach_port_t, queue: DispatchQueue? = default) -&gt; DispatchSourceMachReceive class func memoryPressure(eventMask: DispatchSource.MemoryPressureEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceMemoryPressure class func process(identifier: pid_t, eventMask: DispatchSource.ProcessEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceProcess class func read(fileDescriptor: Int32, queue: DispatchQueue? = default) -&gt; DispatchSourceRead class func signal(signal: Int32, queue: DispatchQueue? = default) -&gt; DispatchSourceSignal class func timer(flags: DispatchSource.TimerFlags = default, queue: DispatchQueue? = default) -&gt; DispatchSourceTimer class func userDataAdd(queue: DispatchQueue? = default) -&gt; DispatchSourceUserDataAdd class func userDataOr(queue: DispatchQueue? = default) -&gt; DispatchSourceUserDataOr class func fileSystemObject(fileDescriptor: Int32, eventMask: DispatchSource.FileSystemEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceFileSystemObject class func write(fileDescriptor: Int32, queue: DispatchQueue? = default) -&gt; DispatchSourceWrite } class DispatchSource { struct ProcessEvent : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let exit: ProcessEvent static let fork: ProcessEvent static let exec: ProcessEvent static let signal: ProcessEvent static let all: ProcessEvent = [.exit, .fork, .exec, .signal] } } extension DispatchSourceProcess { var handle: pid_t var data: DispatchSource.ProcessEvent var mask: DispatchSource.ProcessEvent } extension DispatchSourceUserDataAdd { func mergeData(value: UInt) } Module Overview The first revision of this proposal included only a brief overview of the most critical changes in the Dispatch module. For the interested, included below is a full output of the Dispatch module after the transformations proposed by this document. class DispatchGroup : DispatchObject { init() func wait(timeout: DispatchTime = default) -&gt; Int func wait(walltime timeout: DispatchWalltime) -&gt; Int func notify(queue: DispatchQueue, exeute block: () -&gt; Void) func enter() func leave() } class DispatchIO : DispatchObject { enum StreamType : UInt { case stream case random typealias RawValue = UInt var hashValue: Int { get } init?(rawValue: UInt) var rawValue: UInt { get } } struct CloseFlags : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let stop: DispatchIO.CloseFlags typealias Element = DispatchIO.CloseFlags typealias RawValue = UInt } struct IntervalFlags : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let strictInterval: DispatchIO.IntervalFlags typealias Element = DispatchIO.IntervalFlags typealias RawValue = UInt } class func read(fileDescriptor: Int32, length: Int, queue: DispatchQueue, handler: (DispatchData, Int32) -&gt; Void) class func write(fileDescriptor: Int32, data: DispatchData, queue: DispatchQueue, handler: (DispatchData?, Int32) -&gt; Void) convenience init(type: DispatchIO.StreamType, fileDescriptor: Int32, queue: DispatchQueue, cleanupHandler: (error: Int32) -&gt; Void) convenience init(type: DispatchIO.StreamType, path: UnsafePointer&lt;Int8&gt;, oflag: Int32, mode: mode_t, queue: DispatchQueue, cleanupHandler: (error: Int32) -&gt; Void) convenience init(type: DispatchIO.StreamType, io: DispatchIO, queue: DispatchQueue, cleanupHandler: (error: Int32) -&gt; Void) func close(flags: DispatchIO.CloseFlags) var fileDescriptor: Int32 { get } func read(offset: off_t, length: Int, queue: DispatchQueue, ioHandler io_handler: (Bool, DispatchData?, Int32) -&gt; Void) func setHighWater(highWater high_water: Int) func setInterval(interval: UInt64, flags: DispatchIO.IntervalFlags) func setLowWater(lowWater low_water: Int) func withBarrier(barrier: () -&gt; Void) func write(offset: off_t, data: DispatchData, queue: DispatchQueue, ioHandler io_handler: (Bool, DispatchData?, Int32) -&gt; Void) } class DispatchObject : OS_object { func suspend() func resume() func setTargetQueue(queue: DispatchQueue?) } class DispatchQueue : DispatchObject { struct GlobalAttributes : OptionSet { let rawValue: UInt64 init(rawValue: UInt64) static let qosUserInteractive: DispatchQueue.GlobalAttributes static let qosUserInitiated: DispatchQueue.GlobalAttributes static let qosDefault: DispatchQueue.GlobalAttributes static let qosUtility: DispatchQueue.GlobalAttributes static let qosBackground: DispatchQueue.GlobalAttributes typealias Element = DispatchQueue.GlobalAttributes typealias RawValue = UInt64 } class var main: DispatchQueue { get } class func global(attributes: DispatchQueue.GlobalAttributes) -&gt; DispatchQueue class func getSpecific&lt;T&gt;(key: DispatchSpecificKey&lt;T&gt;) -&gt; T? convenience init(label: String, attributes: DispatchQueueAttributes = default, target: DispatchQueue? = default) func after(when: DispatchTime, execute work: @convention(block) () -&gt; Void) func after(walltime when: DispatchWalltime, execute work: @convention(block) () -&gt; Void) func apply(applier iterations: Int, execute block: @noescape (Int) -&gt; Void) func asynchronously(execute workItem: DispatchWorkItem) func asynchronously(group: DispatchGroup? = default, qos: DispatchQoS = default, flags: DispatchWorkItemFlags = default, execute work: @convention(block) () -&gt; Void) var label: String { get } func synchronously(execute block: @noescape () -&gt; Void) func synchronously(execute workItem: DispatchWorkItem) func synchronously&lt;T&gt;(execute work: @noescape () throws -&gt; T) rethrows -&gt; T func synchronously&lt;T&gt;(flags: DispatchWorkItemFlags, execute work: @noescape () throws -&gt; T) rethrows -&gt; T var qos: DispatchQoS { get } func getSpecific&lt;T&gt;(key: DispatchSpecificKey&lt;T&gt;) -&gt; T? func setSpecific&lt;T&gt;(key: DispatchSpecificKey&lt;T&gt;, value: T) } @noreturn func dispatchMain() class DispatchSemaphore : DispatchObject { init(value: Int) func wait(timeout: DispatchTime = default) -&gt; Int func wait(walltime timeout: DispatchWalltime) -&gt; Int func signal() -&gt; Int } class DispatchSource : DispatchObject { struct MachSendEvent : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let dead: DispatchSource.MachSendEvent typealias Element = DispatchSource.MachSendEvent typealias RawValue = UInt } struct MemoryPressureEvent : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let normal: DispatchSource.MemoryPressureEvent static let warning: DispatchSource.MemoryPressureEvent static let critical: DispatchSource.MemoryPressureEvent static let all: DispatchSource.MemoryPressureEvent typealias Element = DispatchSource.MemoryPressureEvent typealias RawValue = UInt } struct ProcessEvent : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let exit: DispatchSource.ProcessEvent static let fork: DispatchSource.ProcessEvent static let exec: DispatchSource.ProcessEvent static let signal: DispatchSource.ProcessEvent static let all: DispatchSource.ProcessEvent typealias Element = DispatchSource.ProcessEvent typealias RawValue = UInt } struct TimerFlags : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let strict: DispatchSource.TimerFlags typealias Element = DispatchSource.TimerFlags typealias RawValue = UInt } struct FileSystemEvent : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let delete: DispatchSource.FileSystemEvent static let write: DispatchSource.FileSystemEvent static let extend: DispatchSource.FileSystemEvent static let attrib: DispatchSource.FileSystemEvent static let link: DispatchSource.FileSystemEvent static let rename: DispatchSource.FileSystemEvent static let revoke: DispatchSource.FileSystemEvent static let all: DispatchSource.FileSystemEvent typealias Element = DispatchSource.FileSystemEvent typealias RawValue = UInt } class func machSend(port: mach_port_t, eventMask: DispatchSource.MachSendEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceMachSend class func machReceive(port: mach_port_t, queue: DispatchQueue? = default) -&gt; DispatchSourceMachReceive class func memoryPressure(eventMask: DispatchSource.MemoryPressureEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceMemoryPressure class func process(identifier: pid_t, eventMask: DispatchSource.ProcessEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceProcess class func read(fileDescriptor: Int32, queue: DispatchQueue? = default) -&gt; DispatchSourceRead class func signal(signal: Int32, queue: DispatchQueue? = default) -&gt; DispatchSourceSignal class func timer(flags: DispatchSource.TimerFlags = default, queue: DispatchQueue? = default) -&gt; DispatchSourceTimer class func userDataAdd(queue: DispatchQueue? = default) -&gt; DispatchSourceUserDataAdd class func userDataOr(queue: DispatchQueue? = default) -&gt; DispatchSourceUserDataOr class func fileSystemObject(fileDescriptor: Int32, eventMask: DispatchSource.FileSystemEvent, queue: DispatchQueue? = default) -&gt; DispatchSourceFileSystemObject class func write(fileDescriptor: Int32, queue: DispatchQueue? = default) -&gt; DispatchSourceWrite } protocol DispatchSourceType : NSObjectProtocol { typealias DispatchSourceHandler = @convention(block) () -&gt; Void func setEventHandler(handler: DispatchSourceHandler?) func setCancelHandler(handler: DispatchSourceHandler?) func setRegistrationHandler(handler: DispatchSourceHandler?) func cancel() func resume() func suspend() var handle: UInt { get } var mask: UInt { get } var data: UInt { get } var isCancelled: Bool { get } } extension DispatchSource : DispatchSourceType { } protocol DispatchSourceUserDataAdd : DispatchSourceType { func mergeData(value: UInt) } extension DispatchSource : DispatchSourceUserDataAdd { } protocol DispatchSourceUserDataOr : DispatchSourceType { func mergeData(value: UInt) } extension DispatchSource : DispatchSourceUserDataOr { } protocol DispatchSourceMachSend : DispatchSourceType { var handle: mach_port_t { get } var data: DispatchSource.MachSendEvent { get } var mask: DispatchSource.MachSendEvent { get } } extension DispatchSource : DispatchSourceMachSend { } protocol DispatchSourceMachReceive : DispatchSourceType { var handle: mach_port_t { get } } extension DispatchSource : DispatchSourceMachReceive { } protocol DispatchSourceMemoryPressure : DispatchSourceType { var data: DispatchSource.MemoryPressureEvent { get } var mask: DispatchSource.MemoryPressureEvent { get } } extension DispatchSource : DispatchSourceMemoryPressure { } protocol DispatchSourceProcess : DispatchSourceType { var handle: pid_t { get } var data: DispatchSource.ProcessEvent { get } var mask: DispatchSource.ProcessEvent { get } } extension DispatchSource : DispatchSourceProcess { } protocol DispatchSourceRead : DispatchSourceType { } extension DispatchSource : DispatchSourceRead { } protocol DispatchSourceSignal : DispatchSourceType { } extension DispatchSource : DispatchSourceSignal { } protocol DispatchSourceTimer : DispatchSourceType { func setTimer(start: DispatchTime, leeway: DispatchTimeInterval = default) func setTimer(walltime start: DispatchWalltime, leeway: DispatchTimeInterval = default) func setTimer(start: DispatchTime, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = default) func setTimer(start: DispatchTime, interval: Double, leeway: DispatchTimeInterval = default) func setTimer(walltime start: DispatchWalltime, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = default) func setTimer(walltime start: DispatchWalltime, interval: Double, leeway: DispatchTimeInterval = default) } extension DispatchSource : DispatchSourceTimer { } protocol DispatchSourceFileSystemObject : DispatchSourceType { var handle: Int32 { get } var data: DispatchSource.FileSystemEvent { get } var mask: DispatchSource.FileSystemEvent { get } } extension DispatchSource : DispatchSourceFileSystemObject { } protocol DispatchSourceWrite : DispatchSourceType { } extension DispatchSource : DispatchSourceWrite { } extension DispatchSourceMemoryPressure { var data: DispatchSource.MemoryPressureEvent { get } var mask: DispatchSource.MemoryPressureEvent { get } } extension DispatchSourceMachReceive { var handle: mach_port_t { get } } extension DispatchSourceFileSystemObject { var handle: Int32 { get } var data: DispatchSource.FileSystemEvent { get } var mask: DispatchSource.FileSystemEvent { get } } extension DispatchSourceUserDataOr { func mergeData(value: UInt) } struct DispatchData : RandomAccessCollection, _ObjectiveCBridgeable { typealias Iterator = DispatchDataIterator typealias Index = Int typealias Indices = DefaultRandomAccessIndices&lt;DispatchData&gt; static let empty: DispatchData enum Deallocator { case free case unmap case custom(DispatchQueue?, @convention(block) () -&gt; Void) } init(bytes buffer: UnsafeBufferPointer&lt;UInt8&gt;) init(bytesNoCopy bytes: UnsafeBufferPointer&lt;UInt8&gt;, deallocator: DispatchData.Deallocator = default) var count: Int { get } func withUnsafeBytes&lt;Result, ContentType&gt;(body: @noescape (UnsafePointer&lt;ContentType&gt;) throws -&gt; Result) rethrows -&gt; Result func enumerateBytes(block: @noescape (buffer: UnsafeBufferPointer&lt;UInt8&gt;, byteIndex: Int, stop: inout Bool) -&gt; Void) mutating func append(_ bytes: UnsafePointer&lt;UInt8&gt;, count: Int) mutating func append(_ other: DispatchData) mutating func append&lt;SourceType&gt;(_ buffer: UnsafeBufferPointer&lt;SourceType&gt;) func copyBytes(to pointer: UnsafeMutablePointer&lt;UInt8&gt;, count: Int) func copyBytes(to pointer: UnsafeMutablePointer&lt;UInt8&gt;, from range: CountableRange&lt;Index&gt;) func copyBytes&lt;DestinationType&gt;(to buffer: UnsafeMutableBufferPointer&lt;DestinationType&gt;, from range: CountableRange&lt;Index&gt;? = default) -&gt; Int subscript(index: Index) -&gt; UInt8 { get } subscript(bounds: Range&lt;Int&gt;) -&gt; RandomAccessSlice&lt;DispatchData&gt; { get } func subdata(in range: CountableRange&lt;Index&gt;) -&gt; DispatchData func region(location: Int) -&gt; (data: DispatchData, offset: Int) var startIndex: Index { get } var endIndex: Index { get } func index(before i: Index) -&gt; Index func index(after i: Index) -&gt; Index func makeIterator() -&gt; Iterator typealias IndexDistance = Int typealias _Element = UInt8 typealias SubSequence = RandomAccessSlice&lt;DispatchData&gt; typealias _ObjectiveCType = __DispatchData } struct DispatchDataIterator : IteratorProtocol, Sequence { mutating func next() -&gt; _Element? typealias Element = _Element typealias Iterator = DispatchDataIterator typealias SubSequence = AnySequence&lt;_Element&gt; } struct DispatchQoS : Equatable { let qosClass: DispatchQoS.QoSClass let relativePriority: Int static let background: DispatchQoS static let utility: DispatchQoS static let defaultQoS: DispatchQoS static let userInitiated: DispatchQoS static let userInteractive: DispatchQoS static let unspecified: DispatchQoS enum QoSClass { case background case utility case defaultQoS case userInitiated case userInteractive case unspecified var hashValue: Int { get } } init(qosClass: DispatchQoS.QoSClass, relativePriority: Int) } infix func ==(a: DispatchQoS.QoSClass, b: DispatchQoS.QoSClass) -&gt; Bool func ==(a: DispatchQoS, b: DispatchQoS) -&gt; Bool infix func ==(a: DispatchQoS.QoSClass, b: DispatchQoS.QoSClass) -&gt; Bool struct DispatchQueueAttributes : OptionSet { let rawValue: UInt64 init(rawValue: UInt64) static let serial: DispatchQueueAttributes static let concurrent: DispatchQueueAttributes static let qosUserInteractive: DispatchQueueAttributes static let qosUserInitiated: DispatchQueueAttributes static let qosDefault: DispatchQueueAttributes static let qosUtility: DispatchQueueAttributes static let qosBackground: DispatchQueueAttributes static let noQoS: DispatchQueueAttributes typealias Element = DispatchQueueAttributes typealias RawValue = UInt64 } final class DispatchSpecificKey&lt;T&gt; { init() } struct DispatchTime { let rawValue: dispatch_time_t static func now() -&gt; DispatchTime static let distantFuture: DispatchTime } enum DispatchTimeInterval { case seconds(Int) case milliseconds(Int) case microseconds(Int) case nanoseconds(Int) } struct DispatchWalltime { let rawValue: dispatch_time_t static func now() -&gt; DispatchWalltime static let distantFuture: DispatchWalltime init(time: timespec) } func +(time: DispatchTime, interval: DispatchTimeInterval) -&gt; DispatchTime func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime func +(time: DispatchWalltime, interval: DispatchTimeInterval) -&gt; DispatchWalltime func +(time: DispatchWalltime, seconds: Double) -&gt; DispatchWalltime func -(time: DispatchTime, interval: DispatchTimeInterval) -&gt; DispatchTime func -(time: DispatchTime, seconds: Double) -&gt; DispatchTime func -(time: DispatchWalltime, interval: DispatchTimeInterval) -&gt; DispatchWalltime func -(time: DispatchWalltime, seconds: Double) -&gt; DispatchWalltime class DispatchWorkItem { init(group: DispatchGroup? = default, qos: DispatchQoS = default, flags: DispatchWorkItemFlags = default, block: () -&gt; ()) func perform() func wait(timeout: DispatchTime = default) -&gt; Int func wait(timeout: DispatchWalltime) -&gt; Int func notify(queue: DispatchQueue, execute: @convention(block) () -&gt; Void) func cancel() var isCancelled: Bool { get } } struct DispatchWorkItemFlags : OptionSet, RawRepresentable { let rawValue: UInt init(rawValue: UInt) static let barrier: DispatchWorkItemFlags static let detached: DispatchWorkItemFlags static let assignCurrentContext: DispatchWorkItemFlags static let noQoS: DispatchWorkItemFlags static let inheritQoS: DispatchWorkItemFlags static let enforceQoS: DispatchWorkItemFlags typealias Element = DispatchWorkItemFlags typealias RawValue = UInt } Impact on existing code All Swift code that uses libdispatch via the current C API will be affected by this change. Alternatives considered The alternative here was to leave the libdispatch API as it is currently imported in C. This proposal aims to improve the experience of using libdispatch in Swift and we did not feel that leaving the API as-is was a viable alternative.",
    "url": "http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html",
    "relUrl": "/docs/2019-08-26-0088-libdispatch-for-swift3.html"
  },
  "88": {
    "id": "88",
    "title": "SE-0089 Renaming `String.init<T>(_: T)`",
    "content": "Renaming String.init&lt;T&gt;(_: T) Proposal: SE-0089 Authors: Austin Zheng, Brent Royal-Gordon Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1881 Previous Revisions: 1 Introduction Swift’s String type ships with a large number of initializers that take one unlabeled argument. One of these initializers, defined as init&lt;T&gt;(_: T), is used to create a string containing the textual representation of an object. It is very easy to write code which accidentally invokes this initializer, when one of the other synonymous initializers was desired. Such code will compile without warnings and can be very difficult to detect. Discussion threads: pre-proposal part 1, pre-proposal part 2, review thread, post-review thread Motivation String ships with a number of initializers which take a single unlabeled argument. These include non-failable initializers which create a String out of a Character, NSString, CharacterView, or UnicodeScalarView, initializers which build a string out of a number, and failable initializers which take a UTF8View or a UTF16View. There are at least two possible situations in which a user may write incorrect code which nevertheless compiles successfully: The user means to call one of the non-failable initializers besides the init&lt;T&gt;(_: T) initializer, but passes in an argument of incorrect type. The user means to call one of the failable initializers, but accidentally assigns the created object to a value of non-nullable type. In both cases the compiler silently infers the use of the init&lt;T&gt;(_: T) initializer in lieu of the desired initializer. This may result in code which inadvertently utilizes the expensive reflection machinery and/or produces an unintentionally lossy representation of the value. Proposed solution A proposed solution to this problem follows: The current reflection-based String.init&lt;T&gt;(_: T) initializer will be renamed to String.init&lt;T&gt;(describing: T). This initializer will rarely be invoked directly by user code. A new protocol will be introduced: LosslessStringConvertible, which refines/narrows CustomStringConvertible. This protocol will be defined as follows: protocol LosslessStringConvertible : CustomStringConvertible { /// Instantiate an instance of the conforming type from a string representation. init?(_ description: String) } Values of types that conform to LosslessStringConvertible are capable of being represented in a lossless, unambiguous manner as a string. For example, the integer value 1050 can be represented in its entirety as the string &quot;1050&quot;. The description property for such a type must be a value-preserving representation of the original value. As such, it should be possible to attempt to create an instance of a LosslessStringConvertible conforming type from a string representation. A possible alternate name for this protocol is ValuePreservingStringLiteral. The core team may wish to choose this name instead, or another name that better describes the protocol’s contract. A new String initializer will be introduced: init&lt;T: LosslessStringConvertible&gt;(_ v: T) { self = v.description }. This allows the String(x) syntax to continue to be used on all values of types that can be converted to a string in a value-preserving way. As a performance optimization, the implementation of the string literal interpolation syntax will be changed to prefer the unlabeled initializer when interpolating a type that is LosslessStringConvertible or that otherwise has an unlabeled String initializer, but use the String.init&lt;T&gt;(describing: T) initializer if not. Standard library types to conform The following standard library types and protocols should be changed to conform to LosslessStringConvertible. Protocols FloatingPoint: “FP types should be able to conform. There are algorithms that are guaranteed to turn IEEE floating point values into a decimal representation in a reversible way. I don’t think we care about NaN payloads, but an encoding could be created for them as well.” (Chris Lattner) Integer Types Bool: either “true” or “false”, since these are their canonical representations. Character UnicodeScalar String String.UTF8View String.UTF16View String.CharacterView String.UnicodeScalarView StaticString Future directions Additional conformances to LosslessStringLiteral Once conditional conformance of generic types to protocols is implemented, the additional protocols and types below are candidates for conformance to LosslessStringLiteral: Protocols RangeReplaceableCollection where Iterator.Element == Character RangeReplaceableCollection where Iterator.Element == UnicodeScalar SetAlgebra where Iterator.Element == Character SetAlgebra where Iterator.Element == UnicodeScalar Types ClosedRange where Bound : LosslessStringConvertible CountableClosedRange where Bound : LosslessStringConvertible CountableRange where Bound : LosslessStringConvertible Range where Bound : LosslessStringConvertible Impact on existing code This API change may impact existing code. Code which intends to invoke init&lt;T&gt;(_: T) will need to be modified so that the proper initializer is called. In addition, it is possible that this change may uncover instances of the erroneous behavior described previously. Alternatives considered One alternative solution might be to make LosslessStringConvertible a separate protocol altogether from CustomStringConvertible and CustomDebugStringConvertible. Arguments for and against that approach can be found in this earlier version of this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html",
    "relUrl": "/docs/2019-08-26-0089-rename-string-reflection-init.html"
  },
  "89": {
    "id": "89",
    "title": "SE-0090 Remove `.self` and freely allow type references in expressions",
    "content": "Remove .self and freely allow type references in expressions Proposal: SE-0090 Authors: Joe Groff, Tanner Nelson Review Manager: Chris Lattner Status: Deferred Decision Notes: Rationale Revision: 2 Introduction Swift’s grammar currently requires that type references only appear as part of a constructor call T(x) or member access T.x. To get the metatype object for T, one must refer to the special member T.self. I propose allowing type references to appear freely in expressions and removing the .self member from the language. Swift-evolution thread: Making .self After Type Optional Motivation The constructor-or-member restriction on type references exists to provide grammatical and semantic disambiguation between type references and other expressions: Like C++, Java, and C#, Swift adopts angle bracket syntax for generic parameters, T&lt;U&gt;. In expression contexts, this introduces a grammar ambiguity with operators &lt; and &gt;. The expression T&lt;U&gt;(x) could be parsed either as a constructor call, (T&lt;U&gt;)(x), or as a chain of comparisons, (T&lt;U)&gt;(x). Rather than follow in C++’s footsteps of relying on name lookup to resolve the parse, which introduces ugly interdependencies between parsing and semantic analysis, Swift borrowed the heuristic grammatical approach taken by Java and C# to disambiguate these cases. When parsing an expression, when we see an identifier is followed by an opening angle bracket T&lt;, we attempt to parse a potential generic parameter list using the type grammar, and if we reach a matching closing bracket &gt;, we look at the following token. If the token after &gt; is (, ., or one of a few other disambiguating tokens, we accept the parse as a generic parameter list; otherwise, we backtrack and reparse the initial &lt; as an infix operator. Though not formally perfect by any means, this heuristic approach works well because a &lt; b &gt; c is unlikely to begin with (and impossible in standard Swift, because Bool is not Comparable in the standard library), and (a &lt; b, c &gt; (d)) is unlikely as a standalone tuple of expressions due to the already-low precedence of &gt;. Swift adds leading-dot .member expressions over Java and C#, so (a &lt; b, c &gt; .d) is a possibly semantically valid expression, but in practice this has never been reported as a problem. Swift reuses several expression forms as type sugar for common types: T? for Optional&lt;T&gt;, [T] for Array&lt;T&gt;, and [T: U] for Dictionary&lt;T, U&gt;. (T, U, ...) is also both the primitive syntax for tuple types and for tuple literals. Since bare type references are not currently allowed in expressions, this avoids conflicts between the type reference and expression forms; [T].self can only be a type reference to Array&lt;T&gt;, since a single-element array containing the type object for T has to be spelled [T.self]. (Note that this fails for (), which is both a valid type reference and expression.) Though precedented by other languages (arguably including Objective-C, since one can only indirectly message classes via [Class method] and cannot reference a Class object directly), this constructor-or-member restriction hasn’t been a great fit for Swift, since Swift places a stronger emphasis on type objects. Unlike Java or C#, Swift type objects are first-class, strongly-typed “metatypes”, and type objects are readily available without having to go through obscure reflection APIs. Type objects can also be used dynamically in polymorphic contexts via class methods and static protocol requirements, as in Objective-C. Though similar to Objective-C’s [T self], Swift’s T.self syntax is frequently criticized as obscure, and uglifies code that works heavily with type objects. We should improve our heuristics for dealing with these ambiguities so that .self becomes unnecessary. Proposed solution I propose making the following changes: Augment the lookahead rule for parsing generic parameter lists in expressions, so that T&lt;U&gt; type references can be reliably parsed at arbitrary positions within expressions. Treat the disambiguation of T?, [T], and [T: U] as a contextual typing problem, favoring the type reference analysis if possible, but allowing type context to choose the array or dictionary literal interpretation. Remove the now nearly useless magic .self member from the language. Detailed design Disambiguating T&lt;U&gt; To disambiguate T&lt;U&gt; in more expression positions, we can expand the set of lookahead tokens we accept after a potential generic parameter list. Let’s enumerate the expression productions in which T&lt;U&gt; is likely to appear: As a top-level statement or variable binding, followed by a newline, semicolon, or enclosing }: _ = T&lt;U&gt;; let t = T&lt;U&gt; /* n */ let makeType: () -&gt; Any.Type = { T&lt;U&gt; } In a ternary, followed by :: condition ? T&lt;U&gt; : V&lt;W&gt; or, less likely (if some creative developer in future Swift conformed metatypes to BooleanProtocol), as the condition followed by ?: T&lt;U&gt; ? x : y On the LHS of a cast, followed by is or as: T&lt;U&gt; as Superclass.Type T&lt;U&gt; is Protocol.Type T&lt;U&gt; as? Protocol.Type As an element of a container literal, followed by ,, :, or ]: [T&lt;U&gt;, V&lt;W&gt;] [T&lt;U&gt;: V&lt;W&gt;] As a binding in a capture list, also followed by ]: {[t = T&lt;U&gt;] in t } As an element of a tuple or argument list, followed by , or ): doStuff(withType: T&lt;U&gt;, andOtherType: V&lt;W&gt;) As the root of a constructor call or member access, followed by (, ., or [: T&lt;U&gt;(x: 1, y: 2) T&lt;U&gt;.staticMethod() T&lt;U&gt;[x] // maybe we&#39;ll have `static subscript` one day? As the operand of an operator, followed by a postfix or infix operator token: ++T&lt;U&gt; T&lt;U&gt;++ T&lt;U&gt; + x T&lt;U&gt;+x Operators are interesting because they also potentially require special token-splitting behavior in the lexer to interpret &gt;+ as two tokens rather than a single operator name. Potential ambiguities arise when &gt; is followed by a token that can also begin a new subexpression. This isn’t a problem for many of the tokens enumerated above; , ; : ? } ] ) is and as all unambiguously terminate or continue the current expression and can be safely added to the set of disambiguating tokens. Let’s consider the potentially ambiguous cases: Newlines: As the last production in an expression, T&lt;U&gt; may be followed by another statement or declaration on a new line. This is formally ambiguous with an expression involving &lt; and &gt; operators broken across lines: a &lt; b &gt; c However, as we noted before, a &lt; b &gt; c is not a semantically correct expression in standard Swift. Furthermore, Swift does not have a comma operator, so a &lt; b, c &gt; d is not a valid expression outside of a tuple, function call, or array literal. For these reasons, I propose that it’s safe to say that a potential generic parameter list whose closing angle bracket is followed by a token on a new line is parsed as a generic parameter list. // Parses as generic param list `let foo = (a&lt;b&gt;); c` let foo = a&lt;b&gt; c // Parses as operator expr `let foo = (a&lt;b)&gt;c` let foo = a&lt;b&gt;c Opening brackets: Though we already include ( among the set of disambiguating tokens, we do not include [. We do not currently support static subscript members, so this wouldn’t be immediately useful. If we think that’s something we may introduce in the future, we could consider adding [ to the set of disambiguating tokens. The expression production (a &lt; b, c &gt; [d]) is theoretically possible, if a function takes multiple unlabeled Bool arguments. This strikes me as slightly more likely than (a &lt; b, c &gt; .d) or (a &lt; b, c &gt; (d)), since array literals are more common than .constants, and array literals don’t have the precedence defense that obviates the need to write (a &lt; b, c &gt; (d)). Operators: Swift requires balanced whitespace around infix operators, which can disambiguate between a generic type as the left operand of a binary operator and a prefix operator as the right operand of &gt;: a&lt;b&gt; + c // (a&lt;b&gt;) + c a&lt;b &gt; +c // (a&lt;b) &gt; (+c) I’m going to go out on a limb and say that’s good enough. We could conceive of heroics to decide when to split operator tokens in the a&lt;b&gt;+c case, but in the standard library, the only operators that apply to type objects are != and ==, and while there are some developers who favor “Yoda conditionals” with the constant on the left, the variable == T&lt;U&gt; style with the constant on the right is more common. In summary, I propose we keep the existing disambiguation rule for generic parameter lists, but expand the list of disambiguating tokens to include . , ; : ? } ] ( ) is and as, spaced binary operators, and any token on a new line. This should let us parse T&lt;U&gt; in expression context reliably enough to eliminate the need for .self as a grammatical disambiguator. Disambiguating type sugar syntax The semantic problem of disambiguating type sugar from literal expressions can be considered a contextual typing problem and handled during type checking. If x?, [x], (x, y, ...), or [x: y] appear in a metatype type context, we can attempt the type reference interpretation. If x? is applied to an optional value x, or [x] appears in ArrayLiteralConvertible context, or [x: y] appears in DictionaryLiteralConvertible context, then we attempt the expression interpretation: func useType(_ type: Any.Type) {} func useArray(_ array: [Any.Type]) {} func useDictionary(_ dict: [Any.Type: Any.Type]) {} useType(Int?) // Passes Optional&lt;Int&gt; useType([Int]) // Passes Array&lt;Int&gt; useType([Int: String]) // Passes Dictionary&lt;Int, String&gt; useArray([Int]) // Passes an array, containing Int useDictionary([Int: String]) // Passes a dictionary, mapping Int =&gt; String The type reference interpretation should still only be valid when the sugar syntax is applied to concrete type references, not metatype variables: let int = Int useType([int]) // Error, can&#39;t form type reference, and // array literal doesn&#39;t type-check If type context is not available, the compiler should reject a potentially ambiguous expression: let x = [Int] // Error, could be either Array(Int) or Array&lt;Int&gt; print([Int]) // Likewise let int = Int let y = [int] // OK, not a type reference, evaluated as array containing // `int` This should not usually be problematic, since type references are most useful as function parameters, where type context is readily available. The usual language mechanisms for providing context can be used to clear up the ambiguity, such as providing explicit variable types or using as coercion, can be used to pick the correct interpretation: let x1: Any.Type = [Int] // [Int] is Array&lt;Int&gt; let x2: [Any.Type] = [Int] // [Int] is Array(Int) let x3 = [Int as Any.Type] // Another way to force array literal interp print([Int] as Any.Type) // Prints the metatype print([Int] as [Any.Type]) // Prints the array Impact on existing code If these heuristics are well-chosen, existing code should not be noticeably affected by these changes, other than being liberated from the burdensome .selfs on type references. This is something we should verify experimentally by compiling existing codebases with a compiler that implements these proposed language changes. Alternatives considered Change syntax to eliminate the ambiguities There are various fundamental things we could change in Swift’s syntax to eliminate the ambiguities from the language entirely, including: using different brackets for generic type parameters, e.g. Array(Int) or Array[Int]; making the UppercaseTypes, lowercaseValues convention a syntactic requirement, as is done in ML and Haskell. These are directions we rejected early on in the development of Swift, since we felt that maintaining familiarity with C-family languages was worth burning some implementation complexity. Revision history May 26, 2016 A previous revision of this proposal offered a default disambiguation rule for ambiguous type references without type context: let x = [Int] // binds x to the type object Array&lt;Int&gt; In discussion, the core team decided it was preferable for ambiguous references to be rejected by the compiler and require explicit context.",
    "url": "http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html",
    "relUrl": "/docs/2019-08-26-0090-remove-dot-self.html"
  },
  "90": {
    "id": "90",
    "title": "SE-0091 Improving operator requirements in protocols",
    "content": "Improving operator requirements in protocols Proposal: SE-0091 Authors: Tony Allevato, Doug Gregor Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-2073 Previous Revision: 1 Introduction When a type conforms to a protocol that declares an operator as a requirement, that operator must be implemented as a global function defined outside of the conforming type. This can lead both to user confusion and to poor type checker performance since the global namespace is overcrowded with a large number of operator overloads. This proposal mitigates both of those issues by proposing that operators in protocols be declared statically (to change and clarify where the conforming type implements it) and that Swift use universal lookup for operators that finds candidates both at the global scope and within types. Swift-evolution thread: Discussion about operators and protocols in the context of FloatingPoint Motivation The proposal came about as a result of discussion about SE-0067: Enhanced Floating Point Protocols. To implement the numerous arithmetic and comparison operators, this protocol defined named instance methods for them and then implemented the global operator functions to delegate to them. For example, public protocol FloatingPoint { func adding(rhs: Self) -&gt; Self // and others } public func + &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T { return lhs.adding(rhs) } One of the motivating factors for these named methods was to make the operators generic and reduce the number of concrete global overloads, which would improve the type checker’s performance compared to individual concrete overloads for each conforming type. Some concerns were raised about the use of named methods: They bloat the public interface. Every floating point type would expose mutating and non-mutating methods for each arithmetic operation, as well as non-mutating methods for the comparisons. We don’t expect users to actually call these methods directly but they must be present in the public interface because they are requirements of the protocol. Therefore, they would clutter API documentation and auto-complete lists and make the properties and methods users actually want to use less discoverable. Swift’s naming guidelines encourage the use of “terms of art” for naming when it is appropriate. In this case, the operator itself is the term of art. It feels odd to elevate (2.0).adding(2.0).isEqual(to: 4.0) to the same first-class status as 2.0 + 2.0 == 4.0; this is the situation that overloaded operators were made to prevent. Devising good names for the operators is tricky; the swift-evolution list had a fair amount of bikeshedding about the naming and preposition placement of isLessThanOrEqual(to:) in order to satisfy API guidelines, for example. Having both an adding method and a + operator provides two ways for the user to do the same thing. This may lead to confusion if users think that the two ways of adding have slightly different semantics. Some contributors to the discussion list have expressed concerns about operators being members of protocols at all. I feel that removing them entirely would be a step backwards for the Swift language; a protocol is not simply a list of properties and methods that a type must implement, but rather a higher-level set of requirements. Just as properties, methods, and associated types are part of that requirement set, it makes sense that an arithmetic type, for example, would declare arithmetic operators among its requirements as well. Inconsistency in the current operator design with protocols When a protocol declares an operator as a requirement, that requirement is located inside the protocol definition. For example, consider Equatable: protocol Equatable { func ==(lhs: Self, rhs: Self) -&gt; Bool } However, since operators are global functions, the actual implementation of that operator for a conforming type must be made outside the type definition. This can look particularly odd when extending an existing type to conform to an operator-only protocol: extension Foo: Equatable {} func ==(lhs: Foo, rhs: Foo) -&gt; Bool { // Implementation goes here } This is an odd inconsistency in the Swift language, driven by the fact that operators must be global functions. What’s worse is that every concrete type that conforms to Equatable must provide the operator function at global scope. As the number of types conforming to this protocol increases, so does the workload of the compiler to perform type checking. Proposed solution When a protocol wishes to declare operators that conforming types must implement, we propose adding the ability to declare operator requirements as static members of the protocol: protocol Equatable { static func ==(lhs: Self, rhs: Self) -&gt; Bool } Types conforming to a protocol that contains static operators would implement the operators as static methods (or class methods for class types) defined within the type: struct Foo: Equatable { let value: Int static func ==(lhs: Foo, rhs: Foo) -&gt; Bool { return lhs.value == rhs.value } } let f1 = Foo(value: 5) let f2 = Foo(value: 10) let eq = (f1 == f2) We initially considered requiring users to declare a global “trampoline” operator for each operator inside their protocols. This operator would be generic and constrained to that protocol type and would use the static types of its actual arguments to dispatch to the correct implementation. However, this is a burden on protocol authors to provide these stub functions that are purely an implementation detail. Instead, Swift should always perform operator lookup universally such that it sees all operators defined at either module scope or within a type/extension of a type. This gives us the syntactic improvements immediately and the natural Swift thing of defining your functionality within the type or an extension thereof just works. While it may seem odd that operators will be the only place where Swift does such universal lookup, operators can be considered a special case. This is a cleaner approach than requiring the user to manually provide trampoline operators. There is really no way to avoid it: we simply don’t want normal lexical name lookup for operators when they can be defined in types. This approach does not (directly) give any of the type checker performance/QoI improvements mentioned above. The key insight here is that we don’t want to consider both a generic operator based on some protocol (for example, + for Arithmetic types) and the operator functions used to satisfy that requirement. Therefore, we can achieve the performance improvements by making that insight part of the semantic model: when we find all operators, we also find the operators in the protocols themselves. The operators in the protocols are naturally generic; e.g., the Arithmetic + effectively has a generic function type like this: &lt;Self: Arithmetic&gt;(Self, Self) -&gt; Self Then, we say that we do not consider an operator function if it implements a protocol requirement, because the requirement is a generalization of all of the operator functions that satisfy that requirement. With this rule, we’re effectively getting the same effects as if users had declared trampoline operators, but it’s automatic. Benefits of this approach By using the name of the operator itself as the method, this approach avoids bloating the public interfaces of protocols and conforming types with additional named methods, reducing user confusion. This also will lead to better consistency going forward, as various authors of such protocols will not be providing their own method names. This approach also significantly reduces the number of symbols in the global namespace. Consider a protocol like Equatable, which requires a global definition of == for every type that conforms to it. The approach described above with universal lookup will ignore all of the implementations of == on types where it satisfies the Equatable conformance, which leaves only the single operator on Equatable itself to be considered instead. (This assumes that nobody implements == while not conforming to Equatable; while this is certainly possible, it is likely to be rare enough that it would not negatively impact performance.) Other kinds of operators (prefix, postfix, assignment) Static operator methods have the same signatures as their global counterparts. So, for example, prefix and postfix operators as well as assignment operators would be defined the way one would expect: protocol SomeProtocol { static func +=(lhs: inout Self, rhs: Self) static prefix func ~(value: Self) -&gt; Self // These are deprecated, of course, but used here just to serve as an // example. static prefix func ++(value: inout Self) -&gt; Self static postfix func ++(value: inout Self) -&gt; Self } Class types and inheritance While this approach works well for value types, it has the same limitations that today’s global operators have with regard to class types; namely that they are dispatched based on the static type of the operands rather than their dynamic types. This can lead to surprises when using base class references. This is not a regression from current behavior and we leave that problem open for a future dedicated design. For now, we require that operators implemented in a class are either static or final class methods. We do note, however, that the common case of “Subclass uses the result of Superclass’s operator in its computation” has a quite elegant solution in this design that does not involve overriding. Consider this example: protocol Equatable { static func ==(lhs: Self, rhs: Self) -&gt; Bool } class Superclass: Equatable { var foo: Int static func ==(lhs: Superclass, rhs: Superclass) -&gt; Bool { return lhs.foo == rhs.foo } } class Subclass: Superclass { var bar: String static func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool { guard lhs as Superclass == rhs as Superclass else { return false } return lhs.bar == rhs.bar } } Since the operators are dispatched based on the static types of the operands, the explicit up-casts to the superclass allows us to reuse its implementation as part of our subclass’s computation. Removal of non-static protocol operators Because the proposed solution serves as a replacement and improvement for the existing syntax used to declare operator requirements in protocols, we propose that the non-static operator method syntax be removed in Swift 3. Going forward, static member operators should be the only way to define operators that are required for protocol conformance. This is a breaking change for existing code, but supporting two kinds of operators with different declaration and use syntax would lead to significant user confusion. Global operator functions would be unaffected by this change. Users would still be able to define them as before. Detailed design Currently, the Swift language allows the use of operators as the names of global functions and of functions in protocols. This proposal is essentially asking to extend that list to include static/class methods of protocols and concrete types. Interestingly, the production rules themselves of the Swift grammar for function declarations already appear to support declaring static functions inside a protocol or other type with names that are operators. In fact, declaring a static operator function in a protocol works today (that is, the static modifier is ignored). However, defining such a function in a concrete type fails with the error operators are only allowed at global scope. This area of Parser::parseDeclFunc appears to be the likely place to make a change to allow this. Restrictions on methods with operator names Since methods with operator names are now found as part of a universal lookup, we restrict a few characteristics of their declarations as follows: Methods with operator names must be static (or alternatively final class inside classes). Non-static methods with operator names are an error. Methods with operator names must satisfy the same function signature requirements as global operator functions (infix operators take two arguments, prefix/postfix operators take one argument, and so forth). Impact on existing code The ability to declare operators as static/class functions inside a type is a new feature and would not affect existing code. Changing the way operators are declared in protocols (static instead of non-static) is a breaking change. As described above, we propose removing it entirely in Swift 3. Applying this change to the protocols already in the Swift standard library (such as Equatable) would be a breaking change, because it would change the way by which subtypes conform to that protocol. It might be possible to implement a quick fix that hoists a global operator function into the subtype’s definition, either by making it static and moving the code itself or by wrapping it in an extension. Alternatives considered One alternative would be to do nothing. This would leave us with the problems cited above: Concrete types either provide their own global operator overloads, potentially exploding the global namespace and increasing the workload of the type checker… …or they define generic operators that delegate to named methods, but those named methods bloat the public interface of the type. Furthermore, there is no consistency required for these named methods among different types; each can define its own, and subtle differences in naming can lead to user confusion. Another alternative would be that instead of using static methods, operators could be defined as instance methods on a type. For example, protocol SomeProtocol { func +(rhs: Self) -&gt; Self } struct SomeType: SomeProtocol { func +(rhs: SomeType) -&gt; SomeType { ... } } func + &lt;T: SomeProtocol&gt;(lhs: T, rhs: T) -&gt; T { return lhs.+(rhs) } There is not much to be gained by doing this, however. It does not solve the dynamic dispatch problem for classes described above, and it would require writing operator method signatures that differ from those of the global operators because the first argument instead becomes the implicit self. As a matter of style, when it doesn’t necessarily seem appropriate to elevate one argument of an infix operator—especially one that is commutative—to the special status of “receiver” while the other remains an argument. Likewise, commutative operators with heterogeneous arguments are more awkward to implement if operators are instance methods. Consider a contrived example of a CustomStringProtocol type that supports concatenation with Character using the + operator, commutatively. With static operators, both versions of the operator are declared in CustomStringProtocol, as one would expect: protocol CustomStringProtocol { static func +(lhs: Self, rhs: Character) -&gt; Self static func +(lhs: Character, rhs: Self) -&gt; Self } Likewise, the implementation of both operators would be contained entirely within the conforming types. If these were instance methods, it’s unclear how the version that has the Character argument on the left-hand side would be expressed in the protocol, or how it would be implemented if an instance of Character were the receiver. Would it be an extension on the Character type? This would split the implementation of an operation that logically belongs to CustomStringProtocol across two different locations in the code, which is something we’re trying to avoid. Acknowledgments Thanks to Chris Lattner and Dave Abrahams for contributing to the early discussions, particularly regarding the need to improve type checker performance by genericizing protocol-based operators. Thanks also to Doug Gregor who provided some incredibly valuable insight near the end of the review process that was significant enough that I consider him now a coäuthor of the proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html",
    "relUrl": "/docs/2019-08-26-0091-improving-operators-in-protocols.html"
  },
  "91": {
    "id": "91",
    "title": "SE-0092 Typealiases in protocols and protocol extensions",
    "content": "Typealiases in protocols and protocol extensions Proposal: SE-0092 Authors: David Hart, Doug Gregor Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1539 Introduction This proposal is from the Generics Manifesto and brings the typealias keyword back into protocols for type aliasing. Motivation In Swift versions prior to 2.2, the typealias keyword was used outside of protocols to declare type aliases and in protocols to declare associated types. Since SE-0011 and Swift 2.2, associated type now use the associatedtype keyword and typealias is available for implementing true associated type aliases. Proposed solution The solution allows the creation of associated type aliases. Here is an example from the standard library: protocol Sequence { associatedtype Iterator : IteratorProtocol typealias Element = Iterator.Element } The example above shows how this simplifies referencing indirect associated types: func sum&lt;T: Sequence where T.Element == Int&gt;(sequence: T) -&gt; Int { return sequence.reduce(0, combine: +) } Allowing typealias in protocol extensions also allows extensions to use aliases to simplify code that the protocol did not originally propose: extension Sequence { typealias Element = Iterator.Element func concat(other: Self) -&gt; [Element] { return Array&lt;Element&gt;(self) + Array&lt;Element&gt;(other) } } Detailed design The following grammar rules needs to be added: protocol-member-declaration → protocol-typealias-declaration protocol-typealias-declaration → typealias-declaration Impact on existing code This will initially have no impact on existing code, but will probably require improving the Fix-It that was created for migrating typealias to associatedtype in Swift 2.2. But once typealias starts being used inside protocols, especially in the Standard Library, name clashes might start cropping up between the type aliases and associated types. For example: protocol Sequence { typealias Element = Iterator.Element // once this is added } protocol MySequence: Sequence { associatedtype Element // MySequence.Element is ambiguous } But there is no reason that those name clashes behave differently than current clashes between associated types: protocol Foo { associatedtype Inner: IntegerType func foo(inner: Inner) } protocol Bar { associatedtype Inner: FloatingPointType var inner: Inner { get } } struct FooBarImpl: Foo, Bar { // error: Type ‘FooBarImpl’ does not conform to protocol ‘Bar&#39; func foo(inner: Int) {} var inner: Float }",
    "url": "http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html",
    "relUrl": "/docs/2019-08-26-0092-typealiases-in-protocols.html"
  },
  "92": {
    "id": "92",
    "title": "SE-0093 Adding a public `base` property to slices",
    "content": "Adding a public base property to slices Proposal: SE-0093 Author: Max Moiseev Review Manager: Dave Abrahams Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#2929 Introduction Slice types provided by the standard library should allow public readonly access to their base collections to make efficient implementations of protocol requirements possible in conforming types. Motivation The MutableCollection protocol conformance requires providing an implementation of the following subscript: subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get set } If the collection chooses to use one of a variety of slice types from the standard library as its SubSequence, the default implementation of a setter for this subscript will use the algorithm provided by the _writeBackMutableSlice function. This approach is fine for forward collections. It is quite possible, however, that the most efficient implementation of this setter would be to simply call the memcpy function. Unfortunately, slice API does not provide any way to reach to the underlying base collection, even though reference to it is stored in an internal property. Proposed solution We propose to export a public readonly property base, that will enable optimizations mentioned above. Here is how MutableRandomAccessSlice definition would look like: public struct MutableRandomAccessSlice&lt; Base : protocol&lt;RandomAccessIndexable, MutableIndexable&gt; &gt; : RandomAccessCollection, MutableCollection { /// The underlying collection of the slice public var base: Base { get } } The same change is applicable to both mutable and immutable slice types. Impact on existing code The proposed change is purely additive and does not affect existing code. Alternatives considered An alternative for the immutable slices would be to simply rename the already read-only _base property to base and make it public, but this way the change is not purely additive and might cause some damage inside the standard library code.",
    "url": "http://localhost:4000/docs/2019-08-26-0093-slice-base.html",
    "relUrl": "/docs/2019-08-26-0093-slice-base.html"
  },
  "93": {
    "id": "93",
    "title": "SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib",
    "content": "Add sequence(first:next:) and sequence(state:next:) to the stdlib Proposal: SE-0094 Authors: Lily Ballard, Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1622 Previous Revision: 1 Previous Proposal: SE-0045 Introduction This proposal introduces sequence(first:next:) and sequence(state:next:), a pair of global functions that return (potentially-infinite) sequences of lazy applications of a closure to an initial value or a mutable state. Swift-evolution thread: Discussion thread topic for SE-0045 Initial Discussion Motivation SE-0045, originally proposed iterate(_:apply:) (see SE-0045r1), a method that was subsequently changed to unfold(_:applying:). The proposal was accepted with modifications. The core team rejected unfold based on its naming. As its core utility remains unquestionably high, this proposal re-introduces the method with better, more Swift-appropriate naming. This function provides the natural counterpart to reduce as well as a replacement for non-striding C-style for loops that were removed by the acceptance of SE-0007, sequence can be used to apply generation steps that use non-linear math or apply non-mathematical operations, as in the following examples: for x in sequence(first: 0.1, next: { $0 * 2 }).prefix(while: { $0 &lt; 4 }) { // 0.1, 0.2, 0.4, 0.8, ... } and for view in sequence(first: someView, next: { $0.superview }) { // someView, someView.superview, someView.superview.superview, ... } See also: SE-0007 Remove C-style For Loops, SE-0045, SE-0045r1, SE-0045r3 Detailed design The declarations for the proposed functions look like: public func sequence&lt;T&gt;(first: T, next: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt; public func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T&gt; Both functions return potentially-infinite sequences of lazy repeated applications of a function to an initial value or a state. The first function, sequence(first:next:), yields the first value, followed by a series of values derived from invoking next using the previous value. The yielded sequence looks like [first, next(first), next(next(first)), ... . This sequence terminates when the next function returns nil. If the function never returns nil the sequence is infinite. This function is equivalent to Haskell’s iterate, however the Swift version is not always infinite and may terminate. The second function, sequence(state:next:), passes the state value as an inout parameter to next and yields each subsequent return value. This function is equivalent to Haskell’s unfoldr, though we’ve chosen to make the state an inout parameter instead of returning a new state as this is less likely to produce unwanted Copy on Write (COW) copies of data structures. Both functions return a sequence type named UnfoldSequence. Existing Swift naming conventions would call this SequenceSequence. Using UnfoldSequence instead resolves the unwarranted redundancy and provides a meaningful reference to developers familiar with functional programming languages. Impact on existing code None, this change is purely additive. Alternatives considered The natural name for sequence(state:next:) is unfold. Functional languages that offer unfold pair it with fold, which has already been established in Swift as reduce. Renaming reduce has already been rejected. The name sequence best describes this function in Swift. unfold on its own is not descriptive and has no meaning to developers not familiar with functional programming languages. The function sequence(first:next:) can be expressed using sequence(state:next:). We include it in this proposal due to this form’s high utility. Correctly reimplementing this form in terms of sequence(state:next:) is non-trivial; the simple solution is more eager than it should be.",
    "url": "http://localhost:4000/docs/2019-08-26-0094-sequence-function.html",
    "relUrl": "/docs/2019-08-26-0094-sequence-function.html"
  },
  "94": {
    "id": "94",
    "title": "SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax",
    "content": "Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax Proposal: SE-0095 Authors: Adrian Zubarev, Austin Zheng Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1938 Previous Revision: 1 Introduction The current protocol&lt;&gt; construct, which defines an existential type consisting of zero or more protocols, should be replaced by an infix &amp; type operator joining bare protocol type names. Discussion threads: pre-proposal, review thread 1, return for revision thread Motivation A stated goal for Swift 3.0 is making breaking changes to prepare the way for features to be introduced in future features, especially those involving the enhancements to the generics system detailed in Completing Generics. One such change described in Completing Generics is improving the existing protocol&lt;&gt; syntax in order to allow it to serve as a syntactic foundation for more generalized existential types. This is a straightforward change which will allow a later version of Swift to introduce better handling for existential types without making breaking changes, or changes whose functionality overlaps with that of existing features. Proposed solution The protocol&lt;...&gt; construct should be removed. In its place, an infix type operator &amp; will be introduced. An existential type comprised of more than one protocol will be defined by listing its types, separated by the &amp; operator, as shown below in the examples. The existing Any typealias, which represents all types that conform to zero or more protocols (i.e. all types), will become a keyword. Its meaning will not change. Trivial example: protocol A { } protocol B { } protocol C { } struct Foo : A, B, C { } let a : A &amp; B &amp; C = Foo() Example with functions: protocol A { } protocol B { } // Existential func firstFunc(x: A &amp; B) { ... } // Generic func secondFunc&lt;T : A &amp; B&gt;(x: T) { ... } The use of &amp; instead of , more clearly conveys the intent of the syntactic construct: defining a composite type formed from the conjunction of two or more protocol types. Impact on existing code Programmers will need to update any code using protocol&lt;...&gt;. Code that uses Any, but no protocol composition, will be unaffected. Code that happens to use protocol&lt;&gt; must be changed to use Any instead. Future directions Whenever a generalized existential proposal is prepared, the syntax established by this proposal can be extended as appropriate to cover additional functionality (such as where clauses). Alternatives considered The original proposal suggested replacing protocol&lt;&gt; with either Any&lt;&gt; or any&lt;&gt;. Acknowledgements Matthew Johnson and Brent Royal-Gordon provided valuable input which helped shape the first version of this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html",
    "relUrl": "/docs/2019-08-26-0095-any-as-existential.html"
  },
  "95": {
    "id": "95",
    "title": "SE-0096 Converting `dynamicType` from a property to an operator",
    "content": "Converting dynamicType from a property to an operator Proposal: SE-0096 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-2218 Introduction This proposal establishes dynamicType as a named operator rather than a property. Swift-evolution thread: RFC: didset and willset Motivation In Swift, dynamicType is a property. Because of that, it shows up as an “appropriate” code completion for all values regardless of whether it makes sense to do so or not. For example, Swift offers 4.dynamicType and myFunction().dynamicType, etc. Unlike most properties, it does not express a logical attribute of a specific type. Instead, it can be applied to any expression. Since dynamicType behaves more like a operator (like sizeof), its user-facing calling syntax should follow suit. Detailed Design Upon adoption of this proposal, Swift resyntaxes dynamicType as an operator instead of a member. This proposal puts forth dynamicType: dynamicType(value) // returns the dynamicType of value Once the Swift language has sufficient capabilities, the goal is to migrate this operation to the standard library. At this time, this operation cannot be written as a stdlib feature and it will be implemented as a compiler feature. Impact on Existing Code Adopting this proposal will break code and require migration support. The postfix property syntax must change to an operator call. Alternatives Considered The core team may also consider typeof(x) instead of dynamicType(x) as the call is syntactically closer to sizeof(x). Note that this may introduce confusion. Unlike Swift, identically-named C++ and C# terms return static types. Javascript also includes typeof(x) but Javascript does not support static types. Acknowledgements Thank you, Nate Cook",
    "url": "http://localhost:4000/docs/2019-08-26-0096-dynamictype.html",
    "relUrl": "/docs/2019-08-26-0096-dynamictype.html"
  },
  "96": {
    "id": "96",
    "title": "SE-0097 Normalizing naming for "negative" attributes",
    "content": "Normalizing naming for “negative” attributes Proposal: SE-0097 Author: Erica Sadun Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction This proposal normalizes naming for “negative” attributes by adopting a rule that replaces property names starting with no with adjectives starting with non. Swift-evolution thread: RFC: didset and willset Motivation Swift is an opinionated language. One opinion it adheres to is that attributes should be built around “non”, and not “no”, avoiding camel casing bumps. Converting no-prefixed attributes to non-integrated attributes establishes a single word that describes how each attribute modifies the syntax they decorate. Detailed Design Upon adoption, Swift will rename: noreturn to nonreturning noescape to nonescaping Impact on Existing Code This proposal requires migration support to rename keywords that use the old convention to adopt the new convention. This is a simple substitution with limited impact on existing code. Alternatives Considered The core team may consider exceptions for terms of art. For example, “no return” indicates “there is no return from this function”, as in the “point of no return”.",
    "url": "http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html",
    "relUrl": "/docs/2019-08-26-0097-negative-attributes.html"
  },
  "97": {
    "id": "97",
    "title": "SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing",
    "content": "Lowercase didSet and willSet for more consistent keyword casing Proposal: SE-0098 Author: Erica Sadun Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction This proposal adopts consistent conjoined keyword lowercasing. Swift-evolution thread: RFC: didset and willset Motivation Swift is an opinionated language. One opinion it adheres to is that keywords should use conjoined lowercasing. Conjoined lowercase terms already in the language include typealias, associatedtype, and fallthrough. Using this casing style enables programmers to treat keywords as atomic concepts. This proposal formalizes this rule and fixes current inconsistencies. Detailed Design Upon adoption, Swift will rename didSet and willSet to didset and willset. Future expansions to the language will follow this adopted rule, for example didchange. This proposal deliberately omits the dynamicType keyword, which will be addressed under separate cover: to be moved to the standard library as a standalone global function. Impact on Existing Code This proposal requires migration support to rename keywords that use the old convention to adopt the new convention. This is a simple substitution that should limit effect on code. Alternatives Considered Not adopting this rule for Swift.",
    "url": "http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html",
    "relUrl": "/docs/2019-08-26-0098-didset-capitalization.html"
  },
  "98": {
    "id": "98",
    "title": "SE-0099 Restructuring Condition Clauses",
    "content": "Restructuring Condition Clauses Proposal: SE-0099 Authors: Erica Sadun, Chris Lattner Review Manager: Joe Groff Status: Implemented (Swift 3) Decision Notes: Rationale Previous Revision: 1 Introduction Swift condition clauses appear in guard, if, and while statements. This proposal re-architects the condition grammar to enable an arbitrary mix of Boolean expressions, let conditions (which test and unwrap optionals), general case clauses for arbitrary pattern matching, and availability tests. It removes where clauses from optional binding conditions and case conditions, and eliminates gramatical ambiguity by using commas for separation between clauses instead of using them both to separate clauses and terms within each clause. These modifications streamline Swift’s syntax and alleviate the situation where many Swift developers don’t know they can use arbitrary Boolean conditions after a value binding. Swift-evolution thread: [Pitch] making where and , interchangeable in guard conditions Motivation Swift currently allows an arbitrary mix of binding, patterns, availability tests, and Boolean assertions within a single compound condition. However, its grammar includes ambiguity that force subsequent Boolean assertions to be preceded by a where clause (with a special-case exception made for availability tests). condition-clause → expression condition-clause → expression, condition-list condition-clause → condition-list condition-clause → availability-condition, expression condition-list → condition | condition, condition-list condition → availability-condition | case-condition | optional-binding-condition The rules are complex, confusing, and imprecise. The grammar establishes that standalone Boolean tests must either precede binding or be joined with optional binding and pattern conditions. The where clause, which makes sense in for loops and switch statement pattern matching, adds little to optional binding in condition clauses, as in the following example. It allows for code such as: guard x == 0, let y = optional where z == 2 else { ... In this example, the Boolean z == 2 clause has no semantic relationship to the optional condition to which it’s syntactically bound. Eliminating where enables the subordinate condition to stand on its own and be treated as a first class test among peers. The root problem lies in the condition grammar: commas are used both to separate items within a clause (e.g. in if let x = a, y = b {) and to separate mixed kinds of clauses (e.g. if let x = a, case y? = b {). This proposal resolves this problem by retaining commas as separators between clauses (as used elsewhere in Swift) and limits clauses to single items. After adoption of these changes, the previous example would be written in any of these styles: guard x == 0, let y = optional, z == 2 else { ... guard x == 0, let y = optional, z == 2 else { ... etc. This approach also solves ambiguity problems with the current grammar. For example, in current Swift, the comma in the following example could indicate a separator between two different pattern matches within the “case” clause (which has a ‘let’ pattern), or it could be an “if case” followed by an “if let” clause: if case let x = a, let y = b { With the new approach, this is unambiguously an if case followed by an if let. To include two if case clauses, repeat the case keyword: if case let x = a, case let y = b { The advantages in accepting this proposal are: The “list of lists” ambiguity problems are solved. Swift uses a cleaner and simpler grammar. where clauses are no longer used to conjoin Boolean expressions with conditional binding. This fixes user confusion issues and addresses a problem where Boolean conditions need to be attached to arbitrary bindings. Detailed Design Under this proposal, condition lists are updated to accept a grammar along the following lines: ‌condition-list → condition | condition , condition-list ‌condition → expression | availability-condition | case-condition | optional-binding-condition Where case-condition and optional-binding-condition are limited to a single item. This enables guard, while, and if to adopt grammars like: guard condition-list else code-block while condition-list code-block if condition-list code-block (else-clause)? Note: A repeat-while statement does not use a condition list. Its grammar is repeat code-block while expression Where clauses are removed from optional binding conditions and case-conditions, so: optional-binding-condition → optional-binding-head (optional-binding-continuation-list)? (where-clause)? becomes: optional-binding-condition → optional-binding-head The optional-binding-continuation-list is removed, disallowing comma-delineated binding of multiple items: guard let x = opt1, y = opt2, z = opt3, booleanAssertion else { } This change will not affect case-item-lists in switch statements, which are distinct from case-conditions in Swift’s guard, while, and if statements. All three conditions (availability conditions, case conditions, and optional binding conditions) remain otherwise unaffected. Impact on Existing Code This proposal requires migration of condition lists to replace where with a comma and introduce let in a few places. This should be straight-forward for the compiler to address using fixit hints. Alternatives Considered An earlier version of this proposal considered allowing free interchange of commas with the where keyword. Adjusting the where clause in this way wouldn’t introduce the ability to mix and match Boolean expressions, availability conditions, case conditions, and optional binding conditions in condition clauses, and was therefore discarded from consideration. Another version retained commas and where clauses but allowed arbitrary ordering of conditions and expressions. Another version suggested separating clauses with semicolons and newlines. Rationale On June 8, 2016, this proposal was accepted with revision for Swift 3. There was near unanimous agreement that the Swift 2 grammar was inconsistent and ambiguous and should be changed; most of the disagreement centered on how. Many alternatives were discussed, including the following: The proposal as originally reviewed suggests using ‘;’ or newline as a separator. To many people, this looked heavy, and it’s also inconsistent with the rest of the language, which never otherwise used semicolon as an intra-statement separator (except in the defunct for;; loop). Introducing a keyword separator, such as using ‘where’ everywhere or introducing a new ‘and’ keyword, is also bulky and either reads poorly or requires stealing new keywords. Some commenters suggested using ‘&amp;&amp;’ for consistency with simple boolean conditions. This isn’t workable due to precedence issues. The ambiguities arise from the fact that there are comma-separated lists within comma-separated lists—within the list of conditions, each ‘case’ or ‘let’ condition can have multiple declarations. If we eliminated this feature, so that every ‘case’ or ‘let’ condition had to start with ‘case’ or ‘let’, the ambiguity is resolved, and comma can remain the condition separator. This does break consistency with non-conditional ‘let’ declarations and case clauses in ‘switch’ but is otherwise workable. Of these alternatives, the core team found the last one to be the best choice. ‘case’ and ‘let’ conditions should each specify a single declaration, comma should remain the condition separator, and the ‘where’ keyword can be retired from its purpose as a boolean condition introducer. Some code becomes more verbose, but in common formatting patterns, it aligns more nicely, as in: guard let x = foo(), let y = bar(), let z = bas(), x == y || y == z else { } and though it breaks commonality between ‘let’ conditions and ‘let’ declarations, it’s more important to preserve higher-level consistency throughout the language in how components of expressions and statements are separated. Thanks everyone for the discussion, and thanks Erica and Chris for the proposal! Since, aside from the approved syntax, the fundamental thrust of the proposal remains the same, Chris has volunteered to revise it to be in line with the approved decision.",
    "url": "http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html",
    "relUrl": "/docs/2019-08-26-0099-conditionclauses.html"
  },
  "99": {
    "id": "99",
    "title": "SE-0100 Add sequence-based initializers and merge methods to Dictionary",
    "content": "Add sequence-based initializers and merge methods to Dictionary Proposal: SE-0100 Author: Nate Cook Review Manager: TBD Status: Withdrawn Introduction The Dictionary type should allow initialization from a sequence of (Key, Value) tuples and offer methods that merge a sequence of (Key, Value) tuples into a new or existing dictionary, using a closure to combine values for duplicate keys. Swift-evolution thread: First message of thread, Initial proposal draft Motivation Array and Set both have initializers that create a new instance from a sequence of elements. The Array initializer is useful for converting other sequences and collections to the “standard” collection type, while the Set initializer is essential for recovering set operations after performing any functional operations on a set. For example, filtering a set produces a collection without any kind of set operations available. let numberSet = Set(1 ... 100) let fivesOnly = numberSet.lazy.filter { $0 % 5 == 0 } fivesOnly is a LazyFilterCollection&lt;Set&lt;Int&gt;&gt; instead of a Set – sending that back through the Set sequence initializer restores the expected methods. let fivesOnlySet = Set(numberSet.lazy.filter { $0 % 5 == 0 }) fivesOnlySet.isSubsetOf(numberSet) // true Dictionary, on the other hand, has no such initializer, so a similar operation leaves no room except for building a mutable Dictionary via iteration or functional methods with dubious performance. These techniques also don’t support type inference from the source sequence, increasing verbosity. let numberDictionary = [&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4] let evenOnly = numberDictionary.lazy.filter { (_, value) in value % 2 == 0 } var viaIteration: [String: Int] = [:] for (key, value) in evenOnly { viaIteration[key] = value } let viaReduce: [String: Int] = evenOnly.reduce([:]) { (cumulative, kv) in var dict = cumulative dict[kv.key] = kv.value return dict } Beyond initialization, Array and Set both also provide a method to add a new block of elements to an existing collection. Array provides this via append(contentsOf:) for the common appending case or replaceSubrange(_:with:) for general inserting or replacing, while the unordered Set type lets you pass any sequence to unionInPlace(_:) to add elements to an existing set. Once again, Dictionary has no corresponding API – looping and adding elements one at a time as shown above is the only way to merge new elements into an existing dictionary. Proposed solution This proposal puts forward two new ways to convert (Key, Value) sequences to dictionary form: a full-width, failable initializer and a set of merging APIs that handle input data with duplicate keys. Sequence-based initializer The proposed solution would add a new, failable initializer to Dictionary that accepts any sequence of (Key, Value) tuple pairs. init?&lt;S: Sequence where S.Iterator.Element == (key: Key, value: Value)&gt;( _ keysAndValues: S) Instead of the techniques for recovering a Dictionary instance shown above, the proposed initializer would allow a much cleaner syntax. let viaProposed = Dictionary(evenOnly)! Like Array.init(_:) and Set.init(_:), this is a full-width initializer. To ensure this, the initializer requires that each key in the supplied sequence is unique, and returns nil whenever that condition isn’t met. This model prevents accidentally dropping values for keys that might be duplicated, but allows easier recovery than the trap that results from duplicate keys in a dictionary literal. The new initializer allows for some convenient uses that aren’t currently possible. Initializing from a DictionaryLiteral (the type, not an actual literal) let literal: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4] let dictFromDL = Dictionary(literal)! Swapping keys and values of an existing dictionary guard let reversedDict = Dictionary(dictFromDL.map { ($1, $0) }) else { throw Errors.ReversalFailed } // [2: &quot;b&quot;, 4: &quot;d&quot;, 1: &quot;a&quot;, 3: &quot;c&quot;] Converting an array to an indexed dictionary (popular on the thread) let names = [&quot;Cagney&quot;, &quot;Lacey&quot;, &quot;Bensen&quot;] let dict = Dictionary(names.enumerated().map { (i, val) in (i + 1, val) })! // [2: &quot;Lacey&quot;, 3: &quot;Bensen&quot;, 1: &quot;Cagney&quot;] Initializing from a pair of zipped sequences (examples abound) let letters = &quot;abcdef&quot;.characters.lazy.map { String($0) } let dictFromZip = Dictionary(zip(letters, 1...10))! // [&quot;b&quot;: 2, &quot;e&quot;: 5, &quot;a&quot;: 1, &quot;f&quot;: 6, &quot;d&quot;: 4, &quot;c&quot;: 3] This particular use is currently blocked by SR-922. As a workaround, add .map {(key: $0, value: $1)}. That last one might feel familiar to Cocoa developers accustomed to dictionaryWithObjects:forKeys:. Merging initializer and methods Creating a Dictionary from a dictional literal currently checks the keys for uniqueness, trapping on a duplicate. The sequence-based initializer shown above has the same requirements, failing and returning nil when encountering duplicate keys. let duplicates: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;a&quot;: 3, &quot;b&quot;: 4] let letterDict = Dictionary(duplicates) // nil However, some use cases can be forgiving of duplicate keys, so this proposal includes a second new initializer. This initializer allows the caller to supply, along with the sequence, a combining closure that’s called with the old and new values for any duplicate keys. Since the caller has to explicitly handle each case of duplication, this initializer doesn’t need to be failable. init&lt;S: Sequence where S.Iterator.Element == (key: Key, value: Value)&gt;( merging keysAndValues: S, combine: @noescape (Value, Value) throws -&gt; Value ) rethrows This example shows how one could keep the first value of all those supplied for a duplicate key. let letterDict2 = Dictionary(merging: duplicates, combine: { (first, _) in first }) // [&quot;b&quot;: 2, &quot;a&quot;: 1] Or the largest value for any duplicate keys. let letterDict3 = Dictionary(merging: duplicates, combine: max) // [&quot;b&quot;: 4, &quot;a&quot;: 3] At other times the merging initializer could be used to intentionally combine values for duplicate keys. Donnacha Oisín Kidney wrote a neat frequencies() method for sequences as an example of such a use in the thread. extension Sequence where Iterator.Element: Hashable { func frequencies() -&gt; [Iterator.Element: Int] { return Dictionary(merging: self.lazy.map { v in (v, 1) }, combine: +) } } [1, 2, 2, 3, 1, 2, 4, 5, 3, 2, 3, 1].frequencies() // [2: 4, 4: 1, 5: 1, 3: 3, 1: 3] This proposal also includes new mutating and non-mutating methods for Dictionary that merge the contents of a sequence of (Key, Value) tuples into an existing dictionary, merge(contentsOf:) and merged(with:). mutating func merge&lt; S: Sequence where S.Iterator.Element == (key: Key, value: Value)&gt;( contentsOf other: S, combine: @noescape (Value, Value) throws -&gt; Value ) rethrows func merged&lt; S: Sequence where S.Iterator.Element == (key: Key, value: Value)&gt;( with other: S, combine: @noescape (Value, Value) throws -&gt; Value ) rethrows -&gt; [Key: Value] As above, there are a wide variety of uses for the merge. The most common might be merging two dictionaries together. // Adding default values let defaults: [String: Bool] = [&quot;foo&quot;: false, &quot;bar&quot;: false, &quot;baz&quot;: false] var options: [String: Bool] = [&quot;foo&quot;: true, &quot;bar&quot;: false] options.merge(contentsOf: defaults) { (old, _) in old } // options is now [&quot;foo&quot;: true, &quot;bar&quot;: false, &quot;baz&quot;: false] // Summing counts repeatedly var bugCounts: [String: Int] = [&quot;bees&quot;: 9, &quot;ants&quot;: 112, ...] while bugCountingSource.hasMoreData() { bugCounts.merge(contentsOf: bugCountingSource.countMoreBugs(), combine: +) } Detailed design The design is simple enough – loop through the sequence and update the new or existing dictionary. As an optimization, it makes sense to push the merging down to the variant storage layer to avoid having to do duplicate hash/index lookups when duplicate keys are found. Collected in one place, the new APIs for Dictionary look like this: typealias Element = (key: Key, value: Value) /// Creates a new dictionary using the key/value pairs in the given sequence. /// If the given sequence has any duplicate keys, the result is `nil`. init?&lt;S: Sequence where S.Iterator.Element == Element&gt;( _ keysAndValues: S) /// Creates a new dictionary using the key/value pairs in the given sequence, /// using a combining closure to determine the value for any duplicate keys. init&lt;S: Sequence where S.Iterator.Element == Element&gt;( merging keysAndValues: S, combine: @noescape (Value, Value) throws -&gt; Value ) rethrows /// Merges the key/value pairs in the given sequence into the dictionary, /// using a combining closure to determine the value for any duplicate keys. mutating func merge&lt; S: Sequence where S.Iterator.Element == Element&gt;( contentsOf other: S, combine: @noescape (Value, Value) throws -&gt; Value ) rethrows /// Returns a new dictionary created by merging the key/value pairs in the /// given sequence into the dictionary, using a combining closure to determine /// the value for any duplicate keys. func merged&lt;S: Sequence where S.Iterator.Element == Element&gt;( with other: S, combine: @noescape (Value, Value) throws -&gt; Value ) rethrows -&gt; [Key: Value] An initial implementation and more comprehensive documentation can be found here. Impact on existing code As a new API, this will have no impact on existing code. Alternatives considered As suggested in the thread, a method could be added to Sequence that would build a dictionary. This approach seems less of a piece with the rest of the standard library, and overly verbose when used with a Dictionary that is only passing through filtering or mapping operations. In addition, I don’t think the current protocol extension system could handle a passthrough case (i.e., something like extension Sequence where Generator.Element == (Key, Value)). An earlier version of this proposal suggested a non-failable version of the sequence-based initializer that would implicitly choose the final value passed as the “winner”. This option makes too strong an assumption about the desired behavior for duplicate keys, leading to an unpredictable and opaque API. Alternately, the status quo could be maintained.",
    "url": "http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html",
    "relUrl": "/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html"
  },
  "100": {
    "id": "100",
    "title": "SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct",
    "content": "Reconfiguring sizeof and related functions into a unified MemoryLayout struct Proposal: SE-0101 Authors: Erica Sadun, Dave Abrahams Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction This proposal addresses sizeof, sizeofValue, strideof, strideofValue, align, and alignOf. It discards the value-style standalone functions and combines the remaining items into a unified structure. Review 1: Swift Evolution Review Thread Original Proposal Prior Discussions: Swift Evolution Pitch: [Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue Earlier Discussions SE-0101 Review Motivation Although sizeof(), etc are treated as terms of art, these names are appropriated from C. The functions do not correspond to anything named sizeof in LLVM. Swift’s six freestanding memory functions increase the API surface area while providing lightly-used and unsafe functionality. These APIs are not like map, filter, and Dictionary. They’re specialty items that you should only reach for when performing unsafe operations, mostly inside the guts of higher-level constructs. Refactoring this proposal to use a single namespace increases discoverability, provides a single entry point for related operations, and enables future expansions without introducing further freestanding functions. Detailed Design This proposal introduces a new struct, MemoryLayout /// Accesses the memory layout of `T` through its /// `size`, `stride`, and `alignment` properties public struct MemoryLayout&lt;T&gt; { /// Returns the contiguous memory footprint of `T`. /// /// Does not include any dynamically-allocated or &quot;remote&quot; /// storage. In particular, `MemoryLayout&lt;T&gt;.size`, when /// `T` is a class type, is the same regardless of how many /// stored properties `T` has. public static var size: Int { return _sizeof(T) } /// For instances of `T` in an `Array&lt;T&gt;`, returns the number of /// bytes from the start of one instance to the start of the /// next. This is the same as the number of bytes moved when an /// `UnsafePointer&lt;T&gt;` is incremented. `T` may have a lower minimal /// alignment that trades runtime performance for space /// efficiency. The result is always positive. public static var stride: Int { return _strideof(T) } /// Returns the default memory alignment of `T`. public static var alignment: Int { return _alignof(T) } } With this design, consumers call: // Types MemoryLayout&lt;Int&gt;.size // 8 MemoryLayout&lt;Int&gt;.stride // 8 MemoryLayout&lt;Int&gt;.alignment // 8 Values This proposal removes sizeofValue(), strideofValue(), and alignofValue() from the standard library. This proposal adopts the stance that sizes relate to types, not values. Russ Bishop writes in the initial review thread, “Asking about the size of an instance implies things that aren’t true. Sticking value labels on everything doesn’t change the fact that sizeOf(swift_array) is not going to give you the size of the underlying buffer no matter how you slice it.” As the following chart shows, type-based calls consistently outnumber instance-based calls in gist, github, and stdlib searches. The Google search for sizeof is probably too general based on its use in other languages. &lt;tr width = 800&gt; &lt;th width = 200&gt;Term&lt;/td&gt; &lt;th width = 150&gt;stdlib search&lt;/td&gt; &lt;th width = 150&gt;gist search&lt;/td&gt; &lt;th width = 150&gt;Google site:github.com swift&lt;/td&gt; &lt;/tr&gt; &lt;tr width = 800&gt; &lt;td width = 200&gt;sizeof&lt;/td&gt; &lt;td width = 150&gt;157&lt;/td&gt; &lt;td width = 150&gt;169&lt;/td&gt; &lt;td width = 150&gt;(18,600, term is probably too general)&lt;/td&gt; &lt;/tr&gt; &lt;tr width = 800&gt; &lt;td width = 200&gt;sizeofValue&lt;/td&gt; &lt;td width = 150&gt;4&lt;/td&gt; &lt;td width = 150&gt;34&lt;/td&gt; &lt;td width = 150&gt;584&lt;/td&gt; &lt;/tr&gt; &lt;tr width = 800&gt; &lt;td width = 200&gt;alignof&lt;/td&gt; &lt;td width = 150&gt;44&lt;/td&gt; &lt;td width = 150&gt;11&lt;/td&gt; &lt;td width = 150&gt;334&lt;/td&gt; &lt;/tr&gt; &lt;tr width = 800&gt; &lt;td width = 200&gt;alignofValue&lt;/td&gt; &lt;td width = 150&gt;5&lt;/td&gt; &lt;td width = 150&gt;5&lt;/td&gt; &lt;td width = 150&gt;154&lt;/td&gt; &lt;/tr&gt; &lt;tr width = 800&gt; &lt;td width = 200&gt;strideof&lt;/td&gt; &lt;td width = 150&gt;24&lt;/td&gt; &lt;td width = 150&gt;19&lt;/td&gt; &lt;td width = 150&gt;347&lt;/td&gt; &lt;/tr&gt; &lt;tr width = 800&gt; &lt;td width = 200&gt;strideofValue&lt;/td&gt; &lt;td width = 150&gt;1&lt;/td&gt; &lt;td width = 150&gt;5&lt;/td&gt; &lt;td width = 150&gt;163&lt;/td&gt; &lt;/tr&gt; If for some reason, the core team decides that there’s a compelling reason to include value calls, an implementation might look something like this: extension MemoryLayout&lt;T&gt; { init(_ : @autoclosure () -&gt; T) {} public static func of(_ candidate : @autoclosure () -&gt; T) -&gt; MemoryLayout&lt;T&gt;.Type { return MemoryLayout.init(candidate).dynamicType } } // Value let x: UInt8 = 5 MemoryLayout.of(x).size // 1 MemoryLayout.of(1).size // 8 MemoryLayout.of(&quot;hello&quot;).stride // 24 MemoryLayout.of(29.2).alignment // 8 Known Limitations and Bugs According to Joe Groff, concerns about existential values (it’s illegal to ask for the size of an existential value’s dynamic type) could be addressed by “having sizeof and friends formally take an Any.Type instead of T.Type. (This might need some tweaking of the underlying builtins to be able to open existential metatypes, but it seems implementable.)&quot; This proposal uses &lt;T&gt; / T.Type to reflect Swift’s current implementation. Note: There is a known bug (cite D. Gregor) that does not enforce .self when used with sizeof, allowing sizeof(UInt). This call should be sizeof(UInt.self). This proposal is written as if the bug were resolved without relying on adoption of SE-0090. Impact on Existing Code This proposal requires migration support to replace function calls with struct-based namespacing. This should be a simple substitution with limited impact on existing code that is easily addressed with a fixit. Alternatives Considered The original proposal introduced three renamed standalone functions: public func memorySize&lt;T&gt;(ofValue _: @autoclosure T -&gt; Void) -&gt; Int public func memoryInterval&lt;T&gt;(ofValue _: @autoclosure T -&gt; Void) -&gt; Int public func memoryAlignment&lt;T&gt;(ofValue _: @autoclosure T -&gt; Void) -&gt; Int These functions offered human factor advantages over the current proposal but didn’t address Dave’s concerns about namespacing and overall safety. This alternative has been discarded and can be referenced by reading the original proposal. Acknowledgements Thank you, Xiaodi Wu, Matthew Johnson, Pyry Jahkola, Tony Allevato, Joe Groff, Russ Bishop, and everyone else who contributed to this proposal",
    "url": "http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html",
    "relUrl": "/docs/2019-08-26-0101-standardizing-sizeof-naming.html"
  },
  "101": {
    "id": "101",
    "title": "SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type",
    "content": "Remove @noreturn attribute and introduce an empty Never type Proposal: SE-0102 Author: Joe Groff Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1953 Introduction We should remove the rarely-used @noreturn function type attribute and instead express functions that don’t return in terms of a standard uninhabited type. Swift-evolution threads: SE-0097: Normalizing naming for “negative” attributes was the review discussion from which this proposal arose. Change @noreturn to unconstructible return type Motivation Functions that never return, such as exit, fatalError, or dispatchMain, use the @noreturn attribute to communicate this fact to the compiler. This lets the compiler avoid generating incorrect control flow diagnostics for conditions such as “function does not provide a return value” after a function call that intentionally ends the program. It’s relatively rare that users need to write new functions that don’t return; however, @noreturn as currently designed generates complexity. As an orthogonal attribute of function types, its interaction must be specified with every other aspect of function types, including throws and non-void returns. Does @noreturn throws mean “cannot return normally, but can throw”, or does it mean “cannot return at all?” Is @noreturn () -&gt; Int allowed, and if so, does it behave differently from @noreturn () -&gt; ()? Should it be possible for generic operations such as function composition to be parameterized by or overload on @noreturn, so that compose(exit, getExitCode) is itself @noreturn? Swift already allows for the definition of uninhabited types. An enum type that has no cases has no valid values and cannot be constructed, a fact that many Swift users already exploit as a namespacing mechanism. A function declared to return an uninhabited type cannot return normally. /// The type of expressions that can never happen. public /*closed*/ enum Never { /*no values*/ } func foo() -&gt; Never { fatalError(&quot;no way out!&quot;) } The ability to express @noreturn thus exists in the language already and does not require an attribute. Once this concept is understood, answers to the other questions about @noreturn fall out naturally. () throws -&gt; Never clearly cannot return normally but can still throw. It becomes impossible for a function to claim both to not return and have a return type. Since Never is a first-class type, it can propagate naturally through generic operators without requiring overloading or new generics features. The net result is a simpler, more consistent, and more expressive model for handling nonreturning functions. Proposed solution The @noreturn attribute is removed from the language. Where @noreturn is currently used to exempt nonterminating code paths from control flow requirements such as exiting a guard...else clause or return-ing from a non-Void function, that exemption is transferred to expressions of uninhabited type. Detailed design Language design An uninhabited type is defined as a type that visibly has no values: An enum is an uninhabited type if it is known to have no cases, or if all of its cases are known, all of them have associated values, and all of its associated value types are empty. Note that under the resilience model, an external public enum cannot be considered empty unless it is closed, since it must otherwise be assumed to have private or retroactively added cases. A tuple, struct, or class is an uninhabited type if it has any stored properties of uninhabited type. Under the resilience model, this again means that only fragile external types can be reliably considered uninhabited. A resilient external struct or class’s properties cannot be assumed to be stored. Functions and metatypes are never uninhabited types. If an expression of uninhabited type is evaluated, it is considered unreachable by control flow diagnostics: func noReturn() -&gt; Never { fatalError() // fatalError also returns Never, so no need to `return` } func pickPositiveNumber(below limit: Int) -&gt; Int { guard limit &gt;= 1 else { noReturn() // No need to exit guarded scope after noReturn } return rand(limit) } An ignored expression of uninhabited type should also not produce an “unused result” warning. Code that would run after an uninhabited expression should raise “will not be executed” warnings. Standard library The standard library exports a new public closed enum type Never, defined to have no cases: public /*closed*/ enum Never { /* this space intentionally left blank */ } This type should be used by convention as the return type of functions that don’t return. Existing @noreturn functions in the standard library and SDK, such as fatalError, are changed to return Never. The Clang importer also imports C and Objective-C functions declared with __attribute__((noreturn)) as returning Never in Swift. SIL and runtime design The noreturn attribute still needs to exist at the SIL level, since SIL lowered function types encode the exact calling convention of functions, including imported C functions. A function returning an uninhabited type at the semantic level may still need to be lowered to have a specific inhabited return type for ABI purposes. There is currently a hole in our model. An uninhabited type is treated like a zero-sized type by type layout, and is loaded and stored like one, so a value of uninhabited type can be summoned by loading from a pointer: func neverSayNever() -&gt; Never { return UnsafeMutablePointer.alloc(1).memory } This can already be argued to be undefined behavior since the allocation is not (and cannot be) initialize-d first, but it would nonetheless be safer to make a load or store of an uninhabited type into a trap operation, both statically in IRGen (perhaps with a SIL diagnostic pass to warn when we statically see uninhabited loads or stores) and at runtime by giving uninhabited types a value witness table whose operations trap. Impact on existing code The number of @noreturn functions in the wild is fairly small, and all of them I can find return Void. It should be trivial to migrate existing @noreturn functions to use -&gt; Never. Alternatives considered Naming Never The best name for the standard library uninhabited type was a point of contention. Many of the names suggested by type theory literature or experience in functional programming circles are wanting: Void might have been mathematically appropriate, but alas has already been heavily confused with “unit” in C-derived circles. Names like Nothing, Nil, etc. have the potential to be confused with the nil value of Optional, or with returning Void. Type theory jargon like Bottom wouldn’t be immediately understood by many users. The first revision of this proposal suggested NoReturn, but in discussion, the alternative name Never was suggested, which was strongly preferred by most participants. Never properly implies the temporal aspect–this function returns never –and also generalizes well to other potential applications for an uninhabited type. For instance, if we gained the ability to support typed throws, then () throws&lt;Never&gt; -&gt; Void would also clearly communicate a function that never throws. Instead of one standard type, it might be also useful for documentation purposes to have multiple types to indicate how a type doesn’t return, e.g.: enum Exit {} /// Exit process normally func exit(_ code: Int) -&gt; Exit enum Abort {} /// Exit process abnormally func fatalError(_ message: String) -&gt; Abort enum InfiniteLoop {} /// Takes over control of the process func dispatchMain() -&gt; InfiniteLoop This proposal chooses not to go in this direction. Never as a universal “bottom” subtype An uninhabited type can be seen as a subtype of any other type–if evaluating an expression never produces a value, it doesn’t matter what the type of that expression is. If this were supported by the compiler, it would enable some potentially useful things, for instance using a nonreturning function directly as a parameter to a higher-order function that expects a result (array.filter(fatalError)) or allowing a subclass to override a method and covariantly return Never. This can be considered as a separate proposal. Moving from @noreturn to -&gt; Never is not a regression here, since the compiler does not allow an arbitrary conversion from @noreturn (T...) -&gt; U to (T...) -&gt; V today. The most important use case, a nonreturning function in void context, will still work by the existing (T...) -&gt; U to (T...) -&gt; Void subtyping rule.",
    "url": "http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html",
    "relUrl": "/docs/2019-08-26-0102-noreturn-bottom-type.html"
  },
  "102": {
    "id": "102",
    "title": "SE-0103 Make non-escaping closures the default",
    "content": "Make non-escaping closures the default Proposal: SE-0103 Author: Trent Nadeau Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1952 Previous Revision: 1 Introduction The current default of closure arguments to functions (i.e., arguments to functions that themselves have function type such as (T) -&gt; U) is to be “escaping”, meaning they can escape the function body such as saving it to a field in a struct or a global variable. In order to say that a closure argument cannot possibly escape the function body (“non-escaping”), the developer must explicitly add an @noescape annotation to the argument type. This proposal switches the default to be non-escaping and requires an @escaping annotation if a closure argument can escape the function body. Since the escaping case can be statically detected, this annotation can be added via an error with a fixit. Other annotations that have consequences for escape semantics (e.g., @autoclosure(escaping)) will be altered to make use of the new @escaping annotation. Swift-evolution threads: Make non-escaping closures the default Motivation Per Chris Lattner on swift-evolution: To provide some more details, this approach has the following advantages: Most functional algorithms written in pure Swift will benefit because they are naturally noescape. The core team feels that this will reduce the boilerplate involved with writing these algorithms. The compiler has enough logic in it to provide a great QoI experience when a developer doesn’t think about escaping, and tries to escape a closure - it can provide a fixit that suggests adding @escaping. Recent changes (to disallow escaping closures to close over an inout parameter) are pushing the language to prefer noescape closures. noescape closures have also always been the preferred default, since they eliminate a class of retain cycle issues. “@autoclosure(escaping)” can be simplified and standardized to “@autoclosure @escaping” Detailed design The @noescape annotation is removed from the language. The compiler will emit an error with a fixit to remove the annotation. The compiler will emit an error if a closure argument is found to possibly escape the function body. In order to silence the warning, the developer must add, manually or via fixit, the @escaping annotation to the argument type. The compiler’s semantic analysis implementation can be simplified as the more constrained escaping case that conflicts with other attributes is now no longer the default. The standard library should be changed to use the new default whenever possible by removing all uses of @noescape and only adding @escaping where the compiler detects the need. A helper that will convert a non-escaping closure to an “escaping” one will be added to the standard library. This helper is useful when a function has a non-escaping closure argument (the closure is called before it returns), but the closure may be used as an argument to a function requiring an escaping closure, such as various LazySequence methods. The helper should verify that the closure has not actually escaped and trap if it does. It should have the following signature: func withoutActuallyEscaping&lt;ClosureType, ResultType&gt;( _ closure: ClosureType, do: (fn: @escaping ClosureType) throws -&gt; ResultType) rethrows -&gt; ResultType { // ... } An example of its use: func yourFunction(fn: (Int) -&gt; Int) { // fn defaults to non-escaping. withoutActuallyEscaping(fn) { fn in // fn is now marked @escaping inside the closure // ... somearray.lazy.map(fn) // pass fn to something that is notationally @escaping // ... } } Imported C/Objective-C APIs Per the Core Team, most Cocoa closure/block parameters are escaping (e.g., delegates). As such the Clang importer will automatically add the @escaping annotation to closure/block parameters encountered in imported Objective-C APIs unless they are explicitly marked with the Clang ((noescape)) attribute. This will also be done with imported C APIs with function pointer or block parameters. Impact on existing code Existing code using the @noescape attribute will need to be migrated to remove the attribute since it will be the default. In addition, the compiler will need to detect escaping closures that are not marked with @escaping and create an error with a fixit to add the required attribute. Uses of @autoclosure(escaping) must be changed to @autoclosure @escaping. There should be few, if any, changes required for uses of Cocoa APIs as these will be mostly marked as @escaping, and escaping closure arguments are more constrained than non-escaping ones. Future directions The @noescape(once) annotation proposed in SE-0073 would, if some future version is accepted, just become @once. Alternatives considered Keep the existing semantics and the @noescape attribute as they are now. Keep the existing semantics but change the attribute name to @nonescaping. Acknowledgements Thanks to Chris Lattner, John McCall, and anyone else who reviewed and contributed to this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html",
    "relUrl": "/docs/2019-08-26-0103-make-noescape-default.html"
  },
  "103": {
    "id": "103",
    "title": "SE-0104 Protocol-oriented integers",
    "content": "Protocol-oriented integers Proposal: SE-0104 Authors: Dave Abrahams, Maxim Moiseev Review Manager: Ben Cohen Status: Implemented (Swift 4) Bug: SR-3196 Previous Revisions: 1, 2, 3 Discussion on swift-evolution: here. Decision notes: Rationale Introduction This proposal cleans up Swifts integer APIs and makes them more useful for generic programming. The language has evolved in ways that affect integers APIs since the time the original proposal was approved for Swift 3. We also attempted to implement the proposed model in the standard library and found that some essential APIs were missing, whereas others could be safely removed. Major changes to the APIs introduced by this revision are listed in a dedicated section. Motivation Swift’s integer protocols don’t currently provide a suitable basis for generic programming. See this blog post for an example of an attempt to implement a generic algorithm over integers. The way the IntegerArithmetic protocol is defined, it does not generalize to floating point numbers and also slows down compilation by requiring every concrete type to provide an implementation of arithmetic operators, thus polluting the overload set. Converting from one integer type to another is performed using the concept of the ‘maximum width integer’ (see MaxInt), which is an artificial limitation. The very existence of MaxInt makes it unclear what to do should someone implement Int256, for example. Another annoying problem is the inability to use integers of different types in comparison and bit-shift operations. For example, the following snippets won’t compile: var x: Int8 = 42 let y = 1 let z = 0 x &lt;&lt;= y // error: binary operator &#39;&lt;&lt;=&#39; cannot be applied to operands of type &#39;Int8&#39; and &#39;Int&#39; if x &gt; z { ... } // error: binary operator &#39;&gt;&#39; cannot be applied to operands of type &#39;Int8&#39; and &#39;Int&#39; Currently, bit-shifting a negative number of (or too many) bits causes a trap on some platforms, which makes low-level bit manipulations needlessly dangerous and unpredictable. Finally, the current design predates many of the improvements that came since Swift 1, and hasn’t been revised since then. Proposed solution We propose a new model that does not have above mentioned problems and is more easily extensible. +-+ +-+ +&gt;+ Numeric | | Comparable | | | (+,-,*) | | (==,&lt;,&gt;,...)| | +++ +++ | ^ ^ +-++ | | | SignedNumeric | +-+-+--+ | (unary -) | | BinaryInteger | ++-+ |(words,%,bitwise,...)| ^ +++--+-+ | +--^ ^ ^+ | | | | ++++ +++ +--+-+ | SignedInteger | | FixedWidthInteger | | UnsignedInteger | | | |(endianness,overflow,...)| | | ++-+ +-+--+--+ +-+--+ ^ ^ ^ ^ | | | | | | | | ++--+-+ +-+-+-+ |Int family |-+ |UInt family|-+ +--+ | +--+ | +--+ +--+ There are several benefits provided by this model over the old one: It allows mixing integer types in generic functions. The possibility to initialize instances of any concrete integer type with values of any other concrete integer type enables writing functions that operate on more than one type conforming to BinaryInteger, such as heterogeneous comparisons or bit shifts, described later. It removes the overload resolution overhead. Arithmetic and bitwise operations can now be defined as generic operators on protocols. This approach significantly reduces the number of overloads for those operations, which used to be defined for every single concrete integer type. It enables protocol sharing between integer and floating point types. Note the exclusion of the % operation from Numeric. Its behavior for floating point numbers is sufficiently different from the one for integers that using it in generic context would lead to confusion. The FloatingPoint protocol introduced by SE-0067 should now refine SignedNumeric. It makes future extensions possible. The proposed model eliminates the ‘largest integer type’ concept previously used to interoperate between integer types (see toIntMax in the current model) and instead provides access to machine words. It also introduces the multipliedFullWidth(by:), dividingFullWidth(_:), and quotientAndRemainder methods. Together these changes can be used to provide an efficient implementation of bignums that would be hard to achieve otherwise. The implementation of proposed model in the standard library is available in the new-integer-protocols branch. A note on bit shifts This proposal introduces the concepts of smart shifts and masking shifts. The semantics of shift operations are often undefined in under- or over-shift cases. Smart shifts, implemented by &gt;&gt; and &lt;&lt;, are designed to address this problem and always behave in a well defined way, as shown in the examples below: x &lt;&lt; -2 is equivalent to x &gt;&gt; 2 (1 as UInt8) &gt;&gt; 42 will evaluate to 0 (-128 as Int8) &gt;&gt; 42 will evaluate to 0xff or -1 In most scenarios, the right hand operand is a literal constant, and branches for handling under- and over-shift cases can be optimized away. For other cases, this proposal provides masking shifts, implemented by &amp;&gt;&gt; and &amp;&lt;&lt;. A masking shift logically preprocesses the right hand operand by masking its bits to produce a value in the range 0...(x-1) where x is the number of bits in the left hand operand. On most architectures this masking is already performed by the CPU’s shift instructions and has no cost. Both kinds of shift avoid undefined behavior and produce uniform semantics across architectures. Detailed design What’s new in this revision Shift operators were reorganized (pull request) Masking shift operators were moved from BinaryInteger to FixedWidthInteger. Non-masking shift operators were moved from FixedWidthInteger to BinaryInteger. Rationale: attempts to implement masking shifts for arbitrary-precision integers have failed because the semantics aren’t clear. Attempts to clarify the definition of the semantics of masking shift for BinaryInteger have failed, indicating that the operation doesn’t actually make sense outside of FixedWidthInteger. ArithmeticOverflow was removed in favor of using a simple Bool. Rationale: the enum proves to have poor ergonomics. It only appears as part of a result tuple, where a label already helps counteract the readability deficit usually caused by returning an un-labeled Bool. BinaryInteger’s initializers from floating point values were changed from: init?&lt;T : FloatingPoint&gt;(exactly source: T) init&lt;T : FloatingPoint&gt;(_ source: T) to: init?&lt;T : BinaryFloatingPoint&gt;(exactly source: T) init&lt;T : BinaryFloatingPoint&gt;(_ source: T) Rationale: Attempts to implement these initializers for arbitrary models of FloatingPoint have failed (see here and here) whereas they are clearly implementable for models of BinaryFloatingPoint, suggesting that the operation doesn’t actually make sense outside of BinaryFloatingPoint. BinaryInteger’s init(extendingOrTruncating:) was renamed to init(truncatingIfNeeded:) Rationale: extendingOrTruncating emphasizes a part of the semantics (“extending”) that is lossless and thus doesn’t warrant the implied warning of an argument label. The two use cases for this initializer are intentional truncation and optimizing out range checks that are known by the programmer to be un-needed. Both these cases are better served by truncatingIfNeeded. Protocols Numeric The Numeric protocol declares binary arithmetic operators – such as +, -, and * — and their mutating counterparts. It provides a suitable basis for arithmetic on scalars such as integers and floating point numbers. Both mutating and non-mutating operations are declared in the protocol, however only the mutating ones are required, as default implementations of the non-mutating ones are provided by a protocol extension. The Magnitude associated type is able to hold the absolute value of any possible value of Self. Concrete types do not have to provide a type alias for it, as it can be inferred from the magnitude property. This property can be useful in operations that are simpler to implement in terms of unsigned values, for example, printing a value of an integer, which is just printing a ‘-‘ character in front of an absolute value. Please note that for ordinary work, the magnitude property should not be preferred to the abs(_) function, whose return value is of the same type as its argument. public protocol Numeric : Equatable, ExpressibleByIntegerLiteral { /// Creates a new instance from the given integer, if it can be represented /// exactly. /// /// If the value passed as `source` is not representable exactly, the result /// is `nil`. In the following example, the constant `x` is successfully /// created from a value of `100`, while the attempt to initialize the /// constant `y` from `1_000` fails because the `Int8` type can represent /// `127` at maximum: /// /// let x = Int8(exactly: 100) /// // x == Optional(100) /// let y = Int8(exactly: 1_000) /// // y == nil /// /// - Parameter source: A BinaryInteger value to convert to an integer. init?&lt;T : BinaryInteger&gt;(exactly source: T) /// A type that can represent the absolute value of any possible value of the /// conforming type. associatedtype Magnitude : Numeric, Comparable /// The magnitude of this value. /// /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`. /// You can use the `magnitude` property in operations that are simpler to /// implement in terms of unsigned values, such as printing the value of an /// integer, which is just printing a &#39;-&#39; character in front of an absolute /// value. /// /// let x = -200 /// // x.magnitude == 200 /// /// The global `abs(_:)` function provides more familiar syntax when you need /// to find an absolute value. In addition, because `abs(_:)` always returns /// a value of the same type, even in a generic context, using the function /// instead of the `magnitude` property is encouraged. /// /// - SeeAlso: `abs(_:)` var magnitude: Magnitude { get } /// Returns the sum of the two given values. /// /// The sum of `lhs` and `rhs` must be representable in the same type. In the /// following example, the result of `100 + 200` is greater than the maximum /// representable `Int8` value: /// /// let x: Int8 = 10 + 21 /// // x == 31 /// let y: Int8 = 100 + 121 /// // Overflow error static func +(_ lhs: Self, _ rhs: Self) -&gt; Self /// Adds the given value to this value in place. /// /// For example: /// /// var x = 15 /// x += 7 /// // x == 22 static func +=(_ lhs: inout Self, rhs: Self) /// Returns the difference of the two given values. /// /// The difference of `lhs` and `rhs` must be representable in the same type. /// In the following example, the result of `10 - 21` is less than zero, the /// minimum representable `UInt` value: /// /// let x: UInt = 21 - 10 /// // x == 11 /// let y: UInt = 10 - 21 /// // Overflow error static func -(_ lhs: Self, _ rhs: Self) -&gt; Self /// Subtracts the given value from this value in place. /// /// For example: /// /// var x = 15 /// x -= 7 /// // x == 8 static func -=(_ lhs: inout Self, rhs: Self) /// Returns the product of the two given values. /// /// The product of `lhs` and `rhs` must be representable in the same type. In /// the following example, the result of `10 * 50` is greater than the /// maximum representable `Int8` value. /// /// let x: Int8 = 10 * 5 /// // x == 50 /// let y: Int8 = 10 * 50 /// // Overflow error static func *(_ lhs: Self, _ rhs: Self) -&gt; Self /// Multiples this value by the given value in place. /// /// For example: /// /// var x = 15 /// x *= 7 /// // x == 105 static func *=(_ lhs: inout Self, rhs: Self) } extension Numeric { public static prefix func + (x: Self) -&gt; Self { return x } } SignedNumeric The SignedNumeric protocol is for numbers that can be negated. public protocol SignedNumeric : Numeric { /// Returns the additive inverse of this value. /// /// let x = 21 /// let y = -x /// // y == -21 /// /// - Returns: The additive inverse of this value. /// /// - SeeAlso: `negate()` static prefix func - (_ operand: Self) -&gt; Self /// Replaces this value with its additive inverse. /// /// The following example uses the `negate()` method to negate the value of /// an integer `x`: /// /// var x = 21 /// x.negate() /// // x == -21 /// /// - SeeAlso: The unary minus operator (`-`). mutating func negate() } extension SignedNumeric { public static prefix func - (_ operand: Self) -&gt; Self { var result = operand result.negate() return result } public mutating func negate() { self = 0 - self } } BinaryInteger The BinaryInteger protocol is the basis for all the integer types provided by the standard library. This protocol adds a few new initializers. Two of them allow to create integers from floating point numbers, others support construction from instances of any type conforming to BinaryInteger, using different strategies: Initialize Self with the value, provided that the value is representable. The precondition should be satisfied by the caller. Extend or truncate the value to fit into Self Clamp the value to the representable range of Self BinaryInteger also declares bitwise and shift operators. public protocol BinaryInteger : Comparable, Hashable, Numeric, CustomStringConvertible, Strideable { associatedtype Words : Collection // where Iterator.Element == UInt /// A Boolean value indicating whether this type is a signed integer type. /// /// *Signed* integer types can represent both positive and negative values. /// *Unsigned* integer types can represent only nonnegative values. static var isSigned: Bool { get } /// Creates an integer from the given floating-point value, if it can be /// represented exactly. /// /// If the value passed as `source` is not representable exactly, the result /// is `nil`. In the following example, the constant `x` is successfully /// created from a value of `21.0`, while the attempt to initialize the /// constant `y` from `21.5` fails: /// /// let x = Int(exactly: 21.0) /// // x == Optional(21) /// let y = Int(exactly: 21.5) /// // y == nil /// /// - Parameter source: A floating-point value to convert to an integer. init?&lt;T : BinaryFloatingPoint&gt;(exactly source: T) /// Creates an integer from the given floating-point value, truncating any /// fractional part. /// /// Truncating the fractional part of `source` is equivalent to rounding /// toward zero. /// /// let x = Int(21.5) /// // x == 21 /// let y = Int(-21.5) /// // y == -21 /// /// If `source` is outside the bounds of this type after truncation, a /// runtime error may occur. /// /// let z = UInt(-21.5) /// // Error: ...the result would be less than UInt.min /// /// - Parameter source: A floating-point value to convert to an integer. /// `source` must be representable in this type after truncation. init&lt;T : BinaryFloatingPoint&gt;(_ source: T) /// Creates an new instance from the given integer. /// /// If the value passed as `source` is not representable in this type, a /// runtime error may occur. /// /// let x = -500 as Int /// let y = Int32(x) /// // y == -500 /// /// // -500 is not representable as a &#39;UInt32&#39; instance /// let z = UInt32(x) /// // Error /// /// - Parameter source: An integer to convert. `source` must be representable /// in this type. init&lt;T : BinaryInteger&gt;(_ source: T) /// Creates a new instance from the bit pattern of the given instance by /// sign-extending or truncating to fit this type. /// /// When the bit width of `T` (the type of `source`) is equal to or greater /// than this type&#39;s bit width, the result is the truncated /// least-significant bits of `source`. For example, when converting a /// 16-bit value to an 8-bit type, only the lower 8 bits of `source` are /// used. /// /// let p: Int16 = -500 /// // &#39;p&#39; has a binary representation of 11111110_00001100 /// let q = Int8(truncatingIfNeeded: p) /// // q == 12 /// // &#39;q&#39; has a binary representation of 00001100 /// /// When the bit width of `T` is less than this type&#39;s bit width, the result /// is *sign-extended* to fill the remaining bits. That is, if `source` is /// negative, the result is padded with ones; otherwise, the result is /// padded with zeros. /// /// let u: Int8 = 21 /// // &#39;u&#39; has a binary representation of 00010101 /// let v = Int16(truncatingIfNeeded: u) /// // v == 21 /// // &#39;v&#39; has a binary representation of 00000000_00010101 /// /// let w: Int8 = -21 /// // &#39;w&#39; has a binary representation of 11101011 /// let x = Int16(truncatingIfNeeded: w) /// // x == -21 /// // &#39;x&#39; has a binary representation of 11111111_11101011 /// let y = UInt16(truncatingIfNeeded: w) /// // y == 65515 /// // &#39;y&#39; has a binary representation of 11111111_11101011 /// /// - Parameter source: An integer to convert to this type. init&lt;T : BinaryInteger&gt;(truncatingIfNeeded source: T) /// Creates a new instance with the representable value that&#39;s closest to the /// given integer. /// /// If the value passed as `source` is greater than the maximum representable /// value in this type, the result is the type&#39;s `max` value. If `source` is /// less than the smallest representable value in this type, the result is /// the type&#39;s `min` value. /// /// In this example, `x` is initialized as an `Int8` instance by clamping /// `500` to the range `-128...127`, and `y` is initialized as a `UInt` /// instance by clamping `-500` to the range `0...UInt.max`. /// /// let x = Int8(clamping: 500) /// // x == 127 /// // x == Int8.max /// /// let y = UInt(clamping: -500) /// // y == 0 /// /// - Parameter source: An integer to convert to this type. init&lt;T : BinaryInteger&gt;(clamping source: T) /// The collection of words in two&#39;s complement representation of the value, /// from the least significant to most. var words: Words { get } /// The number of bits in the current binary representation of this value. /// /// This property is a constant for instances of fixed-width integer /// types. var bitWidth : Int { get } /// The number of trailing zeros in this value&#39;s binary representation. /// /// For example, in a fixed-width integer type with a `bitWidth` value of 8, /// the number -8 has three trailing zeros. /// /// let x = Int8(bitPattern: 0b1111_1000) /// // x == -8 /// // x.trailingZeroBits == 3 var trailingZeroBits: Int { get } /// Returns the quotient of dividing the first value by the second. /// /// For integer types, any remainder of the division is discarded. /// /// let x = 21 / 5 /// // x == 4 static func /(_ lhs: Self, _ rhs: Self) -&gt; Self /// Divides this value by the given value in place. /// /// For example: /// /// var x = 15 /// x /= 7 /// // x == 2 static func /=(_ lhs: inout Self, rhs: Self) /// Returns the remainder of dividing the first value by the second. /// /// The result has the same sign as `lhs` and is less than `rhs.magnitude`. /// /// let x = 22 % 5 /// // x == 2 /// let y = 22 % -5 /// // y == 2 /// let z = -22 % -5 /// // z == -2 /// /// - Parameters: /// - lhs: The value to divide. /// - rhs: The value to divide `lhs` by. `rhs` must not be zero. static func %(_ lhs: Self, _ rhs: Self) -&gt; Self /// Replaces this value with the remainder of itself divided by the given /// value. For example: /// /// var x = 15 /// x %= 7 /// // x == 1 /// /// - Parameter rhs: The value to divide this value by. `rhs` must not be /// zero. /// /// - SeeAlso: `remainder(dividingBy:)` static func %=(_ lhs: inout Self, _ rhs: Self) /// Returns the inverse of the bits set in the argument. /// /// The bitwise NOT operator (`~`) is a prefix operator that returns a value /// in which all the bits of its argument are flipped: Bits that are `1` in /// the argument are `0` in the result, and bits that are `0` in the argument /// are `1` in the result. This is equivalent to the inverse of a set. For /// example: /// /// let x: UInt8 = 5 // 0b00000101 /// let notX = ~x // 0b11111010 /// /// Performing a bitwise NOT operation on 0 returns a value with every bit /// set to `1`. /// /// let allOnes = ~UInt8.min // 0b11111111 /// /// - Complexity: O(1). static prefix func ~ (_ x: Self) -&gt; Self /// Returns the result of performing a bitwise AND operation on this value /// and the given value. /// /// A bitwise AND operation results in a value that has each bit set to `1` /// where *both* of its arguments have that bit set to `1`. For example: /// /// let x: UInt8 = 5 // 0b00000101 /// let y: UInt8 = 14 // 0b00001110 /// let z = x &amp; y // 0b00000100 static func &amp;(_ lhs: Self, _ rhs: Self) -&gt; Self static func &amp;=(_ lhs: inout Self, _ rhs: Self) /// Returns the result of performing a bitwise OR operation on this value and /// the given value. /// /// A bitwise OR operation results in a value that has each bit set to `1` /// where *one or both* of its arguments have that bit set to `1`. For /// example: /// /// let x: UInt8 = 5 // 0b00000101 /// let y: UInt8 = 14 // 0b00001110 /// let z = x | y // 0b00001111 static func |(_ lhs: Self, _ rhs: Self) -&gt; Self static func |=(_ lhs: inout Self, _ rhs: Self) /// Returns the result of performing a bitwise XOR operation on this value /// and the given value. /// /// A bitwise XOR operation, also known as an exclusive OR operation, results /// in a value that has each bit set to `1` where *one or the other but not /// both* of its arguments had that bit set to `1`. For example: /// /// let x: UInt8 = 5 // 0b00000101 /// let y: UInt8 = 14 // 0b00001110 /// let z = x ^ y // 0b00001011 static func ^(_ lhs: Self, _ rhs: Self) -&gt; Self static func ^=(_ lhs: inout Self, _ rhs: Self) /// Returns the result of shifting this value&#39;s binary representation the /// specified number of digits to the right. static func &gt;&gt;&lt;RHS: BinaryInteger&gt;(_ lhs: Self, _ rhs: RHS) -&gt; Self /// Stores the result of shifting a value&#39;s binary representation the /// specified number of digits to the right in the left-hand-side variable. static func &gt;&gt;=&lt;RHS: BinaryInteger&gt;(_ lhs: inout Self, _ rhs: RHS) /// Returns the result of shifting a value&#39;s binary representation the /// specified number of digits to the left. static func &lt;&lt; &lt;RHS: BinaryInteger&gt;(_ lhs: Self, _ rhs: RHS) -&gt; Self /// Stores the result of shifting a value&#39;s binary representation the /// specified number of digits to the left in the left-hand-side variable static func &lt;&lt;= &lt;RHS: BinaryInteger&gt;(_ lhs: inout Self, _ rhs: RHS) /// Returns the quotient and remainder of this value divided by the given /// value. /// /// Use this method to calculate the quotient and remainder of a division at /// the same time. /// /// let x = 1_000_000 /// let (q, r) = x.quotientAndRemainder(dividingBy: 933) /// // q == 1071 /// // r == 757 /// /// - Parameter rhs: The value to divide this value by. /// - Returns: A tuple containing the quotient and remainder of this value /// divided by `rhs`. func quotientAndRemainder(dividingBy rhs: Self) -&gt; (quotient: Self, remainder: Self) /// Returns `-1` if this value is negative and `1` if it&#39;s positive; /// otherwise, `0`. /// /// - Returns: The sign of this number, expressed as an integer of the same /// type. func signum() -&gt; Self } extension BinaryInteger { init() { self = 0 } } FixedWidthInteger The FixedWidthInteger protocol adds the notion of endianness as well as static properties for type bounds and bit width. The ReportingOverflow family of methods is used in default implementations of mutating arithmetic methods (see the Numeric protocol). Having these methods allows the library to provide both bounds-checked and masking implementations of arithmetic operations, without duplicating code. The multipliedFullWidth(by:) and dividingFullWidth(_:) methods are necessary building blocks to implement support for integer types of a greater width such as arbitrary-precision integers. public protocol FixedWidthInteger : BinaryInteger { /// The number of bits used for the underlying binary representation of /// values of this type. /// /// An unsigned, fixed-width integer type can represent values from 0 through /// `(2 ** bitWidth) - 1`, where `**` is exponentiation. A signed, /// fixed-width integer type can represent values from /// `-(2 ** bitWidth - 1)` through `(2 ** bitWidth - 1) - 1`. For example, /// the `Int8` type has a `bitWidth` value of 8 and can store any integer in /// the range `-128...127`. static var bitWidth : Int { get } /// The maximum representable integer in this type. /// /// For unsigned integer types, this value is `(2 ** bitWidth) - 1`, where /// `**` is exponentiation. For signed integer types, this value is /// `(2 ** bitWidth - 1) - 1`. static var max: Self { get } /// The minimum representable value. /// /// For unsigned integer types, this value is always `0`. For signed integer /// types, this value is `-(2 ** bitWidth - 1)`, where `**` is /// exponentiation. static var min: Self { get } /// Returns the sum of this value and the given value along with a flag /// indicating whether overflow occurred in the operation. /// /// - Parameter other: The value to add to this value. /// - Returns: A tuple containing the result of the addition along with a /// flag indicating whether overflow occurred. If the `overflow` component /// is `.none`, the `partialValue` component contains the entire sum. If /// the `overflow` component is `.overflow`, an overflow occurred and the /// `partialValue` component contains the truncated sum of this value and /// `other`. /// /// - SeeAlso: `+` func addingReportingOverflow(_ other: Self) -&gt; (partialValue: Self, overflow: Bool) /// Returns the difference of this value and the given value along with a /// flag indicating whether overflow occurred in the operation. /// /// - Parameter other: The value to subtract from this value. /// - Returns: A tuple containing the result of the subtraction along with a /// flag indicating whether overflow occurred. If the `overflow` component /// is `.none`, the `partialValue` component contains the entire /// difference. If the `overflow` component is `.overflow`, an overflow /// occurred and the `partialValue` component contains the truncated /// result of `other` subtracted from this value. /// /// - SeeAlso: `-` func subtractingReportingOverflow(_ other: Self) -&gt; (partialValue: Self, overflow: Bool) /// Returns the product of this value and the given value along with a flag /// indicating whether overflow occurred in the operation. /// /// - Parameter other: The value to multiply by this value. /// - Returns: A tuple containing the result of the multiplication along with /// a flag indicating whether overflow occurred. If the `overflow` /// component is `.none`, the `partialValue` component contains the entire /// product. If the `overflow` component is `.overflow`, an overflow /// occurred and the `partialValue` component contains the truncated /// product of this value and `other`. /// /// - SeeAlso: `*`, `multipliedFullWidth(by:)` func multipliedReportingOverflow(by other: Self) -&gt; (partialValue: Self, overflow: Bool) /// Returns the quotient of dividing this value by the given value along with /// a flag indicating whether overflow occurred in the operation. /// /// For a value `x`, if zero is passed as `other`, the result is /// `(x, .overflow)`. /// /// - Parameter other: The value to divide this value by. /// - Returns: A tuple containing the result of the division along with a /// flag indicating whether overflow occurred. If the `overflow` component /// is `.none`, the `partialValue` component contains the entire quotient. /// If the `overflow` component is `.overflow`, an overflow occurred and /// the `partialValue` component contains the truncated quotient. /// /// - SeeAlso: `/`, `dividingFullWidth(_:)` func dividedReportingOverflow(by other: Self) -&gt; (partialValue: Self, overflow: Bool) /// Returns a double-width value containing the high and low parts of the /// result of multiplying this value by an argument. /// /// Use this method to calculate the full result of a product that would /// otherwise overflow. Unlike traditional truncating multiplication, the /// `multipliedFullWidth(by:)` method returns both the high and low /// parts of the product of `self` and `other`. The following example uses /// this method to multiply two `UInt8` values that normally overflow when /// multiplied: /// /// let x: UInt8 = 100 /// let y: UInt8 = 20 /// let result = x.multipliedFullWidth(by: y) /// // result.high == 0b00000111 /// // result.low == 0b11010000 /// /// The product of `x` and `y` is 2000, which is too large to represent in a /// `UInt8` instance. The `high` and `low` components of the `result` /// represent 2000 when concatenated to form a double-width integer; that /// is, using `result.high` as the high byte and `result.low` as the low byte /// of a `UInt16` instance. /// /// let z = UInt16(result.high) &lt;&lt; 8 | UInt16(result.low) /// // z == 2000 /// /// - Parameters: /// - other: A value to multiplied `self` by. /// - Returns: A tuple containing the high and low parts of the result of /// multiplying `self` and `other`. /// /// - SeeAlso: `multipliedReportingOverflow(by:)` func multipliedFullWidth(by other: Self) -&gt; DoubleWidth&lt;Self&gt; /// Returns a tuple containing the quotient and remainder of dividing the /// first argument by this value. /// /// The resulting quotient must be representable within the bounds of the /// type. If the quotient of dividing `lhs` by `self` is too large to /// represent in the type, a runtime error may occur. /// /// - Parameters: /// - lhs: A value containing the high and low parts of a double-width /// integer. The `high` component of the tuple carries the sign, if the /// type is signed. /// - Returns: A tuple containing the quotient and remainder of `lhs` divided /// by `self`. func dividingFullWidth(_ lhs: DoubleWidth&lt;Self&gt;) -&gt; (quotient: Self, remainder: Self) /// The number of bits equal to 1 in this value&#39;s binary representation. /// /// For example, in a fixed-width integer type with a `bitWidth` value of 8, /// the number 31 has five bits equal to 1. /// /// let x: Int8 = 0b0001_1111 /// // x == 31 /// // x.populationCount == 5 var populationCount: Int { get } /// The number of leading zeros in this value&#39;s binary representation. /// /// For example, in a fixed-width integer type with a `bitWidth` value of 8, /// the number 31 has three leading zeros. /// /// let x: Int8 = 0b0001_1111 /// // x == 31 /// // x.leadingZeroBits == 3 /// - SeeAlso: `BinaryInteger.trailingZeroBits` var leadingZeroBits: Int { get } /// Creates an integer from its big-endian representation, changing the /// byte order if necessary. init(bigEndian value: Self) /// Creates an integer from its little-endian representation, changing the /// byte order if necessary. init(littleEndian value: Self) /// The big-endian representation of this integer. /// /// If necessary, the byte order of this value is reversed from the typical /// byte order of this integer type. On a big-endian platform, for any /// integer `x`, `x == x.bigEndian`. /// /// - SeeAlso: `littleEndian` var bigEndian: Self { get } /// The little-endian representation of this integer. /// /// If necessary, the byte order of this value is reversed from the typical /// byte order of this integer type. On a little-endian platform, for any /// integer `x`, `x == x.littleEndian`. /// /// - SeeAlso: `bigEndian` var littleEndian: Self { get } /// A representation of this integer with the byte order swapped. var byteSwapped: Self { get } /// Returns the result of shifting a value&#39;s binary representation the /// specified number of digits to the right, masking the shift amount to the /// type&#39;s bit width. static func &amp;&gt;&gt;(_ lhs: Self, _ rhs: Self) -&gt; Self /// Calculates the result of shifting a value&#39;s binary representation the /// specified number of digits to the right, masking the shift amount to the /// type&#39;s bit width, and stores the result in the left-hand-side variable. static func &amp;&gt;&gt;=(_ lhs: inout Self, _ rhs: Self) /// Returns the result of shifting a value&#39;s binary representation the /// specified number of digits to the left, masking the shift amount to the /// type&#39;s bit width. static func &amp;&lt;&lt;(_ lhs: Self, _ rhs: Self) -&gt; Self /// Returns the result of shifting a value&#39;s binary representation the /// specified number of digits to the left, masking the shift amount to the /// type&#39;s bit width, and stores the result in the left-hand-side variable. static func &amp;&lt;&lt;=(_ lhs: inout Self, _ rhs: Self) } Auxiliary protocols public protocol UnsignedInteger : BinaryInteger { associatedtype Magnitude : BinaryInteger } public protocol SignedInteger : BinaryInteger, SignedNumeric { associatedtype Magnitude : BinaryInteger } DoubleWidth&lt;T&gt; The DoubleWidth&lt;T&gt; type allows to create wider fixed-width integer types from the ones available in the standard library. Standard library currently provides fixed-width integer types of up to 64 bits. A value of DoubleWidth&lt;Int64&gt; will double the range of the underlying type and implement all the FixedWidthInteger requirements. Please note though that the implementation will not necessarily be the most efficient one, so it would not be a good idea to use DoubleWidth&lt;Int32&gt; instead of a built-in Int64. public enum DoubleWidth&lt;T : FixedWidthInteger&gt; { case .parts(high: T, low: T.Magnitude) public var high: T { get } public var low: T.Magnitude { get } } Representing it as an enum instead of a simple struct allows to use it both as a single value, as well as in destructuring matches. let high = doubleWidthValue.high let low = doubleWidthValue.low // or case let (high, low) = doubleWidthValue Extra operators In addition to the operators described in the protocols section, we also provide a few extensions: Non-mutating homogeneous shifts extension FixedWidthInteger { public static func &amp;&gt;&gt; (lhs: Self, rhs: Self) -&gt; Self public static func &amp;&lt;&lt; (lhs: Self, rhs: Self) -&gt; Self Heterogeneous shifts extension BinaryInteger { // &#39;Smart&#39; shifts static func &gt;&gt; &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Self static func &gt;&gt;= &lt;Other : BinaryInteger&gt;(lhs: inout Self, rhs: Other) static func &lt;&lt; &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Self static func &lt;&lt;= &lt;Other : BinaryInteger&gt;(lhs: inout Self, rhs: Other) } extension FixedWidthInteger { public static func &amp;&gt;&gt; &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Self public static func &amp;&gt;&gt;= &lt;Other : BinaryInteger&gt;(lhs: inout Self, rhs: Other) public static func &amp;&lt;&lt; &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Self public static func &amp;&lt;&lt;= &lt;Other : BinaryInteger&gt;(lhs: inout Self, rhs: Other) } Heterogeneous equality and comparison extension BinaryInteger { // Equality static func == &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Bool static func != &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Bool // Comparison static func &lt; &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Bool static func &lt;= &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Bool static func &gt; &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Bool static func &gt;= &lt;Other : BinaryInteger&gt;(lhs: Self, rhs: Other) -&gt; Bool } Masking arithmetic public func &amp;* &lt;T: FixedWidthInteger&gt;(lhs: T, rhs: T) -&gt; T public func &amp;- &lt;T: FixedWidthInteger&gt;(lhs: T, rhs: T) -&gt; T public func &amp;+ &lt;T: FixedWidthInteger&gt;(lhs: T, rhs: T) -&gt; T Non-goals This proposal: DOES NOT solve the integer promotion problem, which would allow mixed-type arithmetic. However, we believe that it is an important step in the right direction. DOES NOT include the implementation of a BigInt type, but allows it to be implemented in the future. Source compatibility The proposed change is designed to be as non-breaking as possible, and it has been proven that it does not break code on concrete integer types. However, there are still a few API breaking changes in the realm of generic code: Integer protocols in Swift up to and including version 3 were not particularly useful for generic programming, but were rather a means of sharing implementation between conforming types. Therefore we believe the amount of code that relied on these protocols is relatively small. The breakage can be further reduced by introducing proper aliases for the removed protocols with deprecation warnings. Deprecation of the BitwiseOperations protocol. We find it hard to imagine a type that conforms to this protocol, but is not a binary integer type. Addition of ‘smart’ shifts will change the behavior of existing code. It will still compile, but will be potentially less performant due to extra logic involved. In a case, where this becomes a problem, newly introduced masking shift operators can be used instead. Unfortunately, performance characteristics of the code cannot be statically checked, and thus migration cannot be provided.",
    "url": "http://localhost:4000/docs/2019-08-26-0104-improved-integers.html",
    "relUrl": "/docs/2019-08-26-0104-improved-integers.html"
  },
  "104": {
    "id": "104",
    "title": "SE-0105 Removing Where Clauses from For-In Loops",
    "content": "Removing Where Clauses from For-In Loops Proposal: SE-0105 Author: Erica Sadun Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction This proposal removes where clauses from for-in loops, where they are better expressed (and read) as guard conditions. Swift Evolution Discussion: [Pitch] Retiring where from for-in loops Motivation As syntactic sugar, the for loop’s where clause is rarely used, hard to discover, and elevates one style (continue on condition, aka filtering) above other related styles: break on condition (while or until), return on condition (unless), throw on condition, and abort (fatalError()) on condition. The where clause supports a fluent style that is difficult to document separately at its point of use and may be hard to breakpoint and debug. Eliminating where in favor of guard statements addresses all these points: better commenting, better breakpointing and debugging, and full domain coverage over filtering and early exit in a way that where cannot. Frequency of Use Where clauses are rarely used. In the Swift standard library, they occur three times, compared to about 600 uses of for-in. private/StdlibUnittest/StdlibUnittest.swift.gyb: for j in instances.indices where i != j { public/core/Algorithm.swift: for value in rest where value &lt; minValue { public/core/Algorithm.swift: for value in rest where value &gt;= maxValue { I pulled down a random sample of popular Swift repositories from GitHub and found one use of for-in-where among my sample vs over 650 for-in uses. Carthage/Source/CarthageKit/Algorithms.swift: for (node, var incomingEdges) in workingGraph where incomingEdges.contains(lastSource) { Confusion of Use Consider the following two code snippets: print(&quot;for in&quot;) var theArray = [1, 2, 3, 4, 5, 6, 7, 8, 9] for x in theArray where x % 2 == 1 { print (x) } print(&quot;while&quot;) var anArray = [1, 2, 3, 4, 5, 6, 7, 8, 9] while let x = anArray.popLast() where x % 2 == 1 { print(x) } In the first, the where clause acts as a filter, using syntactic sugar for continue when its condition is not met. In while loops, it’s a conjoined Boolean, and will break when its condition is not met. In my experience offering peer support for new Swift developers, the where clause is a source of confusion when it is considered and/or used. Completeness of Guard Conditions Guard conditions can continue (mimicking the current use of where), break, return, or otherwise exit scope. This offers more flexible and complete behavior. for x in sequence { guard condition else { continue } // current where behavior guard condition else { break } guard condition else { return } guard condition else { throw error } guard condition else { fatalError() } // etc. } Removing where from for-in loops reduces cognitive burden when interpreting intent. The logic is easier to read and follow. And the Swift grammar is simpler. SE-0099 Upon accepting SE-0099, the core team removed where clauses from condition clauses. The team wrote, “[T]he ‘where’ keyword can be retired from its purpose as a [B]oolean condition introducer.” Malformed Grammar In Swift’s current form, the where-clause in for-loops inconsistently applied. Unlike switch statements and do loops, a for-in loop’s where-clause is separated from the pattern it modifies. for case? pattern in expression where-clause? code-block case-item-list → pattern where-clause? | pattern where-clause? , case-item-list catch pattern? where-clause? code-block This separation makes the clause harder to associate with the pattern, can confuse users as to whether it modifies the expression or the pattern, and represents an inconsistency in Swift’s grammar. The where-clause really should have been designed like this: for case? pattern where-clause? in expression code-block Other Where Clause Uses This proposal does not affect where clause use in generics. Using generic constraints unamibiguously offers positive utility. Retiring where from catch clauses and switch statements is less clear cut. case_item_list : pattern where_clause? | pattern where_clause? &#39;,&#39; case_item_list catch_clause : &#39;catch&#39; pattern? where_clause? code_block Case: Instances of case.*: in the standard library: 1337 (!) Instances of case.*where.*: in the standard library: 1-ish Instances of case.*: in my Apple sample code collection: 40 (!) Instances of case.*where.*: in my Apple sample code collection: 7 Instances of case.*: in popular 3rd party source code: Over 1400 Instances of case.*where.*: in popular 3rd party source code: 17 public/core/String.swift: // case let x where (x &gt;= 0x41 &amp;&amp; x &lt;= 0x5a): Catch: Instances of catch in popular 3rd party source code: 75 Instances of catch.*where in popular 3rd party source code: 0 Instances of catch in the standard library: 18 Instances of catch.*where in the standard library: 0 Unlike generic constraints, nothing prevents semantic disjunction in switch-case and catch where clauses, both provide expressive potential that could be missed. Detailed Design This proposal removes the where clause from the for-in loop grammar: for case? pattern in expression code-block Impact on Existing Code Code must be refactored to move the where clause into guard (or, for less stylish coders, if) conditions. Alternatives Considered Not accepting this proposal, leaving the grammar intact. Including catch and case under the umbrella of this proposal. I think the general Swift user base would be extremely upset. Redesigning switch and catch statements to allow disjoint expressions a la SE-0099 would be difficult and disruptive. Change where in catch and case clauses to if, restricting where clauses strictly to type constraints without burning a new keyword. As Xiaodi Wu puts it, “Replacing where with if is unambiguous and eliminates the implication of a subordinate semantic relationship that can’t be enforced, while still exposing all of the expressiveness made possible by where in that particular scenario.” switch json { case let json as NSArray if json.count &gt; 0: // handle non-empty array case let json as NSDictionary if json.allKeys.count &gt; 0: // handle non-empty dict default: break } Extending the syntactic sugar in for-in loops to include while, unless, and until. This adds all four variations on break and continue to the for-in vocabulary, and might include a simultaneous renaming of where to if. Acknowledgements Big thanks to Joe Groff, Brent Royal-Gordon, Xiaodi Wu",
    "url": "http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html",
    "relUrl": "/docs/2019-08-26-0105-remove-where-from-forin-loops.html"
  },
  "105": {
    "id": "105",
    "title": "SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test",
    "content": "Add a macOS Alias for the OSX Platform Configuration Test Proposal: SE-0106 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bugs: SR-1823, SR-1887 Introduction Starting in Sierra, Apple’s Mac-based OS (OS X) will be renamed “macOS”. All user-facing Swift APIs must go through Swift Evolution. While this is a trivial API change, I have put together a formal proposal as is normal and usual for this process. This proposal adds the #if os(macOS) platform configuration test to alias the current #if os(OSX) Swift Evolution Discussion: [DRAFT] Aliasing the OS X Platform Configuration Test Motivation At WWDC 2016, Apple renamed its Mac operating system from OSX to macOS. Adding rather than replacing “OSX” enables API adoption to be purely additive and supports the notion that Swift-based applications can and may be deployed to operating systems earlier than Sierra. Choosing to use both names originates from the following rationale: The configuration test should not remain as #if os(OSX). That’s the wrong name for Sierra’s now-supported operating system. Developers can and will still deploy to OS X for Yosemite and El Capitan using Swift. Forcing developers to migrate OSX to macOS places an undue burden on existing code. While aliasing the two may cause issues down the road (“Why does this test have two names?”), I believe Swift developers can easily reason why both variations exist. Current Art Swift currently supports the following platform configuration tests, defined in lib/Basic/LangOptions.cpp. The literals true and false The os() function that tests for OSX, iOS, watchOS, tvOS, Linux, Windows, Android, and FreeBSD The arch() function that tests for x86_64, arm, arm64, i386, powerpc64, s390x, and powerpc64le The swift() function that tests for specific Swift language releases, e.g. swift(&gt;=2.2) Detailed Design static const StringRef SupportedConditionalCompilationOSs[] = { &quot;OSX&quot;, &quot;macOS&quot;, &quot;tvOS&quot;, &quot;watchOS&quot;, &quot;iOS&quot;, &quot;Linux&quot;, &quot;FreeBSD&quot;, &quot;Windows&quot;, &quot;Android&quot; }; if (Target.isMacOSX()) { addPlatformConditionValue(&quot;os&quot;, &quot;OSX&quot;); addPlatformConditionValue(&quot;os&quot;, &quot;macOS&quot;); } Use: #if os(macOS) // Code specific to macOS or OS X #endif Impact on Existing Code This proposal is purely additive. It will not affect existing code other than adding another way to refer to OS X/macOS. Alternatives Considered Instead of retaining and aliasing os(OSX), it can be fully replaced by os(macOS). This mirrors the situation with the phoneOS to iOS rename and would require a migration assistant to fixit old-style use. Charlie Monroe points out: “Since Swift 3.0 is a code-breaking change my guess is that there is no burden if the Xcode migration assistent automatically changes all #if os(OSX) to #if os(macOS), thus deprecating the term OSX, not burdening the developer at all. If iOS was renamed to phoneOS and kept versioning, you’d still expect #if os(iOS) to be matched when targeting phoneOS and vice-versa.” Unaddressed Issues This proposal is narrowly focused on conditional compilation blocks. Both @available and #available are also affected by the macOS rename. Current platform names include both OSX and OSXApplicationExtension. The obvious alternatives for these are macOS and macOSApplicationExtension. A separate bug report SR-1887 has been filed for this.",
    "url": "http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html",
    "relUrl": "/docs/2019-08-26-0106-rename-osx-to-macos.html"
  },
  "106": {
    "id": "106",
    "title": "SE-0107 UnsafeRawPointer API",
    "content": "UnsafeRawPointer API Proposal: SE-0107 Author: Andrew Trick Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale For detailed instructions on how to migrate your code to this new Swift 3 API refer to the UnsafeRawPointer Migration Guide. See also: See bindMemory(to:capacity:), assumingMemoryBound(to:), and withMemoryRebound(to:capacity:). For quick reference on the full API, jump to: Full UnsafeRawPointer API Contents: Introduction Proposed Solution Motivation Memory model explanation Expected use cases Detailed design Impact on existing code Implementation status Future improvements and planned additive API Variations under consideration Alternatives previously considered Introduction Swift enforces type safe access to memory and follows strict aliasing rules. However, code that uses unsafe APIs or imported types can circumvent the language’s natural type safety. Consider the following example of type punning using the UnsafePointer type: let ptrT: UnsafeMutablePointer&lt;T&gt; = ... // Store T at this address. ptrT[0] = T() // Load U at this address let u = UnsafePointer&lt;U&gt;(ptrT)[0] This code violates assumptions made by the compiler and falls into the category of “undefined behavior”. Undefined behavior is a way of saying that we cannot easily specify constraints on the behavior of programs that violate a rule. The program may crash, corrupt memory, or be miscompiled in other ways. Miscompilation may include optimizing away code that was expected to execute or executing code that was not expected to execute. Swift already protects against undefined behavior as long as the code does not use “unsafe” constructs. However, UnsafePointer is an important API for interoperability and building high performance data structures. As such, the rules for safe, well-defined usage of the API should be clear. Currently, it is too easy to use UnsafePointer improperly. For example, innocuous argument conversion such as this could lead to undefined behavior: func takesUIntPtr(_ p: UnsafeMutablePointer&lt;UInt&gt;) -&gt; UInt { return p[0] } func takesIntPtr(q: UnsafeMutablePointer&lt;Int&gt;) -&gt; UInt { return takesUIntPtr(UnsafeMutablePointer(q)) } Furthermore, no API currently exists for accessing raw, untyped memory. UnsafePointer&lt;Pointee&gt; and UnsafeMutablePointer&lt;Pointee&gt; refer to a typed region of memory, and the compiler assumes that the element type (Pointee) is consistent with other access to the same memory. For details of the compiler’s rules for memory aliasing, see proposed Type Safe Memory Access documentation. Making UnsafePointer safer requires introducing a new pointer type that is not subject to the same strict aliasing rules. This proposal aims to achieve several goals in one coherent design: Specify a memory model that encompasses all UnsafePointer access and defines which memory operations are subject to strict aliasing rules. Inhibit UnsafePointer conversion that violates strict aliasing, in order to make violations of the model clear and verifiable. Provide an untyped pointer type. Provide an API for raw, untyped memory access (memcpy semantics). Provide an API for manual memory layout (bytewise pointer arithmetic). Swift-evolution threads: [RFC] UnsafeBytePointer API for In-Memory Layout [RFC] UnsafeBytePointer API for In-Memory Layout (Round 2) [RFC] UnsafeRawPointer API (Round 3) Week #1 Week #2 Week #3 Mentions of UnsafePointer that appear in this document’s prose also apply to UnsafeMutablePointer. Proposed Solution We first introduce each aspect of the proposed API so that the Motivation section can show examples. The Detailed design section lists the complete API. UnsafeRawPointer New raw pointer types, UnsafeRawPointer and UnsafeMutableRawPointer, will represent a “raw”, untyped view of memory. Typed pointers, UnsafePointer&lt;T&gt; and UnsafeMutablePointer&lt;T&gt;, continue to represent a typed view of memory. Memory access through a raw pointer accesses raw memory, and memory access through a typed pointer accesses typed memory. Because a raw pointer may alias with any type, the semantics of reading and writing through a raw pointer are similar to C memcpy. Memory access through a typed pointer adheres to strict aliasing. Memory allocation and initialization UnsafeMutableRawPointer will provide allocate and deallocate methods: UnsafeMutableRawPointer { static func allocate(bytes size: Int, alignedTo: Int) func deallocate(bytes: Int, alignedTo: Int) } Initializing memory via an UnsafeMutableRawPointer produces an UnsafeMutablePointer&lt;Pointee&gt;, and deinitializing the UnsafeMutablePointer&lt;Pointee&gt; returns an UnsafeMutableRawPointer. UnsafeMutableRawPointer { // Returns an UnsafeMutablePointer into the newly initialized memory. func initializeMemory&lt;T&gt;(as: T.Type, count: Int = 1, to: T) -&gt; UnsafeMutablePointer&lt;T&gt; } UnsafeMutablePointer&lt;Pointee&gt; { /// Returns a raw pointer to the uninitialized memory. public func deinitialize(count: Int = 1) -&gt; UnsafeMutableRawPointer } The type parameter T passed to initializeMemory is an explicit argument because the user must reason about the type’s size and alignment at the point of initialization. Inferring the type from the value argument could result in miscompilation if the inferred type ever deviates from the user’s original expectations. The type parameter also importantly conveys that the raw memory becomes accessible via a pointer to that type at the point of the call. The type should be explicitly spelled at this point because accesing the memory via a typed pointer of an unrelated type could also result in miscompilation. Binding memory to a type With the above API for allocation and initialization, the only way to acquire a typed pointer is by using a raw pointer to initialize memory. Raw pointer initialization implicitly binds the memory to the initialized type. A memory location’s bound type is an abstract, dynamic property of the memory used to formalize type safety. Whenever memory is accessed via a typed pointer, the memory must be bound to a related type. This includes operations on Unsafe[Mutable]Pointer in addition to regular language constructs, which are always strictly typed. It does not include memory accessed via a raw pointer, which is not strictly typed. Violations result in undefined behavior. The user may defer initialization and explicitly bind memory to a type using the bindMemory API: Unsafe[Mutable]RawPointer { /// Returns an `Unsafe[Mutable]Pointer&lt;T&gt;` pointing to this memory. func bindMemory&lt;T&gt;(to: T.Type, capacity: Int) -&gt; Unsafe[Mutable]Pointer&lt;T&gt; } Calling bindMemory on a newly allocated raw pointer produces a typed pointer to uninitialized memory. The bound memory can then be safely initialized using a typed pointer: let ptrToA = rawPtr.bindMemory(to: A.self, capacity: 1) ptrToA.initialize(to: A()) Note that typed pointer initialization does not bind the type. The memory must already be bound to the correct type as a precondition. Allocating and binding memory to a type may be performed in one step by using UnsafeMutablePointer.allocate(): UnsafeMutablePointer&lt;Pointee&gt; { static func allocate(capacity count: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt; } Raw memory access Loading from and storing to memory via an Unsafe[Mutable]RawPointer is safe independent of the memory’s bound type as long as layout guarantees are met (per the ABI), and care is taken to properly initialize and deinitialize nontrivial values (see Trivial types). This allows raw memory to be reinterpreted without rebinding the memory type. Rebinding memory invalidates existing typed pointers, but loading from and storing to raw memory does not. UnsafeMutableRawPointer { /// Read raw bytes from memory at `self + offset` and construct a /// value of type `T`. /// /// - Precondition: The underlying pointer plus `offset` is properly /// aligned for accessing `T`. /// /// - Precondition: The memory is initialized to a value of some type, `U`, /// such that `T` is layout compatible with `U`. func load&lt;T&gt;(fromByteOffset: Int = 0, as: T.Type) -&gt; T /// Store a value&#39;s bytes into raw memory at `self + offset`. /// /// - Precondition: The underlying pointer plus `offset` is properly /// aligned for storing type `T`. /// /// - Precondition: `T` is a trivial type. /// /// - Precondition: The memory is uninitialized, or initialized to some /// trivial type `U` such that `T` and `U` are mutually layout /// compatible. /// /// - Postcondition: The memory is initialized to raw bytes. If the /// memory is bound to type `U`, then it now contains a value of /// type `U`. func storeBytes&lt;T&gt;(of: T, toByteOffset: Int = 0, as: T.Type) } The load and storeBytes operations are asymmetric. load reads raw bytes but properly constructs a new value of type T with its own lifetime. Any copied references will be retained. In contrast, storeBytes only operates on a value’s raw bytes, writing them into untyped memory. The in-memory copy will not be constructed and any previously initialized value in this memory will not be deinitialized (it cannot be because its type is unknown). Consequently, storeBytes should only be performed on trivial types. Assigning memory to a nontrivial type via a raw pointer is done by binding the type: rawPtr.bindMemory(to: PreviousType.self, capacity: 1).deinitialize(count: 1) rawPtr.initializeMemory(as: NewType.self, to: NewType()) Bytewise pointer arithmetic Providing an API for accessing raw memory would not serve much purpose without the ability to compute byte offsets. Naturally, UnsafeRaw[Mutable]Pointer is Strideable as a sequence of bytes. UnsafeRawPointer : Strideable { public func distance(to : UnsafeRawPointer) -&gt; Int public func advanced(by : Int) -&gt; UnsafeRawPointer } public func == (lhs: UnsafeRawPointer, rhs: UnsafeRawPointer) -&gt; Bool public func &lt; (lhs: UnsafeRawPointer, rhs: UnsafeRawPointer) -&gt; Bool public func + (lhs: UnsafeRawPointer, rhs: Int) -&gt; UnsafeRawPointer public func - (lhs: UnsafeRawPointer, rhs: UnsafeRawPointer) -&gt; Int UnsafePointer conversion Currently, an UnsafePointer initializer supports conversion between potentially incompatible pointer types: struct Unsafe[Mutable]Pointer&lt;Pointee&gt; { public init&lt;U&gt;(_ from : Unsafe[Mutable]Pointer&lt;U&gt;) } This initializer will be removed. UnsafePointer conversion is still possible, but is now explicit and provably correct based on the conversion’s preconditions and postconditions. Recall that bindMemory(to:capacity:) produces a typed pointer from a raw pointer. As explained above, it can be used to bind uninitialized memory for deferred initialization. When invoked on memory that is already bound, and potentially already initialized, it effectively rebinds the memory. Because memory can only be bound to one type at a time, all strictly typed memory operations that subsequently access this memory must be consistent with the newly bound type. A convenience API makes it easy to handle type mismatches that arise from interoperability without compromising on safety. In this case, the user already has a typed pointer but needs to temporarily rebind the memory for the purpose of invoking code that expects a different type. withMemoryRebound&lt;T&gt;(to:capacity:) rebinds memory to the specified type, executes a closure with a pointer to the rebound memory, then rebinds memory to the original type before returning: Unsafe[Mutable]Pointer&lt;Pointee&gt; { func withMemoryRebound&lt;T&gt;(to: T.Type, capacity count: Int, _ body: (Unsafe[Mutable]Pointer&lt;T&gt;) throws -&gt; ()) rethrows } This is safe provided that the body closure does not capture self. It is possible to directly acquire a typed pointer from a raw pointer without rebinding the type, bypassing static safety. This does not weaken the rules for typed memory access because it relies on the precondition is that memory is already bound to the returned pointer’s type. This is useful when the memory’s bound type is known but the pointer’s type has been erased: Unsafe[Mutable]RawPointer { func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; Unsafe[Mutable]Pointer&lt;T&gt; } For a more detailed discussion, see the Memory model explanation. Motivation The following examples show the differences between memory access as it currently would be done using UnsafeMutablePointer vs. the proposed UnsafeMutableRawPointer. Consider two layout compatible, but unrelated structs, A and B, and helpers that read from these structs via unsafe pointers: // common definitions used by old and new code struct A { var value: Int } struct B { var value: Int } func printA(_ pA: UnsafePointer&lt;A&gt;) { print(pA[0]) } func printB(_ pB: UnsafePointer&lt;B&gt;) { print(pB[0]) } Normal allocation, initialization, access, and deinitialization of a struct looks like this with UnsafePointer: // old version func initA(pA: UnsafeMutablePointer&lt;A&gt;) { pA.initialize(to: A(value:42)) } func initB(pB: UnsafeMutablePointer&lt;B&gt;) { pB.initialize(to: B(value:13)) } func normalLifetime() { let pA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: 1) initA(pA) printA(pA) pA.deinitialize(count: 1) pA.deallocateCapacity(1) } This code continues to work. However, with UnsafeMutableRawPointer, it is possible to distinguish between raw allocated memory, and memory that has been initialized as some type. First, we define new initialization helpers that take raw pointers and return typed pointers: // new version func initRawA(p: UnsafeMutableRawPointer) -&gt; UnsafeMutablePointer&lt;A&gt; { return p.initializeMemory(as: A.self, to: A(value:42)) } func initRawB(p: UnsafeMutableRawPointer) -&gt; UnsafeMutablePointer&lt;B&gt; { return p.initializeMemory(as: B.self, to: B(value:13)) } Now we can allocate raw memory and obtain a typed pointer through initialization: // new version func normalLifetime() { let rawPtr = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout&lt;A&gt;.stride, alignedTo: MemoryLayout&lt;A&gt;.alignment) // rawPtr cannot be assigned to a value of `A`, forcing initialization before // typed access. let pA = initRawA(rawPtr) printA(pA) let uninitPtr = pA.deinitialize(count: 1) uninitPtr.deallocate(bytes: MemoryLayout&lt;A&gt;.stride, alignedTo: MemoryLayout&lt;A&gt;.alignment) } Consider another example, now ignoring memory deallocation for brevity. Technically, it is correct to initialize values of type A and B in different memory locations, but confusing and dangerous with the current UnsafeMutablePointer API: // old version // Return a pointer to (A, B). func initAB() -&gt; UnsafeMutablePointer&lt;A&gt; { // Memory is uninitialized, but pA is already typed. let pA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: 2) // Part of the memory is initialized to `A`. Redundant conversion of // UnsafeMutablePointer values like this is not uncommon, and it is // nonobvious at the point of conversion that it does not actually // change the pointer type. initA(UnsafeMutablePointer(pA)) // pA is recast as pB with no indication that the pointee type has changed. initB(UnsafeMutablePointer(pA + 1)) return pA } Code in the caller is confusing: // old version func testInitAB() { let pA = initAB() printA(pA) // pA is again recast as pB with no indication that the pointee type changes. printB(UnsafeMutablePointer(pA + 1)) // Or recast to pB first, which is also misleading because the pointer still // points to an initialized `A` value at the point of the cast. printB(UnsafeMutablePointer&lt;B&gt;(pA) + 1) } With UnsafeMutableRawPointer there is no need to cast to an invalid pointer type in order to access manually allocated memory: // new version // Return a pointer to an untyped memory region initialized with (A, B). func initRawAB() -&gt; UnsafeMutableRawPointer { let rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2 * MemoryLayout&lt;Int&gt;.stride, alignedTo: MemoryLayout&lt;Int&gt;.alignment) // Initialize the first Int with `A`, producing UnsafeMutablePointer&lt;A&gt;. let pA = initRawA(rawPtr) // Initialize the second Int with `B`. // This implicitly casts UnsafeMutablePointer&lt;A&gt; to UnsafeMutableRawPointer, // which is equivalent to initB(rawPtr + MemoryLayout&lt;Int&gt;.stride). // Unlike the old API, no unsafe pointer conversion is needed. initRawB(pA + 1) return rawPtr } Now, in the caller, unsafe conversion from raw memory to typed memory is always explicit: // new version // Code in the caller is explicit: func testInitAB() { // Get a raw pointer to (A, B). let p = initRawAB() // The untyped memory is explicitly converted to a pointer-to-A. // Safe because we know the underlying memory is bound to `A` via // raw pointer initialization. let pA = p.assumingMemoryBound(to: A.self) printA(pA) // Converting from a pointer-to-A into a pointer-to-B without // rebinding the type requires casting to an UnsafeRawPointer. printB(UnsafeRawPointer(pA + 1).assumingMemoryBound(to: B.self)) // Or directly convert the original UnsafeRawPointer into pointer-to-B. printB((p + MemoryLayout&lt;Int&gt;.stride).assumingMemoryBound(to: B.self)) } This is much more explicit and verifiable, but still not statically type safe. However, now that it is possible to bind memory to a type, this example may be rewritten so that strict aliasing rules are statically enforced. Now the caller no longer needs to assume the pointer type that was used to initialize memory in initAB. They only need to agree on the layout of the memory: // new and improved version // Return a pointer to an untyped memory region initialized with (A, B). func initRawAB() -&gt; UnsafeMutableRawPointer { let intPtr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 2) intPtr[0] = 42 // knowing A is layout compatible with Int intPtr[1] = 13 // knowing B is layout compatible with Int return UnsafeMutableRawPointer(intPtr) } func testInitAB() { // Get a raw pointer to (A, B). let p = initRawAB() let pA = p.bindMemory(to: A.self, capacity: 1) printA(pA) // Knowing the `B` has the same alignment as `A`. let pB = UnsafeRawPointer(pA + 1).bindMemory(to: B.self, capacity: 1) printB(pB) } Initializing or assigning values of different types to the same location using a typed pointer is undefined. Here, the compiler can choose to ignore the order of assignment, and initAthenB may print 13 twice or 42 twice. // old version func initAthenB(_ p: UnsafeMutablePointer&lt;Void&gt;) { let p = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1) initA(UnsafeMutablePointer(p)) // *p = 42 printA(UnsafeMutablePointer(p)) initB(UnsafeMutablePointer(p)) // *p = 13 printB(UnsafeMutablePointer(p)) } With the proposed API, assigning values of different types to the same location can now be safely done by properly initializing and deinitializing the memory through UnsafeMutableRawPointer. Ultimately, the values may still be accessed via the same convenient UnsafeMutablePointer type. Type punning has not happened, because the UnsafeMutablePointer has the same type as the memory’s bound type whenever it is dereferenced. // new version func initAthenB { let rawPtr = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout&lt;Int&gt;.stride, alignedTo: MemoryLayout&lt;Int&gt;.alignment) let pA = initRawA(rawPtr) // raw pointer initialization binds memory to `A` printA(pA) // After deinitializing pA, uninitPtr receives a pointer to // untyped raw memory, which may be reused for `B`. let uninitPtr = pA.deinitialize(count: 1) // rawPtr and uninitPtr have the same value, thus are substitutable. assert(rawPtr == uninitPtr) // initB rebinds the memory to `B` before writing to memory, so // reinitialization cannot be reordered with previous accesses to pA. initRawB(uninitPtr) printB(pB) } No API currently exists that allows initialized memory to hold either A or B. // old version // This conditional initialization looks valid, but is dangerous. func initAorB(_ p: UnsafeMutablePointer&lt;Void&gt;, isA: Bool) { if isA { initA(UnsafeMutablePointer(p)) } else { initB(UnsafeMutablePointer(p)) } } Code in the caller could produce undefined behavior: // old version func testInitAorB() { let p = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1) // If the compiler inlines, then the initialization and use of the // values of type `A` and `B`, which share memory, could be incorrectly // interleaved. initAorB(p, isA: true) printA(UnsafeMutablePointer(p)) initAorB(p, isA: false) printB(UnsafeMutablePointer(p)) } UnsafeMutableRawPointer allows initialized memory to hold either A or B. The same UnsafeMutableRawPointer value can be reused across multiple initializations and deinitializations. Unlike the old API, this is safe because the memory initialization on a raw pointer writes to untyped memory and binds the memory type. Binding memory to a type separates access to the distinct types from the compiler’s viewpoint. // new version func initRawAorB(_ p: UnsafeMutableRawPointer, isA: Bool) { // Unsafe pointer conversion is no longer required to initialize memory. if isA { initRawA(p) } else { initRawB(p) } } Code in the caller is well defined because initAorB is now a compiler barrier for unsafe pointer access. Furthermore, each unsafe pointer cast is explicit: // new version func testInitAorB() { let p = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout&lt;Int&gt;.stride, alignedTo: MemoryLayout&lt;Int&gt;.alignment) initRawAorB(p, isA: true) printA(p.assumingMemoryBound(to: A.self)) initRawAorB(p, isA: false) printB(p.assumingMemoryBound(to: B.self)) } UnsafeMutableRawPointer provides a legal way to reinterpret memory in-place, which was previously unsupported. The following example is safe because the load of B reads from untyped memory via a raw pointer. // new version func testReinterpret() { let p = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout&lt;Int&gt;.stride, alignedTo: MemoryLayout&lt;Int&gt;.alignment) // Initialize raw memory to `A`. initRawAorB(p, isA: true) // Load from raw memory as `B` (reinterpreting the value in memory). print(p.load(as: B.self)) } This is not “type-punning” because a typed pointer is never accessed. Note that printB(p.assumingMemoryBound(to: B.self)) would be illegal, because the a typed pointer to B cannot be used to access an unrelated type A. Developers may be forced to work with “loosely typed” APIs, particularly for interoperability: func readBytes(_ bytes: UnsafePointer&lt;UInt8&gt;) { // 3rd party implementation... } func readCStr(_ string: UnsafePointer&lt;CChar&gt;) { // 3rd party implementation... } Working with these third party API’s exclusively using UnsafeMutablePointer would lead to undefined behavior, as shown here using the current API: // old version func stringFromBytes(size: Int, value: UInt8) { let bytes = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: size + 1) bytes.initialize(to: value, count: size) bytes[size] = 0 // Unsafe pointer conversion is required to invoke readCString. // If readCString is inlineable and compiled with strict aliasing, // then it could read uninitialized memory. readCStr(UnsafePointer(bytes)) // The signature of readBytes is consistent with the `bytes` argument type. readBytes(bytes) } Reading from uninitialized memory is now prevented by explicitly rebinding the type. // new version func stringFromBytes(size: Int, value: UInt8) { let buffer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: size + 1) buffer.initialize(to: value, count: size) buffer[size] = 0 buffer.withMemoryRebound(to: CChar.self, capacity: size + 1) { readCStr($0) } readBytes(buffer) } Rather than temporarily rebinding memory, the user may want to rebind memory to CChar once and keep the same typed pointer around for future use without keeping track of the memory capacity. In that case, the program could continue to write UInt8 values to memory without casting to CChar and without rebinding memory as long as those writes use the UnsafeMutableRawPointer.storeBytes API for raw memory access: // new version func mutateBuffer(size: Int, value: UInt8) { let rawBuffer = UnsafeMutableRawPointer.allocate(bytes: size + 1, alignedTo: 1) rawBuffer.initializeMemory(as: UInt8.self, count: size, to: value) rawBuffer.initializeMemory(as: UInt8.self, atIndex: size, to: 0) let cstr = rawBuffer.bindMemory(to: CChar.self, capacity: size + 1) // Access memory as CChar. readCStr(cstr) // Write UInt8 values to memory without needing explicitly cast each // value to CChar first. for i in 0..&lt;size { rawBuffer.storeBytes(of: getByte(), toByteOffset: i, as: UInt8.self) } // Access memory again as CChar. readCStr(cstr) } func getByte() -&gt; UInt8 { // 3rd party implementation... } The side effects of illegal type punning may result in storing values in the wrong sequence, reading uninitialized memory, or memory corruption. It could even result in execution following code paths that aren’t expected as shown here: // old version func testUndefinedExecution() { let pA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: 1) pA[0] = A(value:42) if pA[0].value != 42 { // Code path should never execute... releaseDemons() } // This compiler may inline this, and hoist the store above the // previous check. unforeseenCode(pA) } func releaseDemons() { // Something that should never be executed... } func assignB(_ pB: UnsafeMutablePointer&lt;B&gt;) { pB[0] = B(value:13) } func unforeseenCode(_ pA: UnsafeMutablePointer&lt;A&gt;) { // At some arbitrary point in the future, the same memory is // innocuously assigned to B. assignB(UnsafeMutablePointer(pA)) } Prohibiting conversion between incompatible UnsafePointer types, providing an API for binding memory to a type, and supporting raw memory access are necessary to avoid the dangers of type punning and encourage safe idioms for working with pointers. Memory model explanation Raw vs. Typed Pointers The fundamental difference between Unsafe[Mutable]RawPointer and Unsafe[Mutable]Pointer&lt;Pointee&gt; is simply that the former is used for “untyped” memory access, and the later is used for “typed” memory access. Let’s refer to these as “raw pointers” and “typed pointers”. Because operations on raw pointers access untyped memory, the compiler cannot make assumptions about the underlying type of memory and must be conservative. With operations on typed pointers, the compiler may make strict assumptions about the type of the underlying memory, which allows more aggressive optimization. Memory initialization All allocated memory is either “uninitialized” or “initialized”. Upon initialization, memory contains a typed value. Initialized memory may be assigned to a new value of the same type. Upon deinitialization, the memory no longer holds a value. Consider the sequence of abstract memory operations: Abstract Operation Memory State rawptr = allocate() uninitialized tptr = rawptr.initializeMemory(T) initialized tptr.pointee = T initialized tptr.deinitialize() uninitialized Initializing memory via a raw pointer binds the memory type. Initialized memory must always be bound to a type. Deinitialization does not unbind the type. Memory remains bound to a type until it is rebound to a different type. Abstract Operation Memory State Type rawptr = allocate() uninitialized None tptr = rawptr.initializeMemory(T) initialized bound to T tptr.deinitialize() uninitialized bound to T uptr = rawptr.initializeMemory(U) initialized bound to U uptr.deinitialize() uninitialized bound to U rawptr.deallocate() invalid None Rebinding memory effectively changes the type of any initialized values within the rebound memory region. Accessing the memory via a typed pointer of unrelated type is undefined: Abstract Operation Memory State Type tptr = rawptr.initializeMemory(T) initialized bound to T tptr.deinitialize() uninitialized bound to T uptr = rawptr.initializeMemory(U) initialized bound to U uptr.deinitialize() uninitialized bound to U tptr.initialize() undefined undefined By this convention, raw pointers primarily refer to uninitialized memory and typed pointers primarily refer to initialized memory. This is not a requirement, and important use cases follow different conventions. After a raw pointer is initialized, the raw pointer value remains valid and can continue to be used to access the underlying memory in an untyped way. Conversely, a raw pointer can bound to a typed pointer without initializing the underlying memory. Binding memory type A raw pointer’s memory may be explicitly bound to a type, bypassing raw initialization: let ptrA = rawPtr.bindMemory(to: A.self, capacity: 1) The resulting typed pointer may then be used to initialize memory: ptrA.initialize(to: A()) Abstract Operation Memory State Type rawptr = allocate() uninitialized None tptr = rawptr.bindMemory(T) uninitialized bound to T tptr.initialize() initialized bound to T The memory remains bound to this type until it is rebound through raw pointer initialization or another call to bindMemory(to:). Abstract Operation Memory State Type rawptr = allocate() uninitialized None tptr = rawptr.bindMemory(T) uninitialized bound to T tptr.initialize() initialized bound to T tptr.deinitialize() uninitialized bound to T uptr = rawptr.bindMemory(U) uninitialized bound to U uptr.initialize() initialized bound to U Allocation and binding can be combined as typed allocation: Abstract Operation Memory State Type tptr = allocate(T) uninitialized bound to T tptr.initialize() initialized bound to T Typed pointer initialization Initializing memory via a typed pointer requires the memory to be already be bound to that type. This is often more convenient than working with raw pointers, and can improve performance in some cases. In particular, it is an effective technique for implementing data structures that manage storage for contiguous elements. The data structure may allocate a buffer with extra capacity and track the initialized state of each element position as such: func getAt(index: Int) -&gt; A { if !isInitializedAt(index) { (ptrA + index).initialize(to: Type()) } return ptrA[index] } For example, see the C buffer use case below. When using a typed pointer to initialize memory, the programmer must ensure that memory has been bound to that type and takes responsibility for tracking the initialized state of memory. Strict aliasing Accessing memory via a pointer type that is unrelated to the memory’s bound type violates strict aliasing, and is thus undefined. For the purpose of this proposal, we simply specify when strict aliasing applies and that aliasing types must be related. For an explanation of related types and layout compatibility, see proposed Type Safe Memory Access documentation. Regardless of whether strict aliasing applies, accessing initialized in-memory values always requires the access type to be layout compatible with the value’s type. This applies to access via the raw pointer API in addition to typed pointer access. Similarly, rebinding initialized in-memory values to another type requires both the previous and new type to be mutually layout compatible. Accessing memory via a typed pointer (or normal, safe language construct) has an additional requirement that the pointer type must be related to the memory’s bound type. For this reason, typed pointers are only obtained by initializing raw memory or explicitly binding the memory type. In practice, with the proposed API, the only way to violate strict aliasing is to reuse a typed pointer value after the underlying memory has been rebound to an unrelated type: Abstract Operation Memory State Type tptr = rawptr.bindMemory(T) uninitialized bound to T uptr = rawptr.bindMemory(U) uninitialized bound to U tptr.initialize() undefined T is unrelated to U Accessing initialized memory with a raw pointer. A program may read from and write to memory via a raw pointer even after the memory has been initialized: let rawPtr = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout&lt;SomeType&gt;.stride, alignedTo: MemoryLayout&lt;SomeType&gt;.alignment) let ptrToSomeType = rawPtr.initializeMemory(as: SomeType.self, to: SomeType()) // read raw initialized memory let reinterpretedValue = rawPtr.load(as: AnotherType.self) // overwrite raw initialized memory rawPtr.storeBytes(of: AnotherType(), as: AnotherType.self) SomeType and AnotherType need not to be related types. They must only be layout compatible. In other words, the programmer must ensure compatibility of the size, alignment, and position of references. This requires some knowledge of the ABI. Loading from raw memory reinterprets the in-memory bytes, and constructs a new local value. If that value contains class references, the class type of those reference must be related to the instance’s dynamic type. This is a incontrovertible property of all reference values in the system. Storing a value into raw memory does not support reference types. Additionally, it requires consideration of the type of value being overwritten because a raw store overwrites memory contents without destroying the previous value. Storing to raw memory is safe if either the memory is uninitialized or initialized to a trivial type. The value being stored must also be trivial so that it can be assigned via a bit-for-bit copy. Trivial types A “trivial type” promises that assignment just requires a fixed-size bit-for-bit copy without any indirection or reference-counting operations. Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enums. Examples of trivial types: Integer and floating-point types Bool Optional&lt;T&gt; where T is trivial Unmanaged&lt;T: AnyObject&gt; struct types where all members are trivial enum types where all payloads are trivial Expected use cases This section lists several typical use cases involving UnsafeRawPointer and UnsafePointer. For explanatory purposes consider the following global definitions: struct A { var value: Int32 } struct B { var value: Int32 } var ptrToA: UnsafeMutablePointer&lt;A&gt; var eltCount: Int = 0 Single value Using a pointer to a single value: func createValue() { ptrToA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: 1) ptrToA.initialize(to: A(value: 42)) } func deleteValue() { ptrToA.deinitialize(count: 1) ptrToA.deallocate(capacity: 1) } C array Using a fully initialized set of contiguous homogeneous values: func createCArray(from source: UnsafePointer&lt;A&gt;, count: Int) { ptrToA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: count) ptrToA.initialize(from: source, count: count) eltCount = count } func deleteCArray() { ptrToA.deinitialize(count: eltCount) ptrToA.deallocate(capacity: eltCount) } C buffer Managing a buffer with a mix of initialized and uninitialized contiguous elements. Typically, information about which elements are initialized will be separately maintained to ensure that each method’s preconditions are met: func createCBuffer(size: Int) { ptrToA = UnsafeMutablePointer&lt;A&gt;.allocate(capacity: size) eltCount = size } // - precondition: memory at `index` is uninitialized. func initElement(index: Int, with value: A) { (ptrToA + index).initialize(to: value) } // - precondition: memory at `index` is initialized. func getElement(index: Int) -&gt; A { return ptrToA[index] } // - precondition: memory at `index` is initialized. func assignElement(index: Int, with value: A) { ptrToA[index] = value } // - precondition: memory at `index` is initialized. func deinitElement(index: Int) { (ptrToA + index).deinitialize() } // - precondition: memory for all elements is uninitialized. func freeCBuffer() { ptrToA.deallocate(capacity: eltCount) } Manual layout of typed, aligned memory // Layout an object with header type `A` followed by `n` elements of type `B`. func createValueWithTail(count: Int) { // Assuming the alignment of `A` satisfies the alignment of `B`. let numBytes = MemoryLayout&lt;A&gt;.stride + (count * MemoryLayout&lt;B&gt;.stride) let rawPtr = UnsafeMutableRawPointer.allocate( bytes: numBytes, alignedTo: MemoryLayout&lt;A&gt;.alignment) // Initialize the object header. ptrToA = rawPtr.initializeMemory(as: A.self, to: A(value: 42)) // Append `count` elements of type `B` to the object tail. eltCount = count UnsafeMutableRawPointer(ptrToA + 1).initializeMemory( as: B.self, count: count, to: B(value: 13)) } func getTailElement(index: Int) -&gt; B { return UnsafeRawPointer(ptrToA + 1) .assumingMemoryBound(to: B.self)[index] } func deleteValueWithTail() { UnsafeMutableRawPointer(ptrToA + 1) .assumingMemoryBound(to: B.self).deinitialize(count: eltCount) let numBytes = MemoryLayout&lt;A&gt;.stride + (eltCount * MemoryLayout&lt;B&gt;.stride) ptrToA.deinitialize(count: 1).deallocate( bytes: numBytes, alignedTo: MemoryLayout&lt;A&gt;.alignment) } Raw buffer of unknown type Direct bytewise memory access to a buffer of unknown type: // Format1: // flags: UInt16 // state: UInt16 // value: Int32 // Format2: // value: Int32 func receiveMsg(flags: UInt16, state: UInt16, value: Int32) { // ... } func readMsg(msgBuf: UnsafeRawPointer, isFormat1: Bool) { if isFormat1 { receiveMsg(flags: msgBuf.load(as: UInt16.self), state: msgBuf.load(fromByteOffset: 2, as: UInt16.self), value: msgBuf.load(fromByteOffset: 4, as: Int32.self)) } else { receiveMsg(flags: 0, state: 0, value: msgBuf.load(as: Int32.self)) } } Loads and stores on untyped memory Accessing raw underlying memory bytes, independent of the memory’s bound type: // Direct bytewise element copy. func copyArrayElement(fromIndex: Int, toIndex: Int) { let srcPtr = UnsafeRawPointer(ptrToA + fromIndex) let destPtr = UnsafeMutableRawPointer(ptrToA + toIndex) destPtr.copyBytes(from: srcPtr, count: MemoryLayout&lt;A&gt;.size)) } // Bytewise element swap. // Initializes and deinitializes temporaries of type Int. // Int is layout compatible with `A`. func swapArrayElements(index i: Int, index j: Int) { let rawPtrI = UnsafeMutableRawPointer(ptrToA + i) let rawPtrJ = UnsafeMutableRawPointer(ptrToA + j) let tmpi = rawPtrI.load(as: Int.self) let tmpj = rawPtrJ.load(as: Int.self) rawPtrI.storeBytes(of: tmpj, as: Int.self) rawPtrJ.storeBytes(of: tmpi, as: Int.self) } Custom memory allocation var freePtr: UnsafeMutableRawPointer? = nil func allocate32() -&gt; UnsafeMutableRawPointer { if let newPtr = freePtr { freePtr = nil return newPtr } return UnsafeMutableRawPointer.allocate(bytes: 4, alignedTo: 4) } func deallocate32(_ rawPtr: UnsafeMutableRawPointer) { if freePtr != nil { rawPtr.deallocate(bytes: 4, alignedTo: 4) } else { freePtr = rawPtr } } func createA(value: Int32) -&gt; UnsafeMutablePointer&lt;A&gt; { return allocate32().initializeMemory(as: A.self, to: A(value: value)) } func createB(value: Int32) -&gt; UnsafeMutablePointer&lt;B&gt; { return allocate32().initialize(as: B.self, to: B(value: value)) } func deleteA(ptrToA: UnsafeMutablePointer&lt;A&gt;) { deallocate32(ptrToA.deinitialize(count: 1)) } func deleteB(ptrToB: UnsafeMutablePointer&lt;B&gt;) { deallocate32(ptrToB.deinitialize(count: 1)) } Detailed design Pointer conversion details UnsafePointer&lt;T&gt; to UnsafeRawPointer conversion will be provided via an unlabeled initializer. extension UnsafeRawPointer: _Pointer { init&lt;T&gt;(_: UnsafePointer&lt;T&gt;) init&lt;T&gt;(_: UnsafeMutablePointer&lt;T&gt;) } extension UnsafeMutableRawPointer: _Pointer { init&lt;T&gt;(_: UnsafeMutablePointer&lt;T&gt;) } Conversion from UnsafeRawPointer to a typed UnsafePointer&lt;T&gt; requires invoking UnsafeRawPointer.bindMemory(to:capacity:) or UnsafeRawPointer.assumingMemoryBound(to:), explicitly spelling the destination type: let p = UnsafeRawPointer(...) let pT = p.bindMemory(to: T.self, capacity: n) ... let pT2 = p.assumingMemoryBound(to: T.self) Just as with unsafeBitCast, although the destination of the cast can usually be inferred, we want the developer to explicitly state the intended destination type, both because type inference can be surprising, and because it’s important for code comprehension. Some existing conversions between UnsafePointer types do not convert Pointee types but instead coerce an UnsafePointer to an UnsafeMutablePointer. This is no longer an inferred conversion, but must be explicitly requested: extension UnsafeMutablePointer { init(mutating from: UnsafePointer&lt;Pointee&gt;) } Implicit argument conversion Consider two C functions that take const pointers: void takesConstTPtr(const T*); void takesConstVoidPtr(const void*); Which will be imported with immutable pointer argument types: func takesConstTPtr(_: UnsafePointer&lt;T&gt;) func takesConstVoidPtr(_: UnsafeRawPointer) Mutable pointers can be passed implicitly as immutable pointers. let unsafeMutablePtr: UnsafeMutablePointer&lt;T&gt; let mutableRawPtr: UnsafeMutableRawPointer takesConstTPtr(unsafeMutablePtr) takesConstVoidPtr(mutableRawPtr) Any mutable or immutable typed pointer can be passed implicitly as an immutable void pointer: let unsafePtr: UnsafePointer&lt;T&gt; let unsafeMutablePtr: UnsafeMutablePointer&lt;T&gt; takesConstVoidPtr(unsafePtr) takesConstVoidPtr(unsafeMutablePtr) Implicit inout conversion will continue to work: var anyT: T takesConstTPtr(&amp;anyT) takesConstVoidPtr(&amp;anyT) Array/String conversion will continue to work: let a = [T()] takesConstTPtr(a) takesConstVoidPtr(a) let s = &quot;string&quot; takesConstVoidPtr(s) Consider two C functions that take non-const pointers: void takesTPtr(T*); void takesVoidPtr(void*); Which will be imported with mutable pointer argument types: func takesTPtr(_: UnsafeMutablePointer&lt;T&gt;) func takesVoidPtr(_: UnsafeMutableRawPointer) Any mutable pointer type can be passed implicitly as a mutable void pointer: let unsafeMutablePtr: UnsafeMutablePointer&lt;T&gt; takesVoidPtr(unsafeMutablePtr) Implicit inout conversion will continue to work: var anyT = T(...) takesTPtr(&amp;anyT) takesVoidPtr(&amp;anyT) Array/String conversion to mutable pointer is still not allowed. Bulk copies The following API entry points support copying or moving values between unsafe pointers. Given values of these types: let unsafePtr: UnsafePointer&lt;T&gt; let unsafeMutablePtr: UnsafeMutablePointer&lt;T&gt; let rawPtr: UnsafeRawPointer let mutableRawPtr: UnsafeMutableRawPointer let c: Int UnsafeRawPointer to UnsafeMutableRawPointer raw copy (memcpy): mutableRawPtr.copyBytes(from: rawPtr, count: c) UnsafePointer&lt;T&gt; to UnsafeMutableRawPointer: A raw copy from typed to raw memory can also be done by calling copyBytes, exactly as shown above. Implicit argument conversion from UnsafePointer&lt;T&gt; to UnsafeRawPointer makes this seamless. Additionally, raw memory can be bulk initialized from typed memory: mraw.initializeMemory(as: T.self, from: unsafePtr, count: c) UnsafeMutablePointer&lt;T&gt; to UnsafeMutableRawPointer: Because UnsafeMutablePointer&lt;T&gt; arguments are implicitly converted to UnsafePointer&lt;T&gt;, the initializeMemory call above works seamlessly. Additionally, a mutable typed pointer can be moved-from: mraw.moveInitializeMemory(as: T.self, from: unsafeMutablePtr, count: c) UnsafeRawPointer to UnsafeMutablePointer&lt;T&gt;: No bulk conversion is currently supported from raw to typed memory. UnsafePointer&lt;T&gt; to UnsafeMutablePointer&lt;T&gt;: Copying between typed memory is still supported via bulk assignment (the naming style is updated for consistency): ump.assign(from: up, count: c) ump.moveAssign(from: up, count: c) CString conversion One of the more common unsafe pointer conversions arises from viewing a C string as either an array of bytes (UInt8) or C characters (CChar). In Swift, this manifests as arguments of type UnsafePointer&lt;UInt8&gt; and UnsafePointer&lt;CChar&gt;. The String API even encourages interoperability between C APIs and a String’s UTF8 encoding. For example: var utf8 = template.nulTerminatedUTF8 let (fd, fileName) = utf8.withUnsafeMutableBufferPointer { (utf8) -&gt; (CInt, String) in let cStrBuf = UnsafeRawPointer(utf8.baseAddress!) .assumingMemoryBound(to: UnsafePointer&lt;CChar&gt;) let fd = mkstemps(cStrBuf, suffixlen) let fileName = String(cString: cStrBuf) ... } This particular case is theoretically invalid because nulTerminatedUTF8 writes a buffer of UInt8 and mkstemps overwrites the same memory as a buffer of CChar. More commonly, the pointer conversion is valid because the buffer is only initialized once. Nonetheless, the explicit casting is extremely awkward for such a common use case. To avoid excessive UnsafePointer conversion and ease migration to the UnsafeRawPointer model, helpers will be added to the String API. In CString.swift: extension String { init(cString: UnsafePointer&lt;UInt8&gt;) } And in StringUTF8.swift: extension String { var nulTerminatedUTF8CString: ContiguousArray&lt;CChar&gt; } With these two helpers, conversion between UnsafePointer&lt;CChar&gt; and UnsafePointer&lt;UInt8&gt; is safe without sacrificing efficiency. The String initializer already copies the byte array into the String’s internal representation, so can trivially convert the element type. The nulTerminatedUTF8CString function also copies the string’s internal representation into an array of UInt8. With this helper, no unsafe casting is necessary in the previous example: var utf8Cstr = template.nulTerminatedUTF8CString let (fd, fileName) = utf8.withUnsafeMutableBufferPointer { (utf8CStrBuf) -&gt; (CInt, String) in let fd = mkstemps(utf8CStrBuf, suffixlen) let fileName = String(cString: utf8CStrBuf) ... } Full UnsafeRawPointer API Most of the API was already presented above. For the sake of having it in one place, a list of the expected UnsafeMutableRawPointer members is shown below. For full doc comments, see the github revision. struct UnsafeMutableRawPointer : Strideable, Hashable, _Pointer { var _rawValue: Builtin.RawPointer var hashValue: Int init(_ _rawValue : Builtin.RawPointer) init(_ other : OpaquePointer) init(_ other : OpaquePointer?) init?(bitPattern: Int) init?(bitPattern: UInt) init&lt;T&gt;(_: UnsafeMutablePointer&lt;T&gt;) init?&lt;T&gt;(_: UnsafeMutablePointer&lt;T&gt;?) static func allocate(bytes: Int, alignedTo: Int) -&gt; UnsafeMutableRawPointer func deallocate(bytes: Int, alignedTo: Int) func bindMemory&lt;T&gt;(to: T.Type, capacity: Int) -&gt; UnsafeMutablePointer&lt;T&gt; func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafeMutablePointer&lt;T&gt; func initializeMemory&lt;T&gt;(as: T.Type, at: Int = 0, count: Int = 1, to: T) -&gt; UnsafeMutablePointer&lt;T&gt; func initializeMemory&lt;T&gt;(as: T.Type, from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeMutablePointer&lt;T&gt; func initializeMemory&lt;C : Collection&gt;(as: C.Iterator.Element.Type, from: C) -&gt; UnsafeMutablePointer&lt;C.Iterator.Element&gt; func moveInitializeMemory&lt;T&gt;( as: T.Type, from: UnsafeMutablePointer&lt;T&gt;, count: Int ) -&gt; UnsafeMutablePointer&lt;T&gt; { func load&lt;T&gt;(fromByteOffset: Int = 0, as: T.Type) -&gt; T func storeBytes&lt;T&gt;(of: T, toByteOffset: Int = 0, as: T.Type) func copyBytes(from: UnsafeRawPointer, count: Int) func distance(to: UnsafeRawPointer) -&gt; Int func advanced(by: Int) -&gt; UnsafeRawPointer } The immutable UnsafeRawPointer members are: struct UnsafeRawPointer : Strideable, Hashable, _Pointer { var _rawValue: Builtin.RawPointer var hashValue: Int init(_ _rawValue : Builtin.RawPointer) init(_ other : OpaquePointer) init(_ other : OpaquePointer?) init?(bitPattern: Int) init?(bitPattern: UInt) init&lt;T&gt;(_: UnsafeMutablePointer&lt;T&gt;) init?&lt;T&gt;(_: UnsafeMutablePointer&lt;T&gt;?) func deallocate(bytes: Int, alignedTo: Int) func bindMemory&lt;T&gt;(to: T.Type, capacity: Int) -&gt; UnsafePointer&lt;T&gt; func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafePointer&lt;T&gt; func load&lt;T&gt;(fromByteOffset: Int = 0, as: T.Type) -&gt; T func distance(to: UnsafeRawPointer) -&gt; Int func advanced(by: Int) -&gt; UnsafeRawPointer } The added UnsafeMutablePointer members are: UnsafeMutablePointer&lt;Pointee&gt; { init(mutating from: UnsafePointer&lt;Pointee&gt;) func withMemoryRebound&lt;T&gt;(to: T.Type, capacity count: Int, _ body: @noescape (UnsafeMutablePointer&lt;T&gt;) throws -&gt; ()) rethrows } The added UnsafePointer members are: UnsafePointer&lt;Pointee&gt; { // Inferred initialization from mutable to immutable. init(_ from: UnsafeMutablePointer&lt;Pointee&gt;) } The following unsafe pointer conversions on Unsafe[Mutable]Pointer members are removed: UnsafeMutablePointer&lt;Pointee&gt; { init&lt;U&gt;(_ from : UnsafeMutablePointer&lt;U&gt;) init?&lt;U&gt;(_ from : UnsafeMutablePointer&lt;U&gt;?) init&lt;U&gt;(_ from : UnsafePointer&lt;U&gt;) init?&lt;U&gt;(_ from : UnsafePointer&lt;U&gt;?) } UnsafePointer&lt;Pointee&gt; { init&lt;U&gt;(_ from : UnsafePointer&lt;U&gt;) init?&lt;U&gt;(_ from : UnsafePointer&lt;U&gt;?) } UnsafeMutablePointer.deinitialize now returns a raw pointer: UnsafeMutablePointer&lt;Pointee&gt; { func deinitialize(count: Int = 1) -&gt; UnsafeMutableRawPointer } The following UnsafeMutablePointer members are renamed: extension UnsafeMutablePointer&lt;Pointee&gt; { static func allocate(capacity: Int) func deallocate(capacity: Int) func initialize(to: Pointee, count: Int = 1) func assign(from source: UnsafePointer&lt;Pointee&gt;, count: Int) func moveInitialize(from source: ${Self}, count: Int) func initialize(from source: UnsafePointer&lt;Pointee&gt;, count: Int) func initialize&lt;C : Collection&gt;(from source: C) func moveAssign(from source: ${Self}, count: Int) } The following UnsafeMutablePointer members are removed: extension UnsafeMutablePointer&lt;Pointee&gt; { func assignBackwardFrom(_ source: UnsafePointer&lt;Pointee&gt;, count: Int) func moveInitializeBackwardFrom(_ source: ${Self}, count: Int) } Impact on existing code The largest impact of this change is that void* and const void* are imported as UnsafeMutableRawPointer and UnsafeRawPointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs. Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeRawPointer API. Otherwise, they can work around the new restriction by using bindMemory(to:capacity:), assumingMemoryBound&lt;T&gt;(to), or adding a mutating label to their initializer. The unsafeptr_convert branch contains an implementation of a previous design, which will soon be ported to the rawptr branch. Swift code migration All occurrences of the type Unsafe[Mutable]Pointer&lt;Void&gt; will be automatically replaced with Unsafe[Mutable]RawPointer. Initialization of the form Unsafe[Mutable]Pointer(p) will automatically be replaced by Unsafe[Mutable]RawPointer(p) whenever the type checker determines that is the expression’s expected type. Conversion between incompatible Unsafe[Mutable]Pointer values will produce a diagnostic explaining asking the user to migrate to one of these forms: Unsafe[Mutable]RawPointer($0).withMemoryRebound(to:capacity:) Unsafe[Mutable]RawPointer($0).bindMemory(to:capacity:) Unsafe[Mutable]RawPointer($0).assumingMemoryBound(to: T.self) The following UnsafeMutablePointer methods: initializeFrom(_: UnsafePointer&lt;Pointee&gt;, count: Int) initializeBackwardFrom(_: UnsafePointer&lt;Pointee&gt;, count: Int) assignFrom(_ source: Unsafe[Mutable]Pointer&lt;Pointee&gt;, count: Int) moveAssignFrom(_ source: Unsafe[Mutable]Pointer&lt;Pointee&gt;, count: Int) will be automatically converted to: initialize(from: UnsafePointer&lt;Pointee&gt;, count: Int) assign(from source: Unsafe[Mutable]Pointer&lt;Pointee&gt;, count: Int) Standard library changes Disallowing inferred UnsafePointer conversion requires some standard library code to use an explicit .bindMemory(to:capacity:) whenever the conversion may previously violate strict aliasing. All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to Unsafe[Mutable]RawPointer. e.g. unsafeAddress() now returns UnsafeRawPointer, not UnsafePointer&lt;Void&gt;. Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeRawPointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses. StringCore.baseAddress changes from OpaquePointer to UnsafeMutableRawPointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, non-dereferenceable and not involved in address computation. The StringCore implementation does a considerable amount of casting between different views of the String storage. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This will be made safe by using bindMemory(to:capacity:). CoreAudio utilities now use Unsafe[Mutable]RawPointer. Implementation status An unsafeptr_convert branch has the first prototype, named UnsafeBytePointer, and includes standard library and type system changes listed below. A rawptr branch has the latest proposed implementation of UnsafeRawPointer. I am currently updating the rawptr branch to include the following changes. There are a several things going on here in order to make it possible to build the standard library with the changes: A new UnsafeRawPointer type is defined. The type system imports void* as UnsafeRawPointer. The type system handles implicit conversions to UnsafeRawPointer. UnsafeRawPointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt; (Recent feedback suggestes that UnsafeMutablePointer should also be introduced). The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as mutating or have been rewritten. Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeRawPointer instead. Explicit labeled Unsafe[Mutable]Pointer initializers are added. The inferred Unsafe[Mutable]Pointer conversion is removed. Remaining work: A SIL-level builtin needs to be implemented for binding a region of memory. A name mangled abbreviation needs to be created for UnsafeRawPointer. We may want a convenience utility for binding null-terminated string without providing a capacity. The StringAPI tests should probably be rewritten with UnsafeRawPointer. The NSStringAPI utilities and tests may need to be ported to UnsafeRawPointer The CoreAudio utilities and tests may need to be ported to UnsafeRawPointer. Future improvements and planned additive API UnsafeRawPointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows “packed” struct members. At that time we may also want to add an “unaligned” flag to UnsafeRawPointer’s load and initialize methods. Alternatives previously considered unsafeBitCast workaround In some cases, developers can safely reinterpret values to achieve the same effect as type punning: let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;.allocate(capacity: 1) ptrI32[0] = Int32() let u = unsafeBitCast(ptrI32[0], to: UInt32.self) Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn’t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type. typePunnedMemory property We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library. Special UnsafeMutablePointer type The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it’s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeRawPointer. However, it doesn’t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value. To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige. UnsafeBytePointer This first version of this proposal introduced an UnsafeBytePointer. UnsafeRawPointer better conveys the type’s role with respect to uninitialized memory. The best way to introduce UnsafeRawPointer to users is by showing how it represents uninitialized memory. It is the result of allocation, input to initialization, and result of deinitialization. This helps users understand the relationship between initializing memory and imbuing it with a type. Furthermore, we do not intend to allow direct access to the “bytes” via subscript which would be implied by UnsafeBytePointer. Alternate proposal for void* type Changing the imported type for void* will be somewhat disruptive. We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an “opaque” untyped pointer. Converting to UnsafeRawPointer would be necessary to perform pointer arithmetic or to conservatively handle possible type punning. This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers. There seems to be general agreement that UnsafeMutablePointer&lt;Void&gt; is fundamentally the wrong way to represent untyped memory. From a practical perspective, given the current restrictions of the language, it’s not clear how to statically enforce the necessary rules for casting UnsafePointer&lt;Void&gt; once general UnsafePointer&lt;T&gt; conversions are disallowed. The following conversions should be inferred, and implied for function arguments (ignoring mutability): UnsafePointer&lt;T&gt; to UnsafePointer&lt;Void&gt; UnsafePointer&lt;Void&gt; to UnsafeRawPointer I did not implement this simpler design because my primary goal was to enforce legal pointer conversion and rid Swift code of undefined behavior. I can’t do that while allowing UnsafePointer&lt;Void&gt; conversions. The general consensus now is that as long as we are making source breaking changes to UnsafePointer, we should try to shoot for an overall better design that helps programmers understand the concepts.",
    "url": "http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html",
    "relUrl": "/docs/2019-08-26-0107-unsaferawpointer.html"
  },
  "107": {
    "id": "107",
    "title": "SE-0108 Remove associated type inference",
    "content": "Remove associated type inference Proposal: SE-0108 Authors: Douglas Gregor, Austin Zheng Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction In Swift, a type T may choose to conform to a protocol P, where P has associated types that may be used in the protocol requirements. If the associated types are used in the requirements, the types that T chooses to bind those associated types to can currently be inferred by the type checker by examining how T chooses to implement P’s requirements: // This protocol is used in subsequent examples throughout the document. protocol SimpleCollection { associatedtype Element func object(at index: Int) -&gt; Element? } class StringBag : SimpleCollection { func object(at index: Int) -&gt; String? { // ... } } In this example, the typechecker deduces that StringBag.Element is String through the way the object(at:) requirement is implemented. In order to simplify the compiler and typechecker, we propose to remove associated type witness inference. swift-evolution thread: pre-proposal Motivation According to Completing Generics: […] associated type inference is the only place in Swift where we have a global type inference problem: it has historically been a major source of bugs, and implementing it fully and correctly requires a drastically different architecture to the type checker. The main advantage of removing associated type witness inference is that it decreases the complexity of the type checker. Doing so removes the only aspect of Swift that depends upon global type inference. Simplifying the type checker makes it easier to improve the performance and correctness of the type checker code. Given that both are widely acknowledged issues with current versions of Swift, any opportunity for improvement should be carefully considered. As Douglas Gregor (original author of the relevant type inference code) puts it: Because this is the only place we do global type inference, it’s put tremendous pressure on the type checker that caused a huge number of bugs, crashes, and outright incomprehensible behavior. […] [The re-implementation is] still not global enough to actually be predictable, and the legacy of this mis-feature manifests in a number of weird ways (e.g., typealiases in protocol extensions cannot be used to satisfy associated type requirements, weird rules for when a defaulted associated type gets used). Proposed solution Associated type witness inference will be removed. A type implementing one or more protocols with associated types will have to explicitly spell out how those associated types are bound using one of the following methods. Explicit binding using typealias A type may bind an associated type to a specific type using a typealias declaration, whether in the primary definition or retroactively through an extension: class StringBag : SimpleCollection { typealias Element = String func object(at index: Int) -&gt; String? { /* ... */ } } Explicit binding using nested type A type may bind an associated type to a specific type by defining a nested type with the name of that associated type: class FooBag : SimpleCollection { struct Element { /* ... */ } func object(at index: Int) -&gt; Element? { /* ... */ } } Default type for associated type A type may adopt the default type specified for an associated type without any explicit annotation: protocol P { associatedtype A = Int } class C : P { // C.A is Int // ... } Removing the associated type witness inference machinery will allow typealiases to be defined in protocol extensions, which can also be used to define default type values for associated types: protocol P { associatedtype A associatedtype B } extension P where A : Fooable { typealias B = Int } class C1 : P { // C1.A is not Fooable struct A { /* ... */ } // Must bind &#39;C1.B&#39; explicitly typealias B = String } class C2 : P { // C2.A is Fooable struct A : Fooable { /* ... */ } // &#39;C2.B&#39; is implicitly Int // No need for explicit binding } Detailed design There currently exists a possible issue where a requirement on a protocol might be implemented both by a protocol extension (default implementation), and by a conforming type, but the implementation considered by the compiler to fulfill the protocol requirement is surprising to the programmer. The following example illustrates this issue: protocol P { associatedtype A = Int func doSomething() -&gt; A } extension P { func doSomething() -&gt; Int { return 50 } } class C : P { func doSomething() -&gt; String { return &quot;hello&quot; } } func myMethod&lt;T : P&gt;(_ x: T) -&gt; T.A { return x.doSomething() } Currently, C.A for the previous example would be inferred to be String, and the doSomething() implementation returning String would be considered to fulfill the protocol requirement. If associated type inference were to be removed, C.A would be bound as Int (since there would be no explicit typealias declaration overriding the default type value), and the doSomething() implementation returning Int would be considered to fulfill the protocol requirement. Thus, the semantics of the code listing above would change even though the source itself remained unchanged. To some extent, this is an issue inherent to any design which makes no distinctions at the site of implementation between members intended to satisfy protocol requirements and members that are explicitly not intended to satisfy protocol requirements. Rather than adding keywords to create this distinction, Douglas Gregor has proposed and implemented type checker heuristics that will generate warnings when a programmer implements a member that “looks like” it should fulfill a protocol requirement but does not actually do so. This is one possible mitigation strategy that should be revisited as a way to decrease the possible impact of removing associated type witness inference from the compiler. Impact on existing code Swift source code containing types conforming to protocols with associated types will need to explicitly define their associated types using the syntax detailed in the proposal in some cases. This is a source-breaking change. Alternatives considered A couple of alternatives follow. Keep the current behavior The current behavior is kept. Swift will continue to allow associated types to be inferred. There are some advantages to this approach. Brevity is slightly improved. A type’s associated types don’t “stand out” in the type declaration, being unobtrusively and implicitly defined through the implementation of protocol requirements. As well, Dave Abrahams expresses a potential issue: Finally, I am very concerned that there are protocols such as Collection, with many inferrable associated types, and that conforming to these protocols could become much uglier. As with many proposals, there is a tradeoff between the status quo and the proposed behavior. As Completing Generics puts it, Is the value of this feature worth keeping global type inference in the Swift language […]? Require explicit declaration using associatedtype An earlier draft of this proposal detailed a design in which types would explicitly bind their associated types using an associatedtype declaration. It is presented as an alternative for consideration.",
    "url": "http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html",
    "relUrl": "/docs/2019-08-26-0108-remove-assoctype-inference.html"
  },
  "108": {
    "id": "108",
    "title": "SE-0109 Remove the `Boolean` protocol ",
    "content": "Remove the Boolean protocol Proposal: SE-0109 Authors: Anton Zhilin, Chris Lattner Review Manager: Doug Gregor Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift@76cf339, apple/swift@af30ae3 Introduction For legacy and historical reasons Swift has supported a protocol named Boolean for abstracting over different concrete Boolean types. This causes problems primarily because it is pointless and very confusing to newcomers to Swift: is quite different than Bool, but shows up right next to it in documentation and code completion. Once you know that it is something you don’t want, you constantly ignore it. Boolean values are simple enough that we don’t need a protocol to abstract over multiple concrete implementations. From a historical perspective, it was a very early solution to the bridging challenge of BOOL (which comes in as ObjCBool). In the time since then, Swift has developed a number of more advanced ways to solve these sorts of bridging problems, and BOOL is already bridged in automatically as Bool in almost all cases. Another pragmatic problem with the Boolean protocol is that it isn’t used consistently in APIs that take Boolean parameters: almost everything takes Bool concretely. This means that its supposed abstraction isn’t useful. The only significant users are the unary !, and binary &amp;&amp; and || operators. Discussion thread Proposal Remove Boolean protocol, and change the three operators that take it to operate on Bool directly. Impact on existing code This change is backwards incompatible, but extremely unlikely to break code in practice. As already mentioned, APIs that have parameters or return values of type BOOL are automatically bridged in as Bool, so they will not see any change at all. The only significant place they appear in APIs are for the STOP out parameters on certain Objective-C collection types, e.g.: class NSArray : NSObject ... { func enumerateObjects(_ block: @noescape (AnyObject, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void) which is used like this: x.enumerateObjects { value, index, STOP in STOP.pointee = true } This continues to work even without the Boolean protocol because ObjCBool still conforms to BooleanLiteralConvertible.",
    "url": "http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html",
    "relUrl": "/docs/2019-08-26-0109-remove-boolean.html"
  },
  "109": {
    "id": "109",
    "title": "SE-0110 Distinguish between single-tuple and multiple-argument function types",
    "content": "Distinguish between single-tuple and multiple-argument function types Proposal: SE-0110 Authors: Vladimir S., Austin Zheng Review Manager: Chris Lattner Status: Accepted Decision Notes: Rationale, Additional Commentary Bug: SR-2008 Introduction Swift’s type system should properly distinguish between functions that take one tuple argument, and functions that take multiple arguments. Discussion: pre-proposal Motivation Right now, the following is possible: let fn1 : (Int, Int) -&gt; Void = { x in // The type of x is the tuple (Int, Int). // ... } let fn2 : (Int, Int) -&gt; Void = { x, y in // The type of x is Int, the type of y is Int. // ... } A variable of function type where there exist n parameters (where n &gt; 1) can be assigned a value (whether it be a named function, a closure literal, or other acceptable value) which either takes in n parameters, or one tuple containing n elements. This seems to be an artifact of the tuple splat behavior removed in SE-0029. The current behavior violates the principle of least surprise and weakens type safety, and should be changed. Proposed solution We propose that this behavior should be fixed in the following ways: A function type declared with n parameters (n &gt; 1) can only be satisfied by a function value which takes in n parameters. In the above example, only the fn2 expression would be considered valid. To declare a function type with one tuple parameter containing n elements (where n &gt; 1), the function type’s argument list must be enclosed by double parentheses: let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 } We understand that this may be a departure from the current convention that a set of parentheses enclosing a single object are considered semantically meaningless, but it is the most natural way to differentiate between the two situations described above and would be a clearly-delineated one-time-only exception. Impact on existing code Minor changes to user code may be required if this proposal is accepted. Alternatives considered Don’t make this change.",
    "url": "http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html",
    "relUrl": "/docs/2019-08-26-0110-distingish-single-tuple-arg.html"
  },
  "110": {
    "id": "110",
    "title": "SE-0111 Remove type system significance of function argument labels",
    "content": "Remove type system significance of function argument labels Proposal: SE-0111 Author: Austin Zheng Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale, Additional Commentary Bug: SR-2009 Introduction Swift’s type system should not allow function argument labels to be expressed as part of a function type. Discussion: pre-proposal Motivation Right now, argument labels are considered significant by the type system, and the type system establishes subtyping relationships between function types with and without argument labels. Here is an example: func doSomething(x: Int, y: Int) -&gt; Bool { return x == y } let fn1 : (Int, Int) -&gt; Bool = doSomething // Okay fn1(1, 2) // fn2&#39;s type is actually (x: Int, y: Int) -&gt; Bool let fn2 = doSomething // Okay fn2(x: 1, y: 2) // NOT ALLOWED fn2(1, 2) As currently implemented, this feature can lead to surprising behavior: func sinkBattleship(atX x: Int, y: Int) -&gt; Bool { /* ... */ } func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool { /* ... */ } var battingAveragePredicate : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage battingAveragePredicate = sinkBattleship // sinkBattleship is invoked battingAveragePredicate(ofHits: 1, forRuns: 2) Removing this feature simplifies the type system. It also changes the way argument labels are treated to be consistent with how default arguments are treated; that is, tied to a declaration and not part of the type system: Essentially, argument labels become part of the names of declarations (only!), which is consistent with our view that the names of functions/methods/initializers include all of the argument names. Proposed solution We propose simplifying the type system by removing the significance of the argument labels from the type system. Function types may only be defined in terms of the types of the formal parameters and the return value. func doSomething(x: Int, y: Int) -&gt; Bool { return x == y } func somethingElse(a: Int, b: Int) -&gt; Bool { return a &gt; b } // fn2&#39;s type is (Int, Int) -&gt; Bool var fn2 = doSomething // Okay fn2(1, 2) // Okay fn2 = somethingElse Writing out a function type containing argument labels will be prohibited: // NOT ALLOWED let fn3 : (a: Int, b: Int) -&gt; Bool // Must write: // let fn3 : (Int, Int) -&gt; Bool This change would also allow functions referred to by their fully-qualified names to be invoked without redundancy: // Before: doSomething(x:y:)(x: 10, y: 10) // After: doSomething(x:y:)(10, 10) Detailed design The examples above demonstrate when argument labels are and aren’t necessary when invoking a function or function-like member. More formally, the rules for when argument labels are necessary follow the rules for default arguments, and can be spelled out as such: If the invocation refers directly to the name of the function as stated in the declaration, the argument labels need to be supplied: either in the reference, or in the argument list itself. func doSomething(x: Int, y: Int) -&gt; Bool { return true } // In the reference doSomething(x:y:)(10, 10) // In the argument list doSomething(x: 10, y: 10) // Note that this will be an error: // doSomething(x:y:)(x: 10, y: 10) If the invocation refers to a value, property, or variable of function type, the argument labels do not need to be supplied. It will be an error to supply argument labels in this situation. func doSomething(x: Int, y: Int) -&gt; Bool { return true } let x = doSomething x(10, 10) // NOT ALLOWED x(x: 10, y: 10) // NOT ALLOWED x(something: 10, anotherThing: 10) Impact on existing code Minor changes to user code may be required if this proposal is accepted. Note that this proposal intentionally does not affect the treatment of labeled tuples by the type system (for example, func homeCoordinates() -&gt; (x: Int, y: Int)); it only affects parameter lists used to invoke values of function type. Alternatives considered Besides simply not adopting this proposal: Allow spelling function types with purely cosmetic argument labels Rather than prohibiting labels altogther, allow a function type to be written with purely cosmetic argument labels: var fn3 : (x: Int, y: Int) -&gt; Bool var fn4 : (a: Int, b: Int) -&gt; Bool func foo(a: Int, b: Int) -&gt; Bool { return false } // All okay fn3 = foo fn4 = foo fn3 = fn4 fn4 = fn3 Instead of having the compiler establish implicit subtyping relationships between function types with identical constituent types but different labels, the labels will simply be ignored outright and all such function types will be considered identical. (This does not affect the programmer experience.) The primary advantage of this alternative is that it allows the use of cosmetic argument labels as a form of documentation for libraries and modules vending out APIs. It is often more convenient to look at the type signature than to pull up the documentation. (Adopting this alternative would also cause more existing code to stop working than if the main proposal were adopted.) The primary disadvantage of this alternative is that it may lead users into falsely assuming that argument labels are significant (and that labeling their function types as such will prevent them from improperly assigning a value of (a: Int, b: Int) -&gt; Void type to a variable of (x: Int, b: Int) -&gt; Void type). It also creates the possibility of users drawing a false equivalence between the definition of parameter lists in function types, and the definition of tuple types with named members (where the labels are significant). Prohibit implicit subtyping Instead of adopting the approach laid out in the main proposal, properly enforce the significance of argument labels in function types by disallowing implicit conversions between functions with identical constituent types and different labels. (It will still be permitted to convert a function type with argument labels into an equivalent function type without labels.) func sinkBattleship(atX x: Int, y: Int) -&gt; Bool { /* ... */ } func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool { /* ... */ } var battingAveragePredicate : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage // NOT ALLOWED // sinkBattleship has incompatible argument labels battingAveragePredicate = sinkBattleship // Okay var genericFunc : (Int, Int) -&gt; Bool = sinkBattleship genericFunc = battingAveragePredicate",
    "url": "http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html",
    "relUrl": "/docs/2019-08-26-0111-remove-arg-label-type-significance.html"
  },
  "111": {
    "id": "111",
    "title": "SE-0112 Improved NSError Bridging",
    "content": "Improved NSError Bridging Proposal: SE-0112 Authors: Doug Gregor, Charles Srstka Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction Swift’s error handling model interoperates directly with Cocoa’s NSError conventions. For example, an Objective-C method with an NSError** parameter, e.g., - (nullable NSURL *)replaceItemAtURL:(NSURL *)url options:(NSFileVersionReplacingOptions)options error:(NSError **)error; will be imported as a throwing method: func replaceItem(at url: URL, options: ReplacingOptions = []) throws -&gt; URL Swift bridges between ErrorProtocol-conforming types and NSError so, for example, a Swift enum that conforms to ErrorProtocol can be thrown and will be reflected as an NSError with a suitable domain and code. Moreover, an NSError produced with that domain and code can be caught as the Swift enum type, providing round-tripping so that Swift can deal in ErrorProtocol values while Objective-C deals in NSError objects. However, the interoperability is incomplete in a number of ways, which results in Swift programs having to walk a careful line between the ErrorProtocol-based Swift way and the NSError-based way. This proposal attempts to bridge those gaps. Swift-evolution thread: Charles Srstka’s pitch for Consistent bridging for NSErrors at the language boundary, which discussed Charles’ original proposal that addressed these issues by providing NSError to ErrorProtocol bridging and exposing the domain, code, and user-info dictionary for all errors. This proposal expands upon that work, but without directly exposing the domain, code, and user-info. Motivation There are a number of weaknesses in Swift’s interoperability with Cocoa’s error model, including: There is no good way to provide important error information when throwing an error from Swift. For example, let’s consider a simple application-defined error in Swift: enum HomeworkError : Int, ErrorProtocol { case forgotten case lost case dogAteIt } One can throw HomeworkError.dogAteIt and it can be interpreted as an NSError by Objective-C with an appropriate error domain (effectively, the mangled name of the HomeworkError type) and code (effectively, the case discriminator). However, one cannot provide a localized description, help anchor, recovery attempter, or any other information commonly placed into the userInfo dictionary of an NSError. To provide these values, one must specifically construct an NSError in Swift, e.g., throw NSError(code: HomeworkError.dogAteIt.rawValue, domain: HomeworkError._domain, userInfo: [ NSLocalizedDescriptionKey : &quot;the dog ate it&quot; ]) There is no good way to get information typically associated with NSError’s userInfo in Swift. For example, the Swift-natural way to catch a specific error in the AVError error domain doesn’t give one access to the userInfo dictionary, e.g.,: catch let error as AVError where error == .diskFull { // AVError is an enum, so one only gets the equivalent of the code. // There is no way to access the localized description (for example) or // any other information typically stored in the ``userInfo`` dictionary. } The workaround is to catch as an NSError, which is quite a bit more ugly: catch let error as NSError where error._domain == AVFoundationErrorDomain &amp;&amp; error._code == AVFoundationErrorDomain.diskFull.rawValue { // okay: userInfo is finally accessible, but still weakly typed } This makes it extremely hard to access common information, such as the localized description. Moreover, the userInfo dictionary is effectively untyped so, for example, one has to know a priori that the value associated with the known AVErrorTimeKey will be typed as CMTime: catch let error as NSError where error._domain = AVFoundationErrorDomain { if let time = error.userInfo[AVErrorTimeKey] as? CMTime { // ... } } It would be far better if one could catch an AVError directly and query the time in a type-safe manner: catch let error as AVError { if let time = error.time { // ... } } NSError is inconsistently bridged with ErrorProtocol. Swift interoperates by translating between NSError and ErrorProtocol when mapping between a throwing Swift method/initializer and an Objective-C method with an NSError** parameter. However, an Objective-C method that takes an NSError* parameter (e.g., to render it) does not bridge to ErrorProtocol, meaning that NSError is part of the API in Swift in some places (but not others). For example, NSError leaks through when the following UIDocument API in Objective-C: - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted; is imported into Swift as follows: func handleError(_ error: NSError, userInteractionPermitted: Bool) One would expect the first parameter to be imported as ErrorProtocol. Proposed solution This proposal involves directly addressing (1)-(3) with new protocols and a different way of bridging Objective-C error code types into Swift, along with some conveniences for working with Cocoa errors: Introduce three new protocols for describing more information about errors: LocalizedError, RecoverableError, and CustomNSError. For example, an error type can provide a localized description by conforming to LocalizedError: extension HomeworkError : LocalizedError { var errorDescription: String? { switch self { case .forgotten: return NSLocalizedString(&quot;I forgot it&quot;) case .lost: return NSLocalizedString(&quot;I lost it&quot;) case .dogAteIt: return NSLocalizedString(&quot;The dog ate it&quot;) } } } Imported Objective-C error types should be mapped to struct types that store an NSError so that no information is lost when bridging from an NSError to the Swift error types. We propose to introduce a new macro, NS_ERROR_ENUM, that one can use to both declare an enumeration type used to describe the error codes as well as tying that type to a specific domain constant, e.g., typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) { AVErrorUnknown = -11800, AVErrorOutOfMemory = -11801, AVErrorSessionNotRunning = -11803, AVErrorDeviceAlreadyUsedByAnotherSession = -11804, // ... } The imported AVError will have a struct that allows one to access the userInfo dictionary directly. This retains the ability to catch via a specific code, e.g., catch AVError.outOfMemory { // ... } However, catching a specific error as a value doesn’t lose information: catch let error as AVError where error.code == .sessionNotRunning { // able to access userInfo here! } This also gives the ability for one to add typed accessors for known keys within the userInfo dictionary: extension AVError { var time: CMTime? { get { return userInfo[AVErrorTimeKey] as? CMTime? } set { userInfo[AVErrorTimeKey] = newValue.map { $0 as CMTime } } } } Bridge NSError to ErrorProtocol, so that all NSError uses are bridged consistently. For example, this means that the Objective-C API: - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted; is imported into Swift as: func handleError(_ error: ErrorProtocol, userInteractionPermitted: Bool) This will use the same bridging logic in the Clang importer that we use for other value types (Array, String, URL, etc.), but with the runtime translation we’ve already been doing for catching/throwing errors. When we introduce this bridging, we will need to remove NSError’s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, one can still explicitly turn an NSError into ErrorProtocol via a bridging cast, e.g., nsError as ErrorProtocol. In Foundation, add an extension to ErrorProtocol that provides access to the localized description, which is available for all error types. extension ErrorProtocol { var localizedDescription: String { return (self as! NSError).localizedDescription } } For the Cocoa error domain, which is encapsulated by the NSCocoaError type, add typed access for common user-info keys. Note that we focus only on those user-info keys that are read by user code (vs. only accessed by frameworks): extension NSCocoaError { // Note: for exposition only. Not actual API. private var userInfo: [NSObject : AnyObject] { return (self as! NSError).userInfo } var filePath: String? { return userInfo[NSFilePathErrorKey] as? String } var stringEncoding: String.Encoding? { return (userInfo[NSStringEncodingErrorKey] as? NSNumber) .map { String.Encoding(rawValue: $0.uintValue) } } var underlying: ErrorProtocol? { return (userInfo[NSUnderlyingErrorKey] as? NSError)?.asError } var url: URL? { return userInfo[NSURLErrorKey] as? URL } } Rename ErrorProtocol to Error: once we’ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged: func handleError(_ error: Error, userInteractionPermitted: Bool) Detailed design This section details both the design (including the various new protocols, mapping from Objective-C error code enumeration types into Swift types, etc.) and the efficient implementation of this design to interoperate with NSError. Throughout the detailed design, we already assume the name change from ErrorProtocol to Error. New protocols This proposal introduces several new protocols that allow error types to expose more information about error types. The LocalizedError protocol describes an error that provides localized messages for display to the end user, all of which provide default implementations. The conforming type can provide implementations for any subset of these requirements: protocol LocalizedError : Error { /// A localized message describing what error occurred. var errorDescription: String? { get } /// A localized message describing the reason for the failure. var failureReason: String? { get } /// A localized message describing how one might recover from the failure. var recoverySuggestion: String? { get } /// A localized message providing &quot;help&quot; text if the user requests help. var helpAnchor: String? { get } } extension LocalizedError { var errorDescription: String? { return nil } var failureReason: String? { return nil } var recoverySuggestion: String? { return nil } var helpAnchor: String? { return nil } } The RecoverableError protocol describes an error that might be recoverable: protocol RecoverableError : Error { /// Provides a set of possible recovery options to present to the user. var recoveryOptions: [String] { get } /// Attempt to recover from this error when the user selected the /// option at the given index. This routine must call handler and /// indicate whether recovery was successful (or not). /// /// This entry point is used for recovery of errors handled at a /// &quot;document&quot; granularity, that do not affect the entire /// application. func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: (recovered: Bool) -&gt; Void) /// Attempt to recover from this error when the user selected the /// option at the given index. Returns true to indicate /// successful recovery, and false otherwise. /// /// This entry point is used for recovery of errors handled at /// the &quot;application&quot; granularity, where nothing else in the /// application can proceed until the attmpted error recovery /// completes. func attemptRecovery(optionIndex recoveryOptionIndex: Int) -&gt; Bool } extension RecoverableError { /// By default, implements document-modal recovery via application-model /// recovery. func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: (recovered: Bool) -&gt; Void) { handler(recovered: attemptRecovery(optionIndex: recoveryOptionIndex)) } } Error types that conform to RecoverableError may be given an opportunity to recover from the error. The user can be presented with some number of (localized) recovery options, described by recoveryOptions, and the selected option will be passed to the appropriate attemptRecovery method. The CustomNSError protocol describes an error that wants to provide custom NSError information. This can be used, e.g., to provide a specific domain/code or to populate NSError’s userInfo dictionary with values for custom keys that can be accessed from Objective-C code but are not covered by the other protocols. /// Describes an error type that fills in the userInfo directly. protocol CustomNSError : Error { var errorDomain: String { get } var errorCode: Int { get } var errorUserInfo: [String : AnyObject] { get } } Note that, unlike with NSError, the provided errorUserInfo requires String keys. This is in line with common practice for NSError and is important for the implementation (see below). All of these properties are defaulted, so one can provide any subset: extension CustomNSError { var errorDomain: String { ... } var errorCode: Int { ... } var errorUserInfo: [String : AnyObject] { ... } } Mapping error types to NSError Every type that conforms to the Error protocol is implicitly bridged to NSError. This has been the case since Swift 2, where the compiler provides a domain (i.e., the mangled name of the type) and code (based on the discriminator of the enumeration type). This proposal also allows for the userInfo dictionary to be populated by the runtime, which will check for conformance to the various protocols (LocalizedError, RecoverableError, or CustomNSError) to retrieve information. Conceptually, this could be implemented by eagerly creating a userInfo dictionary for a given instance of Error: func createUserInfo(error: Error) -&gt; [NSObject : AnyObject] { var userInfo: [NSObject : AnyObject] = [:] // Retrieve custom userInfo information. if let customUserInfoError = error as? CustomNSError { userInfo = customUserInfoError.userInfo } if let localizedError = error as? LocalizedError { if let description = localizedError.errorDescription { userInfo[NSLocalizedDescriptionKey] = description } if let reason = localizedError.failureReason { userInfo[NSLocalizedFailureReasonErrorKey] = reason } if let suggestion = localizedError.recoverySuggestion { userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion } if let helpAnchor = localizedError.helpAnchor { userInfo[NSHelpAnchorErrorKey] = helpAnchor } } if let recoverableError = error as? RecoverableError { userInfo[NSLocalizedRecoveryOptionsErrorKey] = recoverableError.recoveryOptions userInfo[NSRecoveryAttempterErrorKey] = RecoveryAttempter() } } The RecoveryAttempter class is an implementation detail. It will implement the informal protocol NSErrorRecoveryAttempting for the given error: class RecoveryAttempter : NSObject { @objc(attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:) func attemptRecovery(fromError nsError: NSError, optionIndex recoveryOptionIndex: Int, delegate: AnyObject?, didRecoverSelector: Selector, contextInfo: UnsafeMutablePointer&lt;Void&gt;) { let error = nsError as! RecoverableError error.attemptRecovery(optionIndex: recoveryOptionIndex) { success in // Exposition only: this part will actually have to be // implemented in Objective-C to pass the BOOL and void* through. delegate?.perform(didRecoverSelector, with: success, with: contextInfo) } } @objc(attemptRecoveryFromError:optionIndex:) func attemptRecovery(fromError nsError: NSError, optionIndex recoveryOptionIndex: Int) -&gt; Bool { let error = nsError as! RecoverableError return error.attemptRecovery(optionIndex: recoveryOptionIndex) } } The actual the population of the userInfo dictionary should not be eager. NSError provides the notion of global “user info value providers” that it uses to lazily request the values for certain keys, via setUserInfoValueProvider(forDomain:provider:), which is declared as: extension NSError { @available(OSX 10.11, iOS 9.0, tvOS 9.0, watchOS 2.0, *) class func setUserInfoValueProvider(forDomain errorDomain: String, provider: ((NSError, String) -&gt; AnyObject?)? = nil) } The runtime would need to register a user info value provider for each error type the first time it is bridged into NSError, supplying the domain and the following user info value provider function: func userInfoValueProvider(nsError: NSError, key: String) -&gt; AnyObject? { let error = nsError as! Error switch key { case NSLocalizedDescriptionKey: return (error as? LocalizedError)?.errorDescription case NSLocalizedFailureReasonErrorKey: return (error as? LocalizedError)?.failureReason case NSLocalizedRecoverySuggestionErrorKey: return (error as? LocalizedError)?.recoverySuggestion case NSHelpAnchorErrorKey: return (error as? LocalizedError)?.helpAnchor case NSLocalizedRecoveryOptionsErrorKey: return (error as? RecoverableError)?.recoveryOptions case NSRecoveryAttempterErrorKey: return error is RecoverableError ? RecoveryAttempter() : nil default: guard let customUserInfoError = error as? CustomNSError else { return nil } return customUserInfoError.userInfo[key] } } On platforms that predate the introduction of user info value providers, there are alternate implementation strategies, including introducing a custom NSDictionary subclass to use as the userInfo in the NSError that lazily populates the dictionary by, effectively, calling the userInfoValueProvider function above for each requested key. Or, one could eagerly populate userInfo on older platforms. Importing error types from Objective-C In Objective-C, error domains are typically constructed using an enumeration describing the error codes and a constant describing the error domain, e.g, extern NSString *const AVFoundationErrorDomain; typedef NS_ENUM(NSInteger, AVError) { AVErrorUnknown = -11800, AVErrorOutOfMemory = -11801, AVErrorSessionNotRunning = -11803, AVErrorDeviceAlreadyUsedByAnotherSession = -11804, // ... } This is currently imported as an enum that conforms to Error: enum AVError : Int { case unknown = -11800 case outOfMemory = -11801 case sessionNotRunning = -11803 case deviceAlreadyUsedByAnotherSession = -11804 static var _domain: String { return AVFoundationErrorDomain } } and Swift code introduces an extension that makes it an Error, along with some implementation magic to allow bridging from an NSError (losing userInfo in the process): extension AVError : Error { static var _domain: String { return AVFoundationErrorDomain } } Instead, error enums should be expressed with a new macro, NS_ERROR_ENUM, that ties together the code and domain in the Objective-C header: extern NSString *const AVFoundationErrorDomain; typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) { AVErrorUnknown = -11800, AVErrorOutOfMemory = -11801, AVErrorSessionNotRunning = -11803, AVErrorDeviceAlreadyUsedByAnotherSession = -11804, // ... } This will import as a new struct AVError that contains an NSError, so there is no information loss. The actual enum will become a nested type Code, so that it is still accessible. The resulting struct will be as follows: struct AVError { /// Stored NSError. Note that error.domain == AVFoundationErrorDomain is an invariant. private var error: NSError /// Describes the error codes; directly imported from AVError enum Code : Int, ErrorCodeProtocol { typealias ErrorType = AVError case unknown = -11800 case outOfMemory = -11801 case sessionNotRunning = -11803 case deviceAlreadyUsedByAnotherSession = -11804 func errorMatchesCode(_ error: AVError) -&gt; Bool { return error.code == self } } /// Allow one to create an error (optionally) with a userInfo dictionary. init(_ code: Code, userInfo: [NSObject: AnyObject] = [:]) { error = NSError(code: code.rawValue, domain: _domain, userInfo: userInfo) } /// Retrieve the code. var code: Code { return Code(rawValue: error.code)! } /// Allow direct access to the userInfo dictionary. var userInfo: [NSObject: AnyObject] { return error.userInfo } /// Make it easy to refer to constants without context. static let unknown: Code = .unknown static let outOfMemory: Code = .outOfMemory static let sessionNotRunning: Code = .sessionNotRunning static let deviceAlreadyUsedByAnotherSession: Code = .deviceAlreadyUsedByAnotherSession } // Implementation detail: makes AVError conform to Error extension AVError : Error { static var _domain: String { return AVFoundationErrorDomain } var _code: Int { return error.code } } This syntax allows one to throw specific errors fairly easily, with or without userInfo dictionaries: throw AVError(.sessionNotRunning) throw AVError(.sessionNotRunning, userInfo: [ ... ]) The ImportedErrorCode protocol is a helper so that we can define a general ~= operator, which is used by both switch case matching and catch blocks: protocol ErrorCodeProtocol { typealias ErrorType : Error func errorMatchesCode(_ error: ErrorType) -&gt; Bool } func ~= &lt;EC: ErrorCodeProtocol&gt; (error: Error, code: EC) -&gt; Bool { guard let myError = error as? EC.ErrorType else { return false } return code.errorMatchesCode(myError) } Mapping NSError types back into Swift When an NSError object bridged to an Error instance, it may be immediately mapped back to a Swift error type (e.g., if the error was created as a HomeworkError instance in Swift and then passed through NSError unmodified) or it might be leave as an instance of NSError. The error might then be catch as a particular Swift error type, e.g., catch let error as AVError where error.code == .sessionNotRunning { // able to access userInfo here! } In this case, the mapping from an NSError instance to AVError goes through an implementation-detail protocol _ObjectiveCBridgeableError: protocol _ObjectiveCBridgeableError : Error { /// Produce a value of the error type corresponding to the given NSError, /// or return nil if it cannot be bridged. init?(_bridgedNSError error: NSError) } The initializer is responsible for checking the domain and (optionally) the code of the incoming NSError to map it to an instance of the Swift error type. For example, AVError would adopt this protocol as follows: // Implementation detail: makes AVError conform to _ObjectiveCBridgeableError extension AVError : _ObjectiveCBridgeableError { init?(_bridgedNSError error: NSError) { // Check whether the error comes from the AVFoundation error domain if error.domain != AVFoundationErrorDomain { return nil } // Save the error self.error = error } } We do not propose that _ObjectiveCBridgeableError become a public protocol, because the core team has already deferred a similar proposal (SE-0058) to make the related protocol _ObjectiveCBridgeable public. Other Issues NSError codes and domains are important for localization of error messages. This is barely supported today by genstrings, but becomes considerably harder when the domain and code are hidden (as they are in Swift). We would need to consider tooling to make it easier to localize error descriptions, recovery options, etc. in a sensible way. Although this is out of the scope of the Swift language per se, it’s an important part of the developer story. Impact on existing code This is a major source-breaking change for Objective-C APIs that operate on NSError values, because those parameter/return/property types will change from NSError to Error. There are ~400 such APIs in the macOS SDK, and closer to 500 in the iOS SDK, which is a sizable number. Fortunately, this is similar in scope to the Foundation value types proposal, and can use the same code migration mechanism. That said, the scale of this change means that it should either happen in Swift 3 or not at all. Future directions Better tooling for describing errors When adopting one of the new protocols (e.g., LocalizedError) in an enum, one will inevitably end up with a number of switch statements that have to enumerate all of the cases, leading to a lot of boilerplate. Better tooling could improve the situation considerably: for example, one could use something like Cocoa’s stringsdict files to provide localized strings identified by the enum name, case name, and property. That would eliminate the need for the switch-on-all-cases implementations of each property. Round-tripping errors through userInfo The CustomNSError protocol allows one to place arbitrary key/value pairs into NSError’s userInfo dictionary. The implementation-detail _ObjectiveCBridgeableError protocol allows one to control how a raw NSError is mapped to a particular error type. One could effectively serialize the entire state of a particular error type into the userInfo dictionary via CustomNSError, then restore it via _ObjectiveCBridgeableError, allowing one to form a complete NSError in Objective-C that can reconstitute itself as a particular Swift error type, which can be useful both for mixed-source projects and (possibly) as a weak form of serialization for NSErrors. Alternatives considered Exposing the domain, code, and user-info dictionary directly This proposal does not directly expose the domain, code, or user-info dictionary on ErrorProtocol, because these notions are superseded by Swift’s strong typing of errors. The domain is effectively subsumed by the type of the error (e.g., a Swift-defined error type uses its mangled name as the domain); the code is some type-specific value (e.g., the discriminator of the enum); and the user-info dictionary is an untyped set of key-value pairs that are better expressed in Swift as data on the specific error type. Bridging NSError to a new value type Error One could introduce a new value type, Error, that stores a domain, code, and user-info dictionary but provides them with value semantics. Doing so would make it easier to create “generic” errors that carry some information. However, we feel that introducing new error types in Swift is already easier than establishing a new domain and a set of codes, because a new enum type provides this information naturally in Swift.",
    "url": "http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html",
    "relUrl": "/docs/2019-08-26-0112-nserror-bridging.html"
  },
  "112": {
    "id": "112",
    "title": "SE-0113 Add integral rounding functions to FloatingPoint",
    "content": "Add integral rounding functions to FloatingPoint Proposal: SE-0113 Author: Karl Wagner Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-2010 Introduction, Motivation The standard library lacks equivalents to the floor() and ceil() functions found in the standard libraries of most other languages. Currently, we need to import Darwin or Glibc in order to access the C standard library versions. In general, rounding of floating-point numbers for predictable conversion in to integers is something we should provide natively. Swift-evolution initial discussion thread: [Proposal] Add floor() and ceiling() functions to FloatingPoint Proposed Solution The proposed rounding API consists of a FloatingPointRoundingRule enum and new round and rounded methods on FloatingPoint /// Describes a rule for rounding a floating-point number. public enum FloatingPointRoundingRule { /// The result is the closest allowed value; if two values are equally close, /// the one with greater magnitude is chosen. Also known as &quot;schoolbook /// rounding&quot;. case toNearestOrAwayFromZero /// The result is the closest allowed value; if two values are equally close, /// the even one is chosen. Also known as &quot;bankers rounding&quot;. case toNearestOrEven /// The result is the closest allowed value that is greater than or equal /// to the source. case up /// The result is the closest allowed value that is less than or equal to /// the source. case down /// The result is the closest allowed value whose magnitude is less than or /// equal to that of the source. case towardZero /// The result is the closest allowed value whose magnitude is greater than /// or equal to that of the source. case awayFromZero } protocol FloatingPoint { ... /// Returns a rounded representation of `self`, according to the specified rounding rule. func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self /// Mutating form of `rounded` mutating func round(_ rule: FloatingPointRoundingRule) } extension FloatingPoint { ... /// Returns `self` rounded to the closest integral value. If `self` is /// exactly halfway between two integers (e.g. 1.5), the integral value /// with greater magnitude (2.0 in this example) is returned. public func rounded() -&gt; Self { return rounded(.toNearestOrAwayFromZero) } /// Rounds `self` to the closest integral value. If `self` is exactly /// halfway between two integers (e.g. 1.5), the integral value with /// greater magnitude is selected. public mutating func round() { round(.toNearestOrAwayFromZero) } } Calls such as rounded(.up) or rounded(.down) are equivalent to C standard library ceil() and floor() functions. (4.4).rounded() == 4.0 (4.5).rounded() == 5.0 (4.0).rounded(.up) == 4.0 (4.0).rounded(.down) == 4.0 Note: the rounding rules in the FloatingPointRoundingRule enum correspond to those in IEEE 754, with the exception of .awayFromZero. Impact on existing code This change is additive, although we may consider suppressing the imported, global-level C functions, or perhaps automatically migrating them to the new instance-method calls. Alternatives considered floor() and ceiling(). The mailing list discussion indicated more nuanced forms of rounding were desired, and that it would be nice to abandon these technical names for what is a pretty common operation. floor() and ceil() or ceiling() are mathematical terms of art. But most people who want to round a floating point are not mathematicians. nextIntegralUp() and nextIntegralDown() are more descriptive, and perhaps a better fit with the rest of the FloatingPoint API, but possibly misleading as (4.0).nextIntegralUp() == 4.0 Changes introduced in implementation RoundingRule was renamed FloatingPointRoundingRule, based on a suggestion from the standard library team. We may want to introduce rounding operations that operate on other types in the future, and they may not want the same set of rules. Also, this type name will be very rarely used, so a long precise typename doesn’t add burden. Added .awayFromZero, which is trivial to implement and was requested by several people during the review period. Removed default rounding direction from protocol requirements (the language doesn’t support that). The default rounding-direction operations were moved to an extension instead.",
    "url": "http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html",
    "relUrl": "/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html"
  },
  "113": {
    "id": "113",
    "title": "SE-0114 Updating Buffer "Value" Names to "Header" Names",
    "content": "Updating Buffer “Value” Names to “Header” Names Proposal: SE-0114 Author: Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#3374 Introduction This proposal updates parameters and generic type parameters from value names to header names for ManagedBuffer, ManagedProtoBuffer, and ManagedBufferPointer. All user-facing Swift APIs must go through Swift Evolution. While this is a trivial API change with an existing implementation, this formal proposal provides a paper trail as is normal and usual for this process. Swift Evolution Thread Patch Motivation This change introduces better semantics for buffer types. Detailed Design This update affects ManagedBuffer, ManagedProtoBuffer, and ManagedBufferPointer. Generic Parameters The generic parameters &lt;Value, Element&gt; become &lt;Header, Element&gt; in affected classes. Type Members Each use of value or Value in type members is renamed to header or Header. Affected members include header: Header _headerPointer, _headerOffset withUnsafeMutablePointerToHeader create(minimumCapacity:makingHeaderWith:) -&gt; Header Initializers that refer to makingHeaderWith Impact on Existing Code Existing third party code will need migration using a simple fixit. Alternatives Considered Not Applicable",
    "url": "http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html",
    "relUrl": "/docs/2019-08-26-0114-buffer-naming.html"
  },
  "114": {
    "id": "114",
    "title": "SE-0115 Rename Literal Syntax Protocols",
    "content": "Rename Literal Syntax Protocols Proposal: SE-0115 Author: Matthew Johnson Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-2054 Introduction This proposal renames the *LiteralConvertible protocols to ExpressibleBy*Literal. Swift-evolution thread: Literal Syntax Protocols An earlier thread that resulted in this proposal: Revisiting SE-0041 Names Motivation The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library. Further, the standard library team has observed: The “literal” protocols are not about conversion, they are about adopting a certain syntax provided by the language. “Convertible” in the name is a red herring: a type can’t be convertible from an integer literal because there is no “IntegerLiteral” entity in the type system. The literal becomes typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes). An earlier proposal was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulty in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team. Proposed solution This proposal addresses both problems by renaming the protocols to ExpressibleBy*Literal. The proposal does not make any changes to the requirements of the protocols. Detailed design All of the *LiteralConvertible protocols will receive new ExpressibleBy*Literal names. This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same. The following protocol declarations and names: public protocol NilLiteralConvertible { ... } public protocol BooleanLiteralConvertible { ... } public protocol FloatLiteralConvertible { ... } public protocol IntegerLiteralConvertible { ... } public protocol UnicodeScalarLiteralConvertible { ... } public protocol ExtendedGraphemeClusterLiteralConvertible { ... } public protocol StringLiteralConvertible { ... } public protocol StringInterpolationConvertible { ... } public protocol ArrayLiteralConvertible { ... } public protocol DictionaryLiteralConvertible { ... } Are changed as follows: public protocol ExpressibleByNilLiteral { ... } public protocol ExpressibleByBooleanLiteral { ... } public protocol ExpressibleByFloatLiteral { ... } public protocol ExpressibleByIntegerLiteral { ... } public protocol ExpressibleByUnicodeScalarLiteral { ... } public protocol ExpressibleByExtendedGraphemeClusterLiteral { ... } public protocol ExpressibleByStringLiteral { ... } public protocol ExpressibleByStringInterpolation { ... } public protocol ExpressibleByArrayLiteral { ... } public protocol ExpressibleByDictionaryLiteral { ... } Impact on existing code All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new ExpressibleBy*Literal name. Alternatives considered Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to choose names they deem best suited for Swift after community discussion and review if they decide to accept this proposal. The discussion thread for this proposal includes abundant bike shedding on the names. This section includes selected examples to highlight different directions that have been discussed. Reviewers are encouraged to read the discussion thread if they wish to see all of the alternatives. The thread includes abundant discusison of the pros and cons of many naming ideas. Some of the names that have been suggested have been inaccurate due to a misunderstanding of what the protocols do. Dave Abrahams explained during the discussion: No, it’s exactly the opposite, as I keep saying. Conformance to this protocol does not mean you can initialize the type with a literal. Proof: func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T { return T(integerLiteral: 43) // Error return T(43) // Also an Error } // It means an instance of the type can be *written* as a literal: func f&lt;T: IntegerLiteralConvertible&gt;() -&gt; T { return 43 // OK } Everybody’s confused about the meaning of the protocol, and doesn’t like the proposed names because they imply exactly the actual meaning of the protocol, which they misunderstand. Previous Version The original version of this proposal introduced a Syntax “namespace” (using an empty enum) and placed the protocols in that namespace with a *Literal naming scheme like this: public protocol _NilLiteralSyntax { ... } public /* closed */ enum Syntax { public typealias NilLiteral = _NilLiteralSyntax } Several commenters suggested that this naming scheme is confusing at the site of use. The ensuing discussion led to the approach in the current proposal. Nate Cook provided the best explanation of the potential confusion: Primarily, the new names read like we’re saying that a conforming type is a literal, compounding a common existing confusion between literals and types that can be initialized with a literal. Swift’s type inference can sometimes make it seem like dark magic is afoot with literal conversions—for example, you need to understand an awful lot about the standard library to figure out why line 1 works here but not line 2: var x = [1, 2, 3, 4, 5] let y = [10, 20] x[1..&lt;2] = [10, 20] // 1 x[1..&lt;2] = y // 2 (Note: The comment above is still valid if it is corrected to say “types that can have instances written as a literal” rather than “types that can be initialized with a literal”.) These new names are a (small) step in the wrong direction. While it’s true that the type system doesn’t have an IntegerLiteral type, the language does have integer literals. If someone reads: extension MyInt : Syntax.IntegerLiteral { ... } the implication is that MyInt is an integer literal, and therefore instances of MyInt should be usable wherever an integer literal is usable. The existing “Convertible” wording may be a red herring, but it at least suggests that there’s a difference between a literal and a concrete type. Namespace names David Sweeris suggested Compiler as an alternative to Syntax. Adrian Zubarev suggested a convention using a nested namespace Literal.*Protocol. Protocol names An alternative naming scheme suggested by Xiaodi Wu emphasizes that the type conforms to a protocol rather than is a literal is: struct Foo: Syntax.IntegerLiteralProtocol { ... } Rename the protocols without placing them in a namespace Adrian Zubarev suggests that we could use the *LiteralProtocol naming scheme for these protocols (replacing Convertible with Protocol) without placing them in a namespace: public protocol NilLiteralProtocol { ... } public protocol BooleanLiteralProtocol { ... } public protocol IntegerLiteralProtocol { ... } public protocol FloatLiteralProtocol { ... } public protocol UnicodeScalarLiteralProtocol { ... } public protocol ExtendedGraphemeClusterProtocol { ... } public protocol StringLiteralProtocol { ... } public protocol StringInterpolationLiteralProtocol { ... } public protocol ArrayLiteralProtocol { ... } public protocol DictionaryLiteralProtocol { ... } Previous proposal This proposal is a follow up to Updating Protocol Naming Conventions for Conversions. Many related alternatives were explored during the discussion and review of that proposal. Acknowledgements The name used in the final proposal was first suggested by Sean Heber. Dave Abrahams suggested moving it out of the Syntax namespace that was used in the original draft of this proposal. The design in the original draft was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev. Dave Abrahams, Nate Cook, David Sweeris, Adrian Zubarev and Xiaodi Wu contributed ideas to the alternatives considered section.",
    "url": "http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html",
    "relUrl": "/docs/2019-08-26-0115-literal-syntax-protocols.html"
  },
  "115": {
    "id": "115",
    "title": "SE-0116 Import Objective-C `id` as Swift `Any` type",
    "content": "Import Objective-C id as Swift Any type Proposal: SE-0116 Author: Joe Groff Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Previous Revision: 1 Introduction Objective-C interfaces that use id and untyped collections should be imported into Swift as taking the Any type instead of AnyObject. Swift-evolution thread: Importing Objective-C id as Swift Any Motivation Objective-C’s id type is currently imported into Swift as AnyObject. This is the intuitive thing to do, but creates a growing tension between idiomatic Objective-C and Swift code. One of Swift’s defining features is its value types, such as String, Array, and Dictionary, which allow for efficient mutation without the hazards of accidental state sharing prevalent with mutable classes. To interoperate with Objective-C, we transparently bridge value types to matching idiomatic Cocoa classes when we know the static types of method parameters and returns. However, this doesn’t help with polymorphic Objective-C interfaces, which to this day are frequently defined in terms of id. These interfaces come into Swift as AnyObject, which doesn’t naturally work with value types. To keep the Swift experience using value types with Cocoa feeling idiomatic, we’ve papered over this impedance mismatch via various language mechanisms: Bridgeable types implicitly convert to their bridged object type. This makes it convenient to use bridgeable types with polymorphic Objective-C interfaces, for example, to build a heterogeneous property list as an [AnyObject] of bridged objects (which in turn bridges to an NSArray). Given a dynamically-typed object of static type AnyObject, the value can be dynamically cast back to a Swift value type using is, as?, and as!. While often convenient, these features are inconsistent with the rest of the language and have in practice been a common source of problems and surprising behavior. We have popular proposals in flight to remove the special cases: SE-0072 (accepted) removes the implicit conversion, requiring one to explicitly write x as NSString or x as AnyObject to use a bridgeable value as an object. SE-0083 (deferred for later consideration) removes the dynamic casting behavior and overloading of as coercion, requiring one to use normal constructors to convert between value types and object types. Meanwhile, Foundation has extensively adopted value types in Swift 3, making this a bigger problem in scope than a handful of standard library types. Swift and Foundation are also being ported to non-Apple platforms that don’t ship an Objective-C runtime, and we want to provide a consistent interface to Foundation between Darwin and other platforms. This means that, even independent of Objective-C, Foundation is still forced to express abstractions in terms of AnyObject. Our current status quo pits the goal of providing a more consistent and predictable standalone language against the goal of providing a portable set of core libraries–if we chip away at the implicit bridging behavior to make the language more predictable, the parts of the standard library and Foundation that are designed to take most advantage of Swift’s features become harder and less attractive to use, and the less idiomatic NS container classes need to be interacted with more frequently. The fundamental tension here is that, whereas ObjC’s polymorphism is centered on objects, Swift opens up polymorphism to all types. Rather than treat bridging as something only a set of preordained types can partake in, we can say that all Swift types can bridge to an Objective-C object. By doing this, we can import Objective-C APIs in terms of Swift’s Any, making them interoperate seamlessly with Swift value types without special-case language behavior. If we achieve this, we can move nearly all of the bridging glue “below the fold” into the compiler implementation, allowing users to work with value types and have them just work with Cocoa APIs without relying on special language rules. Proposed solution We change the behavior of Objective-C APIs imported into Swift so that the id type is imported as Any in bridgeable positions. At compile time and runtime, the compiler introduces a universal bridging conversion operation when a Swift value or object is passed into Objective-C as an id parameter. When id values are brought into Swift as Any, we use the runtime’s existing ambivalent dynamic casting support to handle bridging back to either class references or Swift value types. Untyped Cocoa collections come in as collections of Any. NSArray imports as [Any], NSDictionary as [AnyHashable: Any], and NSSet as Set&lt;AnyHashable&gt; (using an AnyHashable type erasing container to be designed in a follow-up proposal). Detailed design Universal bridging conversion into Objective-C id To describe what bridging an Any to id means, we need to establish a universal bridging conversion from any Swift type to an Objective-C object. There are several cases to consider: Classes are the easiest case—they exist in both Objective-C and Swift and play many of the same roles. A Swift class reference can be brought into Objective-C as is. Bridged value types with established bridging behavior, such as String, Array, Dictionary, Set, etc., should continue to bridge to instances of their corresponding idiomatic Cocoa classes, using the existing internal _ObjectiveCBridgeable protocol. The set of bridged types can be extended in the Swift implementation (and hopefully, eventually, by third parties too) by adding conformances to that protocol. This proposal does not address adding or removing any new bridging behavior, though that would be a natural follow-up proposal. Unbridged value types without an obvious Objective-C analog can still be boxed in an instance of an immutable class. The name and functionality of this class doesn’t need to exposed in the language model, beyond being minimally id-compatible to round-trip through Objective-C code, and being dynamically castable back into the original Swift type from Swift code when an Any value contains a reference to a box. Dynamic casting from Any The runtime currently has the ability to dynamically apply bridging conversions. If an Any or other existential contains a value of bridgeable type, dynamic casts will succeed for either the dynamic type or its bridged counterpart: var x: Any = &quot;foo&quot; as String x as? String // =&gt; String &quot;foo&quot; x as? NSString // =&gt; NSString &quot;foo&quot; x = &quot;bar&quot; as NSString x as? String // =&gt; String &quot;bar&quot; x as? NSString // =&gt; NSString &quot;bar&quot; This ambivalent dynamic casting behavior is exactly what we need to interface with Objective-C APIs that return ids back into Swift as Any, since it is impossible to know locally whether the object is intended to be consumed in Swift as a bridged value or as a class instance. Bridging Objective-C Collections If we take the class constraint away from singular id values, it also makes sense to do so for collections, for instance, bridging an untyped NSArray from Objective-C to a Swift [Any]. This also implies that we would need to lift the current class restriction on covariant Array conversions—[T] would need to be supported as a subtype of [Any]. Dictionary and Set require their keys to be Hashable at minimum, so we would need a way to represent a heterogeneous Hashable type to bridge an untyped NSDictionary or NSSet. The Hashable protocol type cannot itself be used due to limitations in Swift 3; namely, Hashable refines the Equatable protocol, which demands Self constraints of its == requirement, and beyond that, we do not support protocol types conforming to their own protocols in general. As a stopgap, we will likely need an AnyHashable type-erased container in the standard library. Impact on existing code For most code, the combination of this proposal with SE-0072 should have the net effect of most Swift 2 style code working as it does today, allowing value types to be passed into untyped Objective-C APIs without requiring explicit bridging or unbridging operations. There will definitely be edge cases that may behave slightly differently, since the AnyObject constraint may nudge overload resolution or implicit conversion in a different direction from what they would take absent that constraint. AnyHashable type We need a type-erased container to represent a heterogeneous hashable type that is itself Hashable, for use as the upper-bound type of heterogeneous Dictionarys and Sets. The user model for this type would ideally align with our long-term goal of supporting Hashable existentials directly, so the type deserves some short-term compiler support to help us get there. This type deserves its own proposal and design discussion. Future Directions Once we’ve established a universal bridging mechanism for all Swift types, this enables further closing of the expressivity gap with value types and the Objective-C bridge: Importing Objective-C generics as unconstrained We could lift the AnyObject constraint on imported ObjC generic type parameters, allowing ObjC generics to work with Swift value types. Letting Value Types Conform to Objective-C Protocols If we can bridge arbitrary Swift values to Objective-C objects, then we could conceivably implement @objc protocol conformance for Swift value types as well, by setting up the bridged Objective-C class to conform to the protocol and respond to the necessary messages in the Objective-C runtime. This would allow Foundation to vend protocols that work with its value types without compromising portability between Darwin and corelibs platforms. If we wanted to make this work, it would inform some tradeoffs in the potential implementation: We would probably need to produce a unique boxing Objective-C class for every type that conformed to an Objective-C protocol, where we might otherwise be able to share one class (or NSValue for C types). For value types with custom bridging, like String/NSString, does an @objc conformance automatically apply to the bridged class, if not at compile time, at least at runtime? Many Objective-C protocols are intended to be class-constrained, particularly delegate protocols, which are idiomatically weak-referenced from the delegatee class. If @objc no longer implies a class constraint in Swift, it wouldn’t be possible for a property of @objc protocol type to be weak, unless we underwent an annotation or heuristic effort to distinguish Objective-C protocols that are supposed to be class-constrained. Deciding the fate of AnyObject lookup We currently bestow the AnyObject existential type with the special ability to look up any @objc method dynamically, in order to ensure id-based ObjC APIs remain fluent when used in Swift. This is another special, unprincipled, nonportable feature that relies on the Objective-C runtime. If we change id to bridge to Any, it definitely no longer makes sense to apply to AnyObject. A couple of possibilities to consider: We could transfer the existing AnyObject behavior verbatim to Any. We could attempt to eliminate the behavior as a language feature. An approximation of AnyObject’s magic behavior can be made using operators and unapplied method references, in a way that also works for Swift types: /// Dynamically dispatch a method on Any. func =&gt; &lt;T, V&gt;(myself: Any, method: (T) -&gt; V) -&gt; V? { if let myself = myself as? T { return method(myself) } return nil } though that’s not quite the right thing for id lookup, since you want a respondsToSelector rather than isKindOfClass check. We could narrow the scope of the behavior. Jordan has suggested allowing only property and subscript lookup off of AnyObject or Any, as a way of allowing easy navigation of property lists, one of the most common sources of id in Foundation. If we’re confident that the SDK will be sufficiently Swiftified that ids become relatively rare, maybe we could get away without a replacement at all. Hiding the NSObjectProtocol in Swift Aside from AnyObject, another way unnecessary @objc-isms intrude themselves into Swift code is through NSObjectProtocol requirements. In practice, nearly every class in Swift on an Apple platform conforms to this protocol–native Swift classes inherit from a common Objective-C SwiftObject base class internal to the Swift runtime that implements the NSObjectProtocol methods, and almost all Cocoa classes inherit either NSObject or NSProxy. We can also make the box class used to bridge Swift values provide NSObjectProtocol functionality. Eliminating NSObjectProtocol as a formal requirement in Swift will allow native Swift classes, and often value types too, to interoperate more smoothly with Cocoa code with less explicit @objc interop glue. Bridging more types to idiomatic objects Removing the AnyObject constraint and special typing rules makes it more important for the Any-to-id to do the right thing for as many types as possible. Some obvious candidates include: Extending NSNumber bridging to cover not only Int and Double, but all [U]IntNN and FloatNN numeric types, as well as the Decimal struct from Foundation. Bridging Foundation and CoreGraphics structs like CGRect and NSRange to NSValue, the idiomatic box class for those types. When an Optional is passed as a non-nullable id, we might consider bridging the optional’s nil value to NSNull. This would allow containers of optional such as [Foo?] to bridge idiomatically to NSArrays of Foo and NSNull elements. Simplifying pure Swift dynamic casting behavior SE-0083 sought to remove the ambivalent dynamic casting behavior and overloading of as coercion from Swift. This proposal relies on ambivalent dynamic casting to make sense of incoming id values returned from Objective-C into Swift. We could conceivably still limit ambivalent dynamic casting only to Any existentials with Objective-C provenance, so that “pure” Swift code has simpler, more predictable dynamic casting behavior where interop is not involved. We don’t have time to evaluate this in the remaining time for Swift 3, but since the ambivalent casting behavior must remain in the runtime for Objective-C interop and will at best be conditionalized, we can potentially evaluate this later as a dialect change; in Swift 3, all existentials effectively have the “ambivalent” flag set, but in a future version of Swift, we could start turning it off for some values. Revision history version 2 Reduced the scope of the proposal further based on design discussion, implementation, and scheduling concerns: Subset out conditional ambivalent dynamic casting from the proposal. We don’t have time in Swift 3 to implement or evaluate this. Move NSObjectProtocol and NSValue/NSNumber bridging to future directions. These can be done additively.",
    "url": "http://localhost:4000/docs/2019-08-26-0116-id-as-any.html",
    "relUrl": "/docs/2019-08-26-0116-id-as-any.html"
  },
  "116": {
    "id": "116",
    "title": "SE-0117 Allow distinguishing between public access and public overridability",
    "content": "Allow distinguishing between public access and public overridability Proposal: SE-0117 Authors: Javier Soto, John McCall Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#3882 Previous Revision: 1, 2, 3 Introduction Since the first release of Swift, marking a class public has provided two capabilities: it allows other modules to instantiate and use the class, and it also allows other modules to define subclasses of it. Similarly, marking a class member (a method, property, or subscript) public has provided two capabilities: it allows other modules to use the member, and it also allows those modules to override it. This proposal suggests distinguishing these concepts. It creates a new access level open beyond public; for now, open can only be used on classes and overridable class members. A public class will only be usable by other modules, but not subclassable. An open class will be both usable and subclassable. Similarly, a public member will only be usable by other modules, but not overridable. An open member will be both usable and overridable. This spirit of this proposal is to allow one to distinguish these cases while keeping them at the same level of support: it does not adversely affect code that is open, nor does it dissuade one from using open in their APIs. In fact, with this proposal, open APIs are syntactically lighter-weight than public ones. Swift-evolution thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022354.html Motivation Swift is very concerned with the problem of designing and maintaining libraries. Library authors must take care to avoid making promises to their clients that will turn out to prevent later improvements to the library’s implementation. A programming language can never fully lift this burden, of course, but it can help to limit accidental over-promises by reducing the number of implicit guarantees made by code. This has been a guiding idea throughout the Swift language design. For example, declarations in Swift default to internal access control. This prevents other modules from relying on code that was never meant to be exposed, which would be a common error if the default were public. It also encourages library authors to think more carefully about the interface they’re providing to their clients. During initial development, while (say) a method’s signature is still in flux, it can be left internal without limiting the programmer’s ability to use and test it. When it comes time to prepare a public interface, the explicit act of adding public to the method serves as a gentle nudge to think twice about the method’s name and type. In contrast, if the method had to be made public much earlier in development just to be able to use or test it, it would be much more likely to slip through the cracks with an unsatisfactory signature. Method overriding is a very flexible programming technique, but it poses a number of problems for library design. A subclass that overrides methods of its superclass is intricately intertwined with it. The two systems are not composed, and their behavior cannot be understood independently. For example, a programmer who changes how methods on a class delegate to each other is very likely to break subclasses that override those methods, as such subclasses can often only be written by observing the existing pattern of behavior. Within a single module, this can be tolerable, but across library boundaries it’s very problematic unless the superclass has established firm rules from the beginning. It has frequently been observed that designing a class well for subclassing takes far more effort than just designing it for ordinary use, precisely because these rules of delegation do need to be carefully laid out if independently-designed subclasses are going to have any chance of working. Moreover, while subclassing is a temptingly simple manner of allowing customization, it is also inherently limiting. Subclasses cannot be independently tested using a mocked implementation of the superclass or composed to apply the customizations of two different subclasses to a single instance. Again, within a single module, where the superclass and subclasses are co-designed, these problems are more manageable: testing both systems in conjunction is more reasonable, and the divergent customizations can be merged into a single subclass. But across library boundaries, they become major hindrances. Swift is committed to supporting subclassing and overriding. But it makes sense to be conservative about the promises that a class interface makes merely by being public, and it makes sense to give library authors strong tools for managing the overridability of their classes, and it makes sense to encourage programmers to think more carefully about overridability when they lift it into the external interface of a library, where these problems become most apparent. Furthermore, the things that make overriding such a powerful and flexible tool for programmers also have a noticeable, negative impact on performance. Swift is a statically (not JIT) compiled language. It is also a high-level language with a number of intrinsic features that simplify and generalize the programming model and/or improve the safety and security of programming in Swift. These features have costs, but the language has typically been carefully designed to make those costs amenable to optimization. The Swift core team believes that it is important for the success of Swift as a language that programmers not be regularly required to abandon safety or (worse) drop down to a completely different language just to meet their performance goals. That is most at risk when there are flat-line inefficiencies in simply executing code, and so we believe that it is crucial to remain vigilant against pervasive abstraction penalties. Therefore, while dynamic features will always have a place in Swift, the language must always retain some ability to statically optimize them in the default case and without explicit user intervention. And the costs of unrestricted overriding are quite real. The vast majority of class methods are never actually overridden, which means they can be trivially devirtualized. Devirtualization is a very valuable optimization in its own right, but it is even more important as an enabling optimization that allows the compiler to reason about the behavior of the caller and callee together, permitting it to further specialize and optimize both. Making room for subclassing and overrides also requires a great deal more supporting code and metadata, which hurts binary sizes, launch times, memory usage, and just general speed of execution. Finally, it is a goal of Swift’s language and performance design that costs be “progressively disclosed”. Simple code that needs fewer special guarantees should perform better and require less boilerplate. If a programmer merely wants to make a class available for public use, that should not force excess annotations and performance penalties just from the sudden possibility of public subclassing. Proposed design Introduce a new access modifier, open (other spellings are discussed in the Alternatives section below). As usual, this access modifier is exclusive with the other access modifiers; it is not permitted to write something like public open. open is a context-sensitive keyword; there are no restrictions on using or creating declarations with the name open. open is not permitted on arbitrary declarations. Only the specific declarations mentioned here may be open. For the purposes of interpreting existing language rules, open is a higher (more permissive) access level above public. For example, the true access level of a type member is computed as the minimum of the true access level of the type and the declared access level of the member. If the class is public but the member is open, the true access level is public. As an exception to this rule, the true access level of an open class that is a member of an public type is open. Similarly, rules which grant access to public declarations should generally be interpreted as granting access to both public and open declarations. open classes A class may be declared open. A class is invalid if its superclass is declared outside of the current module and that superclass’s access level is not open. An open class may not also be declared final. The superclass of an open class must be open. This is consistent with the existing access rule for superclasses. It may be desirable to lift this restriction in a future proposal. open class members An overridable class member may be declared open. Overridable class members include properties, subscripts, and methods. A class member that overrides a member of its superclass is invalid if the member is declared outside of the current module and that superclass member’s access level is not open. (Note that dynamic members should generally be declared open rather than public, but this is not a requirement, and the compiler will enforce what is actually declared.) A class member that is explicitly declared open may not also be explicitly declared final. This restriction applies even if the method’s true access level is lower than open because of the restricted access level of its class. The existing rules specify that a class member that overrides a member of its superclass must have an access level that is at least the minimum of its class’s access level and the overridden member’s access level. Therefore, if the class is open, and the superclass method is open, the override must also be declared open. As a special case, an override that would otherwise be required to be declared open may instead be declared public if it is final or a member of a final class. An open class member that is inherited from a superclass is still considered open in the subclass unless the class is final. Note that a class member may be explicitly declared open even if its class is not open or even public. This is consistent with the resolution of SE-0025, in which it was decided that public members should be allowed within types with lower access (but with no additional effect). The member overridden by an open member does not itself need to be open. This is consistent with the existing access rule for members, which does not even require the overridden member to be public. Initializers do not participate in open checking; they cannot be declared open, and there are no restrictions on providing an initializer that has the same signature as an initializer in the superclass. This is true even of required initializers. A class’s initializers provide an interface for constructing instances of that class that is logically distinct from the interface of its superclass, even when signatures happen to match and there are well-understood patterns of delegation. Constructing an object of a subclass necessarily involves running code associated with that subclass, and there is no value in arbitrarily restricting what initializers the subclass may declare. Other considerations Objective-C classes and methods are always imported as open. This means that the synthesized header for an Objective-C class would pervasively replace public with open in its interface. The @testable design states that tests have the extra access permissions of the modules that they import for testing. Accordingly, this proposal does not change the fact that tests are allowed to subclass non-final internal and public classes and override non-final internal and public methods from the modules that they @testable import. Code examples /// ModuleA: // This class is not subclassable outside of ModuleA. public class NonSubclassableParentClass { // This method is not overridable outside of ModuleA. public func foo() {} // This method is not overridable outside of ModuleA because // its class restricts its access level. // It is not invalid to declare it as `open`. open func bar() {} // The behavior of `final` methods remains unchanged. public final func baz() {} } // This class is subclassable both inside and outside of ModuleA. open class SubclassableParentClass { // This property is not overridable outside of ModuleA. public var size : Int // This method is not overridable outside of ModuleA. public func foo() {} // This method is overridable both inside and outside of ModuleA. open func bar() {} /// The behavior of a `final` method remains unchanged. public final func baz() {} } /// The behavior of `final` classes remains unchanged. public final class FinalClass { } /// ModuleB: import ModuleA // This is invalid because the superclass is defined outside // of the current module but is not `open`. class SubclassA : NonSubclassableParentClass { } // This is allowed since the superclass is `open`. class SubclassB : SubclassableParentClass { // This is invalid because it overrides a method that is // defined outside of the current module but is not `open&#39;. override func foo() { } // This is allowed since the superclass&#39;s method is overridable. // It does not need to be marked `open` because it is defined on // an `internal` class. override func bar() { } } open class SubclassC : SubclassableParentClass { // This is invalid because it overrides an `open` method within // an `open` class but is not declared `open`. override func bar() { } } open class SubclassD : SubclassableParentClass { // This is valid. open override func bar() { } } open class SubclassE : SubclassableParentClass { // This is also valid. public final override func bar() { } } Alternatives An earlier version of this proposal did not make open default to public. That is, you would have to write public open to get the same effect. This would have the benefit of not confusingly conflating open with access control, but it has the very large drawback of making public open significantly less syntactically privileged than public. This raises questions about “defaults” and so on that aren’t really our intent to raise. Instead, we want to promote the idea that open and public are alternatives. Therefore, while the current proposal is still “opinionated” in the sense that it gently encourages the use of public by making it more consistent with other language features, it no longer makes open feel second-class by forcing more boilerplate. This is consistent with how we’ve expressed our opinions on, say, let vs. var: it’s an extremely casual difference with only occasional enforced use of the former. open could be legal only on class members. Classes would remain subclassable outside of the current module unless explicitly made final. This would prevent the creation of “sealed” class hierarchies because allowing subclassing would always allow public subclassing. It is also inconsistent with the general principle that restrictions on future evolution be opt-in because it would not be legal to make a class final. (Note that it is not legal to make a final class non-final in a future release.) It also has grave conceptual problems with inherited open members of the superclass. open on classes could be interpreted as granting the right to override members. A public class would be subclassable, but none of its members would be overridable, including inherited members. That is, a public class could be used as a compositional superclass, useful for adding new storage to an existing identity but not for messing with its invariants. This would prevent the creation of sealed hierarchies and is inconsistent with the general principle that restrictons on future evolution should be opt-in. Authors would have no ability to reserve the right to decide later whether to allow subclasses; declaring something final is irrevocable. This could be added in a future extension, but it is not the right rule for public. open could be split into different modifiers for classes and methods. An earlier version of this proposal used subclassable and overridable. These keywords are self-explanatory but visually heavyweight. They also imply too much: it seems odd that a non-subclassable class can be subclassed from inside a module, but we are not proposing to make classes and methods final by default. Classes and methods could be inferred as final by default. This would avoid using different default rules inside and outside of the defining module. However, it is analogous to Swift defaulting to private instead of internal. It penalizes code that’s only being used inside an application or library by forcing the developer to micromanage access. The cost of getting something wrong within a module is very low, since it is easy to fix all of the clients. Inherited methods could be made non-open by default. This would arguably be more consistent with the principle of carefully considering the overridable interface of a class, but it would create an enormous annotation and maintenance burden by forcing the entire overridable interface to be restated at every level in the class hierarchy. Overrides could be made non-open by default. However, it would be very difficult to justify this given that inherited methods stay open. Because open now implies public, the burden of asking the user to explicit about final vs. open now seems completely reasonable. Other proposals that have been considered: public(open), which seems visually cluttered public extensible, which is somewhat heavyweight and invites confusion within extension We may want to reconsider the need for final in the light of this change. Impact on existing code This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open. It is likely that we will want the migrator to convert existing code to use open for classes and methods. Related work The fragile modifier in the Swift 4 resilience design is very similar to this, and will follow the precedent set by these keywords.",
    "url": "http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html",
    "relUrl": "/docs/2019-08-26-0117-non-public-subclassable-by-default.html"
  },
  "117": {
    "id": "117",
    "title": "SE-0118 Closure Parameter Names and Labels",
    "content": "Closure Parameter Names and Labels Proposal: SE-0118 Authors: Dave Abrahams, Dmitri Gribenko, Maxim Moiseev Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-2072 Revision History v1 (as proposed) v2: fixed spelling of identifiers containing Utf8 to read UTF8 per convention. Introduction We propose a revision to the names and argument labels of closure parameters in standard library APIs. Swift-evolution thread: Take 2: Stdlib closure argument labels and parameter names Discussion of earlier revision of the proposal: Stdlib closure argument labels and parameter names Motivation The names and argument labels of the standard library’s closure parameters have been chosen haphazardly, resulting in documentation comments that are inconsistent and often read poorly, and in code completion/documentation that is less helpful than it might be. Because of trailing closure syntax, the choice of argument labels for closures has less impact on use-sites than it might otherwise, but there are many contexts in which labels still do appear, and poorly-chosen labels still hurt readability. Proposed Solution The table below summarizes how this proposal changes usage of the APIs in question. Before After s.withUTF8Buffer(invoke: processBytes) s.withUTF8Buffer(processBytes) lines.split(  isSeparator: isAllWhitespace) lines.split(  whereSeparator: isAllWhitespace) words.sort(isOrderedBefore: &gt;) words.sort(by: &gt;) words.sorted(isOrderedBefore: &gt;) words.sorted(by: &gt;) smallest = shapes.min(  isOrderedBefore: haveIncreasingSize) smallest = shapes.min(  by: haveIncreasingSize) largest = shapes.max(  isOrderedBefore: haveIncreasingSize) largest = shapes.max(  by: haveIncreasingSize) if a.lexicographicallyPrecedes(  b,  isOrderedBefore: haveIncreasingWeight) if a.lexicographicallyPrecedes(  b, by: haveIncreasingWeight) ManagedBuffer&lt;Header,Element&gt;.create(  minimumCapacity: 10,  initialValue: makeHeader) ManagedBuffer&lt;Header,Element&gt;.create(  minimumCapacity: 10,  makingValueWith: makeHeader) if roots.contains(isPrime) { if roots.contains(where: isPrime) { if expected.elementsEqual(  actual, isEquivalent: haveSameValue) if expected.elementsEqual(  actual, by: haveSameValue) if names.starts(  with: myFamily,  isEquivalent: areSameExceptForCase) { if names.starts(  with: myFamily,  by: areSameExceptForCase) { let sum = measurements.reduce(0, combine: +) let sum = measurements.reduce(0, +) UTF8.encode(  scalar, sendingOutputTo: accumulateByte) UTF8.encode(  scalar, into: accumulateByte) Note: this summary does not illustrate parameter name changes that have also been made pervasively and have an effect on usability of documentation and code completion. Please see the diffs for examples of those. Detailed design A complete patch, showing API, documentation, and usage changes, is available for review at https://github.com/apple/swift/pull/2981/files. Impact on existing code This change will break code that depends on the current argument labels. Availability annotations can be used make correcting this breakage a normal part of the migration process. Alternatives considered The initial proposal used much more-verbose labels that were designed to be very explicit about the required semantics of the closure parameters. That information, however, is mostly useful to the author of the call, and, we found, didn’t do much to enhance readability at the point of use. Future Extensions (Out of Scope) The process of making these changes revealed that there are compelling arguments for diverging from terms-of-art for the standard functional methods. For example, the polarity of the argument to filter would be crystal clear if it were renamed to where, and the description of the semantics of reduce in the documentation strongly suggest that accumulated might be an improvement. Changing the names of these methods should be considered in a separate proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html",
    "relUrl": "/docs/2019-08-26-0118-closure-parameter-names-and-labels.html"
  },
  "118": {
    "id": "118",
    "title": "SE-0119 Remove access modifiers from extensions",
    "content": "Remove access modifiers from extensions Proposal: SE-0119 Author: Adrian Zubarev Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction One great goal for Swift 3 is to sort out any source breaking language changes. This proposal aims to fix access modifier inconsistency on extensions compared to other scope declarations types. Swift-evolution thread: [Proposal] Revising access modifiers on extensions Motivation The access control of classes, enums and structs in Swift is very easy to learn and memorize. It also disallows to suppress the access modifier of implemented conformance members to lower access modifier if the host type has an access modifier of higher or equal level. `public` &gt; `internal` &gt; `fileprivate` &gt;= `private` public class A { public func foo() {} } public class B : A { // `foo` must retain `public` override public func foo() {} } However in Swift it is possible to grant more visibility to a member but still hide the conformance to a protocol. internal protocol C { func foo() } public struct D : C { // `foo` can be either `internal` or `public` public func foo() {} } The imported module will look like this: public struct D { public func foo() } This simple access control model also allows us to nest types inside each other to create a really nice type hierarchy. Extensions however behave differently when it comes to their access control: The access modifier of an extension sets the default modifier of its members which do not have their own localy defined modifier. public struct D {} // The extension itself has also `private` visibility private extension D { // `foo` is implicitly `private` func foo() {} } Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private. Source: The Swift Programming Language private struct E {} extension E { // `foo` is implicitly `private` func foo() {} } The access modifier can be overridden by the member with a lower access modifier. public struct F {} internal extension F { // `foo` can be `internal`, `fileprivate` or `private` private func foo() {} } Furthermore in Swift 2.2 it is not allowed to apply an access modifier on extensions when a type inheritance clause is present: public protocol SomeProtocol {} // &#39;public&#39; modifier cannot be used with // extensions that declare protocol conformances public extension A : SomeProtocol {} Extensions are also used for protocol default implementations in respect to the mentioned rules. That means that if someone would want to provide a public default implementation for a specific protocol there are three different ways to achieve this goal: public protocol G { func foo() } First way: extension G { public func foo() { /* implement */ } } Second way: public extension G { func foo() { /* implement */ } } Third way: public extension G { public func foo() { /* implement */ } } Any version will currently be imported as: public protocol G { func foo() } extension G { public func foo() } I propose to revise the access control on extensions by removing access modifiers from extensions. That way, access for members follows the same defaults as in the original type. Jordan Rose It would be possible to conform types to a protocol using an extension which has an explicit access modifier. The access modifier respects the modifier of the extended type and the protocol to which it should be conformed. internal protocol H { func foo() } public protocol I { func boo() } public struct J {} public extension J : H { // We can grant `foo` visibility but still hide conformance to `H` // and move everything from `H` to an extra extension bag public func foo() {} // Access modifier on members won&#39;t be overridden by the extension access modifier anymore // And they will respect the access level boundary set by the extension func moo() {} } // The extension of `J` conforming to `I` must retain `public` public extension J : I { // `boo` must retain `public` public func boo() {} } The above extension can be simplified to: // The extension must retain `public` because `J` and `I` are marked as `public` public extension J : H, I { // `foo` can be either `public` or `internal` public func foo() {} // Implicitly `internal` func moo() {} // `boo` must retain `public` public func boo() {} } The right and only one version for public protocol default implementations will look like this: public extension G { public func foo() { /* implement */ } } Removing this behavior would imply less need to learn different behaviors for access control in general. From a future perspective one could allow Swift to have nested extensions (which is neither part nor a strong argument of this proposal). internal protocol K {} public struct L { public struct M {} /* implicitly internal */ extension M : K {} } // Nested extension would remove this: /* internal */ extension L.M : K {} The ability of setting the default modifier could be reintroduces in its own typeless scope design, which might look like this: fileprivate extension Int { // Not visible outside this extension bag private func doSomething() -&gt; Int { ... } fileprivate group { // Every group memebr is `fileprivate` func member1() {} func member2() {} func member3() {} func member4() {} func member5() {} } } Such a mechanism could also be used outside extensions! This idea has its own discussion thread. Proposed solution Remove access modifier from extensions to stop being able to set the default access modifier. Allow access modifier when type-inheritance-clause is present. Access modifier on extensions should respect the modifier of the extended type and the protocol to which it should conform. Public protocol: public type + public protocol = public extension internal type + public protocol = internal extension private type + public protocol = private extension Internal protocol: public type + internal protocol = public extension or internal extension internal type + internal protocol = internal extension private type + internal protocol = private extension Private protocol: public type + private protocol = public extension or internal extension or private extension internal type + private protocol = internal extension or private extension private type + private protocol = private extension Multiple protocol conformance is decided analogously by using the highest access modifier from all protocols + the access level of the extended type. The current grammar will not change: extension-declaration → access-level-modifieropt extension type-identifier type-inheritance-clauseopt extension-body extension-declaration → access-level-modifieropt extension type-identifier requirement-clause extension-body extension-body → { declarationsopt } Iff the access-level-modifier is not present, the access modifier on extensions should always be implicitly internal. Impact on public APIs (imported version): - extension SomeType : SomeProtocol { + public extension SomeType : SomeProtocol { public func someMemeber() } Impact on existing code This is a source-breaking change that can be automated by a migrator. Extensions without an explicit access modifier: //===--===// //===-- public type --===// //===--===// public struct AA {} - extension AA { + public extension AA { func member1() {} public func member2() {} private func member3() {} } //===--===// //===- internal type -===// //===--===// internal struct BB {} // No impact at all because it is already // implicitly `internal` extension BB { func member1() {} private func member2() {} } //===--===// //===- private type --===// //===--===// private struct CC {} - extension CC { + private extension CC { // Implicitly private func member1() {} private func member2() {} } Extensions with an explicit access modifier: //===--===// //===-- public type --===// //===--===// public struct DD {} public extension DD { - func member1() {} + public func member1() {} public func member2() {} private func member3() {} internal func member4() {} } internal extension DD { func member5() {} private func member6() {} internal func member7() {} } private extension DD { // Implicitly private func member8() {} private func member9() {} } //===--===// //===- internal type -===// //===--===// internal struct EE {} internal extension EE { func member1() {} private func member2() {} internal func member3() {} } private extension EE { // Implicitly private func member4() {} private func member5() {} } //===--===// //===- private type --===// //===--===// private struct FF {} private extension FF { // Implicitly private func member1() {} private func member2() {} } Extensions without an explicit access modifier and protocol conformance: public protocol Foo { func foo() } internal protocol Boo { func boo() } private protocol Zoo { func zoo() } //===--===// //===-- public type --===// //===--===// public struct GG {} - extension GG : Foo, Boo, Zoo { + public extension GG : Foo, Boo, Zoo { func member1() {} public func member2() {} private func member3() {} // Access modifier for `foo`, `boo` and `zoo` // won&#39;t have an impact } //===--===// //===- internal type -===// //===--===// internal struct HH {} // No impact at all because it is already // implicitly `internal` extension BB : Foo, Boo, Zoo { func member1() {} private func member2() {} // Access modifier for `foo`, `boo` and `zoo` // won&#39;t have an impact } //===--===// //===- private type --===// //===--===// private struct II {} - extension CC : Foo, Boo, Zoo { + private extension CC : Foo, Boo, Zoo { // Implicitly private func member1() {} private func member2() {} // Access modifier for `foo`, `boo` and `zoo` // won&#39;t have an impact (all are private) } Alternatives considered Allow access modifier when type-inheritance-clause is present and use the rules presented in Proposed solution.",
    "url": "http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html",
    "relUrl": "/docs/2019-08-26-0119-extensions-access-modifiers.html"
  },
  "119": {
    "id": "119",
    "title": "SE-0120 Revise `partition` Method Signature",
    "content": "Revise partition Method Signature Proposal: SE-0120 Authors: Lorenzo Racca, Jeff Hajewski, Nate Cook Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1965 Previous Revision: 1 Introduction This proposal revises the signature for the collection partition algorithm. Partitioning is a foundational API for sorting and for searching through sorted collections. Swift-evolution thread: Feedback from standard library team Swift Bug: SR-1965 Motivation Based on feedback during the review of proposal SE-0074, Implementation of Binary Search Functions and the list of open issues affecting standard library API stability, this is a revised proposal focused only on the existing collection partition method. The standard library’s current partition methods, which partition a mutable collection using a binary predicate based on the value of the first element of a collection, are used by the standard library’s sorting algorithm but don’t offer more general partitioning functionality. A more general partition algorithm using a unary (single-argument) predicate would be more flexible and generally useful. Proposed solution The standard library should replace the two existing partition methods with a single method taking a unary predicate called partition(by:). partition(by:) rearranges the elements of the collection according to the predicate, such that after partitioning there is a pivot index p where no element before p satisfies the predicate and every element at and after p does satisfy the predicate. var n = [30, 40, 20, 30, 30, 60, 10] let p = n.partition(by: { $0 &gt; 30 }) // n == [30, 10, 20, 30, 30, 60, 40] // p == 5 After partitioning is complete, the predicate returns false for every element in n.prefix(upTo: p) and true for every element in n.suffix(from: p). Detailed design partition(by:) should be added as a MutableCollection requirement with default implementations for mutable and bidirectional mutable collections. Any mutable collection can be partitioned, but the bidirectional algorithm generally performs far fewer assignments. The proposed APIs are collected here: protocol MutableCollection { // existing requirements /// Reorders the elements of the collection such that all the elements /// that match the given predicate are after all the elements that do /// not match the predicate. /// /// After partitioning a collection, there is a pivot index `p` where /// no element before `p` satisfies the `belongsInSecondPartition` /// predicate and every element at or after `p` satisfies /// `belongsInSecondPartition`. /// /// In the following example, an array of numbers is partitioned by a /// predicate that matches elements greater than 30. /// /// var numbers = [30, 40, 20, 30, 30, 60, 10] /// let p = numbers.partition(by: { $0 &gt; 30 }) /// // p == 5 /// // numbers == [30, 10, 20, 30, 30, 60, 40] /// /// The `numbers` array is now arranged in two partitions. The first /// partition, `numbers.prefix(upTo: p)`, is made up of the elements that /// are not greater than 30. The second partition, `numbers.suffix(from: p)`, /// is made up of the elements that *are* greater than 30. /// /// let first = numbers.prefix(upTo: p) /// // first == [30, 10, 20, 30, 30] /// let second = numbers.suffix(from: p) /// // second == [60, 40] /// /// - Parameter belongsInSecondPartition: A predicate used to partition /// the collection. All elements satisfying this predicate are ordered /// after all elements not satisfying it. /// - Returns: The index of the first element in the reordered collection /// that matches `belongsInSecondPartition`. If no elements in the /// collection match `belongsInSecondPartition`, the returned index is /// equal to the collection&#39;s `endIndex`. /// /// - Complexity: O(n) mutating func partition( by belongsInSecondPartition: @noescape (Iterator.Element) throws-&gt; Bool ) rethrows -&gt; Index } extension MutableCollection { mutating func partition( by belongsInSecondPartition: @noescape (Iterator.Element) throws-&gt; Bool ) rethrows -&gt; Index } extension MutableCollection where Self: BidirectionalCollection { mutating func partition( by belongsInSecondPartition: @noescape (Iterator.Element) throws-&gt; Bool ) rethrows -&gt; Index } A full implementation of the two default implementations can be found in this gist. Impact on existing code A thorough, though not exhaustive, search of GitHub for the existing partition method found no real evidence of its use. The evident uses of a partition method were mainly either tests from the Swift project or third-party implementations similar to the one proposed. Any existing uses of the existing partition methods could be flagged or replaced programmatically. The replacement code, on a mutable collection c, finding the pivot p: // old let p = c.partition() // new let p = c.first.flatMap({ first in c.partition(by: { $0 &gt;= first }) }) ?? c.startIndex Alternatives considered To more closely match the existing API, the partition(by:) method could be added only as a default implementation for mutable bidirectional collections. This would unnecessarily limit access to the algorithm for mutable forward collections. The external parameter label could be where instead of by. However, using where implies that the method finds a pre-existing partition point within in the collection (as in index(where:)), rather than modifying the collection to be partitioned by the predicate (as in sort(by:), assuming SE-0118 is accepted).",
    "url": "http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html",
    "relUrl": "/docs/2019-08-26-0120-revise-partition-method.html"
  },
  "120": {
    "id": "120",
    "title": "SE-0121 Remove `Optional` Comparison Operators",
    "content": "Remove Optional Comparison Operators Proposal: SE-0121 Author: Jacob Bandes-Storch Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#3637 Introduction Swift’s Comparable protocol requires 4 operators, &lt;, &lt;=, &gt;, and &gt;=, beyond the requirements of Equatable. The standard library additionally defines the following 4 variants, which accept operands of Optional type, with the semantics that .none &lt; .some(_): public func &lt; &lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool public func &gt; &lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool public func &lt;= &lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool public func &gt;= &lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool This proposal removes the above 4 functions. swift-evolution discussion threads: Optional comparison operators Possible bug with arithmetic optional comparison ? ? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs Motivation These optional-friendly comparison operators exist to provide an ordering between optional and non-optional values of the same (Comparable) type. Ostensibly such a feature would be useful in generic programming, allowing algorithms written for Comparable values to be used with optionals: [3, nil, 1, 2].sorted() // returns [nil, 1, 2, 3] However, this doesn’t work in current versions of Swift, because generics don’t support conditional conformances like extension Optional: Comparable where Wrapped: Comparable, so Optional is not actually Comparable. The most common uses of these operators involve coercion or promotion from non-optional to optional types, such as: let a: Int? = 4 let b: Int = 5 a &lt; b // b is coerced from &quot;Int&quot; to &quot;Int?&quot; to match the parameter type. SE-0123 seeks to remove this coercion (for arguments to operators) for a variety of reasons. If the coercion is not removed (if no change is made), the results of comparisons with Optional values are sometimes surprising, making it easy to write bugs. In a thread from December 2015, Al Skipp offers the following example: struct Pet { let age: Int } struct Person { let name: String let pet: Pet? } let peeps = [ Person(name: &quot;Fred&quot;, pet: Pet(age: 5)), Person(name: &quot;Jill&quot;, pet: .None), // no pet here Person(name: &quot;Burt&quot;, pet: Pet(age: 10)), ] let ps = peeps.filter { $0.pet?.age &lt; 6 } ps == [Fred, Jill] // if you don’t own a pet, your non-existent pet is considered to be younger than any actual pet 🐶 On the other hand, if coercion is removed for operator arguments, callers will be required to explicitly handle mixtures of optional and non-optional values in their code, which reduces the “surprise factor”: let a: Int? = 4 let b: Int = 5 a &lt; b // no longer works a &lt; .some(b) // works a &lt; Optional(b) // works In either case, what remains is to decide whether these semantics (that nil is “less than” any non-nil value) are actually useful and worth keeping. Until generics are more mature, the issue of Optional being conditionally Comparable can’t be fully discussed/implemented, so it makes the most sense to remove these questionably-useful operators for now (a breaking change for Swift 3), and add them back in the future if desired. Proposed solution Remove the versions of &lt;, &lt;=, &gt;, and &gt;= which accept optional operands. Variants of == and != which accept optional operands are still useful, and their results unsurprising, so they will remain. (In the future, once it is possible for Optional to conditionally conform to Comparable, it may make sense to reintroduce these operators by adding such a conformance.) Impact on existing code Code which compares optional values: let a: Int? let b: Int if a &lt; b { ... } // if coercion remains if a &lt; .some(b) { ... } // if coercion is removed will need to be updated to explicitly unwrap the values before comparing: if let a = a where a &lt; b { ... } // or guard let a = a else { ... } if a &lt; b { ... } // or if a! &lt; b { ... } This impact is potentially severe, however it may reveal previously-subtle bugs in user code. (The severity will also be somewhat mitigated if optional coercion is removed, since those changes will affect all the same call sites.) Fix-it hints for adding ! are already provided when optional values are passed to non-optional parameters. However, this would significantly change the meaning of user code: a! &lt; b may trap where a &lt; b would have previously returned false. At the core team’s discretion, deprecating the functions (with a helpful message) before removing them may be the best course of action. Alternatives considered The alternative is to keep these operators as they are. As discussed above, this leaves the potential for surprising results, and the fact remains that removing them after Swift 3 would break source stability (while reintroducing them later would be purely additive).",
    "url": "http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html",
    "relUrl": "/docs/2019-08-26-0121-remove-optional-comparison-operators.html"
  },
  "121": {
    "id": "121",
    "title": "SE-0122 Use colons for subscript declarations",
    "content": "Use colons for subscript declarations Proposal: SE-0122 Author: James Froggatt Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction Currently, subscript declarations follow the following model: subscript(externalName internalName: ParamType) -&gt; ElementType { get { … } set { … } } The initial keyword subscript is followed by a parameter list, followed by an arrow to the accessed type. This proposal is to replace the arrow with a colon, to match accessor declarations elsewhere in the language. Swift-evolution thread: Discussion thread topic for that proposal Motivation The arrow, borrowed from function syntax, is very much out of place in this context, and so can act as a mental stumbling block. It is also misleading, as it implies that subscripts have the full capabilities of functions, such as the ability to throw. If throwing functionality were to be added to accessors, it is likely the specific get/set accessor would be annotated. In this case, the effects on a subscript’s ‘function signature’ could become a source of confusion. Subscripts act like parameterised property accessors. This means, like a property, they can appear on the left hand side of an assignment, and values accessed through subscripts can be mutated in-place. The colon has precedent in declaring this kind of construct, so it makes sense to reuse it here. Proposed solution A simple replacement of -&gt; with : in the declaration syntax. Detailed design This would change the above example to look like the following: subscript(externalName internalName: ParamType) : ElementType { get { … } set { … } } Impact on existing code Existing code would have to update subscripts to use a colon. This can be automated in a conversion to Swift 3 syntax. Potential hazards The Swift core team has previously implemented this change internally, but rejected it due to reduced readability. This is something to bear in mind when considering this proposal. The effect largely depends on coding style, which can match either of the following: subscript(_ example: Type) : ElementType subscript(_ example: Type): ElementType This issue is most apparent in the latter example, which omits the leading space before the colon, as the colon blends into the closing bracket. However, the real-world effect of this change is hard to predict, and subscript declarations are rare enough that the consequences of this change are very limited. Alternatives considered We could leave the syntax as it is, or use an alternative symbol, such as :-&gt; or &lt;-&gt;. We could also leave open the possibility of expanding function syntax with inout -&gt;. Colons were chosen for this proposal because they have precedent elsewhere in the language, and are already reserved syntax. Future directions This parameterised accessor syntax could be expanded in a future version of Swift, to support named accessors. This could look something like the following: var image(for state: UIControlState) : UIImage? { get { … } set { … } } button.image(for: .normal) = image",
    "url": "http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html",
    "relUrl": "/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html"
  },
  "122": {
    "id": "122",
    "title": "SE-0123 Disallow coercion to optionals in operator arguments",
    "content": "Disallow coercion to optionals in operator arguments Proposal: SE-0123 Authors: Mark Lacey, Doug Gregor, Jacob Bandes-Storch Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction Swift provides optional types as a means of achieving safety by making the notion of “having” or “not having” a value explicit. This requires programmers to explicitly test whether a variable has a value or not prior to using that value, with the affordance that a user can explicitly force-unwrap the optional if desired (with the semantics that the process will trap if the optional does not have a value). As a convenience to make optionals easier to use, Swift provides syntactic sugar for declaring and using them (for example, T? to declare an Optional&lt;T&gt;). As another convenience, Swift provides coercion of non-optional types to optional types, making it possible to write code like this: func consumesOptional(value: Int?) -&gt; Int { ... } let x: Int = 1 let y = consumesOptional(value: x) or code like this: func returnsOptional() -&gt; Int? { let x: Int = ... return x } Note that we are passing an Int to consumesOptional, despite the fact that it is declared to accept Int?, and we are returning an Int from returnsOptional despite the fact that it is declared to return Int?. This coercion happens for normal function calls, the assignment statement, and for operators defined with optional parameter types, e.g. the comparison operators and the nil-coalescing operator (??). Swift-evolution thread: Optional comparison operators Proposal Disallow the coercion from values to optionals in the context of arguments to operators. Add mixed-optionality versions of the equality operators for Equatable types, and identity operators for AnyObject. Motivation The convenience of coercing values to optionals is very nice in the context of normal function calls, but in the context of operators, it can lead to some strange and unexpected behavior. For example this compiles without error and prints true when executed: let x = -1 let y: Int? = nil print(y &lt; x) // true Similarly, the following compiles without error and prints 1, despite the fact that the argument to the left of the ?? is a non-optional value: let z = 1 print(z ?? 7) Both of these examples represent cases where the silent behavior could potentially hide bugs or confuse readers of the code, and where we should instead reject the code as a type error. For example in the first case the fact that y was not unwrapped could be a bug that is missed in a larger body of code where the declaration of y occurs farther away from the use. Likewise, a reader of the second example might be under the impression that z is an optional if the use of z is actually farther from the declaration. It may also be that the author of the code intended to make z optional and add code that assigns to z in ways that result in nil, but forgot to add that code. The type checker currently has a hack to diagnose comparing nil to non-optional values, but this hack only works for literal nil. This proposal will not affect the existing coercion used for implicitly unwrapped optionals, so for example the following code will continue to work: let x: Int! = 5 let y: Int? = 7 print(x &lt; y) // true It will also not affect coercion in the context of the assignment statement, so this will also continue to work: let b: Bool = ... var v: Int? if b { v = nil } else { v = 7 } Furthermore, this proposal introduces variants of the equality (==, !=) and identity (===, !==) operators that accept arguments of mixed optionality, allowing code like this to continue to work: let x: Int? = 2 let y: Int = 3 if x == y { ... } let dict: [String: Int] if dict[&quot;key&quot;] == y { ... } Detailed design The type checker needs to be updated to remove the current nil-literal hack and replace it with code to explicitly disable the coercion in operator argument contexts. In Optional.swift, we need to add these overloads: public func == &lt;T: Equatable&gt;(lhs: T?, rhs: T) -&gt; Bool public func == &lt;T: Equatable&gt;(lhs: T, rhs: T?) -&gt; Bool public func != &lt;T: Equatable&gt;(lhs: T?, rhs: T) -&gt; Bool public func != &lt;T: Equatable&gt;(lhs: T, rhs: T?) -&gt; Bool In Policy.swift, we need to add these overloads: /// Returns `true` iff `lhs` and `rhs` are references to the same object /// instance (in other words, are identical pointers). /// /// - SeeAlso: `Equatable`, `==` public func === (lhs: AnyObject, rhs: AnyObject) -&gt; Bool public func === (lhs: AnyObject?, rhs: AnyObject) -&gt; Bool public func === (lhs: AnyObject, rhs: AnyObject?) -&gt; Bool /// Returns `true` iff `lhs` and `rhs` are references to different object /// instances (in other words, are different pointers). /// /// - SeeAlso: `Equatable`, `!=` public func !== (lhs: AnyObject, rhs: AnyObject) -&gt; Bool public func !== (lhs: AnyObject?, rhs: AnyObject) -&gt; Bool pubilc func !== (lhs: AnyObject, rhs: AnyObject?) -&gt; Bool In Builtin.swift, we need to add these overloads: /// Returns `true` iff `t0` is identical to `t1`; i.e. if they are both /// `nil` or they both represent the same type. public func == (t0: Any.Type, t1: Any.Type) -&gt; Bool public func == (t0: Any.Type?, t1: Any.Type) -&gt; Bool public func == (t0: Any.Type, t1: Any.Type?) -&gt; Bool /// Returns `false` iff `t0` is identical to `t1`; i.e. if they are both /// `nil` or they both represent the same type. public func != (t0: Any.Type, t1: Any.Type) -&gt; Bool public func != (t0: Any.Type?, t1: Any.Type) -&gt; Bool public func != (t0: Any.Type, t1: Any.Type?) -&gt; Bool One unfortunate consequence of adding these overloads is that equality and identity comparisons of non-optional values to literal nil will now type check, e.g.: let i = 1 if i == nil { // compiles without error print(&quot;should never happen&quot;) } This is consistent behavior from a type-checking perspective, but looks odd in practice. There may be implementation changes we can make to eliminate this behavior. Impact on existing code This is a breaking change for Swift 3. Existing code using ordered comparison operators (&lt;, &lt;=, &gt;, and &gt;=) will need to change to explicitly test optionality (for example via if let), cast to Optional(), or force-unwrap one of the operands being used with an operator. Existing code using the nil-coalescing operator (??) with a non-Optional left-hand side will need to be updated, but the update is trivial: simply remove the use of the operator. Existing code using the equality and identity operators (==, !=, ===, and !==) can remain unchanged. The expectation is that this will result in relatively small impact for most code. For example: if x &lt; y {} // old if let x = x, x &lt; y { // potential fix if you don&#39;t care about x being nil } if x! &lt; y { // another potential fix if you know x is non-nil } In a survey of the following projects, ranging from 2k lines to 21k lines (including whitespace and comments), the following changes were required: Alamofire: No changes. Dollar: No changes. RxSwift: Two removals of ?? due to the left-hand side not being an optional. SwiftyJSON: No changes. swiftpm: One removal of ?? due to the left-hand side not being an optional. One explicit cast to Optional() that looks like it might be due to a type checker bug. There is a prototyped implementation available for review including compiler and standard library modifications (but no test modifications or new tests at this time). Alternatives considered One suggestion was to continue to allow the coercion by default, but add a parameter attribute, @noncoercing, that would disable the coercion for a given parameter and could be used both with operator functions, and non-operator functions.",
    "url": "http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html",
    "relUrl": "/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html"
  },
  "123": {
    "id": "123",
    "title": "SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label",
    "content": "Int.init(ObjectIdentifier) and UInt.init(ObjectIdentifier) should have a bitPattern: label Proposal: SE-0124 Author: Arnold Schwaighofer Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-2064 Introduction Int.init(ObjectIdentifier) and UInt.init(ObjectIdentifier) should have a ‘bitPattern:’ label to make it clear at the use site that we interpret the value as a bit pattern. public func &lt;(lhs: ObjectIdentifier, rhs: ObjectIdentifier) -&gt; Bool { return UInt(bitPattern: lhs) &lt; UInt(bitPattern: rhs) } Swift-evolution thread: Pitch Swift Bug: SR-2064 Branch with change to stdlib: [int_init_objectidentifier_label] (https://github.com/aschwaighofer/swift/tree/int_init_objectidentifier_label) Motivation In Swift we have ObjectIdentifier values which uniquely identify a class instance or metatype. They are implemented as a struct which holds the value of the reference to the instance or metatype as a raw pointer. /// A unique identifier for a class instance or metatype. public struct ObjectIdentifier : Hashable, Comparable { internal let _value: Builtin.RawPointer ... } We have constructors for Int and UInt that capture this value. These constructors don’t have an argument label. extension UInt { /// Create a `UInt` that captures the full value of `objectID`. public init(_ objectID: ObjectIdentifier) { self.init(Builtin.ptrtoint_Word(objectID._value)) } } extension Int { /// Create an `Int` that captures the full value of `objectID`. public init(_ objectID: ObjectIdentifier) { self.init(bitPattern: UInt(objectID)) } } This proposals suggest adding a label bitPattern: to the constructor. extension UInt { /// Create a `UInt` that captures the full value of `objectID`. public init(bitPattern objectID: ObjectIdentifier) { self.init(Builtin.ptrtoint_Word(objectID._value)) } } extension Int { /// Create an `Int` that captures the full value of `objectID`. public init(bitPattern objectID: ObjectIdentifier) { self.init(bitPattern: UInt(objectID)) } } Adding a label bitPattern to the constructors makes it clear that we interpret the pointer value as a bit pattern at the use site. It is similar to what we do in other APIs, for example in UInt(bitPattern: UnsafePointer&lt;Void&gt;(value))). Proposed solution See above. Detailed design We will change the initializers of Int and UInt as shown above. The compiler will suggest corrections in existing code because we mark the old API unavailable. Impact on existing code Existing code will have to add the argument label. Alternatives considered Leave as is. The API will be inconsistent with other APIs such as the UInt(bitPattern: UnsafePointer&lt;T&gt;) API.",
    "url": "http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html",
    "relUrl": "/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html"
  },
  "124": {
    "id": "124",
    "title": "SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`",
    "content": "Remove NonObjectiveCBase and isUniquelyReferenced Proposal: SE-0125 Author: Arnold Schwaighofer Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bug: SR-1962 Introduction Remove NonObjectiveCBase and isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T). isUniquelyReferenced can be replaced by isUniquelyReferencedNonObjC&lt;T: AnyObject&gt;(_ object: T). This replacement is as performant as the call to isUniquelyReferenced in cases where the compiler has static knowledge that the type of object is a native Swift class and dyamically has the same semantics for native swift classes. This change will remove surface API. Rename isUniquelyReferencedNonObjC to isKnownUniquelyReferenced and no longer promise to return false for @objc class instances. Cleanup the ManagedBufferPointer API by renaming holdsUniqueReference to isUniqueReference and removing holdsUniqueOrPinnedReference. Swift-evolution thread: Review Branch with change to stdlib: [remove_nonobjectivecbase_2] (https://github.com/aschwaighofer/swift/commits/remove_nonobjectivecbase_2) Motivation Today we have isUniquelyReferenced which only works on subclasses of NonObjectiveCBase, and we have isUniquelyReferencedNonObjC which also works on @objc classes. class SwiftKlazz : NonObjectiveCBase {} class ObjcKlazz : NSObject {} expectTrue(isUniquelyReferenced(SwiftKlazz())) expectFalse(isUniquelyReferencedNonObjC(ObjcKlazz())) // Would not compile: expectFalse(isUniquelyReferenced(ObjcKlazz())) In most cases we expect developers to be using the ManagedBufferPointer type. In cases where they want to use a custom class they would use isUniquelyReferenced today and can use isUniquelyReferencedNonObjC which will be renamed isKnownUniquelyReferenced in the future. class SwiftKlazz {} expectTrue(isKnownUniquelyReferenced(SwiftKlazz())) Removing isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; will allow us to remove the NonObjectiveCBase class from the standard library thereby further shrinking API surface. Renaming isUniquelyReferencedNonObjC to isKnownUniquelyReferenced makes sense since “NonObjC” makes no sense on platforms without Objective-C interoperability. isKnownUniquelyReferenced will no longer promise to return false for @objc class instances. The intent of this API is to support copy-on-write implementations. Renaming ManagedBufferPointer API holdsUniqueReference to isUniqueReference makes it clearer that is has the same semantics as the isKnownUniquelyReferenced check. We also propose to remove the holdsUniqueOrPinnedReference API because there could not be any uses of it since the pinning API is not public. Proposed solution Remove isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; and remove the NonObjectiveCBase class from the standard library. Clients of the the isUniquelyReferenced API can be migrated to use isUniquelyReferencedNonObjC. In cases – where the type of the object parameter is statically known to be a native non-@objc class – the resulting code will have identical performance characteristics. In fact, the current implementation boils down to the same builtin call. Based on the static type of the object operand the compiler can emit more efficient code when the static type is known to be of a non-@objc class. Rename isUniquelyReferencedNonObjC to isKnownUniquelyReferenced such that the API makes sense on platforms without Objective-C and stop promising to return false for @objc objects. Rename ManagedBufferPointer.holdsUniqueReference to ManagedBufferPointer.isUniqueReference to avoid confusion. Remove ManagedBufferPointer.holdsUniqueOrPinnedReference because there is no public pinning API so having this public API is not necessary. Detailed design Todays APIs that can be used to check uniqueness is the family of isUniquelyReferenced functions. /// Returns `true` iff `object` is a non-`@objc` class instance with /// a single strong reference. /// /// * Does *not* modify `object`; the use of `inout` is an /// implementation artifact. /// * If `object` is an Objective-C class instance, returns `false`. /// * Weak references do not affect the result of this function. /// /// Useful for implementing the copy-on-write optimization for the /// deep storage of value types: /// /// mutating func modifyMe(_ arg: X) { /// if isUniquelyReferencedNonObjC(&amp;myStorage) { /// myStorage.modifyInPlace(arg) /// } /// else { /// myStorage = self.createModified(myStorage, arg) /// } /// } public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T) -&gt; Bool public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T?) -&gt; Bool /// A common base class for classes that need to be non-`@objc`, /// recognizably in the type system. public class NonObjectiveCBase { public init() {} } public func isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;( _ object: inout T ) -&gt; Bool And the somewhat higher level APIs that can be used to model a storage with several elements ManagedBufferPointer. /// Contains a buffer object, and provides access to an instance of /// `Header` and contiguous storage for an arbitrary number of /// `Element` instances stored in that buffer. /// /// For most purposes, the `ManagedBuffer` class works fine for this /// purpose, and can simply be used on its own. However, in cases /// where objects of various different classes must serve as storage, /// `ManagedBufferPointer` is needed. /// /// A valid buffer class is non-`@objc`, with no declared stored /// properties. Its `deinit` must destroy its /// stored `Header` and any constructed `Element`s. /// `Header` and contiguous storage for an arbitrary number of /// `Element` instances stored in that buffer. public struct ManagedBufferPointer&lt;Header, Element&gt; : Equatable { /// Create with new storage containing an initial `Header` and space /// for at least `minimumCapacity` `element`s. /// /// - parameter bufferClass: The class of the object used for storage. /// - parameter minimumCapacity: The minimum number of `Element`s that /// must be able to be stored in the new buffer. /// - parameter initialHeader: A function that produces the initial /// `Header` instance stored in the buffer, given the `buffer` /// object and a function that can be called on it to get the actual /// number of allocated elements. /// /// - Precondition: `minimumCapacity &gt;= 0`, and the type indicated by /// `bufferClass` is a non-`@objc` class with no declared stored /// properties. The `deinit` of `bufferClass` must destroy its /// stored `Header` and any constructed `Element`s. public init( bufferClass: AnyClass, minimumCapacity: Int, initialHeader: @noescape (buffer: AnyObject, capacity: @noescape (AnyObject) -&gt; Int) throws -&gt; Header ) rethrows /// Returns `true` iff `self` holds the only strong reference to its buffer. /// /// See `isUniquelyReferenced` for details. public mutating func holdsUniqueReference() -&gt; Bool /// Returns `true` iff either `self` holds the only strong reference /// to its buffer or the pinned has been &#39;pinned&#39;. /// /// See `isUniquelyReferenced` for details. public mutating func holdsUniqueOrPinnedReference() -&gt; Bool internal var _nativeBuffer: Builtin.NativeObject } /// A class whose instances contain a property of type `Header` and raw /// storage for an array of `Element`, whose size is determined at /// instance creation. public class ManagedBuffer&lt;Header, Element&gt; : ManagedProtoBuffer&lt;Header, Element&gt; { /// Create a new instance of the most-derived class, calling /// `initialHeader` on the partially-constructed object to /// generate an initial `Header`. public final class func create( minimumCapacity: Int, initialHeader: @noescape (ManagedProtoBuffer&lt;Header, Element&gt;) throws -&gt; Header ) rethrows -&gt; ManagedBuffer&lt;Header, Element&gt; { let p = try ManagedBufferPointer&lt;Header, Element&gt;( bufferClass: self, minimumCapacity: minimumCapacity, initialHeader: { buffer, _ in try initialHeader( unsafeDowncast(buffer, to: ManagedProtoBuffer&lt;Header, Element&gt;.self)) }) return unsafeDowncast(p.buffer, to: ManagedBuffer&lt;Header, Element&gt;.self) } } We propose to remove the NonObjectiveCBase class and isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T&gt; and rename isUniquelyReferencedNonObjC to isKnownUniquelyReferenced. Code that was written as the following. class ClientClass : NonObjectiveCBase { } class ClientClass2 : NonObjectiveCBase { } var x: NonObjectiveCBase = pred ? ClientClass() : ClientClass2() if isUniquelyReferenced(x) { ...} Can be changed to the following with exactly the same performance characteristic and semantics. class CommonNonObjectiveCBase {} class ClientClass : CommonNonObjectiveCBase { } class ClientClass2 : CommonNonObjectiveCBase { } var x: CommonNonObjectiveCBase = pred ? ClientClass() : ClientClass2() if isKnownUniquelyReferenced(x) { ...} The new API will be as follows. /// Returns `true` iff `object` is class instance with a single strong /// reference. /// /// * Does *not* modify `object`; the use of `inout` is an /// implementation artifact. /// * Weak references do not affect the result of this function. /// /// Useful for implementing the copy-on-write optimization for the /// deep storage of value types: /// /// mutating func modifyMe(_ arg: X) { /// if isKnownUniquelyReferenced(&amp;myStorage) { /// myStorage.modifyInPlace(arg) /// } /// else { /// myStorage = self.createModified(myStorage, arg) /// } /// } public func isKnownUniquelyReferenced&lt;T : AnyObject&gt;(_ object: inout T) -&gt; Bool public func isKnownUniquelyReferenced&lt;T : AnyObject&gt;(_ object: inout T?) -&gt; Bool /// Contains a buffer object, and provides access to an instance of /// `Header` and contiguous storage for an arbitrary number of /// `Element` instances stored in that buffer. /// /// For most purposes, the `ManagedBuffer` class works fine for this /// purpose, and can simply be used on its own. However, in cases /// where objects of various different classes must serve as storage, /// `ManagedBufferPointer` is needed. /// /// A valid buffer class is non-`@objc`, with no declared stored /// properties. Its `deinit` must destroy its /// stored `Header` and any constructed `Element`s. /// `Header` and contiguous storage for an arbitrary number of /// `Element` instances stored in that buffer. public struct ManagedBufferPointer&lt;Header, Element&gt; : Equatable { /// Create with new storage containing an initial `Header` and space /// for at least `minimumCapacity` `element`s. /// /// - parameter bufferClass: The class of the object used for storage. /// - parameter minimumCapacity: The minimum number of `Element`s that /// must be able to be stored in the new buffer. /// - parameter initialHeader: A function that produces the initial /// `Header` instance stored in the buffer, given the `buffer` /// object and a function that can be called on it to get the actual /// number of allocated elements. /// /// - Precondition: `minimumCapacity &gt;= 0`, and the type indicated by /// `bufferClass` is a non-`@objc` class with no declared stored /// properties. The `deinit` of `bufferClass` must destroy its /// stored `Header` and any constructed `Element`s. public init( bufferClass: AnyClass, minimumCapacity: Int, initialHeader: @noescape (buffer: AnyObject, capacity: @noescape (AnyObject) -&gt; Int) throws -&gt; Header ) rethrows /// Returns `true` iff `self` holds the only strong reference to its buffer. /// /// See `isUniquelyReferenced` for details. public mutating func isUniqueReference() -&gt; Bool } Impact on existing code Existing code that uses isUniquelyReferenced will need to remove the NonObjectiveCBase base class and replace calls to isUniquelyReferenced by isKnownUniquelyReferenced. The old API will be marked unavailable to help migration. Alternatives considered Leave the status quo and pay for type safety with additional API surface. Another alternative we considered – the first version of this proposal – was to replace the isUniquelyReferenced API by an isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;(_ object: T) API that would assume the object to be a non-@objc class and only check this precondition under -Onone. There is however no good reason to keep this API given that the isUniquelyReferencedNonObjC is as performant when the type is statically known to be non-@objc class.",
    "url": "http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html",
    "relUrl": "/docs/2019-08-26-0125-remove-nonobjectivecbase.html"
  },
  "125": {
    "id": "125",
    "title": "SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`",
    "content": "Refactor Metatypes, repurpose T.self and Mirror Proposal: SE-0126 Authors: Adrian Zubarev, Anton Zhilin Review Manager: Chris Lattner Status: Withdrawn Decision Notes: Rationale Introduction This proposal wants to revise metatypes T.Type, repurpose public T.self notation to return a new Type&lt;T&gt; type instance rather than a metatype, merge SE-0101 into Type&lt;T&gt;, rename the global function from SE-0096 to match the changes of this proposal and finally rename current Mirror type to introduce a new (lazy) Mirror type. Swift-evolution threads: [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror [Discussion] Seal T.Type into Type&lt;T&gt; [Discussion] Can we make .Type Hashable? GitHub Gist thread: Refactor metatypes Motivation The following tasks require metatype-like types: Explicit specialization of functions and expressing specific static types. Dynamic dispatch of static methods. Representing any value as a tree, for debug purposes. Retrieving and passing around information about dynamic types - Reflection. Current state of things: [1] is given to metatypes T.Type: The metatype instance is usually ignored. For example, if you pass Derived.self as Base.self into function taking T.Type, it will work with Base. This raises concerns: are metatypes perfectly suited for that purpose? [2] is also given to metatypes T.Type: Because they are used so often, it’s tempting to add useful methods to them, but we can’t, because metatypes are not extensible types. [3] is given to Mirror: Does its name reflect what it’s intended to do? Mirror.DisplayStyle contains optional and set as special cases, but does not contain function at all. Mirror collects all information possible at initialization, while for “true” reflection we want laziness. Mirror allows customization. For example, Array&lt;T&gt; is represented with a field for each of its elements. Do we want this for “true” reflection we want to add in the future? [4] is given to both metatypes T.Type and Mirror: Metatypes are generic. But do we want genericity in reflection? No, we almost always want to cast to Any.Type. Metatypes are used for getting both static and dynamic sizes. In this context, distinction between generic parameter T and value of metatype instance is unclear. People are confused that Mirror is intended to be used for full-featured reflection, while it does not aim for that. Known issues of metatypes: Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context: func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool { return Int.self is T.Type } intConforms(to: CustomStringConvertible.self) //=&gt; FALSE [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self. [2] There isn’t a way to generically expression P.Type yet. [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today. Written by Joe Groff: [1] [2] [3] A possible workaround might look like the example below, but does not allow to decompose P.Type which is a major implementation problem of this proposal: func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool { return Int.self is T } intConforms(to: CustomStringConvertible.Type.self) //=&gt; TRUE This issue was first found and documented as a strange issue in SR-2085. It also raises the concerns: do we need .Protocol at all? We can extend this issue and find the second problem by checking against the metatype of Any: func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool { return Int.self is T } intConforms(to: Any.Type.self) //=&gt; TRUE intConforms(to: Any.self) //=&gt; TRUE As you clearly can see, when using Any the compiler does not require .Type at all. The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem: protocol P {} protocol R : P {} func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool { return R.self is T } rIsSubtype(of: P.Type.self) //=&gt; FALSE We also believe that this issue is also the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type). Proposed solution Metatype&lt;T&gt;: Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around. Introduce a distinction between public and internal T.self notation where the internal T.self notation will be renamed to T.metatype. Rename old metatype T.Type notation to Metatype&lt;T&gt;. Make internal T.metatype notation (builtin - not visible in public Swift) return an instance of Metatype&lt;T&gt;. Public construction of metatypes will look like Type&lt;T&gt;.metatype or T.self.metatype, see below. Metatypes will be used only for dynamic dispatch of static methods, see example below: protocol HasStatic { static func staticMethod() -&gt; String; init() } struct A : HasStatic { static func staticMethod() -&gt; String { return &quot;I am A&quot; }; init() {} } struct B : HasStatic { static func staticMethod() -&gt; String { return &quot;I am B&quot; }; init() {} } func callStatic(_ metatype: Metatype&lt;HasStatic&gt;) { let result = metatype.staticMethod() print(result) let instance = metatype.init() print(instance) } let a = Type&lt;A&gt;.metatype let b = Type&lt;B&gt;.metatype callStatic(a) //=&gt; &quot;I am A&quot; &quot;A()&quot; callStatic(b) //=&gt; &quot;A am B&quot; &quot;B()&quot; Type&lt;T&gt; API: T.self will be repurposed to return ab instance of Type&lt;T&gt; that is declared as follows: public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible { /// Creates an instance that reflects `T`. /// Example: `let type = T.self` public init() /// Returns the contiguous memory footprint of `T`. /// /// Does not include any dynamically-allocated or &quot;remote&quot; storage. /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the /// same regardless of how many stored properties `T` has. public static var size: Int { get } /// Returns the least possible interval between distinct instances of /// `T` in memory. The result is always positive. public static var stride: Int { get } /// Returns the default memory alignment of `T`. public static var alignment: Int { get } /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal. public static var metatype: Metatype&lt;T&gt; { get } /// Returns the contiguous memory footprint of `T`. /// /// Does not include any dynamically-allocated or &quot;remote&quot; storage. /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the /// same regardless of how many stored properties `T` has. public var size: Int { get } /// Returns the least possible interval between distinct instances of /// `T` in memory. The result is always positive. public var stride: Int { get } /// Returns the default memory alignment of `T`. public var alignment: Int { get } /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal. public var metatype: Metatype&lt;T&gt; { get } /// Hash values are not guaranteed to be equal across different executions of /// your program. Do not save hash values to use during a future execution. public var hashValue: Int { get } /// A textual representation of `self`. public var description: String { get } /// A textual representation of `self`, suitable for debugging. public var debugDescription: String { get } } public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool Size of Type&lt;T&gt; struct equals 0. It will be used for generic function specialization: func performWithType(_ type: Type&lt;T&gt;) performWithType(Float.self) metatype(of:) function: The global type(of:) function from SE-0096 will be renamed to metatype(of:) and receive the following declaration: /// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic /// metatype can reflect type `U` where `U : T`. public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt; Mirror API: Rename current Mirror (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable. A completely different Mirror type will be introduced in Swift 3. Mirror wraps metatypes and allows checking subtype relationships at runtime. Mirror contains dynamic versions of size, stride and alignment. Size of Mirror itself is always 8 bytes, because it only needs to store a single metatype. Mirror provides a starting point for adding fully functional (lazy) reflection in the future. public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible { /// Creates an instance of `Mirror`, reflecting type, which is /// reflected by a metatype. public init(_ metatype: Metatype&lt;Any&gt;) /// Creates an instance of `Mirror`, reflecting type `T` public init&lt;T&gt;(_ type: Type&lt;T&gt;) /// Creates an instance of `Mirror`, reflecting /// dynamic metatype of a given instance. public init&lt;T&gt;(reflecting instance: T) /// Returns the contiguous memory footprint of reflected metatype. public var size: Int { get } /// Returns the least possible interval between distinct instances of /// the dynamic type in memory calculated from the reflected dynamic /// metatype. The result is always positive. public var stride: Int { get } /// Returns the minimum memory alignment of the reflected dynamic /// metatype. public var alignment: Int { get } /// Returns an instance of `Metatype&lt;Any&gt;` from reflected dynamic metatype. public var metatype: Metatype&lt;Any&gt; { get } /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`. public func `is`(_ mirror: Mirror) -&gt; Bool { get } /// Checks if type reflected by `self` is a subtype of `T`. public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool { get } /// Checks if type reflected by `self` is a subtype of type reflected by a metatype. public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool { get } /// Hash values are not guaranteed to be equal across different executions of /// your program. Do not save hash values to use during a future execution. public var hashValue: Int { get } /// A textual representation of `self`. public var description: String { get } /// A textual representation of `self`, suitable for debugging. public var debugDescription: String { get } } public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool Summary of metatype-like types: Before T.Type does three things: Specialization of functions. Dynamic dispatch of static methods. Partial reflection using dynamic casts and functions like sizeof, strideof etc. Mirror does two things: It is primarily intended for use in debugging, like PlaygroundQuickLook. With less success, it can be used for reflection. After Type&lt;T&gt; does specialization of functions. Mirror does reflection. Metatype&lt;T&gt; does dynamic dispatch of static methods. DebugRepresentation is used in debugging. Detailed design Possible Implementation: public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible { /// Creates an instance that reflects `T`. /// Example: `let type = T.self` public init() {} /// Returns the contiguous memory footprint of `T`. /// /// Does not include any dynamically-allocated or &quot;remote&quot; storage. /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the /// same regardless of how many stored properties `T` has. public static var size: Int { return _size(of: T.metatype) } /// Returns the least possible interval between distinct instances of /// `T` in memory. The result is always positive. public static var stride: Int { return _stride(of: T.metatype) } /// Returns the default memory alignment of `T`. public static var alignment: Int { return _alignment(of: T.metatype) } /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal. public static var metatype: Metatype&lt;T&gt; { return T.metatype } /// Returns the contiguous memory footprint of `T`. /// /// Does not include any dynamically-allocated or &quot;remote&quot; storage. /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the /// same regardless of how many stored properties `T` has. public var size: Int { return Type&lt;T&gt;.size } /// Returns the least possible interval between distinct instances of /// `T` in memory. The result is always positive. public var stride: Int { return Type&lt;T&gt;.stride } /// Returns the default memory alignment of `T`. public var alignment: Int { return Type&lt;T&gt;.alignment } /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal. public var metatype: Metatype&lt;T&gt; { return Type&lt;T&gt;.metatype } /// Hash values are not guaranteed to be equal across different executions of /// your program. Do not save hash values to use during a future execution. public var hashValue: Int { return _uniqueIdentifier(for: self.metatype) } /// A textual representation of `self`. public var description: String { return &quot;Type&lt; (self.metatype)&gt;()&quot; } /// A textual representation of `self`, suitable for debugging. public var debugDescription: String { return &quot;[&quot; + self.description + &quot; metatype: (self.metatype)&quot; + &quot; size: (self.size)&quot; + &quot; stride: (self.stride)&quot; + &quot; alignment: (self.alignment)]&quot; } } public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool { return true } /// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic /// metatype can reflect type `U` where `U : T`. public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt; { return /* implement */ } public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible { /// Storage for any dynamic metatype. internal let _metatype: Metatype&lt;Any&gt; /// Creates an instance of `Mirror`, reflecting type, which is /// reflected by a metatype. public init(_ metatype: Metatype&lt;Any&gt;) { self._metatype = metatype } /// Creates an instance of `Mirror`, reflecting type `T` public init&lt;T&gt;(_ type: Type&lt;T&gt;) { self._metatype = type.metatype } /// Creates an instance of `Mirror`, reflecting /// dynamic type of a given instance. public init&lt;T&gt;(reflecting instance: T) { self._metatype = metatype(of: instance) } /// Returns the contiguous memory footprint of reflected metatype. public var size: Int { return _size(of: self._metatype) } /// Returns the least possible interval between distinct instances of /// the dynamic type in memory calculated from the reflected dynamic /// metatype. The result is always positive. public var stride: Int { return _stride(of: self._metatype) } /// Returns the minimum memory alignment of the reflected dynamic /// metatype. public var alignment: Int { return _alignment(of: self._metatype) } /// Returns an instance of `Metatype&lt;T&gt;` from reflected dynamic metatype. public var metatype: Any.Type { return self._metatype } /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`. public func `is`(_ mirror: Mirror) -&gt; Bool { return _is(metatype: self._metatype, also: mirror.metatype) } /// Checks if type reflected by `self` is a subtype of `T`. public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool { return _is(metatype: self._metatype, also: type.metatype) } /// Checks if type reflected by `self` is a subtype of type reflected by a metatype. public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool { return _is(metatype: self._metatype, also: metatype) } /// Hash values are not guaranteed to be equal across different executions of /// your program. Do not save hash values to use during a future execution. public var hashValue: Int { return _uniqueIdentifier(for: self._metatype) } /// A textual representation of `self`. public var description: String { return &quot;Mirror( (self._metatype))&quot; } /// A textual representation of `self`, suitable for debugging. public var debugDescription: String { return &quot;[&quot; + self.description + &quot; metatype: (self._metatype)&quot; + &quot; size: (self.size)&quot; + &quot; stride: (self.stride)&quot; + &quot; alignment: (self.alignment)]&quot; } } public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool { return lhs.hashValue == rhs.hashValue } Internal functions: These functions were used in the implementation above to calculate metatype related information. _size(of:), _stride(of:) and _alignment(of:) functions need some additional tweaking so they will work with any matatype stored in an instance of Metatype&lt;Any&gt; rather than a dynamic &lt;T&gt;(of metatype: Metatype&lt;T&gt;) variant, which is not suitable for calculations needed in Mirror. _uniqueIdentifier(for:) function is fully implemented and should just work when the current generic issue with .Protocol metatypes is resolved. _is(metatype:also:) relies on the resolved .Protocol issue. The final implementation should allow to check type relationship between two different metatype instances. internal func _size(of metatype: Metatype&lt;Any&gt;) -&gt; Int { // Fix this to allow any metatype return Int(Builtin.sizeof(metatype)) } internal func _stride(of metatype: Metatype&lt;Any&gt;) -&gt; Int { // Fix this to allow any metatype return Int(Builtin.strideof_nonzero(metatype)) } internal func _alignment(of metatype: Metatype&lt;Any&gt;) -&gt; Int { // Fix this to allow any metatype return Int(Builtin.alignof(metatype)) } internal func _uniqueIdentifier(for metatype: Metatype&lt;Any&gt;) -&gt; Int { let rawPointerMetatype = unsafeBitCast(metatype, to: Builtin.RawPointer.metatype) return Int(Builtin.ptrtoint_Word(rawPointerMetatype)) } internal func _is(metatype m1: Metatype&lt;Any&gt;, also m2: Metatype&lt;Any&gt;) -&gt; Bool { return /* implement - checks type ralationship `M1 : M2` and `M1 == M2` */ } Summary of Steps: Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around. Make public T.self notation return an instance of Type&lt;T&gt;. Rename internal T.self notation to T.metatype (builtin - not visible in public Swift). Rename old metatype T.Type notation to Metatype&lt;T&gt;. Make internal T.metatype notation return an instance of Metatype&lt;T&gt;. Revise APIs with current T.Type notation to use Type&lt;T&gt; and in few edge cases Metatype&lt;T&gt;. Move size, stride and alignment from SE-0101 to Type&lt;T&gt;. Provide a concrete declaration for SE-0096 and rename it to metatype(of:). Rename current Mirror type (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable. Introduce a new Mirror type that is intended to replace metatypes for most use cases and extended with reflection in a future release. Impact on existing code This is a source-breaking change that can be automated by a migrator. The following steps reflects our suggestion of the migration process; these can differ from the final migration process implemented by the core team if this proposal will be accepted: T.Type → Metatype&lt;T&gt; T.self → Type&lt;T&gt;.metatype Mirror → DebugRepresentation CustomReflectable → CustomDebugRepresentable customMirror → customDebugRepresentation sizeof(T.self) → Type&lt;T&gt;.size sizeof(metatype) → Mirror(metatype).size Migrating metatype variables to use Type&lt;T&gt; and Mirror Metatype&lt;T&gt; is a safe default for transition, but we want to discourage usage of metatypes. In some cases, we can provide fix-its to replace usage of Metatype&lt;T&gt; with Type&lt;T&gt; or Mirror. To change type of a variable named type from Metatype&lt;T&gt; to Type&lt;T&gt;: Replace its type with Type&lt;T&gt;. Use the migration patterns below. If some use case does not match any of these, the variable cannot be migrated to type Type&lt;T&gt;. Migration patterns: type = T.self.metatype → type = T.self type = U.self.metatype where U != T → Automatic migration impossible type = Type&lt;T&gt;.metatype → type = T.self type = Type&lt;U&gt;.metatype where U != T → Automatic migration impossible type = otherMetatype where otherMetatype: Metatype&lt;T&gt; → type = T.self type = otherMetatype where otherMetatype: Metatype&lt;U&gt;, U != T → Automatic migration impossible type = mirror.metatype where mirror: Mirror → Automatic migration impossible otherMetatype = type where otherMetatype: Metatype&lt;U&gt; → otherMetatype = Type&lt;T&gt;.metatype Mirror(type) → Mirror(type) type as otherMetatype where otherMetatype: Metatype&lt;U&gt; → type.metatype as metatype&lt;U&gt; type as? otherMetatype → Automatic migration impossible type as! otherMetatype → Automatic migration impossible type is otherMetatype → Automatic migration impossible How to change type of a variable named type from Metatype&lt;T&gt; to Mirror: Replace its type with Mirror. Use the migration patterns below. If some use case does not match any of these, the variable cannot be migrated to type Mirror. Migration patterns: type: Metatype&lt;T&gt; → type: Mirror type = U.self.metatype → type = Mirror(U.self) type = Type&lt;U&gt;.metatype → type = Mirror(U.self) type = otherMetatype → type = Mirror(otherMetatype) type = mirror.metatype where mirror: Mirror → type = mirror otherMetatype = type → otherMetatype = type.metatype Mirror(type) → type type as otherMetatype → type.metatype as! otherMetatype type as? otherMetatype → type.metatype as? otherMetatype type as! otherMetatype → type.metatype as! otherMetatype type is otherMetatype → type.is(otherMetatype) We can also migrate metatype parameters of a function, where assignment means passing an argument to that function. In two cases we can apply these automatically: If a generic function takes parameter Metatype&lt;T&gt;, then we can try to replace Metatype&lt;T&gt; with Type&lt;T&gt;. We can try to replace usage of Metatype&lt;Any&gt; (aka AnyMetatype) with Mirror. Alternatives considered After refactoring metatypes it is assumed that any metatype can be stored inside an instance of Metatype&lt;Any&gt;. If that will not be the case, then we propose to introduce a new standalone type for explained behavior. That type could be named as AnyMetatype. Therefore, any type marked with Metatype&lt;Any&gt; in this proposal will become AnyMetatype. If the community and the core team are strongly against the repurposing of Mirror we’d like to consider to merge the proposed functionality into a single type. For such a change we do believe Type&lt;T&gt; might be the right type here. However, this introduces further complications such as storing dynamic metatypes inside of Type&lt;T&gt; and a few other that we don’t want go in detail here. Future directions Remove public .self: When SE-0090 is accepted we will remove T.self notation and only have type literals like T. Examples: let someInstance = unsafeBitCast(1.0, to: Int) let dynamicSize = Mirror(reflecting: someInstance).size Then we can add Type(_: Type&lt;T&gt;) initializer for disambiguation: Int.self.size // Works fine with this proposal, but what if we drop `.self`? Int.size // Will be an error after dropping `.self`. Type&lt;Int&gt;().size // Would work, but looks odd. Type(Int).size // This version looks much better. When combined with this proposal, the result will be to eliminate all ‘magical’ members that existed in the language: .dynamicType .Type .self There is also Self, but it acts like an associatedtype. Extend Mirror with reflection functionality: Reflection is one of stated goals for Swift 4. With this proposal, adding reflection becomes as simple as extending Mirror. For example, we could add the following computed property: typealias FieldDescriptor = (name: String, type: Mirror, getter: (Any) -&gt; Any, setter: (inout Any, Any) -&gt; ()) var fields: [FieldDescriptor] { get }",
    "url": "http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html",
    "relUrl": "/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html"
  },
  "126": {
    "id": "126",
    "title": "SE-0127 Cleaning up stdlib Pointer and Buffer Routines",
    "content": "Cleaning up stdlib Pointer and Buffer Routines Proposal: SE-0127 Author: Charlie Monroe Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Bugs: SR-1937, SR-1955, SR-1957 Introduction This proposal deals with three routines and one class related to pointers and buffers. The goal of this proposal is to update the API to match new API guidelines and remove redundant identifiers. Swift-evolution thread: Cleaning up stdlib Pointer and Buffer Routines Motivation The Swift standard library has been thoroughly updated to follow the new API guidelines and these are the few places that need to be updated in pointer and buffer APIs: withUnsafe[Mutable]Pointer’s arg argument should have a to: label (SR-1937) withUnsafe[Mutable]Pointers (multiple pointers) functions should be removed. unsafeAddressOf should be removed since there is a limited number of use cases and there are better alternatives to it (SR-1957). ManagedProtoBuffer should be removed. It is a superclass of ManagedBuffer and its sole purpose is to conceal the header property during invocation of the closure creating the initial header in ManagedBuffer.create since the header isn’t initialized at that point. This adds unnecessary complexity to the API in order to prevent something that should be considered programmer’s error. Proposed solution withUnsafe[Mutable]Pointer methods will now include to: argument label: withUnsafePointer(to: &amp;x) { (ptr) -&gt; Void in // ... } The multiple-pointer variations of the methods (withUnsafe[Mutable]Pointers) should be removed since the use cases in which they can be used are very limited and their use can be easily worked around by using nested calls to the single-pointer variants: var x = NSObject() var y = NSObject() withUnsafePointer(to: &amp;x) { (ptrX) -&gt; Void in withUnsafePointer(to: &amp;y) { (ptrY) -&gt; Void in /// ... } } unsafeAddressOf is removed. Suggested replacement is to use Unmanged.passUnretained. let obj = NSObject() let ptr = Unmanaged.passUnretained(obj) // instead of unsafeAddress(of: obj) The class ManagedProtoBuffer is removed as mentioned in motivation. All its members will be moved onto ManagedBuffer instead. Impact on existing code withUnsafe[Mutable]Pointer usage will need to be updated to include the to: label and the multi-pointer versions will need to be removed by the user and nested calls to single-pointer variants need to be used instead. Use of unsafeAddressOf(x) will need to be changed to Unmanaged.passUnretained(x) instead. Since ManagedProtoBuffer doesn’t have any accessible initializers, it can only be referenced in the code as an explicit type. Such occurrences can be renamed to ManagedBuffer instead. Alternatives considered withUnsafePointer’s argument is currently marked as inout which allows the function to provide the same address even for non-object values that are passed in as reference. This, however, may lead to unnecessary creation of var variables, instead of keeping them as immutable (let). Discussion on the mailing list brought up two suggestions: eliminate withUnsafePointer altogether and only keep the mutable withUnsafeMutablePointer variant since it can be used instead of the immutable variant in all use cases. This change would, however, conceal the caller’s intention of what is going to be done with the pointer. The second suggestion was to introduce two variants of withUnsafePointer - one that maintains current behavior and one that that doesn’t require inout argument. This has been viewed on as an additive change not in scope for Swift 3. Instead of removing ManagedProtoBuffer, rename it to ManagedBufferBase.",
    "url": "http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html",
    "relUrl": "/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html"
  },
  "127": {
    "id": "127",
    "title": "SE-0128 Change failable UnicodeScalar initializers to failable",
    "content": "Change failable UnicodeScalar initializers to failable Proposal: SE-0128 Author: Xin Tong Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#3662 Introduction This proposal aims to change some UnicodeScalar initializers (ones that are non-failable) from non-failable to failable. i.e., in case a UnicodeScalar can not be constructed, nil is returned. Motivation Currently, when one passes an invalid value to the non-failable UnicodeScalar UInt32 initializer, it crashes the program by calling _precondition. This is undesirable if one wishes to initialize a Unicode scalar from unknown input. Proposed solution Mark the non-failable UnicodeScalar initializers as failable and return nil when the integer is not a valid Unicode codepoint. Currently, the stdlib crashes the program by calling _precondition if the integer is not a valid Unicode codepoint. For example: var string = &quot;&quot; let codepoint: UInt32 = 55357 // this is invalid let ucode = UnicodeScalar(codepoint) // Program crashes at this point. string.append(ucode) After marking the initializer as failable, users can write code like this and the program will execute fine even if the codepoint isn’t valid. var string = &quot;&quot; let codepoint: UInt32 = 55357 // this is invalid if let ucode = UnicodeScalar(codepoint) { string.append(ucode) } else { // do something else } Impact on existing code The initializers are now failable, returning an optional, so optional unwrapping is necessary. The API changes include: public struct UnicodeScalar { - public init(_ value: UInt32) + public init?(_ value: UInt32) - public init(_ value: UInt16) + public init?(_ value: UInt16) - public init(_ value: Int) + public init?(_ value: Int) } Alternatives considered Leave status quo and force the users to do input checks before trying to initialize a UnicodeScalar.",
    "url": "http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html",
    "relUrl": "/docs/2019-08-26-0128-unicodescalar-failable-initializer.html"
  },
  "128": {
    "id": "128",
    "title": "SE-0129 Package Manager Test Naming Conventions",
    "content": "Package Manager Test Naming Conventions Proposal: SE-0129 Author: Anders Bertelrud Review Manager: Daniel Dunbar Status: Implemented (Swift 3) Decision Notes: Rationale Introduction The Swift Package Manager uses a convention-based rather than a declarative approach for various aspects of package configuration. This is as true of the naming and structure of tests as of other kinds of targets. However, the current conventions are somewhat inconsistent and unintuitive, and they also do not provide enough flexibility. This proposal seeks to address these problems through updated conventions. Motivation Predictability of test target names Module names for test targets are currently formed by appending the suffix TestSuite to the name of the corresponding directory under the top-level Tests directory in the package. This makes it non-obvious to know what name to pass to swift package test in order to run just one set of tests. This is also the case for any other context in which the module name is needed. Ability to declare test target dependencies The way in which the test module name is formed also makes it difficult to add target dependencies that specify the name of the test. This makes it hard to make a test depend on a library, such as a helper library containing shared code for use by the tests. Another consequence of unconditionally appending a TestSuite suffix to every module under the Tests directory is that it becomes impossible to add modules under Tests that define helper libraries for use only by tests. Reportability of errors In order for error messages to be understandable and actionable, they should refer to names the user can see and control. Also, the naming convention needs to have a reliable way of determining user intent so that error messages can be made as clear as possible. Proposed solution The essence of the proposed solution is to make the naming of tests be more predictable and more under the package author’s control. This is achieved in part by simplifying the naming conventions, and in part by reducing the number of differences between the conventions for the the Tests and the Sources top-level directories. First, the naming convention will be changed so a module will be considered a test if it: is located under the Tests directory has a name that ends with Tests A future proposal may want to loosen the restriction so that tests can also be located under Sources, if we feel that there is any use for that. As part of this proposal, SwiftPM will emit an error for any tests located under Sources. Allowing non-test targets under the Tests directory will unblock future improvements to allow test-only libraries to be located there. It will also unblock the potential to support test executables in the future, though this proposal does not specifically address that. Like any other target, a test will be able to be mentioned in a dependency declaration. As a convenience, if there is a target named Foo and a test target named FooTests, a dependency between the two will be automatically established. It will still be allowed to have a FooTests test without a corresponding Foo source module. This can be useful for integration tests or for fixtures, etc. Detailed design Change the naming conventions so that a module will be considered a test if it: is located under the top-level Tests directory, and has a name that ends with Tests Allow a target dependency to refer to the name of a test target, which will allow package authors to create dependencies between tests and libraries. Add an implicit dependency between any test target a non-test target that has the same name but without the Tests suffix. For now, make it an error to have executables or libraries under Tests (for technical reasons, a LinuxMain.swift source file is permitted, and indeed expected, under the Tests top-level directory). The intent is to loosen this restriction in a future proposal, to allow test-specific libraries and test executables under Tests. For now, make it an error to have tests under Sources. We may loosen this this restriction at some point, but would need to define what it would mean from a conceptual point of view to have tests under Sources instead of Tests. Improve error reporting to reflect the new conventions. This includes adding more checks, and also auditing all the error messages relating to testing to see if there is more information that should be displayed. Impact on existing code The change in naming conventions does mean that any module under the top-level Tests directory whose name ends with the suffix Tests will be considered a test module. The fact that this proposal does not involve allowing tests to be located under Sources, and the fact that any module under Tests already had an unconditional TestSuite suffix string appended, makes it unlikely that any current non-test module under Tests would suddenly be considered a test. Any module with a Tests suffix under Sources would need to be renamed. Any current package that refers to a test module using a TestSuite suffix will need to be changed. Alternatives considered An alternative that was considered was to enhance the PackageDescription API to let package authors explicitly tag targets as tests. While we might still want to add this for cases in which the author doesn’t want to use any of the naming conventions, we don’t want such an API to be the only way to specify tests.",
    "url": "http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html",
    "relUrl": "/docs/2019-08-26-0129-package-manager-test-naming-conventions.html"
  },
  "129": {
    "id": "129",
    "title": "SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init",
    "content": "Replace repeating Character and UnicodeScalar forms of String.init Proposal: SE-0130 Author: Roman Levenstein Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction This proposal suggest replacing String initializers taking Character or UnicodeScalar as a repeating value by a more general initializer that takes a String as a repeating value. This is done to avoid the ambiguities in the current String API, which can be only resolved by explicit casting. It is also proposed to remove one of the String.append APIs to match these changes. All user-facing Swift APIs must go through Swift Evolution. While this is a relatively simple API change with an existing implementation, this formal proposal provides a paper trail as is normal and usual for this process. Motivation This change introduces a non-ambiguous API for constructing Strings. With the set of String initializers available today, ones often needs to explicitly cast the repeating value literal to disambiguate what initializer is meant to be used. An example of the ambiguity: &gt; let x = String(repeating:&quot;0&quot;, count: 10) error: repl.swift:29:9: error: ambiguous use of &#39;init(repeating:count:)&#39; let x = String(repeating:&quot;0&quot;, count: 10) ^ Swift.String:11:12: note: found this candidate public init(repeating repeatedValue: Character, count: Int) ^ Swift.String:21:12: note: found this candidate public init(repeating repeatedValue: UnicodeScalar, count: Int) ^ To disambiguate, one currently needs to write something like: let zeroes = String(repeating: &quot;0&quot; as Character, count: 10) or let zeroes = String(repeating: &quot;0&quot; as UnicodeScalar, count: 10) Detailed Design This update affects String. It is proposed to replace the following ambiguous API: public init(repeating repeatedValue: Character, count: Int) public init(repeating repeatedValue: UnicodeScalar, count: Int) by the following, more powerful API: public init(repeating repeatedValue: String, count: Int) To match this change, it is also proposed to remove the following String.append API: public mutating func append(_ x: UnicodeScalar) It should be fine, because there is already an existing and more powerful API: public mutating func append(_ other: String) Impact on Existing Code Existing third party code using these to be removed String APIs will need migration. A fix-it could be provided to automate this migration. Alternatives Considered Not Applicable",
    "url": "http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html",
    "relUrl": "/docs/2019-08-26-0130-string-initializers-cleanup.html"
  },
  "130": {
    "id": "130",
    "title": "SE-0131 Add `AnyHashable` to the standard library",
    "content": "Add AnyHashable to the standard library Proposal: SE-0131 Author: Dmitri Gribenko Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Introduction We propose to add a type-erased AnyHashable container to the standard library. The implementation of SE-0116 “Import Objective-C id as Swift Any type” requires a type-erased container for hashable values. From SE-0116: We need a type-erased container to represent a heterogeneous hashable type that is itself Hashable, for use as the upper-bound type of heterogeneous Dictionarys and Sets. Swift-evolution thread: Add AnyHashable to the standard library. Motivation Currently the Objective-C type NSDictionary * is imported as [NSObject : AnyObject]. We used NSObject as the key type because it is the closest type (in spirit) to AnyObject that also conforms to Hashable. The aim of SE-0116 is to eliminate AnyObject from imported APIs, replacing it with Any. To import unannotated NSDictionaries we need an Any-like type that conforms to Hashable. Thus, unannotated NSDictionaries will be imported as [AnyHashable : Any]. For additional motivation and discussion of API importing and bridging, see SE-0116. Detailed design We are adding the AnyHashable type: /// A type-erased hashable value. /// /// Forwards equality comparisons and hashing operations to an /// underlying hashable value, hiding its specific type. /// /// You can store mixed-type keys in `Dictionary` and other /// collections that require `Hashable` by wrapping mixed-type keys in /// `AnyHashable` instances: /// /// let descriptions: [AnyHashable : Any] = [ /// AnyHashable(&quot;😄&quot;): &quot;emoji&quot;, /// AnyHashable(42): &quot;an Int&quot;, /// AnyHashable(Int8(43)): &quot;an Int8&quot;, /// AnyHashable(Set([&quot;a&quot;, &quot;b&quot;])): &quot;a set of strings&quot; /// ] /// print(descriptions[AnyHashable(42)]!) // prints &quot;an Int&quot; /// print(descriptions[AnyHashable(43)]) // prints &quot;nil&quot; /// print(descriptions[AnyHashable(Int8(43))]!) // prints &quot;an Int8&quot; /// print(descriptions[AnyHashable(Set([&quot;a&quot;, &quot;b&quot;]))]!) // prints &quot;a set of strings&quot; public struct AnyHashable { /// Creates an opaque hashable value that wraps `base`. /// /// Example: /// /// let x = AnyHashable(Int(42)) /// let y = AnyHashable(UInt8(42)) /// /// print(x == y) // Prints &quot;false&quot; because `Int` and `UInt8` /// // are different types. /// /// print(x == AnyHashable(Int(42))) // Prints &quot;true&quot;. public init&lt;H : Hashable&gt;(_ base: H) /// The value wrapped in this `AnyHashable` instance. /// /// let anyMessage = AnyHashable(&quot;Hello&quot;) /// let unwrappedMessage: Any = anyMessage.base /// print(unwrappedMessage) // prints &quot;hello&quot; public var base: Any } extension AnyHashable : Equatable, Hashable { public static func == (lhs: AnyHashable, rhs: AnyHashable) -&gt; Bool public var hashValue: Int { } We are adding convenience APIs to Set&lt;AnyHashable&gt; that allow using existing Set APIs with concrete values that conform to Hashable. For example: func contains42(_ data: Set&lt;AnyHashable&gt;) -&gt; Bool { // Works, but is too verbose: // return data.contains(AnyHashable(42)) return data.contains(42) // Convenience API. } Convenience APIs for Set&lt;AnyHashable&gt;: extension Set where Element == AnyHashable { public func contains&lt;ConcreteElement : Hashable&gt;( _ member: ConcreteElement ) -&gt; Bool public func index&lt;ConcreteElement : Hashable&gt;( of member: ConcreteElement ) -&gt; SetIndex&lt;Element&gt;? mutating func insert&lt;ConcreteElement : Hashable&gt;( _ newMember: ConcreteElement ) -&gt; (inserted: Bool, memberAfterInsert: ConcreteElement) @discardableResult mutating func update&lt;ConcreteElement : Hashable&gt;( with newMember: ConcreteElement ) -&gt; ConcreteElement? @discardableResult mutating func remove&lt;ConcreteElement : Hashable&gt;( _ member: ConcreteElement ) -&gt; ConcreteElement? } Convenience APIs for Dictionary&lt;AnyHashable, *&gt;: extension Dictionary where Key == AnyHashable { public func index&lt;ConcreteKey : Hashable&gt;(forKey key: ConcreteKey) -&gt; DictionaryIndex&lt;Key, Value&gt;? public subscript(_ key: _Hashable) -&gt; Value? { get set } @discardableResult public mutating func updateValue&lt;ConcreteKey : Hashable&gt;( _ value: Value, forKey key: ConcreteKey ) -&gt; Value? @discardableResult public mutating func removeValue&lt;ConcreteKey : Hashable&gt;( forKey key: ConcreteKey ) -&gt; Value? } Impact on existing code AnyHashable itself is additive. Source-breaking changes are discussed in SE-0116.",
    "url": "http://localhost:4000/docs/2019-08-26-0131-anyhashable.html",
    "relUrl": "/docs/2019-08-26-0131-anyhashable.html"
  },
  "131": {
    "id": "131",
    "title": "SE-0132 Rationalizing Sequence end-operation names",
    "content": "Rationalizing Sequence end-operation names Proposal: SE-0132 Authors: Brent Royal-Gordon, Dave Abrahams Review Manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction Sequence and Collection offer many special operations which access or manipulate its first or last elements, but they are plagued by inconsistent naming which can make it difficult to find inverses or remember what the standard library offers. We propose that we standardize these names so they follow consistent, predictable patterns. Swift-evolution thread: [Draft] Rationalizing Sequence end-operation names Scope This proposal does not aim to add or remove any functionality; it merely renames and redesigns existing operations. Adding new operations is out of scope for this proposal unless it’s incidental to the new designs. Nonetheless, we do want the new designs to support adding more operations in the future. The names we’ve chosen are informed by some of the speculative APIs discussed in “Future directions”, although we think they are perfectly sensible names even if nothing else changes. Motivation The Sequence and Collection protocols offer a wide variety of APIs which are defined to operate on, or from, one end of the sequence:   Get Index Exclude Remove (1) Pop (1) Equate (2) Fixed Size             First 1 C.first - S.dropFirst() C.removeFirst() C.popFirst() - Last 1 C.last - S.dropLast() C.removeLast() C.popLast() - First (n: Int) S.prefix(3) - S.dropFirst(3) C.removeFirst(3) - S.starts(with: [x,y,z])   …with closure S.prefix(while: isPrime) - S.drop(while: isPrime) - - S.starts(with: [x,y,z], by: ==) Last (n: Int) S.suffix(3) - S.dropLast(3) C.removeLast(3) - -   …with closure - - - - - - Searching From End             First matching element - C.index(of: x) - - - -   …with closure S.first(where: isPrime) C.index(where: isPrime) - - - - Last matching element - - - - - -   …with closure - - - - - - Based on Index             startIndex ..&lt; (i: Index) C.prefix(upTo: i) - - - - - startIndex … (i: Index) C.prefix(through: i) - - - - - (i: Index) ..&lt; endIndex C.suffix(from: i) - - - - - We have included several blank rows for operands which fit the APIs’ patterns, even if they don’t happen to have any operations currently. Type abbreviations: S = Sequence C = Collection (or a sub-protocol like BidirectionalCollection) Notes: remove and pop both mutate the array to delete the indicated element(s), but remove assumes as a precondition that the indicated elements exist, while pop checks whether or not they exist. String and NSString have bespoke versions of first n and last n Equate operations, in the form of their hasPrefix and hasSuffix methods. Leaving aside the question of whether any gaps in these tables ought to be filled, we see a number of issues with existing terminology. Inconsistent use of prefix and suffix Some APIs which operate on a variable number of elements anchored at one end or the other use the terms prefix or suffix: Sequence.prefix(_:) and Sequence.suffix(_:) Sequence.prefix(while:) String.hasPrefix(_:) and String.hasSuffix(_:) Others, however, use first or last: Sequence.dropFirst(_:) and Sequence.dropLast(_:) Sequence.removeFirst(_:) and Sequence.removeLast(_:) Still others use neither: Sequence.starts(with:) Sequence.drop(while:) These methods are all closely related, but because of this inconsistent terminology, they fail to form predictable method families. first has multiple meanings The word first can mean three different things in these APIs: Just the very first element of the sequence. A subsequence of elements anchored at the beginning of the sequence, as mentioned in the last point. The first element encountered in the sequence which matches a given criterion when walking from the beginning of the sequence towards the end. It would be nice to have more clarity here—particularly around #2, which implies different return value behavior. drop is misleading and scary In a Swift context, we believe the drop methods are actively confusing: drop does not have the -ing or -ed suffix normally used for a nonmutating method. drop has strong associations with destructive operations; it’s the term used, for instance, for deleting whole tables in SQL. Even dropping would probably sound more like a mutating operation than alternatives. As previously mentioned, the use of dropFirst and dropLast for single-drop operations and multiple-drop operations breaks up method families. drop, dropFirst, and dropLast are terms of art, so we allow them a certain amount of leeway. However, we believe the drop functions go well beyond what we should permit. They are relatively uncommon operations, associated primarily with functional languages rather than mainstream object-oriented or imperative languages, and their violation of the normal Swift naming guidelines is especially misleading. The term-of-art exception is not a suicide pact; it is meant to aid understanding by importing common terminology, not bind us to follow every decision made by any language that came before us. In this case, we think we should ignore precedent and forge our own path. Unstated direction of operation Several APIs could theoretically be implemented by working from either end of the sequence, and would return different results depending on the direction, but do not indicate the direction in their names: Sequence.drop(while:) Collection.index(of:) Adding a direction to these APIs would make their behavior clearer and permit us to offer opposite-end equivalents in the future. (Unmerged swift-evolution pull request 329 would add lastIndex methods.) Operations taking an index are really slicing prefix(upTo:), prefix(through:), and suffix(from:) at first appear to belong to the same family as the other prefix and suffix methods, but deeper examination reveals otherwise. They are the only operations which take indices, and they don’t cleanly extend to the other operations which belong to these families. (For instance, it would not make sense to add a dropPrefix(upTo:) method; it would be equivalent to suffix(from:).) Also, on Int-indexed collections like Array, prefix(_:) and prefix(upTo:) are identical, but there is little relationship between suffix(_:) and suffix(from:), which is confusing. suffix(from:) is a particularly severe source of confusion. The other suffix APIs all have parameters relative to the end of the collection, but suffix(from:)’s index is still relative to the beginning of the array. This is obvious if you think deeply about the meaning of an index, but we don’t really want to force our users to stare at a strange API until they have an epiphany. We believe these operations have much more in common with slicing a collection using a range, and that reimagining them as slicing APIs will be more fruitful. Thus, the bottom of the table above should probably be split into a separate one and combined with a table of subrange APIs:   Type Get Remove Replace Based on Index, Arbitrary         (i: Index) ..&lt; (j: Index) Range&lt;Index&gt; C[i ..&lt; j] C.removeSubrange(i ..&lt; j) C.replaceSubrange(i ..&lt; j, with: [x,y])   …Countable CountableRange&lt;Index&gt; C[i ..&lt; j] C.removeSubrange(i ..&lt; j) C.replaceSubrange(i ..&lt; j, with: [x,y]) (i: Index) … (j: Index) ClosedRange&lt;Index&gt; C[i … j] C.removeSubrange(i … j) C.replaceSubrange(i … j, with: [x,y])   …Countable CountableClosedRange&lt;Index&gt; C[i … j] C.removeSubrange(i … j) C.replaceSubrange(i … j, with: [x,y]) Based on Index, From End         startIndex ..&lt; (i: Index) upTo: Index C.prefix(upTo: i) - - (i: Index) ..&lt; endIndex from: Index C.suffix(from: i) - - startIndex … (i: Index) through: Index C.prefix(through: i) - - Why does it matter? Many of these APIs are only occasionally necessary, so it’s important that they be easy to find when needed and easy to understand when read. If you know that prefix(10) will get the first ten elements but don’t know what its inverse is, you will probably not guess that it’s dropFirst(10). The confusing, conflicting names in these APIs are a barrier to users adopting them where appropriate. Proposed solution We sever the index-taking APIs from the others, forming two separate families, which we will call the “Sequence-end operations” and the “index-based operations”. We then consider and redesign them along separate lines. Sequence-end operations Each of these APIs should be renamed to use a directional word based on its row in the table: Operand Directional word Fixed Size   First 1 first Last 1 last First (n: Int) prefix   …with closure prefix Last (n: Int) suffix   …with closure suffix Searching From End   First matching element first   …with closure first Last matching element last   …with closure last To accomplish this, starts(with:) should be renamed to hasPrefix(_:), and other APIs should have directional words replaced or added as appropriate. Additionally, the word drop in the “Exclude” APIs should be replaced with removing. These operations omit the same elements which the remove operations delete, so even though the types are not always the same (removing returns SubSequence, not Self), we think they are similar enough to deserve to be treated as nonmutating forms. These changes yield (altered names bold):   Get Index Exclude Remove (1) Pop (1) Equate (2) Fixed Size             First 1 C.first - S.removingFirst() C.removeFirst() C.popFirst() - Last 1 C.last - S.removingLast() C.removeLast() C.popLast() - First (n: Int) S.prefix(3) - S.removingPrefix(3) C.removePrefix(3) - S.hasPrefix([x,y,z])   …with closure S.prefix(while: isPrime) - S.removingPrefix(while: isPrime) - - S.hasPrefix([x,y,z], by: ==) Last (n: Int) S.suffix(3) - S.removingSuffix(3) C.removeSuffix(3) - -   …with closure - - - - - - Searching From End             First matching element - C.firstIndex(of: x) - - - -   …with closure S.first(where: isPrime) C.firstIndex(where: isPrime) - - - - Last matching element - - - - - -   …with closure - - - - - - Index-based operations Because these APIs look up elements based on their indices, we believe these operations should be exposed as subscripts, and ideally should look like other slicing operations: let head = people[..&lt;i] let tail = people[i..&lt;] let rearrangedPeople = tail + head We will accomplish this by introducing two new types, IncompleteRange and IncompleteClosedRange. These are similar to Range and ClosedRange, except that the bounds are optional. To construct them, we will introduce both prefix and suffix operators taking a non-optional bound, and infix operators taking optional bounds. (We offer both because c[..&lt;i] is more convenient than c[nil ..&lt; i], but doesn’t allow you to dynamically choose between supplying and omitting a bound.) These will follow the existing convention: ..&lt; will construct the half-open IncompleteRange, while ... will construct IncompleteClosedRange. Rather than continuing to proliferate overloads of slicing subscripts, we will also introduce a new RangeExpression protocol which allows any range-like type to convert itself into a plain Range&lt;Index&gt; appropriate to the collection in question. Thus, there should only be two range subscripts: one taking Range&lt;Index&gt;, and one taking everything else. We will also modify the existing removeSubrange(_:) and replaceSubrange(_:with:) calls to take RangeExpression instances, thereby merging many existing variants into one while simultaneously extending them to support IncompleteRange and IncompleteClosedRange. Though technically additive, we believe this is an easy win. Thus, the table above becomes:   Type Get Remove Replace Based on Index, Arbitrary         (i: Index) ..&lt; (j: Index) Range&lt;Index&gt; C[i ..&lt; j] C.removeSubrange(i ..&lt; j) C.replaceSubrange(i ..&lt; j, with: [x,y])   …Countable CountableRange&lt;Index&gt; C[i ..&lt; j] C.removeSubrange(i ..&lt; j) C.replaceSubrange(i ..&lt; j, with: [x,y]) (i: Index) … (j: Index) ClosedRange&lt;Index&gt; C[i … j] C.removeSubrange(i … j) C.replaceSubrange(i … j, with: [x,y])   …Countable CountableClosedRange&lt;Index&gt; C[i … j] C.removeSubrange(i … j) C.replaceSubrange(i … j, with: [x,y]) Based on Index, From End         startIndex ..&lt; (i: Index) IncompleteRange&lt;Index&gt; C[..&lt;i] C.removeSubrange(..&lt;i) C.replaceSubrange(..&lt;i, with: [x,y]) (i: Index) ..&lt; endIndex IncompleteRange&lt;Index&gt; C[i..&lt;] C.removeSubrange(i..&lt;) C.replaceSubrange(i..&lt;, with: [x,y]) startIndex … (i: Index) IncompleteClosedRange&lt;Index&gt; C[…i] C.removeSubrange(…i) C.replaceSubrange(…i, with: [x,y]) However, it should be implemented with merely:   Type Get Remove Replace (i: Index) ..&lt; (j: Index) Range&lt;Index&gt; C[i ..&lt; j] C.removeSubrange(i ..&lt; j) C.replaceSubrange(i ..&lt; j, with: [x,y]) Everything else RangeExpression where Bound == Index C[i … j] C.removeSubrange(i … j) C.replaceSubrange(i … j, with: [x,y]) Detailed design Sequence-end operations The following methods should be renamed as follows wherever they appear in the standard library. These are simple textual substitutions; we propose no changes whatsoever to types, parameter interpretations, or other semantics. Old method New method dropFirst() -&gt; SubSequence removingFirst() -&gt; SubSequence dropLast() -&gt; SubSequence removingLast() -&gt; SubSequence dropFirst(_ n: Int) -&gt; SubSequence removingPrefix(_ n: Int) -&gt; SubSequence drop(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence removingPrefix(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence dropLast(_ n: Int) -&gt; SubSequence removingSuffix(_ n: Int) -&gt; SubSequence removeFirst(_ n: Int) removePrefix(_ n: Int) removeLast(_ n: Int) removeSuffix(_ n: Int) starts&lt;PossiblePrefix: Sequence&gt;(with possiblePrefix: PossiblePrefix) -&gt; Bool where ... hasPrefix&lt;PossiblePrefix: Sequence&gt;(_ possiblePrefix: PossiblePrefix) -&gt; Bool where ... starts&lt;PossiblePrefix : Sequence&gt;(with possiblePrefix: PossiblePrefix, by areEquivalent: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool where ... hasPrefix&lt;PossiblePrefix : Sequence&gt;(_ possiblePrefix: PossiblePrefix, by areEquivalent: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool where ... index(of element: Iterator.Element) -&gt; Index? firstIndex(of element: Iterator.Element) -&gt; Index? index(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index? firstIndex(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index? Index-based operations We will first present an idealized version of the design which cannot be fully implemented in Swift 3 due to generics bugs and limitations. Then we will present the minor changes necessary to implement it. The two should be source-compatible unless users conform their own types to RangeExpression. Idealized design The RangeExpression protocol is defined like so: /// A type which can be used to slice a collection. A `RangeExpression` can /// convert itself to a `Range&lt;Bound&gt;` of indices within a given collection; /// the collection can then slice itself with that `Range`. public protocol RangeExpression { /// Returns `self` expressed as a range of indices within `collection`. /// /// -Parameter collection: The collection `self` should be /// relative to. /// /// -Returns: A `Range&lt;Bound&gt;` suitable for slicing `collection`. /// The return value is *not* guaranteed to be inside /// its bounds. Callers should apply the same preconditions /// to the return value as they would to a range provided /// directly by the user. public func relative&lt;C: Collection&gt;(to collection: C) -&gt; Range&lt;Bound&gt; where C.Index == Bound { } The following existing types will be conformed to RangeExpressible: Range CountableRange ClosedRange CountableClosedRange The Range conformance is not strictly necessary, but allows APIs which do not need to be overridden to implement only a RangeExpression-based variant. Type inference favors concrete members over generic ones, so it should prefer to use parameters explicitly typed as Range&lt;Index&gt; over parameters of a generic type constrained to RangeExpression where Bound == Index. The Indexable and MutableIndexable subscripts which take range types other than Range itself will be removed. So will the RangeReplaceableCollection subscripts which take range types other than Range. Instead, they will be replaced with single generic versions taking a RangeExpression where Bound == Index, using relative(to:) to convert them to Ranges and then calling through to the plain Range variants: extension Collection { /// Accesses a contiguous subrange of the collection&#39;s elements. /// /// The accessed slice uses the same indices for the same elements as the /// original collection. Always use the slice&#39;s `startIndex` property /// instead of assuming that its indices start at a particular value. /// /// This example demonstrates getting a slice of an array of strings, finding /// the index of one of the strings in the slice, and then using that index /// in the original array. /// /// let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;] /// let streetsSlice = streets[2 ..&lt; streets.endIndex] /// print(streetsSlice) /// // Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot; /// /// let index = streetsSlice.index(of: &quot;Evarts&quot;) // 4 /// print(streets[index!]) /// // Prints &quot;Evarts&quot; /// /// - Parameter bounds: A range of the collection&#39;s indices. The bounds of /// the range must be valid indices of the public subscript&lt;R&gt;(bounds: R) -&gt; SubSequence where R: RangeExpression, R.Bound == Index { get { return self[bounds.relative(to: self)] } } } extension MutableCollection { /// Accesses a contiguous subrange of the collection&#39;s elements. /// /// The accessed slice uses the same indices for the same elements as the /// original collection. Always use the slice&#39;s `startIndex` property /// instead of assuming that its indices start at a particular value. /// /// This example demonstrates getting a slice of an array of strings, finding /// the index of one of the strings in the slice, and then using that index /// in the original array. /// /// let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;] /// let streetsSlice = streets[2 ..&lt; streets.endIndex] /// print(streetsSlice) /// // Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot; /// /// let index = streetsSlice.index(of: &quot;Evarts&quot;) // 4 /// streets[index!] = &quot;Eustace&quot; /// print(streets[index!]) /// // Prints &quot;Eustace&quot; /// /// - Parameter bounds: A range of the collection&#39;s indices. The bounds of /// the range must be valid indices of the collection. public subscript&lt;R&gt;(bounds: R) -&gt; SubSequence where R: RangeExpression, R.Bound == Index { get { return self[bounds.relative(to: self)] } set { self[bounds.relative(to: self)] = newValue } } } extension RangeReplaceableCollection { /// Replaces the specified subrange of elements with the given collection. /// /// This method has the effect of removing the specified range of elements /// from the collection and inserting the new elements at the same location. /// The number of new elements need not match the number of elements being /// removed. /// /// In this example, three elements in the middle of an array of integers are /// replaced by the five elements of a `Repeated&lt;Int&gt;` instance. /// /// var nums = [10, 20, 30, 40, 50] /// nums.replaceSubrange(1...3, with: repeatElement(1, count: 5)) /// print(nums) /// // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot; /// /// If you pass a zero-length range as the `subrange` parameter, this method /// inserts the elements of `newElements` at `subrange.startIndex`. Calling /// the `insert(contentsOf:at:)` method instead is preferred. /// /// Likewise, if you pass a zero-length collection as the `newElements` /// parameter, this method removes the elements in the given subrange /// without replacement. Calling the `removeSubrange(_:)` method instead is /// preferred. /// /// Calling this method may invalidate any existing indices for use with this /// collection. /// /// - Parameters: /// - subrange: The subrange of the collection to replace. The bounds of /// the range must be valid indices of the collection. /// - newElements: The new elements to add to the collection. /// /// - Complexity: O(*m*), where *m* is the combined length of the collection /// and `newElements`. If the call to `replaceSubrange` simply appends the /// contents of `newElements` to the collection, the complexity is O(*n*), /// where *n* is the length of `newElements`. public mutating func replaceSubrange&lt;R, C&gt;( _ subrange: R, with newElements: C ) where R : RangeExpression, R.Bound == Index, C : Collection, C.Iterator.Element == Iterator.Element { replaceSubrange(subrange.relative(to: self), with: newElements) } /// Removes the elements in the specified subrange from the collection. /// /// All the elements following the specified position are moved to close the /// gap. This example removes two elements from the middle of an array of /// measurements. /// /// var measurements = [1.2, 1.5, 2.9, 1.2, 1.5] /// measurements.removeSubrange(1..&lt;3) /// print(measurements) /// // Prints &quot;[1.2, 1.5]&quot; /// /// Calling this method may invalidate any existing indices for use with this /// collection. /// /// - Parameter bounds: The range of the collection to be removed. The /// bounds of the range must be valid indices of the collection. /// /// - Complexity: O(*n*), where *n* is the length of the collection. public mutating func removeSubrange&lt;R&gt;(_ bounds: R) where R : RangeExpression, R.Bound == Index { removeSubrange(bounds.relative(to: self)) } } The Collection- and RangeReplaceableCollection-mimicking APIs on String will be similarly replaced with RangeExpression-based versions, except that here the Range versions will be removed too, so all calls will be through RangeExpression. The IncompleteRange and IncompleteClosedRange types will be very similar. They are designed to be useful generally, not merely with RangeExpressible. Below is the interface for IncompleteRange; IncompleteClosedRange would be analogous. prefix operator ..&lt; {} postfix operator ..&lt; {} /// A `Range` which may not have all of its bounds specified. /// The `IncompleteRange` can be completed by providing a /// `Range` or `CountableRange` from which it can retrieve /// default upper and lower bounds. public struct IncompleteRange&lt;Bound : Comparable&gt; { /// The lowest value within the range. /// If `nil`, completing the range will adopt the default value&#39;s /// `lowerBound`. public let lowerBound: Bound? /// The value just above the highest value within the range. /// If `nil`, completing the range will adopt the default value&#39;s /// `upperBound`. public let upperBound: Bound? } extension IncompleteRange { /// Returns a `Range` with the same `upperBound` /// and `lowerBound` as the current instance. `nil` bounds are /// filled in from `defaultBounds`. /// /// This method does not check whether `lowerBound` and `upperBound` /// lie within `defaultBounds`. public func completed(by defaultBounds: Range&lt;Bound&gt;) -&gt; Range&lt;Bound&gt; /// Returns a `Range` with the same `upperBound` /// and `lowerBound` as the current instance. `nil` bounds are /// filled in from `defaultBounds`. /// /// This method does not check whether `lowerBound` and `upperBound` /// lie within `defaultBounds`. /// Nor does it check whether the resulting `lowerBound` is below /// its `upperBound`. public func completed(byUnchecked defaultBounds: Range&lt;Bound&gt;) -&gt; Range&lt;Bound&gt; } extension IncompleteRange where Bound : Strideable, Bound.Stride : SignedInteger { /// Returns a `CountableRange` with the same `upperBound` /// and `lowerBound` as the current instance. `nil` bounds are /// filled in from `defaultBounds`. /// /// This method does not check whether `lowerBound` and `upperBound` /// lie within `defaultBounds`. public func completed(by defaultBounds: CountableRange&lt;Bound&gt;) -&gt; CountableRange&lt;Bound&gt; /// Returns a `CountableRange` with the same `upperBound` /// and `lowerBound` as the current instance. `nil` bounds are /// filled in from `defaultBounds`. /// /// This method does not check whether `lowerBound` and `upperBound` /// lie within `defaultBounds`. /// Nor does it check whether the resulting `lowerBound` is below /// its `upperBound`. public func completed(byUnchecked defaultBounds: CountableRange&lt;Bound&gt;) -&gt; CountableRange&lt;Bound&gt; } extension IncompleteRange: RangeExpression { ... } /// Constructs an `IncompleteRange` with the provided upper /// bound and an unknown lower bound. public prefix func ..&lt; &lt;Bound: Comparable&gt;(upperBound: Bound) -&gt; IncompleteRange&lt;Bound&gt; /// Constructs an `IncompleteRange` with the provided lower /// bound and an unknown upper bound. public postfix func ..&lt; &lt;Bound: Comparable&gt;(lowerBound: Bound) -&gt; IncompleteRange&lt;Bound&gt; /// Constructs an `IncompleteRange` with the provided upper /// and lower bounds. Either or both may be `nil`, in which case the /// bound will be provided when the `IncompleteRange` is /// completed. public func ..&lt; &lt;Bound: Comparable&gt;(lowerBound: Bound?, upperBound: Bound?) -&gt; IncompleteRange&lt;Bound&gt; Finally, since they are now redundant, prefix(upTo:), prefix(through:), and suffix(from:) will be removed. Actual design The actual design varies from the ideal one in four ways: The CountableRange variants of completed(by:) require a slightly different set of constraints to match a workaround on those types. Swift 3 does not support generic subscripts, so we must instead generate subscripts for each known RangeExpression type. Because of the complex way Collection’s protocols are layered, it is necessary to attach subscripts to Indexable and MutableIndexable, and constrain relative(to:)’s parameter to Indexable, instead of Collection and MutableCollection. Swift currently has trouble with the constraints on RangeExpression.relative(to:) if it is a protocol requirement. Thus, it is instead provided as an extension method. A method with simpler generic constraints is instead used as the requirement. These will not affect source compatibility except when a user conforms their own types to RangeExpression, so we suggest we place warnings in the documentation, effectively pre-deprecating its required method. The actual design of RangeExpression is thus as follows: /// A type which can be used to slice a collection. A `RangeExpression` can /// convert itself to a `Range&lt;Bound&gt;` of indices within a given collection; /// the collection can then slice itself with that `Range`. /// /// -Warning: The requirements of `RangeExpression` are likely to change /// in a future version of Swift. If you conform your own /// types to `RangeExpression`, be prepared to migrate them. public protocol RangeExpression { /// The type of the bounds of the `Range` produced by this /// type when used as a `RangeExpression`. associatedtype Bound : Comparable /// Returns `self` expressed as a `Range&lt;Bound&gt;` suitable for /// slicing a collection with the indicated properties. /// /// -Parameter bounds: The range of indices in the collection. /// Equivalent to `startIndex ..&lt; endIndex` /// in `Collection`. /// /// -Parameter offset: A function which can be used to add to or /// subtract from a bound. Equivalent to /// `index(_:offsetBy:)` in `Collection`. /// /// -Returns: A `Range&lt;Bound&gt;` suitable for slicing a collection. /// The return value is *not* guaranteed to be inside /// `bounds`. Callers should apply the same preconditions /// to the return value as they would to a range provided /// directly by the user. /// /// -Warning: This method is likely to be replaced in a future version of Swift. /// If you are calling this method, we recommend using the /// `relative(to:)` extension method instead. If you are implementing /// it, be prepared to migrate your code. /// /// -Recommended: `relative(to:)` // // WORKAROUND unfiled - We want to have this requirement, but it triggers a generics bug // func relative&lt;C: Indexable&gt;(to collection: C) -&gt; Range&lt;Bound&gt; where C.Index == Bound func relative&lt;BoundDistance: SignedInteger&gt;(to bounds: Range&lt;Bound&gt;, offsettingBy offset: (Bound, BoundDistance) -&gt; Bound) -&gt; Range&lt;Bound&gt; } extension RangeExpression { /// Returns `self` expressed as a range of indices within `collection`. /// /// -Parameter collection: The collection `self` should be /// relative to. /// /// -Returns: A `Range&lt;Bound&gt;` suitable for slicing `collection`. /// The return value is *not* guaranteed to be inside /// its bounds. Callers should apply the same preconditions /// to the return value as they would to a range provided /// directly by the user. /// /// -RecommendedOver: `relative(to:offsettingBy:)` public func relative&lt;C: Indexable&gt;(to collection: C) -&gt; Range&lt;Bound&gt; where C.Index == Bound { let bounds = Range(uncheckedBounds: (lower: collection.startIndex, upper: collection.endIndex)) return relative(to: bounds, offsettingBy: collection.index(_:offsetBy:)) } } A full working prototype of RangeExpression and the IncompleteRange types is available in this pull request. Impact on existing code Obviously, any code using these APIs under their old names or designs would have to be transitioned to the new names and designs. The sequence-end operations would be by far the simplest to handle; these are simple renamings and could be handed by @available(renamed:) and migration support. The only complication is that some overloads have transitioned to a new base name, while others have stayed with the old one, but we suspect the migrator is up to this task. The index-based operations are more difficult to migrate. The patterns would be roughly: collection.prefix(upTo: i) =&gt; collection[..&lt;i] collection.prefix(through: i) =&gt; collection[...i] collection.suffix(from: i) =&gt; collection[i..&lt;] A custom fix-it would be ideal, but is probably not necessary; an @available(message:) would do. Presumably this would have to be a special case in the migrator as well. The other changes to the handling of subranges are source-compatible. Alternatives considered skipping instead of removing If the type differences are seen as disqualifying removing as a replacement for drop, we suggest using skipping instead. There are, of course, many possible alternatives to skipping; this is almost a perfect subject for bikeshedding. We’ve chosen skipping because: It is not an uncommon word, unlike (say) omitting. This means non-native English speakers and schoolchildren are more likely to recognize it. It is an -ing verb, unlike (say) without. This makes it fit common Swift naming patterns more closely. It does not imply danger, unlike (say) dropping, nor some sort of ongoing process, unlike (say) ignoring. This makes its behavior more obvious. If you want to suggest an alternative on swift-evolution, please do not merely mention a synonym; rather, explain why it is an improvement on either these axes or other ones. (We would be particularly interested in names other than removing which draw an analogy to something else in Swift.) collection[to/through/from:] instead of IncompleteRange Rather than add new types and operators to replace prefix(upTo/through:) and suffix(from:), we could merely transform these methods into subscripts with parameter labels. This would be a simpler design, but these terms have proven imperfect in the stride calls, and labeled subscripts are rare (actually, we believe they’re unprecedented in the standard library). longestPrefix(where:) instead of prefix(while:) The name prefix(while:) isn’t perfect; it seems to imply more state than is really involved. (There is a stateful loop, but it’s contained within the method.) A name like longestPrefix(where:) might read better and avoid this implication, but we think it’s important that prefix(_:) and prefix(while:) be given parallel names, and longestPrefix(3) doesn’t make much sense. No RangeExpression protocol The RangeExpression protocol could be severed from this proposal, but this seems like a good opportunity to refactor our subrange handling. Other alternatives Rather than using first and last for the “First matching” and “Last matching” categories, we could use a distinct term. These methods have different performance characteristics than the others, and modeling that might be helpful. However, it’s difficult to find a good term—an earlier version of this proposal used earliest and latest, which don’t read perfectly—and the level of confusion is pretty low. We considered using first and last as the basis for both single-element and multiple-element operations (such that prefix(3) would become first(3), etc.), but: These seemed like distinct functionalities, particularly since their types are different. We’re not comfortable with heavily overloading a property with a bunch of methods, and didn’t want to make first and last into methods. Most APIs work fine, but hasFirst(_:) is atrocious, and we see no better alternative which includes the word first. We considered moving first and last to Sequence and possibly making them methods, but our understanding is that the core team has considered and rejected this approach in the past. We considered moving removingFirst and removingLast to Collection and making them properties, to match first and last, but this seemed like the sort of foolish consistency that Ralph Waldo Emerson warned of. Future directions Note: The rest of this proposal is highly speculative and there’s probably no need to read further. Other Sequence API cleanups Seriously source-breaking There is an ongoing discussion about which, if any, of map, flatMap, filter, and reduce ought to be renamed to more closely match Swift naming conventions. There is also discussion about relabeling many closure parameters. The “Future directions” section below suggests every(where:) as an alternative to filter which could be extended in ways compatible with this proposal. Significantly source-breaking The removeSubrange(_:) and replaceSubrange(_:with:) APIs are rather oddly named. They might be better renamed to, for instance, remove(in:) and replace(in:with:). It is not clear how important removingFirst() and removingLast() actually are, given that they’re exactly equivalent to removingPrefix(1) and removingSuffix(1), and their corresponding “get” members are on Collection instead of Sequence. They could be removed. Slightly source-breaking removeFirst/Last() and popFirst/Last() are very nearly redundant; their only difference is that the remove methods have a non-Optional return type and require the collection not be empty, while the pop methods have an Optional return type and return nil if it’s empty. These operations could be merged, with the remove operations taking on the preconditions of the current pop operations; additionally, removePrefix(_:) and removeSuffix(_:) could drop their equivalent preconditions requiring that the elements being removed exist. These changes would simplify the standard library and make these methods more closely parallel the equivalent removing methods, which do not have similar preconditions. Performance-critical code which wants to avoid the checks necessary to remove these preconditions could switch to remove(at:) and removeSubrange(_:), which would continue to reject invalid indices. Adding sequence and collection operations This exercise in renaming suggests all sorts of other APIs we might add, and a few we might rename. In general, we have not attempted to carefully scrutinize the usefulness of each of these APIs; instead, we have merely listed the ones which we can imagine some kind of use for. The main exception is the “Pop” operation; we can imagine several different, and rather incompatible, ways to extend it, and we’re not going to take the time to sort out our thoughts merely to write a “Future directions” section. Filling in the sequence-end API table The gaps in the table suggest a number of APIs we could offer in the future. Here, we have filled in all options which are at least coherent:   Get Index Exclude Remove (1) Pop (1) Equate (2) Fixed Size             First 1 C.first C.firstIndex S.removingFirst() C.removeFirst() C.popFirst() - Last 1 C.last C.lastIndex S.removingLast() C.removeLast() C.popLast() - First (n: Int) S.prefix(_:) C.prefixIndex(_:) S.removingPrefix(_:) C.removePrefix(_:) - S.hasPrefix(_:)   …with closure S.prefix(while:) C.prefixIndex(while:) S.removingPrefix(while:) C.removePrefix(while:) - S.hasPrefix(_:by:) Last (n: Int) S.suffix(_:) C.suffixIndex(_:) S.removingSuffix(_:) C.removeSuffix(_:) - S.hasSuffix(_:)   …with closure S.suffix(while:) C.suffixIndex(while:) S.removingSuffix(while:) C.removeSuffix(while:) - S.hasSuffix(_:by:) Searching From End             First matching element S.first(_:) C.firstIndex(of:) S.removingFirst(_:) C.removeFirst(_:) - -   …with closure S.first(where:) C.firstIndex(where:) S.removingFirst(where:) C.removeFirst(where:) - - Last matching element S.last(_:) C.lastIndex(of:) S.removingLast(_:) C.removeLast(_:) - -   …with closure S.last(where:) C.lastIndex(where:) S.removingLast(where:) C.removeLast(where:) - - To explain a few entries which might not be immediately obvious: firstIndex and lastIndex would be nil if the collection is empty, and lastIndex would be the index before endIndex. prefixIndex would return the last index of the prefix, and suffixIndex would return the first index of the suffix; alternatively, these could be named with Indices and return ranges. first(_:) and last(_:) would return the first and last element equal to the provided value; on a Set, they would be roughly equivalent to NSSet.member(_:). The changes we consider most worthy include: Adding corresponding last and suffix methods for all first and prefix methods. Adding corresponding while: versions of all appropriate prefix/suffix APIs. Ones that could be useful, but can usually be emulated with more work: Adding remove/removing-by-content APIs. Adding prefix/suffixIndex(while:). Ones that are mere conveniences or may not have strong use cases: first/lastIndex and prefix/suffixIndex(_:). first/last(_:). “All” and “Every” as operands One could imagine adding rows to this table for “all” and “every matching”. In addition to creating some useful new API, this would also suggest some interesting renaming for existing APIs: allIndices would be a name for indices. removeAll() is actually an existing name which happens to fit this pattern. every(where:) would be a name for filter. Though some of us believe filter is a strong term of art, we do note that every(where:) does not cause confusion about the sense of its test, a major complaint about filter. In the table below, bold indicates new functionality; italics indicates existing functionality renamed to fit this pattern.   Get Index Exclude Remove (1) Pop (1) Equate (2) Fixed Size             First 1 C.first C.firstIndex S.removingFirst() C.removeFirst() C.popFirst() - Last 1 C.last C.lastIndex S.removingLast() C.removeLast() C.popLast() - First (n: Int) S.prefix(_:) C.prefixIndex(_:) S.removingPrefix(_:) C.removePrefix(_:) - S.hasPrefix(_:)   …with closure S.prefix(while:) C.prefixIndex(while:) S.removingPrefix(while:) C.removePrefix(while:) - S.hasPrefix(_:by:) Last (n: Int) S.suffix(_:) C.suffixIndex(_:) S.removingSuffix(_:) C.removeSuffix(_:) - S.hasSuffix(_:)   …with closure S.suffix(while:) C.suffixIndex(while:) S.removingSuffix(while:) C.removeSuffix(while:) - S.hasSuffix(_:by:) All - allIndices - C.removeAll() - - Searching From End             First matching element S.first(_:) C.firstIndex(of:) S.removingFirst(_:) C.removeFirst(_:) - -   …with closure S.first(where:) C.firstIndex(where:) S.removingFirst(where:) C.removeFirst(where:) - - Last matching element S.last(_:) C.lastIndex(of:) S.removingLast(_:) C.removeLast(_:) - -   …with closure S.last(where:) C.lastIndex(where:) S.removingLast(where:) C.removeLast(where:) - - Every matching element S.every(_:) C.everyIndex(of:) S.removingEvery(_:) C.removeEvery(_:) - -   …with closure S.every(where:) C.everyIndex(where:) S.removingEvery(where:) C.removeEvery(where:) - - An alternative to the every methods is to give them names based on all or any, but these tend to require breaks from the naming patterns of the matching first and last methods to remain grammatical.",
    "url": "http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html",
    "relUrl": "/docs/2019-08-26-0132-sequence-end-ops.html"
  },
  "132": {
    "id": "132",
    "title": "SE-0133 Rename `flatten()` to `joined()`",
    "content": "Rename flatten() to joined() Proposal: SE-0133 Author: Jacob Bandes-Storch Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#3809, apple/swift#3838, apple/swift#3839 Introduction Swift currently defines two similar functions, joined(separator:) and flatten(). joined(separator:) has a specialized implementation for Strings, and flatten() has implementations for various kinds of collections. extension Sequence where Iterator.Element : Sequence { public func joined&lt;Separator: Sequence&gt;(separator: Separator) -&gt; JoinedSequence&lt;Self&gt; public func flatten() -&gt; FlattenSequence&lt;Self&gt; } extension Collection where Element : Collection { // and similar variants public func flatten() -&gt; FlattenCollection&lt;Self&gt; } This proposal renames flatten() to joined() (with no separator argument). It also adds a default separator of &quot;&quot; to the String-specific version of joined(separator:). https://github.com/apple/swift/blob/f72a82327b172e1a2979e46cb7a579e3cc2f3bd6/stdlib/public/core/Join.swift https://github.com/apple/swift/blob/c6e828f761fc30f7ce444431de7da52814f96595/stdlib/public/core/String.swift#L769 https://github.com/apple/swift/blob/f72a82327b172e1a2979e46cb7a579e3cc2f3bd6/stdlib/public/core/Flatten.swift.gyb Swift-evolution threads: [Pitch] Unify joined(separator:) and flatten() [Pitch] Rename flatten() to joined() and give joined() for string sequences the empty string as the default parameter Motivation To a user, there should be no distinction between flatten()ing a sequence or collection, and “joining” it with no separator. Hence, the following expressions should be valid: [[1,2],[3]].joined() // [1,2,3] -- currently named flatten() [[1,2],[3]].joined(separator: []) // [1,2,3] [[1,2],[3]].joined(separator: [0]) // [1,2,0,3] [&quot;ab&quot;,&quot;d&quot;].joined() // &quot;abd&quot; -- currently no nullary function to do this [&quot;ab&quot;,&quot;d&quot;].joined(separator: &quot;&quot;) // &quot;abd&quot; [&quot;ab&quot;,&quot;d&quot;].joined(separator: &quot;_&quot;) // &quot;ab_d&quot; Proposed solution Rename flatten() to joined() with no argument. For now, it’s acceptable to keep the code currently in Join.swift and that in Flatten.swift.gyb separate — in the future it might make sense to unify the algorithms. The String-specific version of joined(separator:) is independent of the Sequence protocol extension (since String is not a Sequence), but the functionality is still useful. For consistency, a default value of &quot;&quot; should be added to the separator parameter: extension Sequence where Iterator.Element == String { func joined(separator: String = &quot;&quot;) -&gt; String { ... } } (Or, if the standard library team deems it a better solution, joined() could be a separate method that simply calls joined(separator: &quot;&quot;).) Impact on existing code Users of flatten() will need to migrate to joined(); this is straightforward with an availability attribute. Application behavior should not change. Alternatives considered An alternative is to leave flatten() and joined(separator:) as separate APIs. The distinction, however, seems unnecessary, and unifying them is a minor win for API clarity.",
    "url": "http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html",
    "relUrl": "/docs/2019-08-26-0133-rename-flatten-to-joined.html"
  },
  "133": {
    "id": "133",
    "title": "SE-0134 Rename two UTF8-related properties on String",
    "content": "Rename two UTF8-related properties on String Proposal: SE-0134 Authors: Xiaodi Wu, Erica Sadun Review Manager: Chris Lattner Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#3816 Previous Revision: 1 Introduction This proposal removes nulTerminatedUTF8 and renames nulTerminatedUTF8CString to enhance clarity and reduce mismatch between user expectations and the Swift programming language. Swift-evolution thread: Discussion thread Motivation Both nulTerminatedUTF8 and nulTerminatedUTF8CString are poorly named for the following reasons: Inappropriate abbreviation of a term of art: The ASCII names for 0 are “null character” or “null terminator”. Both properties instead use the ASCII abbreviation “NUL” in place of the English word “null”. A Google search returned approximately 20,000 results for “NUL-terminated string” and approximately 200,000 results for “null-terminated string”. Impaired recognition: “NUL” is less recognizable than “null”. Further, “NUL” suffers from reduced recognition when written in lowercase: nulTerminated. Hindered source completion: When using source editor completion, users who type “null” will not find a property named nulTerminatedUTF8 or nulTerminatedUTF8CString. Redundant terminology: C strings are terminated by the null character. Using both “C string” and “null-terminated” is redundant and, to some, could unintentionally raise questions as to whether some C strings might not be null-terminated. This proposal removes nulTerminatedUTF8 and eliminates the redundancy in nulTerminatedUTF8CString. Detailed design This proposal introduces the following changes to the Swift standard library: Rename nulTerminatedUTF8CString to utf8CString. Remove nulTerminatedUTF8. utf8CString This property renaming follows the precedent of the related Foundation method cString(using: .utf8) and lowercases its leading utf8. nulTerminatedUTF8 This property is a null-terminated contiguous array of a string’s UTF8 representation. The core team has indicated that clients would be better served by using the utf8CString property and has concluded that nulTerminatedUTF8 should be removed outright. Impact on existing code Fix-its will be needed to help transition existing code. Alternatives considered The alternative is not to rename the stated properties.",
    "url": "http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html",
    "relUrl": "/docs/2019-08-26-0134-rename-string-properties.html"
  },
  "134": {
    "id": "134",
    "title": "SE-0135 Package Manager Support for Differentiating Packages by Swift version",
    "content": "Package Manager Support for Differentiating Packages by Swift version Proposal: SE-0135 Author: Anders Bertelrud Review Manager: Daniel Dunbar Status: Implemented (Swift 3) Decision Notes: Rationale Introduction As new, source-incompatible versions of Swift come into use, there is a growing need for packages to be authored in a way that makes them usable from multiple versions of Swift. While package authors want to adopt new Swift versions as soon as possible, they also need to support their existing clients. Source incompatibilities can arise not only from changes to the language syntax, but also from changes to the Swift Standard Library and the Package Description API of the Swift Package Manager itself. Support for multiple Swift versions could in theory be implemented using #if directives in the package source code, but that approach can become unwieldy when the required code differences are significant. The Swift Package Manager should therefore provide facilities that make it as easy as possible for package authors to support clients using different versions of Swift. The proposal described here intends to solve an immediate need for Swift Package Manager 3; the need for version-specific packages will hopefully diminish as the language and libraries stabilize. We can revisit the need for this support in a future version of Swift. Motivation It is important to allow Swift users to migrate to new Swift versions as easily as possible. At the same time, packages need to stay compatible with existing clients who are not yet ready to migrate. A new version of Swift means a new version of the language, the Standard Library API, and SwiftPM’s own Package Description API. In some cases it’s possible to use #if directives to let a single source base build using different versions of Swift. When the code differences are significant, however, it’s impractical to use conditional code, and some other way to differentiate is needed. This is particularly true for new versions of the Swift Package Manager, as the manifest format evolves. Making this practical requires some improvements to the Package Manager, but to see why, it is useful to look at why current workarounds would be impractical: Impractical workaround #1: A strategy that wouldn’t require any Swift Package Manager changes would be to require package authors to tie the semantic versions(1) of their packages to specific versions of Swift itself. For example, a package author could decide that version 1 of their package would work only with Swift 2.3, and package version 2 would work only with Swift 3. Using different package versions for the different Swift versions would take advantage of the Package Manager’s existing version matching logic to make sure that the right package is chosen, and the right package for the Swift version would automatically be chosen. However, this doesn’t seem like a particularly acceptable restriction, since it ties the release cycles of packages to those of Swift itself. This coupling between new Swift versions and new versions of all packages in use by a client would introduce significant revlock, which may seriously impact adoption. In particular, a client that wanted or needed to migrate to a new version of a package couldn’t do so until they also migrated to a new version of Swift itself. In addition, they would at the same time have to migrate to newer versions of any other package on which they depend (assuming that such newer versions even exist). This is particularly unfortunate in cases in which only the package manifest needs to be different, since that would cause a package that could otherwise support multiple Swift versions to have to bifurcate. What is needed is a way to allow differentiation of packages by not just their own semantic version, but also the version of Swift being used. Impractical workaround #2: Another possible strategy would be to choose package version numbers that also incorporate the version of Swift they require, thereby “flattening” the two version numbers involved (package version and Swift version) into one. One could come up with various schemes for this, such as assigning odd-valued package version numbers to prerelease versions of the Swift language, and even-valued package version numbers to release versions of the Swift language. But this would pollute the version space, and it also sends the wrong message about semantic versioning (which is a strategy that we want package authors to use). Encouraging the abuse of the major version number for other things than the package API is not in the best interest of the maintainability of the package ecosystem. Solution Goals The solution needs to: ensure that the established package ecosystem graph continues to work as-is, even as packages supporting new Swift versions are published support parallel co-existence of actively maintained package graphs for: the latest stable (release) version of Swift the most recent pre-release version of Swift any older versions of Swift that still need to be supported (note that “Swift version” here includes not just the syntax of the language, but also the Standard Library API and the Package Description API) The Swift Package Manager should make it as easy as possible for a package to support multiple Swift versions using a single package repository, when that is possible with respect to the magnitude of the requires source differences). An additional, more abstract goal, is to encourage the whole Swift ecosystem to move forward as quickly as possible. This means optimizing for a workflow that involves latest-GM, current-prerelease, and current-development version, but ideally not a long tail of old GM versions. Proposed Solution There are two parts to the proposed solution: provide package authors with a way to differentiate package repository version tags by Swift version, to support multiple editions of a single semantic package version provide package authors with a way to provide multiple package manifests for a single package version tag, differentiated by Swift version In both cases, version-based name suffixes are used to allow Package Manager to resolve dependencies based on package version as well as Swift version. Version-differentiated package tags When selecting the version of a package dependency to use for a particular client, the Swift Package Manager uses a repository tag naming convention based on the specified version restrictions of the package. For example, a client that specifies this dependency in its Package.swift: .Package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git&quot;, majorVersion: 2) causes the package manager to look for tags in the form of a semantic version (see semver.org for more information). In this example, only tags having a major version number of 2 are considered, and the highest version among them is the one that is selected. Other restrictions involving minor versions and version ranges can be specified in the client’s Package.swift manifest. Regardless of how the desired version restrictions are specified, the highest semantic version that matches the restrictions is the one that is selected when resolving dependencies. This proposal would allow an optional Swift version to appended to the package version, separated from it by a @swift- string. This can be used to provide two separate tags for the same package version, differentiated only by Swift version. For example, version 1.0 of MyPackage could have a 1.0@swift-2.3 tag and a 1.0@swift-3 tag. The expected use case for this is when the differences required to support two or more versions of Swift are large enough that it would be impractical to implement them in the same checkout of the repository. The new logic would first look for tag names having such a Swift version suffix that matches the version of Swift the client wants to use, and if found, omits from consideration any tags that do not have that suffix. The existing logic would be applied to the remaining set of tag candidates. The format of the swift version is not itself a semantic version, but instead follows the Swift marketing versions used. For matching, the number of digits specified affects the precision of the matching; for example, @swift-3 would match any version Swift 3.x.x version, while @swift-3.0 would match only Swift 3.0.x but not Swift 3.1 etc. The most specific version suffix matching the client’s Swift version is used. For example, if both a @swift-3 and a @swift-3.1 tag are found, Swift 3.1 would use the latter and Swift 3.2 would use the former. If no tag names have the Swift version suffix, the matching would work as it currently does, using only the package version restrictions. Version-differentiated package manifests Creating Swift-versioned tags for a particular package version has maintenance consequences. When possible, it’s more maintainable for a package to support multiple Swift versions in a single tag of a repository. In the ideal case, no source changes are required at all in order to support two different Swift versions (this is the case, for example, between Swift 2.2 and Swift 2.3). When the required changes are minimal and a single package manifest can be used, #if directives in the source code can be used to support any other differences between the Swift versions. This already works today. For the Package.swift manifest itself, though, it can be somewhat unwieldy to express differences using only #if directives. This is the case whether the differences are due to language syntax changes (recall that Package.swift manifests are actually Swift source files) or due to changes in the Package Description API. To support this, this proposal would allow a Swift version to be appended to the base Package base name, separated from it by the string @swift-. For example, a package manifest specific to Swift 2.3 would have the file name Package@swift-2.3.swift, while one that worked for any Swift 3.x version would be Package@swift-3.swift. As with versioned tags, in the absence of a version-specific Package.swift file, the Package Manager would use the regular Package.swift file. Often, a package author would use either version-differentiated package tags or version-differentiated package manifests, but they could also be used together when that makes sense. It is hoped that as the Swift language stabilizes and packages eventually drop support for older versions of Swift, many packages will be able to discard the version-specific variants and keep only Package.swift. Impact on existing code There is not expected to be any impact on existing code, since this proposal adds on top of existing functionality. Alternatives Do nothing and let package authors invent their own ways. For the reasons spelled out in the Motivation section, this very undesirable. However, given how close we are to Swift 3’s completion date, there is a possibility that there will not be time to implement this proposal for Swift 3. The consequence would be that future changes to the Package Description API would cause existing packages to break, which could significantly obstruct package adoption of new versions of Swift. Add declarations to the Package.swift manifest to specify the required Swift version or version range. This has a number of problems, including the fact that all of the various manifests would need to be checked out before deciding which to exclude from consideration. Another problems is that such minimum-version requirement declarations would have to be able to be parsed by older versions of the Package Manager, and this is not a guarantee we can make (the manifest might not be parseable using an older version of Swift).",
    "url": "http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html",
    "relUrl": "/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html"
  },
  "135": {
    "id": "135",
    "title": "SE-0136 Memory layout of values",
    "content": "Memory layout of values Proposal: SE-0136 Author: Xiaodi Wu Review Manager: Dave Abrahams Status: Implemented (Swift 3) Decision Notes: Rationale Implementation: apple/swift#4041 Introduction This proposal is to introduce, as a bugfix, a replacement for sizeofValue(_:) and related functions. Swift-evolution thread: MemoryLayout for a value Motivation Members of the core team, having seen a negative impact on the standard library and other code on implementation of SE-0101, have expressed concern that removal of sizeofValue(_:) and related functions without replacement was a mistake. In the standard library, the current workaround makes use of an underscored API: MemoryLayout._ofInstance(x).size. Proposed solution The proposed solution is to re-introduce sizeofValue(_:) and related functions as static methods on MemoryLayout. They would be expressed as follows: MemoryLayout.size(ofValue: x) MemoryLayout.stride(ofValue: x) MemoryLayout.alignment(ofValue: x) Detailed design The implementation will be as follows: extension MemoryLayout { @_transparent public static func size(ofValue _: T) -&gt; Int { return MemoryLayout.size } @_transparent public static func stride(ofValue _: T) -&gt; Int { return MemoryLayout.stride } @_transparent public static func alignment(ofValue _: T) -&gt; Int { return MemoryLayout.alignment } } Impact on existing code No applications will stop compiling due to this change. Standard library implementations that currently use the underscored _ofInstance(_:) will be migrated. Alternatives considered Autoclosure Previously, it has been suggested that the parameter should have an @autoclosure attribute so that the argument is not evaluated. However, such a use of the attribute would be unprecedented in the standard library. Current uses of @autoclosure in the standard library such as assert(_:_:file:line:) do evaluate the autoclosure. Furthermore, in general, a reader expects foo(bar(x)) to invoke both bar(_:) and foo(_:). In fact, during implementation of SE-0101, concern was raised that potential use of expressions such as strideofValue(iter.next()) (where iter is an instance of an iterator), might rely on the side effect of evaluating the argument. By contrast, no use case has yet surfaced where it is necessary to obtain the memory layout stride for the result of an expression that also must not be evaluated. Making use of type(of:) Concerns about confusability of the ofValue functions and their “non-value” counterparts led to the proposal that a spelling such as MemoryLayout.of(type(of: x)).size might be desirable. In that case, the method of(_:) would take an argument of type T.Type rather than T. However, this alternative would produce the consequence that each use of MemoryLayout&lt;Int&gt;.size would be interchangeable with MemoryLayout.of(Int.self).size, potentially leading to confusion about why the standard library provides an apparently duplicative API. Furthermore, Dmitri Gribenko points out that the use of type(of:) could increase confusion about these methods when the dynamic type of a value differs from the static type. Consider a protocol existential: protocol P {} extension Int : P {} var x: P = 1 Even though type(of:) has the semantics of returning the dynamic type, MemoryLayout.of(type(of: x)).size computes the size of the existential box and not the size of an instance of type Int. This is because type(of: x) returns a value of Int.self statically typed as P.Type, with the result that P is the type deduced for the generic parameter of MemoryLayout. Subsuming MemoryLayout into a reflection API The design of a reflection API would exceed the scope of a Swift 3 bugfix. Acknowledgments Thanks to Dave Abrahams and Dmitri Gribenko.",
    "url": "http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html",
    "relUrl": "/docs/2019-08-26-0136-memory-layout-of-values.html"
  },
  "136": {
    "id": "136",
    "title": "SE-0137 Avoiding Lock-In to Legacy Protocol Designs",
    "content": "Avoiding Lock-In to Legacy Protocol Designs Proposal: SE-0137 Authors: Dave Abrahams, Dmitri Gribenko Review Manager: John McCall Status: Implemented (Swift 3) Decision Notes: Rationale Introduction We propose to deprecate or move protocols that shouldn’t be a part of the standard library’s public API going forward. Swift-evolution threads: Late Pitch, Review Motivation We’ve always known that when Swift reached ABI stability (now slated for Swift 4), we would be committed to supporting many of the standard library’s design decisions for years to come. We only realized very recently that, although Swift 3.0 is not shipping with a stable ABI, the promise that Swift 3.0 code will work with Swift 4.0 means that many of the standard library’s protocols will be locked down now. Especially where these protocols show up in refinement hierarchies, we won’t be able to keep Swift 3 code working in the future without carrying them forward into future standard library binaries. Proposed solution The proposed changes are as follows: Deprecate the Indexable protocols with a message indicating that they will be gone in Swift 4. These protocols are implementation details of the standard library designed to work around language limitations that we expect to be gone in Swift 4. There’s no reason for anyone to ever touch these; users should always use a corresponding Collection protocol (e.g. instead of MutableIndexable, use MutableCollection). See this pull request for the detailed design. (This pull request was merged prematurely but will be reverted if the change isn’t approved). Deprecate the ExpressibleByStringInterpolation protocol with a message indicating that its design is expected to change. We know this protocol to be mis-designed and limited, but there’s no time to fix it for Swift 3. If we knew how the new design should look, we might be able to calculate that the current API is supportable in a forward-compatible way (that’s the case for Comparable, for example). Unfortunately, we do not know that yet. See this pull request for the detailed design. Rename Streamable to TextOutputStreamable and add a deprecated Streamable typealias for it. Now that OutputStream been renamed to TextOutputStream, we should also move Streamable out of the way, at least to reduce confusion if and when the name is reused for other purposes. See the following pull requests for the detailed design. (These pull requests were merged prematurely but will be reverted if the change isn’t approved). Multiple pull requests were used to keep the contiguous integration system healthy. https://github.com/apple/swift/pull/4130 https://github.com/apple/swift-package-manager/pull/590 https://github.com/apple/swift/pull/4131 Detailed design See the pull requests referenced above. Impact on existing code No code will stop compiling or behave differently due to this change, though the deprecations will produce warnings. Automatic migration will handle the renaming of Streamable, but other adjustments to suppress the warnings will have to be made manually. Alternatives considered We considered deprecating much more than just protocols, but on reconsideration, we think our other legacy APIs do not result in the same kind of lock-in for the standard library.",
    "url": "http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html",
    "relUrl": "/docs/2019-08-26-0137-avoiding-lock-in.html"
  },
  "137": {
    "id": "137",
    "title": "SE-0138 UnsafeRawBufferPointer",
    "content": "UnsafeRawBufferPointer Proposal: SE-0138 Author: Andrew Trick Review manager: Dave Abrahams Status: Implemented (Swift 3.0.1) Decision Notes: Rationale Contents: Introduction Motivation Proposed Solution Migration Examples Detailed design Implementation status Impact on existing code Alternatives considered Introduction This is a purely additive proposal to improve the Swift 3 migration experience. SE-0107: UnsafeRawPointer formalized Swift’s memory model with respect to strict aliasing and prevented arbitrary conversion between UnsafePointer types. When moving to Swift 3, users will need to migrate much of their code dealing with UnsafePointers. The new UnsafeRawPointer makes that possible. It provides a legal means to operate on raw memory (independent of the type of values in memory), and it provides an API for binding memory to a type for subsequent normal typed access. However, migration is not always straightforward because SE-0107 provided only minimal support for raw pointers. Extending raw pointer support to the UnsafeBufferPointer type will fill in this funcionality gap. This is especially important for code that currently views “raw” bytes of memory as UnsafeBufferPointer&lt;UInt8&gt;. Converting between UInt8 and the client’s element type at every API transition is difficult to do safely with the bindMemory API, but that can be avoided entirely by changing the type the represents a view into raw bytes to UnsafeRawBufferPointer. For more background, see the UnsafeRawPointer Migration Guide. Swift-evolution threads: Week #1 Week #2 Week #3 Week #4 (1) Week #4 (2) Week #5 Motivation This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing UnsafeRawPointer. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should do everything possible in the remaining time to improve the migration experience and encourage correct use of the memory model by introducing this low-risk additive API. Almost all API’s that use raw pointers need to pass or return a length associated with the raw memory “buffer”. It is obvious that providing a type that encapsulates a raw pointer with length would improve the safety and readability of all of these interfaces. It would also support automatic debug-mode bounds checking on each side of the interface. In the short time that users have been migrating code, I have already seen several cases that view raw memory as a collection of UInt8 values. It is natural for the same type that encapsulates a raw pointer and length to also allow clients to view that memory as raw bytes without the need to explicitly bind the memory type each time memory is accessed. This would also improve performance in some cases that I’ve encoutered by avoiding array copies. Let’s call this new type Unsafe[Mutable]RawBufferPointer. Any array could be viewed as UnsafeRawBufferPointer, and that raw view of the bytes could be used by any interface that expects a collection of UInt8. An new array method withUnsafeBytes could expose this raw view of the array as a sequence of bytes as follows: let intArray = [1, 2, 3] var byteBuffer = [UInt8]() intArray.withUnsafeBytes { byteBuffer += $0 assert(byteBuffer[0..&lt;4] == [1, 0, 0, 0]) for (i, b) in $0.enumerated() { assert(b == byteBuffer[i]) } } Any data type could be safely passed to APIs that work with raw memory via UnsafeRawBufferPointer, such as output streams and flat buffers. A new withUnsafeBytes function could view a value as a sequence of bytes as follows: func write(bytes: UnsafeRawBufferPointer) { ... } // imported struct Header struct Header {...} var header = Header(...) withUnsafeBytes(of: &amp;header) { write(bytes: $0) } Data of any type could be loaded from raw memory that was constructed as an array of UInt8: func readHeader(fromBytes bytes: UnsafeRawBufferPointer) -&gt; Header { return bytes.load(as: Header.self) } let array: [UInt8] = ... let header = array.withUnsafeBytes { readHeader(fromBytes: $0) } Foundation Data already provides high-level, safe encapsulation of raw memory and is the common currency for passing raw memory across framework boundaries. Data owns its underlying memory, provides value semantics, and performs release-mode bounds checks. The proposed UnsafeRawBufferPointer is an unowned view into an arbitrary slice of memory. Once UnsafeRawBufferPointer is in place, the Data API can be extended to more safely interoperate with UnsafePointers. Proposed solution Introduce UnsafeRawBufferPointer and UnsafeMutableRawBufferPointer types, which will respectively conform to Collection and MutableCollection of UInt8. These types will provide a debug-mode bounds-checked subset of Unsafe[Mutable]RawPointer’s interface to raw memory: load(fromByteOffset:as:), storeBytes(of:toByteOffset:as:), and copyBytes(from:count:). Please see the doc comments provided in Detailed design. Add an Array.withUnsafe[Mutable]Bytes&lt;R&gt;(_) method that passes an UnsafeRawBufferPointer view of the array buffer to the closure body. Add a withUnsafeMutableBytes&lt;T, R&gt;(of:_) function that passes an UnsafeRawBufferPointer view of a value of type T to the closure body. Amendment to normalize the slice type The original version of this proposal defined Unsafe[Mutable]BufferPointer to be its own SubSequence type. This is the Collection’s slice type returned by a range subscript getter. Using a single type for buffers and buffer slices is very convenient for working with flat memory regions, but it is inconsistent with Swift’s Collection semantics. The problem is that it transparently rebases the slice’s Int-type indices to zero. This has the potential to break generic algorithms, which expect to use the same indices across both the original Collection and its slices. The amended version of this proposal changes SubSequence to [Mutable]RandomAccessSlice&lt;Unsafe[Mutable]RawBufferPointer&gt; rebasing initializers have been added to allow explicit conversion from a slice to a zero-based Unsafe[Mutable]RawBufferPointer. This results in the following behavioral changes: Passing a region within buffer to another function that takes a buffer can no longer be done via subscript: Incorrect: takesRawBuffer(buffer[i..&lt;j]) This now requires an explicit cast: Correct: takesRawBuffer(UnsafeRawBufferPointer(rebasing: buffer[i..&lt;j])) Subscript assignment directly from a buffer no longer compiles: Incorrect: buffer[n..&lt;m] = smaller_buffer This now requires creation of a slice from the complete source buffer: Correct: buffer[n..&lt;m] = smaller_buffer.suffix(from: 0) UnsafeRawBufferPointer’s slice type no longer has a nonmutating subscript setter. So assigning into a mutable let buffer no longer compiles: let slice = buffer[n..&lt;m] slice[i..&lt;j] = buffer[k..&lt;l] The assigned buffer slice now needs to be a var. var slice = buffer[n..&lt;m] slice[i..&lt;j] = buffer[k..&lt;l] Migration Examples Consider these real code migration examples: Network messages, see below. swift-package-manager/OutputByteStream mzaks/FlatBuffersSwift owensd/json-swift This is a small sample of projects that popped up during initial migration. As migration proceeds, more examples continue to surface that would benefit from UnsafeRawBufferPointer. Ideally, code that manages untyped memory buffers can now do so with Foundation’s Data API, avoiding unsafe code altogether. However, when code does drop down the level of UnsafePointer, it should be natural to use the unsafe APIs correctly. As these examples show, UnsafeRawBufferPointer makes it natural to use unsafe pointers correctly when dealing with raw bytes. Network Messages This is a simplified example derived from production code encountered during migration. Originally, this code was reading and writing messages in a UInt8 buffer, then recasting an UnsafePointer to other data types while decoding the message. This is undefined behavior, but was the most reasonable way to solve the problem given existing APIs. Without providing an alternative, developers are resorting to unsafeBitCast or assumingMemoryBound in these cases to force code to compile, which doesn’t make the code any more correct. This is the code after “forced” migration, without fixing memory model issues: // Original Handler... var handler: (Int32, [UInt8]) -&gt; () = { _ in } func handleMessages(_ start: UnsafePointer&lt;UInt8&gt;, _ count: Int) -&gt; Int { var start = start var count = count while count &gt; MemoryLayout&lt;Int32&gt;.size * 2 { let headerSize = MemoryLayout&lt;Int32&gt;.size * 2 let channelID = Int32(unsafeBitCast(start, to: UnsafePointer&lt;Int32&gt;.self).pointee) let payloadSize = Int(unsafeBitCast(start.advanced(by: MemoryLayout&lt;Int32&gt;.size), to: UnsafePointer&lt;Int32&gt;.self).pointee) let totalSize = headerSize + payloadSize if count &lt; totalSize { break } handler(channelID, Array&lt;UInt8&gt;(UnsafeBufferPointer( start: start.advanced(by: headerSize), count: payloadSize))) // Advance to the start of the next packet. start = start.advanced(by: totalSize) count -= totalSize } return count } UnsafeRawBufferPointer provides a convenient way to rewrite the handler and eliminate undefined behavior: // Updated Handler... // imported struct Header struct Header { var channel: Int32 var payloadSize: Int32 } var handler: (_ channel: Int32, _ bytes: UnsafeRawBufferPointer) -&gt; () = { _, _ in } func handleMessages(_ bytes: UnsafeRawBufferPointer) -&gt; Int { var index = 0 while true { let payloadIndex = index + MemoryLayout&lt;Header&gt;.stride if payloadIndex &gt; bytes.count { break } let header = bytes.load(fromByteOffset: index, as: Header.self) index = payloadIndex + Int(header.payloadSize) if index &gt; bytes.count { break } handler(header.channel, bytes[payloadIndex ..&lt; index]) } return bytes.count - index } Now consider the original code that calls this handler: // Original input driver... // imported func read(from fd: Int32, p: UnsafeMutableRawPointer, n: Int) { ... } func read(from fd: Int32) { var data: [UInt8] = [] let tmpBufferSize = 4096 let tmp = UnsafeMutableBufferPointer( start: UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: tmpBufferSize), count: tmpBufferSize) while true { let result = read(self.inputFD, tmp.baseAddress, tmpBufferSize) assert(result &gt;= 0) if result == 0 { break } if data.count != 0 { data.append( contentsOf: UnsafeBufferPointer(start: tmp.baseAddress, count:result)) let remaining = data.withUnsafeBufferPointer { bufferPtr -&gt; Int in return self.extractAndHandleMessages( bufferPtr.baseAddress!, bufferPtr.count) } if (remaining != data.count) { data = Array&lt;UInt8&gt;(data[data.count - remaining..&lt;data.count]) } } else { let remaining = self.extractAndHandleMessages(tmp.baseAddress!, result) if remaining != 0 { data = Array&lt;UInt8&gt;(UnsafeBufferPointer( start: tmp.baseAddress!.advanced(by: result - remaining), count:remaining)) } } } tmp.baseAddress!.deallocate(capacity: tmpBufferSize) } The input driver should now be written using UnsafeRawBufferPointer as follows: // Updated input driver... // imported func read(from fd: Int32, p: UnsafeMutableRawPointer, n: Int) { ... } func read(from fd: Int32) throws { let tmpBuffer = UnsafeMutableRawBufferPointer.allocate(count: 4096) defer { tmpBuffer.deallocate() } let basePtr = tmpBuffer.baseAddress! var position = 0 while true { let result = read(fd, basePtr + position, tmpBuffer.count - position) if (result &lt; 0) { throw FileError() } if result == 0 { break } let dataBytes = UnsafeRawBufferPointer(tmpBuffer.prefix(upTo: position + result)) let remaining = handleMessages(dataBytes) tmpBuffer.copyBytes(from: dataBytes.suffix(remaining)) position = remaining } } On the sender side, the original post-migration code is: // Original message send... // imported func write(from fd: Int32, p: UnsafeMutableRawPointer, n: Int) private func int32ToArray(_ value: UnsafePointer&lt;Int32&gt;) -&gt; [UInt8] { return Array&lt;UInt8&gt;(UnsafeBufferPointer&lt;UInt8&gt;( start: unsafeBitCast(value, to: UnsafePointer&lt;UInt8&gt;.self), count: MemoryLayout&lt;Int32&gt;.size)) } func send(_ channel: Int32, _ message: [UInt8]) throws { var channel = channel var length = Int32(message.count) let header = int32ToArray(&amp;channel) + int32ToArray(&amp;length) header.withUnsafeBufferPointer { ptr in let result = write(self.outputFD, ptr.baseAddress, ptr.count) if result &lt; 0 { throw FileError } } message.withUnsafeBufferPointer { ptr in let result = write(self.outputFD, ptr.baseAddress, ptr.count) if result &lt; 0 { throw FileError } } } With UnsafeRawBufferPointer, the sender code can be written as follows: // Updated message send... // imported func write(from fd: Int32, p: UnsafeMutableRawPointer, n: Int) func send(to fd: Int32, onChannel channel: Int32, message: UnsafeRawBufferPointer) throws { var header = Header(channel: channel, payloadSize: Int32(message.count)) try withUnsafeBytes(of: &amp;header) { let result = write(fd, $0.baseAddress!, $0.count) if (result &lt; 0) { throw FileError() } } let result = write(fd, message.baseAddress!, message.count) if (result &lt; 0) { throw FileError() } } swift-package-manager OutputByteStream UnsafeRawBufferPointer is a useful tool for composing APIs like Swift package manager’s OutputByteStream which needs to operate on raw memory independent of the type, and also needs to view that data as an array of bytes. Consider this current limitation of the OutputStream API: public final class LocalFileOutputStream { override final func writeImpl&lt;C: Collection&gt;(_ bytes: C) where C.Iterator.Element == UInt8 { // FIXME: This will be copying bytes but we don&#39;t have option currently. var contents = [UInt8](bytes) while true { let n = fwrite(&amp;contents, 1, contents.count, fp) Instead, UnsafeRawBufferPointer should be the common type for data handoff in the base class: public class OutputByteStream { func writeImpl(_ bytes: UnsafeRawBufferPointer) } Without claiming this is the best architecture for this utility, we can claim that the author should be able to implement the architecture they have chosen correctly and without unnecessary overhead. Moving to UnsafeRawBufferPointer fixes three design issues in this code that stem from inadequate support for raw memory. Fix #1: The public API of a high-performance utility no longer depends on a generic type conforming to a protocol. There was no reason for this utility to care about the type being streamed, so this was a significant unnecessary overhead. Fix #2: The LocalFileOutputStream subclass can now directly access the bytes without copying into an array: public final class LocalFileOutputStream { override final func writeImpl(_ bytes: UnsafeRawBufferPointer) { // Cast to a mutating raw pointer for legacy libc interop. let ptr = UnsafeMutableRawPointer(mutating: bytes.baseAddress!) while true { let n = fwrite(ptr, 1, contents.count, fp) ... The BufferedOutputByteStream subclass can continue working with a collection of bytes, so there’s no loss in functionality: public final class BufferedOutputByteStream: OutputByteStream { // FIXME: For inmemory implementation we should be share this buffer with OutputByteStream. // One way to do this is by allowing OuputByteStream to install external buffers. private var contents = [UInt8]() override final func writeImpl(_ bytes: UnsafeRawBufferPointer) { contents += bytes } Fix #3: OutputByteStream can be naturally redesigned as follows to directly access a buffer of raw memory, which is already bounds checked and never needs to grow. A subclass like BufferedOutputByteStream can continue to manage its buffer as an array. There are no extra copies or impedance mismatch between base class and subclass: public class OutputByteStream { private var buffer: UnsafeMutableRawBufferPointer private var position: Int = 0 private final var bufferedBytes: UnsafeRawBufferPointer { return UnsafeRawBufferPointer(buffer.prefix(upTo: position)) } private var availableBufferSize: Int { return buffer.count - position } class var bufferSize: Int { return 1024 } init() { buffer = UnsafeMutableRawBufferPointer.allocate(count: type(of: self).bufferSize) } deinit { buffer.deallocate() } private func appendToBuffer(_ bytes: UnsafeRawBufferPointer) { buffer[position ..&lt; position + bytes.count].copyBytes(from: bytes) position += bytes.count } func writeImpl(_ bytes: UnsafeRawBufferPointer) { fatalError(&quot;Subclasses must implement this&quot;) } public final func write(bytes: UnsafeRawBufferPointer) { if bytes.count &gt; availableBufferSize { appendToBuffer(bytes.prefix(upTo: availableBufferSize)) ... } ... } /// Write a sequence of bytes to the buffer. public final func write(_ bytes: ArraySlice&lt;UInt8&gt;) { bytes.withUnsafeBytes { write(bytes: $0) } } /// Write a sequence of bytes to the buffer. public final func write(_ bytes: [UInt8]) { bytes.withUnsafeBytes { write(bytes: $0) } } } /// In-memory implementation of OutputByteStream. public final class BufferedOutputByteStream: OutputByteStream { /// Default buffer size of the data buffer. override class var bufferSize: Int { return 0 } /// Contents of the stream. private var contents = [UInt8]() override public init() { super.init() } override final func writeImpl(_ bytes: UnsafeRawBufferPointer) { contents += bytes } } FlatBuffers Using UnsafeRawBufferPointer, the code for putting a value can be correctly expressed using UnsafeRawBufferPointer without binding memory: public final class FlatBufferBuilder { private var _data : UnsafeMutableRawBufferPointer var cursor = 0 // ignore left/right cursor for brevity. private var freeSpace { return _data.suffix(from: cursor) } public func put&lt;T : Scalar&gt;(value: T) { var v = value let c = MemoryLayout&lt;T&gt;.size increaseCapacity(c) // ... and align withUnsafeBytes(&amp;v) { freeSpace.copyBytes(from: $0, count: c) } cursor += c } public func put&lt;T : Scalar&gt;(value: UnsafePointer&lt;T&gt;, length: Int) { increaseCapacity(length) let ptr = _data.baseAddress! + cursor freeSpace.copyBytes(from: value, count: length) cursor += length } } FlatBufferReader can also be fixed with UnsafeRawBufferPointer: public final class FlatBufferReader { private var _data : UnsafeRawBufferPointer func fromBytes&lt;T : Scalar&gt;(at position: Int) -&gt; T { return _data.load(fromByteOffset: position, as: T.self) } public func get&lt;T : Scalar&gt;(objectOffset: Offset, propertyIndex: Int) -&gt; T { let propertyOffset = getPropertyOffset(propertyIndex) let position = Int(objectOffset + propertyOffset) return fromBytes(at: position) } } owensd/json-swift This JSON parsing library can accept struct Data input here. It then passes the bytes in data to a lower-level parse routine that operates directly on UnsafeBufferPointer. (The library accepts various input sources, including NSData and String, then drops down to unsafe pointer to avoid copying). During 3.0 migration, a call to `bindMemory(to:count:)` would need to be introduced to make it safe to reinterpret memory as `UInt8`: public typealias JSParsingSequence = UnsafeBufferPointer&lt;UInt8&gt; public static func parse(seq: JSParsingSequence) -&gt; JSParsingResult { ... } public static func parse(data: ) -&gt; JSParsingResult { let ptr = (data as NSData).bytes.bindMemory(to: UInt.self, count: data.length) let bytes = UnsafeBufferPointer&lt;UInt8&gt;(start: ptr, count: data.length) return parse(bytes) } This requires the developer to understand how the memory binding APIs work, which is unreasonable for normal interaction with Data. It also uses a deprecated interface to Data and has a lifetime bug. Getting bytes out of Data should now be done using withUnsafeBytes: public func parse(_ data: Data) { return data.withUnsafeBytes { bytes: UnsafeBufferPointer&lt;UInt8&gt; in parse(bytes) } } This now implicitly binds memory, which is a big improvement. However, there is no reason that the parser’s view of memory needs to to be typed as UnsafeBufferPointer&lt;UInt8&gt;. The JSON parser should operate on an UnsafeRawBufferPointer sequence, eliminating the need to bind memory at all. Once the Data interface is extended to support calling closures that take UnsafeRawBufferPointer, it will be possible to write a safer version of the code that completely avoids binding memory: public typealias JSParsingSequence = UnsafeRawBufferPointer public static func parse(data: NSData) -&gt; JSParsingResult { return data.withUnsafeBytes { bytes: UnsafeRawBufferPointer in parse(bytes) } } Detailed design % for mutable in (True, False): % Self = &#39;UnsafeMutableRawBufferPointer&#39; if mutable else &#39;UnsafeRawBufferPointer&#39; % Mutable = &#39;Mutable&#39; if mutable else &#39;&#39; /// A non-owning view over a region of memory as a Collection of bytes /// independent of the type of values held in that memory. Each 8-bit byte in /// memory is viewed as a `UInt8` value. /// /// Reads and writes on memory via `UnsafeRawBufferPointer` are untyped /// operations. Accessing this Collection&#39;s bytes does not bind the /// underlying memory to `UInt8`. The underlying memory must be bound /// to some trivial type whenever it is accessed via a typed operation. /// /// - Note: A trivial type can be copied with just a bit-for-bit /// copy without any indirection or reference-counting operations. /// Generally, native Swift types that do not contain strong or /// weak references or other forms of indirection are trivial, as /// are imported C structs and enums. /// /// In addition to the `Collection` interface, the following subset of /// `Unsafe${Mutable}RawPointer`&#39;s interface to raw memory is /// provided with debug mode bounds checks: /// - `load(fromByteOffset:as:)`, % if mutable: /// - `storeBytes(of:toByteOffset:as:)` /// - `copyBytes(from:count:)` % end /// /// This is only a view into memory and does not own the memory. Copying a value /// of type `Unsafe${Mutable}RawBufferPointer` does not copy the underlying /// memory. However, initialiing another collection, such as `[UInt8]`, with an /// `Unsafe${Mutable}RawBufferPointer` into copies bytes out of memory. /// /// Example: /// swift /// // View a slice of memory at someBytes. Nothing is copied. /// var destBytes = someBytes[0..&lt;n] /// /// // Copy the slice of memory into a buffer of UInt8. /// var byteArray = [UInt8](destBytes) /// /// // Copy another slice of memory into the buffer. /// byteArray += someBytes[n..&lt;m] /// /// % if mutable: /// And assigning into a range of subscripts copies bytes into the memory. /// /// Example (continued): /// swift /// // Copy a another slice of memory back into the original slice. /// destBytes[0..&lt;n] = someBytes[m..&lt;(m+n)] /// /// % end /// TODO: Specialize `index` and `formIndex` and /// `_failEarlyRangeCheck` as in `UnsafeBufferPointer`. public struct Unsafe${Mutable}RawBufferPointer : ${Mutable}Collection, RandomAccessCollection { public typealias Index = Int public typealias IndexDistance = Int public typealias SubSequence = ${Mutable}RandomAccessSlice&lt;Unsafe${Mutable}RawBufferPointer&gt; /// An iterator for the bytes referenced by `${Self}`. public struct Iterator : IteratorProtocol, Sequence { /// Advances to the next byte and returns it, or `nil` if no next byte /// exists. /// /// Once `nil` has been returned, all subsequent calls return `nil`. public mutating func next() -&gt; UInt8? { if _position == _end { return nil } let result = _position!.load(as: UInt8.self) _position! += 1 return result } internal var _position, _end: UnsafeRawPointer? } % if mutable: /// Allocate memory for `size` bytes with word alignment. /// /// - Postcondition: The memory is allocated, but not initialized. public static func allocate(count size: Int) -&gt; UnsafeMutableRawBufferPointer { return UnsafeMutableRawBufferPointer( start: UnsafeMutableRawPointer.allocate( bytes: size, alignedTo: MemoryLayout&lt;UInt&gt;.alignment), count: size) } % end # mutable /// Deallocate this memory allocated for `bytes` number of bytes. /// /// - Precondition: The memory is not initialized. /// /// - Postcondition: The memory has been deallocated. public func deallocate() { _position?.deallocate( bytes: count, alignedTo: MemoryLayout&lt;UInt&gt;.alignment) } /// Reads raw bytes from memory at `self + offset` and constructs a /// value of type `T`. /// /// - Precondition: `offset + MemoryLayout&lt;T&gt;.size &lt; self.count` /// /// - Precondition: The underlying pointer plus `offset` is properly /// aligned for accessing `T`. /// /// - Precondition: The memory is initialized to a value of some type, `U`, /// such that `T` is layout compatible with `U`. public func load&lt;T&gt;(fromByteOffset offset: Int = 0, as type: T.Type) -&gt; T { _debugPrecondition(offset &gt;= 0, &quot;${Self}.load with negative offset&quot;) _debugPrecondition(offset + MemoryLayout&lt;T&gt;.size &lt;= self.count, &quot;${Self}.load out of bounds&quot;) return baseAddress!.load(fromByteOffset: offset, as: T.self) } % if mutable: /// Stores a value&#39;s bytes into raw memory at `self + offset`. /// /// - Precondition: `offset + MemoryLayout&lt;T&gt;.size &lt; self.count` /// /// - Precondition: The underlying pointer plus `offset` is properly /// aligned for storing type `T`. /// /// - Precondition: `T` is a trivial type. /// /// - Precondition: The memory is uninitialized, or initialized to /// some trivial type `U` such that `T` and `U` are mutually layout /// compatible. /// /// - Postcondition: The memory is initialized to raw bytes. If the /// memory is bound to type `U`, then it now contains a value of /// type `U`. /// /// - Note: A trivial type can be copied with just a bit-for-bit /// copy without any indirection or reference-counting operations. /// Generally, native Swift types that do not contain strong or /// weak references or other forms of indirection are trivial, as /// are imported C structs and enums. public func storeBytes&lt;T&gt;( of value: T, toByteOffset offset: Int = 0, as: T.Type ) { _debugPrecondition(offset &gt;= 0, &quot;${Self}.storeBytes with negative offset&quot;) _debugPrecondition(offset + MemoryLayout&lt;T&gt;.size &lt;= self.count, &quot;${Self}.storeBytes out of bounds&quot;) baseAddress!.storeBytes(of: value, toByteOffset: offset, as: T.self) } /// Copies `count` bytes from `source` into memory at `self`. /// /// - Precondition: `count` is non-negative. /// /// - Precondition: The memory at `source..&lt;source + count` is /// initialized to some trivial type `T`. /// /// - Precondition: If the memory at `self..&lt;self+count` is bound to /// a type `U`, then `U` is a trivial type, the underlying /// pointers `source` and `self` are properly aligned for type /// `U`, and `count` is a multiple of `MemoryLayout&lt;U&gt;.stride`. /// /// - Postcondition: The memory at `self..&lt;self+count` is /// initialized to raw bytes. If the memory is bound to type `U`, /// then it contains values of type `U`. public func copyBytes(from source: UnsafeRawBufferPointer) { _debugPrecondition(source.count &lt;= self.count, &quot;${Self}.copyBytes source has too many elements&quot;) baseAddress?.copyBytes(from: source.baseAddress!, count: source.count) } public func copyBytes&lt;C : Collection&gt;(from source: C ) where C.Iterator.Element == UInt8 { _debugPrecondition(numericCast(source.count) &lt;= self.count, &quot;${Self}.copyBytes source has too many elements&quot;) guard let position = _position else { return } for (index, byteValue) in source.enumerated() { position.storeBytes( of: byteValue, toByteOffset: index, as: UInt8.self) } } % end # mutable /// Creates `${Self}` over the `count` contiguous bytes beginning at `start`. /// /// If `start` is nil, `count` must be 0. However, `count` may be 0 even for /// a nonzero `start`. public init(start: Unsafe${Mutable}RawPointer?, count: Int) { _precondition(count &gt;= 0, &quot;${Self} with negative count&quot;) _precondition(count == 0 || start != nil, &quot;${Self} has a nil start and nonzero count&quot;) _position = start _end = start.map { $0 + count } } /// Creates `${Self}` over the contiguous bytes in `buffer`. /// /// - Precondition: `T` is a trivial type. public init&lt;T&gt;(_ buffer: UnsafeMutableBufferPointer&lt;T&gt;) { self.init(start: buffer.baseAddress!, count: buffer.count * MemoryLayout&lt;T&gt;.stride) } % if mutable: /// Converts UnsafeRawBufferPointer to UnsafeMutableRawBufferPointer. public init(mutating bytes: UnsafeRawBufferPointer) { self.init(start: UnsafeMutableRawPointer(mutating: bytes.baseAddress), count: bytes.count) } % else: /// Converts UnsafeMutableRawBufferPointer to UnsafeRawBufferPointer. public init(_ bytes: UnsafeMutableRawBufferPointer) { self.init(start: bytes.baseAddress, count: bytes.count) } /// Creates an `${Self}` view over the contiguous memory in `buffer`. /// /// - Precondition: `T` is a trivial type. public init&lt;T&gt;(_ buffer: UnsafeBufferPointer&lt;T&gt;) { self.init(start: UnsafeMutableRawPointer(mutating: buffer.baseAddress!), count: buffer.count * MemoryLayout&lt;T&gt;.stride) } % end # !mutable % if not mutable: /// Creates a raw buffer over the same memory as the given raw buffer slice. /// /// The new raw buffer will represent the same region of memory as the slice, /// but it&#39;s indices will be rebased to zero. Given: /// /// let slice = buffer[n..&lt;m] /// let rebased = UnsafeRawBufferPointer(rebasing: slice) /// /// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`. /// /// - Parameter slice: the raw buffer slice to rebase. @_inlineable public init(rebasing slice: RandomAccessSlice&lt;UnsafeRawBufferPointer&gt;) { self.init(start: slice.base.baseAddress! + slice.startIndex, count: slice.count) } % end # !mutable /// Creates a raw buffer over the same memory as the given raw buffer slice. /// /// The new raw buffer will represent the same region of memory as the slice, /// but it&#39;s indices will be rebased to zero. Given: /// /// let slice = buffer[n..&lt;m] /// let rebased = UnsafeRawBufferPointer(rebasing: slice) /// /// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`. /// /// - Parameter slice: the raw buffer slice to rebase. @_inlineable public init( rebasing slice: MutableRandomAccessSlice&lt;UnsafeMutableRawBufferPointer&gt; ) { self.init(start: slice.base.baseAddress! + slice.startIndex, count: slice.count) } /// Always zero, which is the index of the first byte in a /// non-empty buffer. public var startIndex: Int { return 0 } /// The &quot;past the end&quot; positionthat is, the position one greater than the /// last valid subscript argument. /// /// The `endIndex` property of an `Unsafe${Mutable}RawBufferPointer` instance is /// always identical to `count`. public var endIndex: Int { return count } public typealias Indices = CountableRange&lt;Int&gt; public var indices: Indices { return startIndex..&lt;endIndex } /// Accesses the `i`th byte in the memory region as a `UInt8` value. public subscript(i: Int) -&gt; UInt8 { get { _debugPrecondition(i &gt;= 0) _debugPrecondition(i &lt; endIndex) return _position!.load(fromByteOffset: i, as: UInt8.self) } % if mutable: nonmutating set { _debugPrecondition(i &gt;= 0) _debugPrecondition(i &lt; endIndex) _position!.storeBytes(of: newValue, toByteOffset: i, as: UInt8.self) } % end # mutable } /// Accesses the bytes in the memory region within `bounds` as a `UInt8` /// values. public subscript(bounds: Range&lt;Int&gt;) -&gt; ${Mutable}RandomAccessSlice&lt;Unsafe${Mutable}RawBufferPointer&gt; { get { _debugPrecondition(bounds.lowerBound &gt;= startIndex) _debugPrecondition(bounds.upperBound &lt;= endIndex) return ${Mutable}RandomAccessSlice(base: self, bounds: bounds) } % if mutable: nonmutating set { _debugPrecondition(bounds.lowerBound &gt;= startIndex) _debugPrecondition(bounds.upperBound &lt;= endIndex) _debugPrecondition(bounds.count == newValue.count) if newValue.count &gt; 0 { (baseAddress! + bounds.lowerBound).copyBytes( from: newValue.baseAddress!, count: newValue.count) } } % end # mutable } /// Returns an iterator over the bytes of this sequence. /// /// - Complexity: O(1). public func makeIterator() -&gt; Iterator { return Iterator(_position: _position, _end: _end) } /// A pointer to the first byte of the buffer. public var baseAddress: Unsafe${Mutable}RawPointer? { return _position } /// The number of bytes in the buffer. public var count: Int { if let pos = _position { return _end! - pos } return 0 } let _position, _end: Unsafe${Mutable}RawPointer? } extension Unsafe${Mutable}RawBufferPointer : CustomDebugStringConvertible { /// A textual representation of `self`, suitable for debugging. public var debugDescription: String { return &quot;${Self}&quot; + &quot;(start: (_position.map(String.init(describing:)) ?? &quot;nil&quot;), count: (count))&quot; } } /// Invokes `body` with an `${Self}` argument and returns the /// result. % if mutable: public func withUnsafeMutableBytes&lt;T, Result&gt;( of arg: inout T, _ body: (UnsafeMutableRawBufferPointer) throws -&gt; Result ) rethrows -&gt; Result { return try withUnsafeMutablePointer(to: &amp;arg) { return try body(UnsafeMutableRawBufferPointer( start: $0, count: MemoryLayout&lt;T&gt;.size)) } } % else: public func withUnsafeBytes&lt;T, Result&gt;( of arg: inout T, _ body: (UnsafeRawBufferPointer) throws -&gt; Result ) rethrows -&gt; Result { return try withUnsafePointer(to: &amp;arg) { try body(UnsafeRawBufferPointer(start: $0, count: MemoryLayout&lt;T&gt;.size)) } } % end # mutable % end # for mutable % for Self in [&#39;ContiguousArray&#39;, &#39;ArraySlice&#39;, &#39;Array&#39;]: extension ${Self} { /// Calls a closure with a view of the array&#39;s underlying bytes of memory as a /// Collection of `UInt8`. /// ${contiguousCaveat} /// /// - Precondition: `Pointee` is a trivial type. /// /// The following example shows how you copy bytes into an array: /// /// var numbers = [Int32](repeating: 0, count: 2) /// var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00] /// numbers.withUnsafeMutableBytes { destBytes in /// byteValues.withUnsafeBytes { srcBytes in /// destBytes.copyBytes(from: srcBytes) /// } /// } /// /// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter that points to /// the contiguous storage for the array. If `body` has a return value, it is /// used as the return value for the `withUnsafeBytes(_:)` method. The /// argument is valid only for the duration of the closure&#39;s execution. /// - Returns: The return value of the `body` closure parameter, if any. /// /// - SeeAlso: `withUnsafeBytes`, `UnsafeRawBufferPointer` public mutating func withUnsafeMutableBytes&lt;R&gt;( _ body: (UnsafeMutableRawBufferPointer) throws -&gt; R ) rethrows -&gt; R { return try self.withUnsafeMutableBufferPointer { return try body(UnsafeMutableRawBufferPointer($0)) } } /// Calls a closure with a view of the array&#39;s underlying bytes of memory as a /// Collection of `UInt8`. /// ${contiguousCaveat} /// /// - Precondition: `Pointee` is a trivial type. /// /// The following example shows how you copy the contents of an array into a /// buffer of `UInt8`: /// /// let numbers = [1, 2, 3] /// var byteBuffer = [UInt8]() /// numbers.withUnsafeBytes { /// byteBuffer += $0 /// } /// /// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter that points to /// the contiguous storage for the array. If `body` has a return value, it is /// used as the return value for the `withUnsafeBytes(_:)` method. The /// argument is valid only for the duration of the closure&#39;s execution. /// - Returns: The return value of the `body` closure parameter, if any. /// /// - SeeAlso: `withUnsafeBytes`, `UnsafeRawBufferPointer` public func withUnsafeBytes&lt;R&gt;( _ body: (UnsafeRawBufferPointer) throws -&gt; R ) rethrows -&gt; R { return try self.withUnsafeBufferPointer { try body(UnsafeRawBufferPointer($0)) } } } %end % for mutable in (True, False): % Mutable = &#39;Mutable&#39; if mutable else &#39;&#39; extension Unsafe${Mutable}BufferPointer&lt;Element&gt; { % if not Mutable: /// Creates a buffer over the same memory as the given buffer slice. /// /// The new buffer will represent the same region of memory as the slice, /// but it&#39;s indices will be rebased to zero. Given: /// /// let slice = buffer[n..&lt;m] /// let rebased = UnsafeBufferPointer(rebasing: slice) /// /// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`. /// /// - Parameter slice: the raw buffer slice to rebase. public init(rebasing slice: RandomAccessSlice&lt;UnsafeBufferPointer&lt;Element&gt;&gt;) { self.init(start: slice.base.baseAddress! + slice.startIndex, count: slice.count) } % end # !mutable /// Creates a buffer over the same memory as the given buffer slice. /// /// The new buffer will represent the same region of memory as the slice, /// but it&#39;s indices will be rebased to zero. Given: /// /// let slice = buffer[n..&lt;m] /// let rebased = UnsafeBufferPointer(rebasing: slice) /// /// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`. /// /// - Parameter slice: the buffer slice to rebase. public init( rebasing slice: MutableRandomAccessSlice&lt;UnsafeMutableBufferPointer&lt;Element&gt;&gt; ) { self.init(start: slice.base.baseAddress! + slice.startIndex, count: slice.count) } } % end Implementation status This proposal is fully implemented on my unsafebytes branch Impact on existing code None Alternatives considered Expect developers to continue using [UInt8] as type-erased buffers but rebind memory each time they cross API boundaries. Expect developers to convert to UnsafeRawPointer without a solution for viewing the raw data as a collection of bytes. There is no alternative to introducing an UnsafeRawBufferPointer API that doesn’t require developers to understand the subtle semantics of raw pointers and binding memory to a type. My experience helping developers migrate their code, which they likely did not write in the first place, shows that this is an unreasonable expectation.",
    "url": "http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html",
    "relUrl": "/docs/2019-08-26-0138-unsaferawbufferpointer.html"
  },
  "138": {
    "id": "138",
    "title": "SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`",
    "content": "Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue Proposal: SE-0139 Author: Joe Groff Review Manager: Doug Gregor Status: Implemented (Swift 3.0.1) Decision Notes: Rationale Introduction A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRange by boxing them into NSValue objects. Swift-evolution thread: here Motivation SE-0116 changed how Objective-C’s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don’t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing: let i = 17 let plist = [&quot;seventeen&quot;: i] // OK try! JSONSerialization.data(withJSONObject: plist) let j: UInt8 = 38 let brokenPlist = [&quot;thirty-eight&quot;: j] // Will throw because `j` didn&#39;t bridge to a JSON type try! JSONSerialization.data(withJSONObject: brokenPlist) We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for. There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Animation as an example in this bug report. With id-as-Any, it’s natural to expect this to work: anim.toValue = CGPoint.zero However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue. Proposed solution All of Swift’s number types should be made to bridge to NSNumber when used as objects in Objective-C: Int8 Int16 Int32 Int64 UInt8 UInt16 UInt32 UInt64 Float Double Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects: NSRange CGPoint CGVector CGSize CGRect CGAffineTransform UIEdgeInsets UIOffset CATransform3D CMTime CMTimeRange CMTimeMapping MKCoordinate MKCoordinateSpan SCNVector3 SCNVector4 SCNMatrix4 Detailed design Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type. Note that, although NSValue has factory initializers and accessors for each of the above struct types, the bridging implementation ought to stick to NSValue’s core valueWithBytes:objCType: and getValue: API, to avoid potential availability issues with the type-specific methods. NSNumber is a bit trickier, since Cocoa’s implementation does not generally guarantee to remember the exact number type an instance was constructed from. When we bridge Swift number types to NSNumber, though, we use specific NSNumber subclasses to preserve the original Swift type, and in these cases we can check the exact Swift type in dynamic casts. For NSNumbers from Cocoa, we can say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumber can potentially be cast to a different type from the original value. Impact on existing code This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C’s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift’s perspective, values should still be able to round-trip from concrete number and struct types to Any to id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumber was constructed from would be lost. Alternatives considered We can of course do nothing and leave the behavior as-is. NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridge UnsafePointer and Unmanaged this way, but we probably shouldn’t. Instead of implementing NSValue bridging in the overlay, Zach Waldowski suggests using Objective-C’s __attribute__((objc_boxable)), which enables autoboxing of a struct in ObjC with @(...) syntax, to also instruct Swift’s Clang importer to synthesize a bridge to NSValue automatically for types annotated with the attribute. However, this attribute hasn’t been widely adopted in Apple SDKs.",
    "url": "http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html",
    "relUrl": "/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html"
  },
  "139": {
    "id": "139",
    "title": "SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`",
    "content": "Warn when Optional converts to Any, and bridge Optional As Its Payload Or NSNull Proposal: SE-0140 Author: Joe Groff Review Manager: Doug Gregor Status: Implemented (Swift 3.0.1) Decision Notes: Rationale Introduction Optionals can be used as values of Any type. After SE-0116, this means you can pass an Optional to an Objective-C method expecting nonnull id: // Objective-C @interface ObjCClass : NSObject - (void)imported: (id _Nonnull)value; @end let s1: String? = nil, s2: String? = &quot;hello&quot; // works, should warn, currently produces an opaque object type ObjCClass().imported(s1) // works, should warn, currently produces an opaque object type ObjCClass().imported(s2) This is often a mistake, and we should raise a warning when it occurs, but is occasionally useful. When an Optional is intentionally passed into Objective-C as a nonnull object, we should bridge some value by bridging the wrapped value, and bridge nones to a singleton such as NSNull: let s1: String? = nil, s2: String? = &quot;hello&quot; // proposed to bridge to NSNull.null ObjCClass().imported(s1) // proposed to bridge to NSString(&quot;hello&quot;) ObjCClass().imported(s2) Swift-evolution thread: here Motivation SE-0116 changed how Objective-C’s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass Swift value types such as String and Array into ObjC. One unfortunate effect is that, since Any in Swift can hold anything, it is now possible to pass an Optional to an Objective-C API that expects a nonnull id. This is not a new issue in Swift–it is possible to use an Optional anywhere there’s unconstrained polymorphism, for example, in string interpolations, or as the element type of a collection, such as an Array&lt;T?&gt;, but bridging id as Any makes this problem much more prevalent. Since Cocoa APIs traffic heavily in Optionals, it’s very easy to accidentally take an Optional result from one API and pass it as Any to another API without unwrapping it first. We can introduce a warning when an Optional is implicitly converted to Any. However, since this is dynamic behavior, it is impossible to prevent Optionals ending up in Anys in all cases, nor would it be desirable to completely prevent it, since it is sometimes useful to keep an Optional inside an Any. Containers and other generic types with Optional members are also useful. Because Optional does not currently have any special bridging behavior, it will currently be bridged to Objective-C as an opaque object, which will be unusable by most Objective-C API. In Objective-C, Cocoa provides NSNull as a standard, non-nil singleton to represent missing values inside collections, since NSArray, NSDictionary, and NSSet are unable to hold nil elements. If we bridge Optionals so that, when they contain some value, we bridge the wrapped value, or use NSNull to represent none, then we get several advantages over the current behavior: Passing a wrapped Optional value into Objective-C will work more consistently with how Optionals inside Anys work in Swift. Swift considers T to be a subtype of T?, so even if an Any contains an optional, casting to the nonoptional type will succeed if the Any contains an optional with a value. By analogy in Objective-C, we would want an Optional passed into ObjC as id to be an instance of the unwrapped class type, so that isKindOfClass: and respondsToSelector: queries succeed if a valid value is passed in. Passing Optional.none to Objective-C APIs that idiomatically expect NSNull will do the right thing. Swift collections such as [T?] will automatically map to NSArrays containing NSNull sentinels, their closest idiomatic analogue in ObjC. Passing Optional.none to Objective-C APIs that expect neither nil nor NSNull will fail in more obvious ways, usually with an NSNull does not respond to selector exception of some kind. id-based Objective-C APIs fundamentally cannot catch all misuses at compile time, so runtime errors on user error are unavoidable. NSNull is rare in Cocoa, and perhaps not that much more useful than an arbitrary sentinel object or opaque box, but is the object most likely to have a useful meaning to existing ObjC APIs. Proposed solution Converting an Optional&lt;T&gt; to an Any should raise a warning unless the conversion is made explicit. When an Optional&lt;T&gt; value does end up in an Any, and gets bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used. Detailed design Warning when Optional is converted to Any When we put an Optional into an Any, we should warn on the implicit conversion: let x: Int? = 3 let y: Any = x // warning: Optional was put in an Any without being unwrapped // `print` takes parameters of type Any print(x) // warning: Optional was passed as an argument of type Any without // being unwrapped // `NSMutableArray` has elements of type `id _Nonnull` in ObjC, // imported as `Any` in Swift let a = NSMutableArray() a.add(x) // warning: Optional was passed as an argument of type Any without // being unwrapped If passing the Optional is intentional, the warning can be suppressed by making the conversion explicit with as Any: let y: Any = x as Any print(x as Any) a.add(x as Any) Bridging Optionals Optional can conform to the implementation- internal _ObjectiveCBridgeable protocol. One subtlety is with nested optional types, such as T??; these are rare, but when they occur, we would want to preserve their value in round-trips through the Objective-C bridge, so we would need to be able to use a different sentinel to distinguish .some(.none) from .none. Since there is no idiomatic equivalent in Cocoa for a nested optional, we can use an opaque singleton object to represent each level of none nesting: var x: String??? x = String?.none x as AnyObject // bridges to NSNull, since it&#39;s an unnested `.none` x = String??.none x as AnyObject // bridges to _SwiftNull(1), since it&#39;s a double-`.none` x = String???.none x as AnyObject // bridges to _SwiftNull(2), since it&#39;s a triple-`.none` Like default-bridged _SwiftValue boxes, these would be id-compatible but otherwise opaque singletons. Impact on existing code This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C’s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift’s perspective, values should still be able to round-trip from Optional to Any to id to Any and back by dynamic casting. Alternatives considered There are unconstrained contexts other than Any promotion where Optionals can be used by accident without unwrapping, such as String.init(describing:), which takes a generic &lt;T&gt;. We may want to warn in some of these cases, but there are subtleties that require deeper consideration. Extending the warning can be considered in the future. We could do nothing, and leave Optionals to bridge by opaque boxing. Charles Srstka argues that passing Optionals into ObjC via Any is programmer error, so should fail early at runtime: I’d say my position has three planks on it, and the above is pretty much the first plank: 1) the idea of an array of optionals is a concept that doesn’t really exist in Objective-C, and I do think that passing one to Obj-C ought to be considered a programmer error. The other two planks would be: 2) Bridging arrays of optionals in this manner could mask the aforementioned programmer error, resulting in unexpected, hard-to-reproduce crashes when an NSNull is accessed as if it were something else, and: 3) Objective-C APIs that accept NSNull objects are fairly rare, so the proposed bridging doesn’t really solve a significant problem (and in the cases where it does, using a map to replace nils with NSNulls is not difficult to write). This point of view is understandable, but is inconsistent with how Swift itself dynamically treats Optionals inside Anys: let a: Int? = 3 let b = a as Any let c = a as! Int // Casts ‘3’ out of the Optional as a non-optional Int And while it’s true that Cocoa uses NSNull sparingly, it is the standard sentinel used in the few places where a null-like object is expected, such as in collections and JSON serialization.",
    "url": "http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html",
    "relUrl": "/docs/2019-08-26-0140-bridge-optional-to-nsnull.html"
  },
  "140": {
    "id": "140",
    "title": "SE-0141 Availability by Swift version",
    "content": "Availability by Swift version Proposal: SE-0141 Author: Graydon Hoare Review Manager: Doug Gregor Status: Implemented (Swift 3.1) Decision Notes: Rationale Bug: SR-2709 Introduction Swift’s existing @available(...) attribute indicates the lifecycle of a given declaration, either unconditionally or relative to a particular platform or OS version range. It does not currently support indicating declaration lifecycle relative to Swift language versions. This proposal seeks to extend it to do so. Swift-evolution threads: Draft, Review Motivation As the Swift language progresses from one version to the next, some declarations will be added, renamed, deprecated or removed from the standard library. Existing code written for earlier versions of Swift will be supported through a -swift-version N command-line flag, that runs the compiler in a backward-compatibility mode for the specified “effective” language version. When running in a backward-compatibility mode, the set of available standard library declarations should change to match expectations of older code. Currently the only mechanism for testing a language version is the compiler-control statement #if swift(&gt;= N) which is a static construct: it can be used to compile-out a declaration from the standard library, but evolving the standard library through this mechanism would necessitate compiling the standard library once for each supported older language version. It would be preferable to compile the standard library once for all supported language versions, but make declarations conditionally available depending on the effective language version of a user of the library. The existing @available(...) attribute is similar to this use-case, and this proposal seeks to extend the attribute to support it. Proposed solution The @available(...) attribute will be extended to support specifying swift version numbers, in addition to its existing platform versions. As an example, an API that is removed in Swift 3.1 will be written as: @available(swift, obsoleted: 3.1) class Foo { //... } When compiling user code in -swift-version 3.0 mode, this declaration would be available, but not when compiling in subsequent versions. Detailed design The token swift will be added to the set of valid initial arguments to the @available(...) attribute. It will be treated similarly, but slightly differently, than the existing platform arguments. In particular: As with platform-based availability judgments, a declaration’s swift version availability will default to available-everywhere if unspecified. A declaration’s swift version availability will be considered in logical conjunction with its platform-based availability. That is, a given declaration will be available if and only if it is both available to the current effective swift version and available to the current deployment-target platform. Similar to the abbreviated form of platform availability, an abbreviated form @available(swift N) will be permitted as a synonym for @available(swift, introduced: N). However, adding swift to a platform availability abbreviation list will not be allowed. That is, writing the following examples is not permitted: @available(swift 3, *) @available(swift 3, iOS 10, *) This restriction is due to the fact that platform-availability lists are interpreted disjunctively (as a logical-_OR_ of their arguments), and adding a conjunct (logical-_AND_) to such a list would make the abbreviation potentially ambiguous to readers. Impact on existing code Existing code does not use this form of attribute, so will not be affected at declaration-site. As declarations are annotated as unavailable or obsoleted via this attribute, some user code may stop working, but the same risk exists (with a worse user experience) in today’s language any time declarations are removed or conditionally-compiled out. The purpose of this proposal is to provide a better user experience around such changes, and facilitate backward-compatibility modes. Alternatives considered The main alternative is compiling libraries separately for each language version and using #if swift(&gt;=N) to conditionally include varying APIs. For a library used locally within a single project, recompiling for a specific language version may be appropriate, but for shipping the standard library it is more economical to compile once with all declarations, and select a subset based on language version.",
    "url": "http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html",
    "relUrl": "/docs/2019-08-26-0141-available-by-swift-version.html"
  },
  "141": {
    "id": "141",
    "title": "SE-0142 Permit where clauses to constrain associated types",
    "content": "Permit where clauses to constrain associated types Proposal: SE-0142 Authors: David Hart, Jacob Bandes-Storch, Doug Gregor Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Bugs: SR-4506 Introduction This proposal seeks to introduce a where clause to associated type declarations and improvements to protocol constraints to bring associated types the same expressive power as generic type parameters. This proposal was discussed twice on the Swift Evolution list in the following threads: [Completing Generics] Arbitrary requirements in protocols [Proposal] More Powerful Constraints for Associated Types Week #1 Week #2 Week #3 Motivation Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where clause. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol could be declared as follows if the current proposal was accepted: protocol Sequence { associatedtype Iterator : IteratorProtocol associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element ... } Detailed Design First of all, this proposal modifies the grammar for a protocol’s associated types to the following: protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt typealias-assignment­opt requirement-clauseopt The new requirement-clause is then used by the compiler to validate the associated types of conforming types. Secondly, the proposal also allows protocols to use the associated types of their conforming protocols in their declaration where clause as below: protocol IntSequence : Sequence where Iterator.Element == Int { ... } Name lookup semantics in the protocol declaration where clause only looks at associated types in the parent protocols. For example, the following code would cause an error: protocol SomeSequence : Sequence where Counter : SomeProtocol { // error: Use of undefined associated type &#39;Counter&#39; associatedtype Counter } But instead should be written on the associated type itself: protocol IntSequence : Sequence { associatedtype Counter : SomeProtocol } Effect on ABI Stability As mentioned previously, there are a number of places in the standard library where this feature would be adopted (such as the SubSequence.Iterator.Element == Iterator.Element example), each of which will change the mangling of any generic function/type that makes use of them. Alternatives Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: protocol Collection : Sequence { where SubSequence : Collection } But as Douglas notes himself, that syntax is ambiguous since we adopted the generic where clause at the end of declarations of the following proposal: SE-0081: Move where clause to end of declaration. For those reasons, it might be wiser not to introduce the shorthand syntax. Acknowledgements Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html",
    "relUrl": "/docs/2019-08-26-0142-associated-types-constraints.html"
  },
  "142": {
    "id": "142",
    "title": "SE-0143 Conditional conformances",
    "content": "Conditional conformances Proposal: SE-0143 Author: Doug Gregor Review Manager: Joe Groff Status: Implemented (Swift 4.2) Decision Notes: Review extended, Rationale Previous Revision: 1 Introduction Conditional conformances express the notion that a generic type will conform to a particular protocol only when its type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable: extension Array: Equatable where Element: Equatable { static func ==(lhs: Array&lt;Element&gt;, rhs: Array&lt;Element&gt;) -&gt; Bool { ... } } This feature is part of the generics manifesto because it’s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library. Swift-evolution thread: here Motivation Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it’s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int] == [Int] would succeed. However, it doesn’t compose: arrays of arrays of Equatable types cannot be compared (e.g., [[Int]] == [[Int]] will fail to compile) because, even though there is an == for arrays of Equatable type, the arrays themselves are never Equatable. Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the “lazy” functionality of the Swift standard library’s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these: extension Sequence { var lazy: LazySequence&lt;Self&gt; { ... } } extension Collection { var lazy: LazyCollection&lt;Self&gt; { ... } } extension BidirectionalCollection { var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... } } extension RandomAccessCollection { var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... } } This approach causes an enormous amount of repetition, and doesn’t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on). Proposed solution In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class (but not a protocol) to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error: t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause extension Array: Equatable where Element: Equatable { } ^ ~~~~~~~~~ Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable: func f&lt;T: Equatable&gt;(_: T) { ... } struct NotEquatable { } func test(a1: [Int], a2: [NotEquatable]) { f(a1) // okay: [Int] conforms to Equatable because Int conforms to Equatable f(a2) // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable } Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example: protocol P { func doSomething() } struct S: P { func doSomething() { print(&quot;S&quot;) } } // Array conforms to P if it&#39;s element type conforms to P extension Array: P where Element: P { func doSomething() { for value in self { value.doSomething() } } } // Dynamically query and use conformance to P. func doSomethingIfP(_ value: Any) { if let p = value as? P { p.doSomething() } else { print(&quot;Not a P&quot;) } } doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times doSomethingIfP([1, 2, 3]) // prints &quot;Not a P&quot; The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal. Detailed design Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design. Multiple conformances Swift already bans programs that attempt to make the same type conform to the same protocol twice, e.g.: protocol P { } struct X : P { } extension X : P { } // error: X already stated conformance to P This existing ban on multiple conformances is extended to conditional conformances, including attempts to conform to the same protocol in two different ways. For example: struct SomeWrapper&lt;Wrapped&gt; { let wrapped: Wrapped } protocol HasIdentity { static func ===(lhs: Self, rhs: Self) -&gt; Bool } extension SomeWrapper: Equatable where Wrapped: Equatable { static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapped&gt;) -&gt; Bool { return lhs.wrapped == rhs.wrapped } } // error: SomeWrapper already stated conformance to Equatable extension SomeWrapper: Equatable where Wrapped: HasIdentity { static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapped&gt;) -&gt; Bool { return lhs.wrapped === rhs.wrapped } } Furthermore, for consistency, the ban extends even to multiple conformances that are “clearly” disjoint, e.g., extension SomeWrapper: Equatable where Wrapped == Int { static func ==(lhs: SomeWrapper&lt;Int&gt;, rhs: SomeWrapper&lt;Int&gt;) -&gt; Bool { return lhs.wrapped == rhs.wrapped } } // error: SomeWrapper already stated conformance to Equatable extension SomeWrapper: Equatable where Wrapped == String { static func ==(lhs: SomeWrapper&lt;String&gt;, rhs: SomeWrapper&lt;String&gt;) -&gt; Bool { return lhs.wrapped == rhs.wrapped } } The section overlapping conformances describes some of the complexities introduced by multiple conformances, to justify their exclusion from this proposal. A follow-on proposal could introduce support for multiple conformances, but should likely also cover related features such as private conformances that are orthogonal to conditional conformances. Implied conditional conformances Stating a non-conditional conformance to a protocol implicitly states conformances to any of the protocols that the protocol inherits: one can declare conformance to the Collection protocol, and it implies conformance to Sequence as well. However, with conditional conformances, the constraints for the conformance to the inherited protocol may not be clear, and even when there is a clear choice, it will often be incorrect, so the conformance to the inherited protocol will need to be stated explicitly. For example, for the first case: protocol P { } protocol Q : P { } protocol R : P { } struct X&lt;T&gt; { } extension X: Q where T: Q { } extension X: R where T: R { } // error: X does not conform to protocol P; add // // extension X: P where &lt;#constraints#&gt; { ... } // // to state conformance to P. Note that both of the constrained extensions could imply the conformance to P. However, because the two extensions have disjoint sets of constraints (one requires T: Q, the other T: R), it becomes unclear which constraints should apply to the conformance to P: picking one set of constraints (e.g. T: Q, from the conformance of X to Q) makes the inherited conformance unusable for X instances where T: R, which would break type safety (because we could have X instances that conform to R but not P!). Moreover, the previously-discussed ban on multiple conformances prohibits introducing two different conformances of X to P (one where T: Q and one where T: R). Therefore, the program above is ill-formed, and the correct fix is for the user to introduce an explicit conformance of X to P with the appropriate set of constraints, e.g.: extension X: P where T: P { } For the second problem mentioned above, when there is an obvious set of requirements to use in an implied conformance, it is likely to be wrong, because of how often conditional conformances are used for wrapper types. For instance: protocol R: P { } protocol S: R { } struct Y&lt;T&gt; { } extension Y: R where T: R { } extension Y: S where T: S { } The conformances of Y: R and Y: S both imply the conformance Y: P, however the constraints T: R are less specialized (more general) than the constraints T: S, because every S is also an R. Therefore, it could be that Y will conform to P when T: R, e.g.: /// compiler produces the following implied inherited conformance: extension Y: P where T: R { } However, it is likely that the best conformance is actually the more relaxed (that is, applicable for more choices of T): extension Y: P where T: P { } This is the case for almost all wrappers for the Sequence/Collection/BidirectionalCollection/… hierarchy (for instance, as discussed below, Slice : BidirectionalCollection where Base : BidirectionalCollection and similarly for RandomAccessCollection), and for most types conforming to several of Equatable, Comparable and Hashable. Implicitly constructing these conformances could be okay if it were possible to relax the overly-strong requirements when they’re noticed in future. However, it can be backwards incompatible, and so not doing it implicitly is defaulting to the safer option. The backwards incompatibility comes from how requirements are inferred in function signatures: given struct Z&lt;A: P&gt; {}, Swift notices that a declaration func foo&lt;A&gt;(x: Z&lt;Y&lt;A&gt;&gt;) requires that Y&lt;A&gt; : P, since it is used in Z, and thus, if the implicit inherited conformance above existed, A: R. This conformance is part of the function’s signature (and mangling!) and is available to be used inside foo: that function can use requirements from R on values of type A. If the library declaring Y was to change to the declaration of the conformance Y: P, the inferred requirement becomes A: P, which changes the foo’s mangled name, and what can be done with values of type A. This breaks both API and ABI compatibility. (Note: the inference above is driven by having a unique conformance, and thus Y: P if and only if A: P. If overlapping conformances were allowed, this inference would not be possible. A possible alternative that’s more directly future-proof with overlapping conformances would be to disable this sort of inference from conditional conformances, and instead require the user to write func foo&lt;A: P&gt;. This could also allow the conformances to be implied, since it would no longer be such a backwards-compatibility problem.) On the other hand, not allowing implicit inherited conformances means that one cannot insert a superprotocol to an existing protocol: for instance, if the second example started as protocol R { } and was changed to protocol R: P { }. However, we believe this is already incompatible, for unrelated reasons. Finally, it is a small change to get implicit behaviour explicitly, by adding the conformance declaration to the extension that would be implying the conformance. For instance, if it is correct for the second example to have T: R as the requirement on Y: P, the Y: R extension only needs to be changed to include , P: extension Y: R, P where T: R { } This is something compilers can, and should, suggest as a fixit. Standard library adoption Adopt conditional conformances to make various standard library types that already have a suitable == conform to Equatable. Specifically: extension Optional: Equatable where Wrapped: Equatable { /*== already exists */ } extension Array: Equatable where Element: Equatable { /*== already exists */ } extension ArraySlice: Equatable where Element: Equatable { /*== already exists */ } extension ContiguousArray: Equatable where Element: Equatable { /*== already exists */ } extension Dictionary: Equatable where Value: Equatable { /*== already exists */ } In addition, implement conditional conformances to Hashable for the types above, as well as Range and ClosedRange: extension Optional: Hashable where Wrapped: Hashable { /*...*/ } extension Array: Hashable where Element: Hashable { /*...*/ } extension ArraySlice: Hashable where Element: Hashable { /*...*/ } extension ContiguousArray: Hashable where Element: Hashable { /*...*/ } extension Dictionary: Hashable where Value: Hashable { /*...*/ } extension Range: Hashable where Bound: Hashable { /*...*/ } extension ClosedRange: Hashable where Bound: Hashable { /*...*/ } While the standard library did not previously provide existing implementations of hashValue for these types, conditional Hashable conformance is a natural expectation for them. Note that Set is already (unconditionally) Equatable and Hashable. In addition, it is intended that the standard library adopt conditional conformance to collapse a number of “variants” of base types where other generic parameters enable conformance to further protocols. For example, there is a type: ReversedCollection&lt;Base: BidirectionalCollection&gt;: BidirectionalCollection that provides a low-cost lazy reversal of any bidirecitonal collection. There is a variation on that type, ReversedRandomAccessCollection&lt;Base: RandomAccessCollection&gt;: RandomAccessCollection that additionaly conforms to RandomAccessCollection when its base does. Users create these types via the reversed() extension method on BidirectionalCollection and RandomAccessCollection respectively. With conditional conformance, the ReversedRandomAccessCollection variant can be replaced with a conditional extension: extension ReversedCollection: RandomAccessCollection where Base: RandomAccessCollection { } @available(*, deprecated, renamed: &quot;ReversedCollection&quot;) public typealias ReversedRandomAccessCollection&lt;T: RandomAccessCollection&gt; = ReversedCollection&lt;T&gt; Similar techniques can be used for variants of Slice, LazySequence, DefaultIndices, Range and others. These refactorings are considered an implementation detail of the existing functionality standard library and should be applied across the board where applicable. Source compatibility From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax—an extension that both declares a protocol conformance and has a where clause—whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility. Effect on ABI Stability As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes: Improve composability: the example in the introduction made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won’t be ABI- or source-breaking, because they’re additive. Eliminating repetition: the lazy wrappers described in the motivation section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren’t part of Swift 4. Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues. Effect on Resilience One of the primary goals of Swift 4 is resilience, which allows libraries to evolve without breaking binary compatibility with the applications that use them. While the specific details of the impact of conditional conformances on resilience will be captured in a more-complete proposal on resilience, possible rules are summarized here: A conditional conformance cannot be removed in the new version of a library, because existing clients might depend on it. A conditional conformance can be added in a new version of a library, roughly following the rules described in the library evolution document. The conformance itself will need to be annotated with the version in which it was introduced. A conditional conformance can be generalized in a new version of the library, i.e., it can be effectively replaced by a (possibly conditional) conformance in a new version of the library that is less specialized than the conditional conformance in the older version of the library. For example. public struct X&lt;T&gt; { } // Conformance in version 1.0 public extension X: Sequence where T: Collection { ... } // Can be replaced by this less-specialized conformance in version 1.1 public extension X: Sequence where T: Sequence { ... } Such conformances would likely need some kind of annotation. Alternatives considered Overlapping conformances As noted in the section on multiple conformances, Swift already bans programs that attempt to make the same type conform to the same protocol twice. This proposal extends the ban to cases where the conformances are conditional. Reconsider the example from that section: struct SomeWrapper&lt;Wrapped&gt; { let wrapped: Wrapped } protocol HasIdentity { static func ===(lhs: Self, rhs: Self) -&gt; Bool } extension SomeWrapper: Equatable where Wrapped: Equatable { static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapped&gt;) -&gt; Bool { return lhs.wrapped == rhs.wrapped } } extension SomeWrapper: Equatable where Wrapped: HasIdentity { static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapped&gt;) -&gt; Bool { return lhs.wrapped === rhs.wrapped } } Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable: No, it does not conform because T is neither Equatable nor HasIdentity. Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable. Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity. Ambiguity, because T conforms to both Equatable and HasIdentity. It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4: // Possible tie-breaker conformance extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, { static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapped&gt;) -&gt; Bool { return lhs.wrapped == rhs.wrapped } } The design is consistent, because this third conditional conformance is more specialized than either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system: To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity). It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we’ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid. All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard. For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. There are several potential solutions to the problem of overlapping conformances (e.g., admitting some form of overlapping conformances that can be resolved at runtime or introducing the notion of conformances that cannot be queried a runtime), but the feature is large enough to warrant a separate proposal that explores the solutions in greater depth. Extending protocols to conform to protocols The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example: extension Collection: Equatable where Iterator.Element: Equatable { static func ==(lhs: Self, rhs: Self) -&gt; Bool { // ... } } This protocol extension would make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise. Overloading across constrained extensions Conditional conformances may exacerbate existing problems with overloading behaving differently with concrete types vs. in a generic context. For example, consider: protocol P { func f() } protocol Q: P { } protocol R: Q { } struct X1&lt;T&gt; { } extension X1: Q where T: Q { func f() { // #1: basic implementation of &#39;f()&#39; } } extension X1: R where T: R { func f() { // #2: superfast implementation of f() using some knowledge of &#39;R&#39; } } // note: compiler implicitly creates conformance `X1: P` equivalent to // extension X1: P where T: Q { } struct X2: R { func f() { } } (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39; X1&lt;X2&gt;().f() // calls #2, which is preferred by overload resolution When satisfying a protocol requirement, Swift chooses the most specific member that can be used given the constraints of the conformance. In this case, the conformance of X1 to P has the constraints T: Q, so the only f() that can be used under those constraints is the f() from the first extension. The f() in the second extension won’t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt; as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X1.f() implementations are visible… and the second is more specialized. This is not a new problem to Swift. We can write a similar example using a constrained extension and non-conditional conformances: protocol P { func f() } protocol Q: P { } struct X3&lt;T&gt; { } extension X3: Q { func f() { // #1: basic implementation of &#39;f()&#39; } } extension X3 where T: R { func f() { // #2: superfast implementation of f() using some knowledge of &#39;R&#39; } } // note: compiler implicitly creates conformance `X3: P` equivalent to // extension X3: P { } struct X2: R { func f() { } } (X3&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39; X3&lt;X2&gt;().f() // calls #2, which is preferred by overload resolution That said, the introduction of conditional conformances might increase the likelihood of these problems surprising developers.",
    "url": "http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html",
    "relUrl": "/docs/2019-08-26-0143-conditional-conformances.html"
  },
  "143": {
    "id": "143",
    "title": "SE-0144 Allow Single Dollar Sign as a Valid Identifier",
    "content": "Allow Single Dollar Sign as a Valid Identifier Proposal: SE-0144 Author: Ankur Patel Review manager: Chris Lattner Status: Rejected Decision Notes: Rationale Introduction The mainline Swift compiler emits an error message when the $ character (U+0024) is used as an identifier by itself, which is a source breaking change from Swift 3.0. For example: let $ = 10 // OR let $ : (Int) -&gt; (Int) = { $0 * $0 } // OR class $ {} This proposal suggests reverting this change, enabling the use of $ as a valid identifier in future versions of Swift (&gt;= 3.1). Motivation Some projects depend on the Dollar library, which uses $ as a namespace. The core team has decided to remove it as a valid character by merging this Pull Request The reason behind the removal of $ character as a valid identifier is: it was never intended to be an identifier, and was never documented (e.g. by TSPL). the $ sigil is more operator/punctuation-like than identifier-like. the $ namespace is already used for anonymous closure arguments (when followed by a number) and by debugger/REPL temporaries (when followed by a letter). Misuses of these cases were already properly rejected by the compiler, it is just the bare $ identifier that was accepted: ERROR at line 1, col 5: expected numeric value following &#39;$&#39; var $a = 5 Proposed solution Allow $ character (U+0024) to be used as a valid identifier without use of any tick marks `$`. Impact on existing code If this proposal is accepted, it will preserve the Swift 3.0 syntax which allows $ to be used as a valid identifier by itself, so there will be no impact on existing code (the TSPL will be updated to reflect this expansion of the grammar though). If this proposal is rejected, then the $ identifier will be rejected in the Swift 4 compiler with a migration hint that changes uses to `$`. Users of the Dollar library will be affected. Alternatives considered The primarily alternative here is to allow for the breaking change and use `$` as the identifier in the Dollar library, or for Dollar to adapt to another namespace.",
    "url": "http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html",
    "relUrl": "/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html"
  },
  "144": {
    "id": "144",
    "title": "SE-0145 Package Manager Version Pinning",
    "content": "Package Manager Version Pinning Proposal: SE-0145 Author: Daniel Dunbar, Ankit Aggarwal, Graydon Hoare Review Manager: Anders Bertelrud Status: Implemented (Swift 3.1) Decision Notes: Rationale Previous Revision: 1 Previous Discussion: Email Thread Introduction This is a proposal for adding package manager features to “pin” or “lock” package dependencies to particular versions. Motivation As used in this proposal, version pinning refers to the practice of controlling exactly which specific version of a dependency is selected by the dependency resolution algorithm, independent from the semantic versioning specification. Thus, it is a way of instructing the package manager to select a particular version from among all of the versions of a package which could be chosen while honoring the dependency constraints. Terminology We have chosen to use “pinning” to refer to this feature, over “lockfiles”, since the term “lock” is already overloaded between POSIX file locks and locks in concurrent programming. Use Cases Our proposal is designed to satisfy several different use cases for such a behavior: Standardizing team workflows When collaborating on a package, it can be valuable for team members (and continuous integration) to all know they are using the same exact version of dependencies, to avoid “works for me” situations. This can be particularly important for certain kinds of open source projects which are actively being cloned by new users, and which want to have some measure of control around exactly which available version of a dependency is selected. Difficult to test packages or dependencies Complex packages which have dependencies which may be hard to test, or hard to analyze when they break, may choose to maintain careful control over what versions of their upstream dependencies they recommend – even if conceptually they regularly update those recommendations following the true semantic version specification of the dependency. Dependency locking w.r.t. deployment When stabilizing a release for deployment, or building a version of a package for deployment, it is important to be able to lock down the exact versions of dependencies in use, so that the resulting product can be exactly recreated later if necessary. Current Behavior The package manager NEVER updates a locally cloned package from its current version without explicit user action (swift package update). We anticipate encouraging users to update to newer versions of packages when viable, but this has not yet been proposed or implemented. Whenever a package is operated on locally in a way that requires its dependencies be present (typically a swift build, but it could also be swift package fetch or any of several other commands), the package manager will fetch a complete set of dependencies. However, when it does so, it attempts to get versions of the missing dependencies compatible with the existing dependencies. From a certain perspective, the package manager today is acting as if the local clones were “pinned”, however, there has heretofore been no way to share that pinning information with other team members. This proposal is aimed at addressing that. Proposed solution We will introduce support for an optional new file Package.pins adjacent to the Package.swift manifest, called the “pins file”. We will also introduce a number of new commands (see below) for maintaining the pins file. This file will record the active version pin information for the package, including data such as the package identifier, the pinned version, and explicit information on the pinned version (e.g., the commit hash/SHA for the resolved tag). The exact file format is unspecified/implementation defined, however, in practice it will be a JSON data file. This file may be checked into SCM by the user, so that its effects apply to all users of the package. However, it may also be maintained only locally (e.g., placed in the .gitignore file). We intend to leave it to package authors to decide which use case is best for their project. We will recommend that it not be checked in by library authors, at least for released versions, since pins are not inherited and thus this information may be confusing. We may codify this recommendation into a warning in a future package manager workflow which provided assistance in publishing package versions. In the presence of a top-level Package.pins file, the package manager will respect the pinned dependencies recorded in the file whenever it needs to do dependency resolution (e.g., on the initial checkout or when updating). In the absence of a top-level Package.pins file, the package manager will operate based purely on the requirements specified in the package manifest, but will then automatically record the choices it makes into a Package.pins file as part of the “automatic pinning” feature. The goal of this behavior is to encourage reproducible behavior among package authors who share the pin file (typically by checking it in). We will also provide an explicit mechanism by which package authors can opt out of the automatic pinning default for their package. The pins file will not override manifest specified version requirements and it will be a warning if there is a conflict between the pins and the manifest specification. The pins file will also not influence dependency resolution for dependent packages; for example if application A depends on library B which in turn depends on library C, then package resolution for application A will use the manifest of library B to learn of the dependency on library C, but ignore any Package.pins file belonging to library B when deciding which version of library C to use. Detailed Design We will add a new command pin to swift package tool with following semantics: $ swift package pin ( [--all] | [&lt;package-name&gt;] [&lt;version&gt;] ) [--message &lt;message&gt;] The package-name refers to the name of the package as specified in its manifest. This command pins one or all dependencies. The command which pins a single version can optionally take a specific version to pin to, if unspecified (or with --all) the behavior is to pin to the current package version in use. Examples: $ swift package pin --all - pins all the dependencies. $ swift package pin Foo - pins Foo at current resolved version. $ swift package pin Foo 1.2.3 - pins Foo at 1.2.3. The specified version should be valid and resolvable. The --message option is an optional argument to document the reason for pinning a dependency. This could be helpful for user to later remember why a dependency was pinned. Example: `$ swift package pin Foo --message &quot;The patch updates for Foo are really unstable and need screening.&quot;` NOTE: When we refer to dependencies in the context of pinning, we are referring to all dependencies of a package, i.e. the transitive closure of its immediate dependencies specified in the package manifest. One of the important ways in which pinning is useful is because it allows specifying a behavior for the closure of the dependencies outside of them being named in the manifest. We will add two additional commands to pin as part of the automatic pinning workflow (see below): $ swift package pin ( [--enable-autopin] | [--disable-autopin] ) These will enable or disable automatic pinning for the package (this state is recorded in the Package.pins file). These commands are verbose, but the expectation is that they are very infrequently run, just to establish the desired behavior for a particular project, and then the pin file (containing this state) is checked in to source control. We will add a new command unpin: $ swift package unpin ( [--all] | [&lt;package-name&gt;] ) This is the counterpart to the pin command, and unpins one or all packages. It is an error to attempt to unpin when automatic pinning is enabled. We will fetch and resolve the dependencies when running the pin commands, in case we don’t have the complete dependency graph yet. We will extend the workflow for update to honor version pinning, that is, it will only update packages which are unpinned, and it will only update to versions which can satisfy the existing pins. The update command will, however, also take an optional argument --repin: $ swift package update [--repin] The update command will warn if there are no unpinned packages which can be updated. Otherwise, the behavior is to update all unpinned packages to the latest possible versions which can be resolved while respecting the existing pins. The [--repin] argument can be used to lift the version pinning restrictions. In this case, the behavior is that all packages are updated, and packages which were previously pinned are then repinned to the latest resolved versions. When automatic pinning is enabled, package update would by default have absolutely no effect without --repin. Thus, we will make package update act as if --repin was specified whenever automatic pinning is enabled. This is a special case, but we believe it is most likely to match what the user expects, and avoids have a command syntax which has no useful behavior in the automatic pinning mode. The update and checkout will both emit logs, notifying the user that pinning is in effect. The swift package show-dependencies subcommand will be updated to indicate if a dependency is pinned. Automatic Pinning The package manager will have automatic pinning enabled by default (this is equivalent to swift package pin --enable-autopin), although package project owners can choose to disable this if they wish to have more fine grained control over their pinning behavior. When automatic pinning is enabled, the package manager will automatic record all package dependencies in the Package.pins file. If package authors do not check this file into their source control, the behavior will typically be no different than the existing package manager behavior (one exception is the package update behavior described above). If a package author does check the file into source control, the effect will be that anyone developing directly on this package will end up sharing the same dependency versions (and modifications will be commited as part of the SCM history). The automatic pinning behavior is an extension of the behaviors above, and works as follows: When enabled, the package manager will write all dependency versions into the pin file after any operation which changes the set of active working dependencies (for example, if a new dependency is added). A package author can still change the individual pinned versions using the package pin commands, these will simply update the pinned state. Some commands do not make sense when automatic pinning is enabled; for example, it is not possible to unpin and attempts to do so will produce an error. Since package pin information is not inherited across dependencies, our recommendation is that packages which are primarily intended to be consumed by other developers either disable automatic pinning or put the Package.pins file into .gitignore, so that users are not confused why they get different versions of dependencies that are those being used by the library authors while they develop. Future Directions We have intentionally kept the pin file format an implementation detail in order to allow for future expansion. For example, we would like to consider embedding additional information on a known tag (like its SHA, when using Git) in the pins file as a security feature, to prevent man-in-the-middle attacks on parts of the package graph. Impact on existing code There will be change in the behaviors of swift build and swift package update in presence of the pins file, as noted in the proposal, however the existing package will continue to build without any modifications. Alternative considered Minimal pin feature set A prior version of this proposal did not pin by default. Since this proposal includes this behavior, we could in theory eliminate the fine grained pinning feature set we expose, like package pin &lt;name&gt; and package unpin. However, we believe it is important for package authors to retain a large amount of control over how their package is developed, and we wish the community to aspire to following semantic versioning strictly. For that reason, we wanted to support mechanisms so that package authors wishing to follow this model could still pin individual dependencies. Pin by default This discussion is historical, from a prior version of a proposal which did not include the automatic pinning behavior; which we altered the proposal for. We have left it in the proposal for historical context. Much discussion has revolved around a single policy-default question: whether SwiftPM should generate a pins file as a matter of course any time it builds. This is how some other package managers work, and it is viewed as a conservative stance with respect to making repeatable builds more likely between developers. Developers will see the pins file and will be likely to check it in to their SCM system as a matter of convention. As a side effect, other developers cloning and trying out the package will then end up using the same dependencies the developer last published. While pinning does reduce the risk of packages failing to build, this practice discourages the community from relying on semver compatibility to completely specify what packages are compatible. That in turn makes it more likely for packages to fail to correctly follow the semver specification when publishing versions. Unfortunately, when packages don’t correctly follow semver then it requires downstream clients to overspecify their dependency constraints since they cannot rely on the package manager automatically picking the appropriate version. Overconstraint is much more of a risk in Swift than in other languages using this style of package management. Specifically: Swift does not support linking multiple versions of a dependency into the same artifact at the same time. Therefore the risk of producing a “dependency hell” situation, in which two packages individually build but cannot be combined due to over-constrained transitive dependencies, is significantly higher than in other languages. Changing the compiler support in this area is not something which is currently planned as a feature, so our expectation is that we will have this limitation for a significant time. For example, if package Foo depends on library LibX version 1.2, and package Bar depends on LibX 1.3, and these are specific version constraints that do not allow version-range variation, then SwiftPM will not allow building a product that depends on both Foo and Bar: their requirements for LibX are incompatible. Where other package managers will simultaneously link two versions of LibX – and hope that the differing simultaneous uses of LibX do not cause other compile-time or run-time errors – SwiftPM will simply fail to resolve the dependencies. We therefore wish to encourage library authors to keep their packages building and testing with as recent and as wide a range of versions of their dependencies as possible, and guard more vigorously than other systems against accidental overconstraint. One way to encourage this behavior is to avoid emitting pins files by default. We also believe that if packages default to exposing their pin files as part of their public package, there is a substantial risk that when developers encounter build failures they will default to copying parts of those pinned versions into their manifest, rather than working to resolve the semver specification issues in the dependencies. If this behavior becomes common place, it may even become standard practice to do this proactively, simply to avoid the potential of breakage. This practice is likely because it resolves the immediate issue (a build failure) without need for external involvement, but if it becomes widespread then it has a side-effect of causing significant overconstraint of packages (since a published package may end up specifying only a single version it is compatible with). Finally, we are also compelled by several pragmatic implications of an approach which optimizes for reliance on the semver specifications: We do not yet have a robust dependency resolution algorithm we can rely on. The complexity of the algorithm is in some ways relative to the degree of conflicts we expect to be present in the package graph (for example, this may mean we need to investigate significantly more work in optimizing its performance, or in managing its diagnostics). The Swift package manager and its ecosystem is evolving quickly, and we expect it will continue to do so for some time. As a consequence, we anticipate that packages will frequently be updated simply to take advantage of new features. Optimizing for an ecosystem where everyone can reliably live on the latest semver-compatible release of a package should help make that a smoother process. If, in practice, the resulting ecosystem either contains too many packages that fail to build, or if a majority of users emit pins files manually regardless of default, this policy choice can be revisited. We considered approaches to “pin by default” that used separate mechanisms when publishing a package to help address the potential for overconstraint, but were unable to find a solution we felt was workable. Naming Choice This feature is called “locking” and the files are “lockfiles” in many other package managers, and there has been considerable discussion around whether the Swift package manager should follow that precedent. In Swift, we have tried to choose the “right” answer for names in order to make the resulting language consistent and beautiful. We have found significant consensus that without considering the prededent, the “lock” terminology is conceptually the wrong word for the operation being performed here. We view pinning as a workflow-focused feature, versus the specification in the manifest (which is the “requirement”). The meaning of pin connotes this transient relationship between the pin action and the underlying dependency. In constrast, not only does lock have the wrong connotation, but it also is a heavily overloaded word which can lead to confusion. For example, if the package manager used POSIX file locking to prevent concurrent manipulation of packages (a feature we intend to implement), and we also referred to the pinning files as “lock files”, then any diagnostics using the term “lock file” would be confusing to a newcomer to the ecosystem familiar with the pinning mechanism but unfamiliar with the concept of POSIX file locking. We believe that there are many more potential future users of the Swift package manager than there are current users familiar with the lock, and chose the “pin” terminology to reflect what we thought was ultimately the best word for the operation, in order to contribute to the best long term experience.",
    "url": "http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html",
    "relUrl": "/docs/2019-08-26-0145-package-manager-version-pinning.html"
  },
  "145": {
    "id": "145",
    "title": "SE-0146 Package Manager Product Definitions",
    "content": "Package Manager Product Definitions Proposal: SE-0146 Author: Anders Bertelrud Review manager: Daniel Dunbar Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-3606 Introduction This proposal introduces the concept of products to the Swift Package Manager, and proposes enhancements to the Package.swift syntax to let packages define products that can be referenced by other packages. Motivation Currently, the Swift Package Manager has only a limited notion of the products that are built for a package. It does have a set of rules by which it infers implicit products based on the contents of the targets in the package, and it also has a small amount of undocumented, unsupported package manifest syntax for explicitly declaring products, but it provides no supported way for package authors to declare what their packages produce. Also, while the Swift Package Manager currently supports dependencies between packages, it has no support for declaring a dependency on anything more fine-grained than a package. Such fine-grained dependencies are often desired, and this desire has in the past been expressed as a request for the ability to declare a dependency on an arbitrary target in a package. That, in turn, leads to requests to provide access control for targets, since a package author may want control over which targets can be independently accessed from outside the package. Even if visibility control for targets were to be provided (indeed, an early draft of the package manifest syntax had the notion of “publishing” a target to external clients), there would still be no way for the package author to declare anything about the kind of product that should be built. One consequence of the lack of ability to define dependencies at subpackage granularity is that package authors have to break up packages into several smaller packages in order to achieve the layering they want. Such package decomposition may be appropriate in some cases, but should be done based on what makes sense from a conceptual standpoint and not because the Swift Package Manager doesn’t allow the author to express their intent. For example, consider the package for a component that has both a library API and command line tools. Such a package is also likely to be partitioned into a set of core libraries on which both the public library and the command line tools depend, but which should remain a private implementation detail as far as clients are concerned. Such a package would currently need to be split up into three separate packages in order to provide the appropriate dependency granularity: one for the public library, another for the command line tools, and a third, private package to provide the shared implementation used by the other two packages. In the case of a single conceptual component that should have a single version number, this fracturing into multiple packages is directly contrary to the developer’s preferred manner of packaging. What is needed is a way to allow package authors to define conceptually distinct products of a package, and to allow client packages to declare dependencies on individual products in a package. Furthermore, explicit product definitions would allow the package author to control the types of artifacts produced from the targets in the package. This would include such things as whether a library is built as a static archive or a dynamic library. We expect that additional product types will be added over time to let package authors build more kinds of artifacts. Proposed solution We will introduce a documented and supported concept of a package product, along with package manifest improvements to let package authors define products and to let package clients define dependencies on such products. In defining a product, a package author will be able specify the type of product as well as its characteristics. Product definitions A package will be able to define an arbitrary number of products that are visible to all direct clients of the package. A product definition consists of a product type, a name (which must be unique among the products in the package), and the root targets that comprise the implementation of the product. There may also be additional properties depending on the type of product (for example, a library may be static or dynamic). Any target may be included in multiple products, though not all kinds of targets are usable in every kind of product; for example, a test target is not able to be included in a library product. The products represent the publicly vended package outputs on which client packages can depend. Other artifacts might also be created as part of building the package, but what the products specifically define are the conceptual “outputs” of the package, i.e. those that make sense to think of as something a client package can depend on and use. Examples of artifacts that are not necessarily products include built unit tests and helper tools that are used only during the build of the package. An example of a package that defines two library products and one executable product: let package = Package( name: &quot;MyServer&quot;, targets: [ Target(name: &quot;Utils&quot;), Target(name: &quot;HTTP&quot;, dependencies: [&quot;Utils&quot;]), Target(name: &quot;ClientAPI&quot;, dependencies: [&quot;HTTP&quot;, &quot;Utils&quot;]), Target(name: &quot;ServerAPI&quot;, dependencies: [&quot;HTTP&quot;]), Target(name: &quot;ServerDaemon&quot;, dependencies: [&quot;ServerAPI&quot;]), ], products: [ .Library(name: &quot;ClientLib&quot;, type: .static, targets: [&quot;ClientAPI&quot;]), .Library(name: &quot;ServerLib&quot;, type: .dynamic, targets: [&quot;ServerAPI&quot;]), .Executable(name: &quot;myserver&quot;, targets: [&quot;ServerDaemon&quot;]), ] ) The initial types of products that can be defined are executables and libraries. Libraries can be declared as either static or dynamic, but when possible, the specific type of library should be left unspecified, letting the build system chooses a suitable default for the platform. Note that tests are not considered to be products, and do not need to be explicitly defined. A product definition lists the root targets to include in the product; for product types that vend interfaces (e.g. libraries), the root targets are those whose modules will be available to clients. Any dependencies of those targets will also be included in the product, but won’t be made visible to clients. The Swift compiler does not currently provide this granularity of module visibility control, but the set of root targets still constitutes a declaration of intent that can be used by IDEs and other tools. We also hope that the compiler will one day support this level of visibility control. See SR-3205 for more details. For example, in the package definition shown above, the library product ClientLib would only vend the interface of the ClientAPI module to clients. Since ClientAPI depends on HTTP and Utilities, those two targets would also be compiled and linked into ClientLib, but their interfaces should not be visible to clients of ClientLib. Implicit products SwiftPM 3 applies a set of rules to infer products based on the targets in the package. For backward compatibility, SwiftPM 4 will apply the same rules to packages that use the SwiftPM 3 PackageDescription API. The package describe command will show implied product definitions. When switching to the SwiftPM 4 PackageDescription API, the package author takes over responsibility for defining the products. There will be tool support (probably in the form of a fix-it on a “package defines no products” warning) to make it easy for the author to add such definitions. Also, the package init command will be extended to automatically add the appropriate product definitions to the manifest when it creates the package. There was significant discussion about whether the implicit product rules should continue to be supported alongside the explicit product declarations. The tradeoffs are described in the “Alternatives considered” section. Product dependencies A target will be able to declare its use of the products that are defined in any of the external package dependencies. This is in addition to the existing ability to declare dependencies on other targets in the same package. To support this, the dependencies parameter of the Target() initializer will be extended to also allow product references. To see how this works, remember that each string listed for the dependencies parameter is just shorthand for .target(name: &quot;...&quot;), i.e. a dependency on a target within the same package. For example, the target definition: Target(name: &quot;Foo&quot;, dependencies: [&quot;Bar&quot;, &quot;Baz&quot;]) is shorthand for: Target(name: &quot;Foo&quot;, dependencies: [.target(name: &quot;Bar&quot;), .target(name: &quot;Baz&quot;)]) This will be extended to support product dependencies in addition to target dependencies: let package = Package( name: &quot;MyClientLib&quot;, dependencies: [ .package(url: &quot;https://github.com/Alamofire/Alamofire&quot;, majorVersion: 3), ], targets: [ Target(name: &quot;MyUtils&quot;), Target(name: &quot;MyClientLib&quot;, dependencies: [ .target(name: &quot;MyUtils&quot;), .product(name: &quot;Alamofire&quot;, package: &quot;Alamofire&quot;) ]) ] ) The package name is the canonical name of the package, as defined in the manifest of the package that defines the product. The product name is the name specified in the product definition of that same manifest. The package name is optional, since the product name is almost always unambiguous (and is frequently the same as the package name). The package name must be specified if there is more than one product with the same name in the package graph (this does not currently work from a technical perspective, since Swift module names must currently be unique within the package graph). In order to continue supporting the convenience of being able to use plain strings as shorthand, and in light of the fact that most of the time the names of packages and products are unique enough to avoid confusion, we will extend the short-hand notation so that a string can refer to either a target or a product. The Package Manager will first try to resolve the name to a target in the same package; if there isn’t one, it will instead to resolve it to a product in one of the packages specified in the dependencies parameter of the Package() initializer. For both the shorthand form and the complete form of product references, the only products that will be visible to the package are those in packages that are declared as direct dependencies – the products of indirect dependencies are not visible to the package. Detailed design Product definitions We will add a products parameter to the Package() initializer: Package( name: String, pkgConfig: String? = nil, providers: [SystemPackageProvider]? = nil, targets: [Target] = [], dependencies: [Package.Dependency] = [], products: [Product] = [], exclude: [String] = [] ) The definition of the Product type will be: public enum Product { public class Executable { public init(name: String, targets: [String]) } public class Library { public enum LibType { case .static case .dynamic } public init(name: String, type: LibType? = nil, targets: [String]) } } The namespacing allows the names of the product types to be kept short. As with targets, there is no semantic significance to the order of the products in the array. Implicit products If the products array is omitted, and if the package uses version 3 of the PackageDescription API, the Swift Package Manager will infer a set of implicit products based on the targets in the package. The rules for implicit products are the same as in SwiftPM 3: An executable product is implicitly defined for any target that produces an executable module (as defined here: https://github.com/apple/swift-package-manager/blob/master/Documentation/Reference.md). If there are any library targets, a single library product is implicitly defined for all the library targets. The name of this product is based on the name of the package. Product dependencies We will add a new enum case to the TargetDependency enum to represent dependencies on products, and another enum case to represent an unbound by-name dependency. The string-literal conversion will create a by-name dependency instead of a target dependency, and there will be logic to bind the by-name dependencies to either target or product dependencies once the package graph has been resolved: public final class Target { /// Represents a target&#39;s dependency on another entity. public enum TargetDependency { /// A dependency on a target in the same project. case Target(name: String) /// A dependency on a product from a package dependency. The package name match the name of one of the packages named in a `.package()` directive. case Product(name: String, package: String?) /// A by-name dependency that resolves to either a target or a product, as above, after the package graph has been loaded. case ByName(name: String) } /// The name of the target. public let name: String /// Dependencies on other entities inside or outside the package. public var dependencies: [TargetDependency] /// Construct a target. public init(name: String, dependencies: [TargetDependency] = []) } For compatibility reasons, packages using the Swift 3 version of the PackageDescription API will have implicit dependencies on the directly specified packages. Packages that have adopted the Swift 4 version need to declare their product dependencies explicitly. Impact on existing code There will be no impact on existing packages that follow the documented Swift Package Manager 3.0 format of the package manifest. Until the package is upgraded to the 4.0 format, the Swift Package Manager will continue to infer products based the existing rules. Alternatives considered Many alternatives were considered during the development of this proposal, and in many cases the choice was between two distinct approaches, each with clear advantages and disadvantages. This section summarizes the major alternate approaches. Not adding product definitions Instead of product definitions, fine-grained dependencies could be introduced by allowing targets to be marked as public or private to the package. Advantage It would avoid the need to introduce new concepts. Disadvantage It would not provide any way for a package author to control the type and characteristics of the various artifacts. Relying on the implied products that result from the inference rules is not likely to be scalable in the long term as we introduce new kinds of product types. Inferring implicit products An obvious alternative to the proposal would be to keep the inference rules even in v4 of the PackageDescription API. Advantage It can be a lot more convenient to not have to declare products, and to be able to add new products just by adding or renaming files and directories. This is particularly true for small, simple packages. Disadvantages The very fact that it is so easy to change the set of products without modifying the package manifest can lead to unexpected behavior due to seemingly unrelated changes (e.g. creating a file called main.swift in a module changes that module from a library to an executable). Also, as packages become more complex and new conceptual parts on which clients can depend are introduced, the interaction of implicit rules with the explicit product definitions can become very complicated. We plan to provide some of the convenience through tooling. For example, an IDE (or swift package itself on the command line) can offer to add product definitions when it notices certain types of changes to the structure of the package. We believe that having defined product types lets the tools present a lot better diagnostics and other forms of help to users, since it provides a clear statement of intent on the part of the package author. Distinguishing between target dependencies and product dependencies The proposal extends the Target() initializer’s dependencies parameter to allow products as well as targets; another approach would have been to add a new parameter, e.g. externalDependencies or productDependencies. Advantage Targets and products are different types of entities, and it is possible for a target and a product to have the same name. Having the dependencies parameter as a heterogeneous list can lead to ambiguity. Disadvantages Conceptually the dependency itself is the same concept, even if type of entity being depended on is technically different. In both cases (target and product), it is up to the build system to determine the exact type of artifacts that should be produced. In most cases, there is no actual semantic ambiguity, since the name of a target, product, and package are often the same uniquely identifiable “brand” name of the component. Also, separating out each type of dependency into individual homogeneous lists doesn’t scale. If a third type of dependency needs to be introduced, a third parameter would also need to be introduced. Keeping the list heterogeneous avoids this.",
    "url": "http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html",
    "relUrl": "/docs/2019-08-26-0146-package-manager-product-definitions.html"
  },
  "146": {
    "id": "146",
    "title": "SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer",
    "content": "Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer Proposal: SE-0147 Author: Ben Cohen Review Manager: Doug Gregor Status: Implemented (Swift 3.1) Decision Notes: Rationale Implementation: apple/swift#6601 Introduction The version of UnsafeMutablePointer.initialize(from:) that takes a Collection should be deprecated in favor of a new method on UnsafeMutableBufferPointer that takes a Sequence, with a goal of improving memory safety and enabling faster initialization of memory from sequences. Similarly, UnsafeMutableRawPointer.initializeMemory(as:from:) should be deprecated in favor of a new UnsafeMutableRawBufferPointer.initialize(as:from:). Motivation UnsafeMutablePointer.initialize(from:) underpins implementations of collections, such as Array, which are backed by a buffer of contiguous memory. When operations like Array.append are implemented, they first ensure their backing store can accommodate the number of elements in a source collection, then pass that collection into the initialize method of their backing store. Unfortunately there is a major flaw in this design: a collection’s count might not accurately reflect the number of elements returned by its iterator. For example, some collections can be misused to return different results on each pass. Or a collection could just be implemented incorrectly. If the collection’s count ends up being lower than the actual number of elements yielded by its iterator, the caller may not allocate enough memory for them. Since UnsafeMutablePointer.initialize(from:) does not receive a limiting capacity, this method would then scribble past the end of the buffer, resulting in undefined behavior. Normally when using Unsafe... constructs in Swift the burden of ensuring safety falls on the caller. When using this method with something known to have correct behavior, like an Array, you can do that. But when used in a generic context like Array.append(contentsOf:), where the caller of initialize does not know exactly what kind of collection they are passing in, it is impossible to use this method safely. You can see the impact of this by running the following code. which exhibits memory-unsafe behavior despite only using “safe” constructs from the standard library, something that shouldn’t be possible: var i = 0 let c = repeatElement(42, count: 10_000).lazy.filter { _ in // capture i and use it to exhibit inconsistent // behavior across iteration of c i += 1; return i &gt; 10_000 } var a: [Int] = [] // a will allocate insufficient memory before // calling self._buffer.initialize(from: c) a.append(contentsOf: c) // memory access violation While a collection returning an inconsistent count is a programming error (in this case, use of the lazy filter in combination with an logically impure function, breaking value semantics), and it would be reasonable for the standard library to trap under these circumstances, undefined behavior like this is not OK. In addition, the requirement to pre-allocate enough memory to accommodate from.count elements rules out using this method to initialize memory from a sequence, since sequences don’t have a count property (they have an underestimatedCount but this isn’t enough since underestimated counts are exactly the problem described above). The proposed solution would allow for this, enabling some internal performance optimizations for generic code. Proposed solution The existing initialize method should be altered to receive a capacity, to avoid running beyond what the caller has allocated. Since UnsafeMutableBufferPointer already exists to encapsulate “pointer plus a count”, the method should be moved to that type and the old method deprecated. This new method should take a Sequence as its from argument, and handle possible element overflow, returning an Iterator of any elements not written due to a lack of space. It should also return an index into the buffer to indicate where the elements were written up to in cases of underflow. Once this has been done, the version of Array.append(contentsOf:) that takes a collection can be eliminated, since the performance benefits of the collection version could be incorporated into the implementation of the one that takes a sequence. The intention of this change is to add memory safety, not to allow the flexibility of collections giving inconsistent counts. Therefore the precondition should remain that the caller should ensure enough memory is allocated to accommodate source.underestedCount elements. The only difference is if they don’t, the behaviour should be well-defined (ideally by trapping, if this can be done efficiently). Therefore: Under-allocating the destination buffer relative to underestimatedCount may trap at runtime. May rather than will because this is an O(n) operation on some collections, so may only be enforced in debug builds. Over-allocating the destination buffer relative to underestimatedCount is valid and simply results in sequence underflow with potentially uninitialized buffer memory (a likely case with arrays that reserve more than they need). The source sequence’s actual count may exceed both underestimatedCount and the destination buffer size, resulting in sequence overflow. This is also valid and handled by returning an iterator to the uncopied elements as an overflow sequence. A matching change should also be made to UnsafeRawBufferPointer.initializeMemory(from:). The one difference is that for convenience this should return an UnsafeMutableBufferPointer of the (typed) intialized elements instead of an index into the raw buffer. Detailed design The following API changes would be made: extension UnsafeMutablePointer { @available(*, deprecated, message: &quot;it will be removed in Swift 4.0. Please use &#39;UnsafeMutableBufferPointer.initialize(from:)&#39; instead&quot;) public func initialize&lt;C : Collection&gt;(from source: C) where C.Iterator.Element == Pointee } extension UnsafeMutableBufferPointer { /// Initializes memory in the buffer with the elements of `source`. /// Returns an iterator to any elements of `source` that didn&#39;t fit in the /// buffer, and an index to the point in the buffer one past the last element /// written (so `startIndex` if no elements written, `endIndex` if the buffer /// was completely filled). /// /// - Precondition: The memory in `self` is uninitialized. The buffer must contain /// sufficient uninitialized memory to accommodate `source.underestimatedCount`. /// /// - Postcondition: The returned iterator /// - Postcondition: The `Pointee`s at `self[startIndex..&lt;initializedUpTo]` /// are initialized. @discardableResult public func initialize&lt;S: Sequence&gt;( from source: S ) -&gt; (unwritten: S.Iterator, initializedUpTo: Index) where S.Iterator.Element == Iterator.Element } extension UnsafeMutableRawPointer { @available(*, deprecated, message: &quot;it will be removed in Swift 4.0. Please use &#39;UnsafeMutableRawBufferPointer.initialize(from:)&#39; instead&quot;) @discardableResult public func initializeMemory&lt;C : Collection&gt;( as: C.Iterator.Element.Type, from source: C ) -&gt; UnsafeMutablePointer&lt;C.Iterator.Element&gt; } extension UnsafeMutableRawBufferPointer { /// Initializes memory in the buffer with the elements of /// `source` and binds the initialized memory to type `T`. /// /// Returns an iterator to any elements of `source` that didn&#39;t fit in the /// buffer, and an index into the buffer one past the last byte written. /// /// - Precondition: The memory in `self` is uninitialized or initialized to a /// trivial type. /// /// - Precondition: The buffer must contain sufficient memory to /// accommodate at least `source.underestimatedCount` elements. /// /// - Postcondition: The memory at `self[startIndex..&lt;initialized.count * /// MemoryLayout&lt;S.Iterator.Element&gt;.stride] is bound to type `S.Iterator`. /// /// - Postcondition: The memory at `self[startIndex..&lt;initialized.count * /// MemoryLayout&lt;S.Iterator.Element&gt;.stride] are initialized.. @discardableResult public func initializeMemory&lt;S: Sequence&gt;( as: S.Iterator.Element.Type, from source: S ) -&gt; (unwritten: S.Iterator, initialized: UnsafeMutableBufferPointer&lt;S.Iterator.Element&gt;) } The += operators and append&lt;C : Collection&gt;(contentsOf newElements: C) methods on Array, ArraySlice and ContiguousArray will be removed as no-longer needed, since the implementation that takes a sequence can be made to be as efficient. The += can be replaced by a generic one that calls RangeReplaceableCollection.append(contenstsOf:): (note, because it forwards on to a protocol requirement, it itself does not need to be a static operator protocol requirement) /// Appends the elements of a sequence to a range-replaceable collection. /// /// Use this operator to append the elements of a sequence to the end of /// range-replaceable collection with same `Element` type. This example /// appends the elements of a `Range&lt;Int&gt;` instance to an array of /// integers. /// /// var numbers = [1, 2, 3, 4, 5] /// numbers += 10...15 /// print(numbers) /// // Prints &quot;[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]&quot; /// /// - Parameters: /// - lhs: The array to append to. /// - rhs: A collection or finite sequence. /// /// - Complexity: O(*n*), where *n* is the length of the resulting array. public func += &lt; R : RangeReplaceableCollection, S : Sequence &gt;(lhs: inout R, rhs: S) where R.Iterator.Element == S.Iterator.Element Source compatibility The addition of the new method does not affect source compatibility. The deprecation of the old method does, but since this is a fundamentally unsound operation that cannot be fixed except via a source-breaking change, it should be aggressively deprecated and then removed. The knock-on ability to remove the version of Array.append(contentsOf:) that takes a collection does not affect source compatibility since the version for sequences will be called for collections instead. Effect on ABI stability This change must be made prior to declaring ABI stability, since it is currently called from the Array.append method, which is inlineable. Alternatives considered Overflow (elements remain on the returned iterator) and underflow (initializedUpTo != endIndex) are almost but not quite mutually exclusive – if the buffer is exactly used, the caller must call .next() to check for any unwritten elements, which means the returned value must be declared var, and the check can’t be chained. This is a little ugly, but is the unavoidable consequence of how iterators work: since iterating is consuming, the initialize method cannot easily test for this and indicate it back to the caller in some other way (such as returning an optional iterator).",
    "url": "http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html",
    "relUrl": "/docs/2019-08-26-0147-move-unsafe-initialize-from.html"
  },
  "147": {
    "id": "147",
    "title": "SE-0148 Generic Subscripts",
    "content": "Generic Subscripts Proposal: SE-0148 Author: Chris Eidhof Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-115 Introduction Make it possible to have generic subscripts. Example: extension Collection { subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Iterator.Element] where Indices.Iterator.Element == Index { // ... } } Or a generic return type: extension JSON { subscript&lt;T: JSONConvertible&gt;(key: String) -&gt; T? { // ... } } Swift-evolution thread: Generic Subscripts. Motivation Currently, subscripts can’t be generic. This is limiting in a number of ways: Some subscripts are very specific and could be made more generic. Some generic methods would feel more natural as a subscript, but currently can’t be. This also makes it impossible to use them as lvalues. This feature is also mentioned in the generics manifesto under generic subscripts. The Rationalizing Sequence end-operation names proposal could greatly benefit from this, as well as the ideas in the String Manifesto. Proposed solution Add generics to subscripts. There are two pieces to this: where to add the generic parameter list, and where to add the where-clause. The most straightforward way would be to use the same syntax as methods: extension Dictionary { subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Iterator.Element] where Indices.Iterator.Element == Index { // ... } } Update Jan 20: during the review it came up that while we’re at it, we should add default arguments to subscripts. For example, the following (contrived) example: subscript&lt;A&gt;(index: A? = nil) -&gt; Element { // ... } Adding default arguments would unify the compiler’s handling of subscripts and functions. Source compatibility This is a purely additive change. We don’t propose changing the Standard Library to use this new feature, that should be part of a separate proposal. (Likewise, we should consider making subscripts throws in a separate proposal). Effect on ABI stability It won’t change the ABI of existing subscript calls. Effect on API resilience It won’t change the ABI of existing subscript calls, but if the standard library introduces new generic subscripts that replace older non-generic subscripts, it will impact ABI. Alternatives considered None.",
    "url": "http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html",
    "relUrl": "/docs/2019-08-26-0148-generic-subscripts.html"
  },
  "148": {
    "id": "148",
    "title": "SE-0149 Package Manager Support for Top of Tree development",
    "content": "Package Manager Support for Top of Tree development Proposal: SE-0149 Author: Boris Bügling Review Manager: Daniel Dunbar Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-3709 Introduction This proposal adds enhancements to swift package edit to support development of packages without strict versioning (“top of tree” development). Motivation The package manager currently supports package dependencies which are strictly versioned according to semantic versioning. This works well for users of packages and it is possible to edit a package in place using swift package edit already, but we want to allow developers to manually check out repositories on their machines as overrides. This is useful when developing multiple packages in tandem or when working on packages alongside an application. When a developer owns multiple packages that depend on each other, it can be necessary to work on a feature across more than one of them at the same time, without having to tag versions in between. The repositories for each package would usually already be checked out and managed manually by the developer, allowing them to switch branches or perform other SCM operations at will. A similar situation will arise when working on a feature that requires code changes to both an application and a dependent package. Developers want to iterate on the package by directly in the context of the application without having to release spurious versions of the package. Allowing developers to provide their own checkouts to the package manager as overrides will make this workflow much easier than it currently is. Proposed solution As a solution to this problem, we propose to extend swift package edit to take an optional path argument to an existing checkout so that users can manually manage source control operations. Detailed Design We will extend the edit subcommand with a new optional argument --path: $ swift package edit bar --path ../bar This allows users to manage their own checkout of the bar repository and will make the package manager use that instead of checking out a tagged version as it normally would. Concretely, this will make ./Packages/bar a symbolic link to the given path in the local filesystem, store this mapping inside the workspace and will ensure that the package manager will no longer be responsible for managing checkouts for the bar package, instead the user is responsible for managing the source control operations on their own. This is consistent with the current behavior of swift edit. Using swift package unedit will also work unchanged, but the checkout itself will not be deleted, only the symlink. If there is no existing checkout at the given filesystem location, the package manager will do an initial clone on the user’s behalf. Impact on existing code There will no impact on existing code. Alternative considered We could have used the symlink in the Packages directory as primary data, but decided against it in order to be able to provide better diagnostics and distinguish use of swift package edit from the user manually creating symbolic links. This makes the symlink optional, but we decided to still create it in order to keep the structure of the Packages directory consistent independently of the use of this feature.",
    "url": "http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html",
    "relUrl": "/docs/2019-08-26-0149-package-manager-top-of-tree.html"
  },
  "149": {
    "id": "149",
    "title": "SE-0150 Package Manager Support for branches",
    "content": "Package Manager Support for branches Proposal: SE-0150 Author: Boris Bügling Review Manager: Daniel Dunbar Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-666 Introduction This proposal adds enhancements to the package manifest to support development of packages without strict versioning. This is one of two features, along with “Package Manager Support for Top of Tree development”, being proposed to enable use of SwiftPM to develop on “top of tree” of related packages. Motivation The package manager currently supports packages dependencies which are strictly versioned according to semantic versioning. This is how a package’s dependencies should be specified when that package is released, but this requirement hinders some development workflows: bootstrapping a new package which does not yet have a version at all developing related packages in tandem in between releases, when one package may depend on the latest revision of another, which has not yet been tagged for release Proposed solution As a solution to this problem, we propose to extend the package manifest to allow specifying a branch or revision instead of a version to support revlocked packages and initial bootstrapping. In addition, we will also allow specifying a branch or revision as an option to the pin subcommand. Detailed Design Specifying branches or revisions in the manifest We will introduce a second initializer for .Package which takes a branch instead of a version range: import PackageDescription let package = Package( name: &quot;foo&quot;, dependencies: [ .Package(url: &quot;http://url/to/bar&quot;, branch: &quot;development&quot;), ] ) In addition, there is also the option to use a concrete revision instead: import PackageDescription let package = Package( name: &quot;foo&quot;, dependencies: [ .Package(url: &quot;http://url/to/bar&quot;, revision: &quot;0123456789012345678901234567890123456789&quot;), ] ) Note that the revision parameter is a string, but it will still be sanity checked by the package manager. It will only accept the full 40 character commit hash here for Git and not a commit-ish or tree-ish. Whenever dependencies are checked out or updated, if a dependency on a package specifies a branch instead of a version, the latest commit on that branch will be checked out for that package. If a dependency on a package specifies a branch instead of a version range, it will override any versioned dependencies present in the current package graph that other packages might specify. For example, consider this graph with the packages A, B, C and D: A -&gt; (B:master, C:master) B -&gt; D:branch1 C -&gt; D:branch2 The package manager will emit an error in this case, because there are dependencies on package D for both branch1 and branch2. While this feature is useful during development, a package’s dependencies should be updated to point at versions instead of branches before that package is tagged for release. This is because a released package should provide a stable specification of its dependencies, and not break when a branch changes over time. To enforce this, it is an error if a package referenced by a version-based dependency specifies a branch in any of its dependencies. Running swift package update will update packages referencing branches to their latest remote state. Running swift package pin will store the commit hash for the currently checked out revision in the pins file, as well as the branch name, so that other users of the package will receive the exact same revision if pinning is enabled. If a revision was specified, users will always receive that specific revision and swift package update becomes a no op. Pinning to a branch or revision In addition to specifying a branch or revision in the manifest, we will also allow specifying it when pinning: $ swift pin &lt;package-name&gt; --branch &lt;branch-name&gt; $ swift pin &lt;package-name&gt; --revision &lt;revision&gt; This is meant to be used for situations where users want to temporarily change the source of a package, but it is just an alternative way to get the same semantics and error handling described in the previous section. Impact on existing code There will no impact on existing code. Alternative considered We decided to make using a version-based package dependency with unversioned dependencies an error, because a released package should provide a stable specification of its dependencies. A dependency on a branch could break at any time when the branch is being changed over time.",
    "url": "http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html",
    "relUrl": "/docs/2019-08-26-0150-package-manager-branch-support.html"
  },
  "150": {
    "id": "150",
    "title": "SE-0151 Package Manager Swift Language Compatibility Version",
    "content": "Package Manager Swift Language Compatibility Version Proposal: SE-0151 Authors: Daniel Dunbar, Rick Ballard Review Manager: Anders Bertelrud Status: Implemented (Swift 3.1) Decision Notes: Rationale Bug: SR-3964 Introduction This proposal adds support for the Swift compiler’s new “language compatibility version” feature to the package manager. Motivation The Swift compiler now supports a “language compatibility version” flag which specifies the Swift major language version that the compiler should try to accept. We need support for an additional package manager manifest feature in order for this feature to be used by Swift packages. Proposed solution We will add support to the package manifest declaration to specify a set of supported Swift language versions: let package = Package( name: &quot;HTTP&quot;, ... swiftLanguageVersions: [3, 4]) When building a package, we will always select the Swift language version that is most close to (but not exceeding) the major version of the Swift compiler in use. If a package does not support any version compatible with the current compiler, we will report an error. If a package does not specify any Swift language versions, the language version to be used will match the major version of the the package’s Swift tools version (as discussed in a separate evolution proposal). A Swift tools version with a major version of ‘3’ will imply a default Swift language version of ‘3’, and a Swift tools version with a major version of ‘4’ will imply a default Swift language version of ‘4’. Detailed design We are operating under the assumption that for the immediate future, the Swift language compatibility version accepted by the compiler will remain an integer major version. With this change, the complete package initializer will be: public init( name: String, pkgConfig: String? = nil, providers: [SystemPackageProvider]? = nil, targets: [Target] = [], products: [Product] = [], dependencies: [Dependency] = [], swiftLanguageVersions: [Int]? = nil, exclude: [String] = [] where absence of the optional language version list indicates the default behavior should be used for this package. Example Behaviors Here are concrete examples of how the package manager will compile code, depending on its language version declarations: Version 3 Packager Manager &amp; Swift 3 (only) Language Package The package manager will compile the code with -swift-version 3. Version 3 Packager Manager &amp; Swift 4 (only) Language Package The package manager will report an error, since the package supports no language version compatible with the tools. Version 3 Packager Manager &amp; Swift [3, 4] Language Package The package manager will compile the code with -swift-version 3, matching the major version of the tools in use. Version 4 Packager Manager &amp; Swift 3 (only) Language Package The package manager will compile the code with -swift-version 3. Version 4 Packager Manager &amp; Swift 4 (only) Language Package The package manager will compile the code with -swift-version 4. Version 4 Packager Manager &amp; Swift [3, 4] Language Package The package manager will compile the code with -swift-version 4. Clients wishing to validate actual Swift 3 compatibility are expected to do so by using an actual Swift 3 implementation to build, since the Swift compiler does not commit to maintaining pedantic Swift 3 compatibility (that is, it is designed to accept any valid Swift 3 code in the -swift-version 3 compatibility mode, but not necessarily to reject any code which the Swift 3 compiler would not have accepted). Impact on existing code Since this is a new API, all packages will use the default behavior once implemented. Because the default Swift tools version of existing packages is “3.0.0” (pending approval of the Swift tools version proposal), the Swift 4 package manager will build such packages in Swift 3 mode. When packages wish to migrate to the Swift 4 language, they can either update their Swift tools version or specify Swift 4 as their language version. New packages created with swift package init by the Swift 4 tools will build with the Swift 4 language by default, due to the Swift tools version that swift package init chooses. This is a new manifest API, so packages which adopt this API will no longer be buildable with package manager versions which do not recognize that API. We expect to add support for this API to Swift 3.1, so it will be possible to create packages which support the Swift 4 and 3 languages and the Swift 4 and 3.1 tools. Alternatives considered We could have made the Swift language version default to the version of the Swift tools in use if not specified. However, tying this to the Swift tools version instead allows existing Swift 3 language packages to build with the Swift 4 tools without changes, as they won’t need to explicitly specify a Swift language version in order to continue to build with the Swift 3 language. We chose not to support any command line features to modify the selected version (e.g., to force a Swift 4 compiler to use Swift 3 mode where acceptable) in order to keep this proposal simple. We will consider these in the future if they prove necessary. We considered supporting a way to set the Swift language version on a per-module basis, instead of needing to set it for the entire package. We think this would be best done using build settings, which the package manager does not yet support. We are pending per-module support for this feature until build settings are supported.",
    "url": "http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html",
    "relUrl": "/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html"
  },
  "151": {
    "id": "151",
    "title": "SE-0152 Package Manager Tools Version",
    "content": "Package Manager Tools Version Proposal: SE-0152 Author: Rick Ballard Review Manager: Anders Bertelrud Status: Implemented (Swift 3.1) Decision Notes: Rationale Bug: SR-3965 Introduction This proposal introduces a “Swift tools version” which is declared for each Swift package. The tools version declares the minimum version of the Swift tools required to use the package, determines what version of the PackageDescription API should be used in the Package.swift manifest, and determines which Swift language compatibility version should be used to parse the Package.swift manifest. This feature shall be added to Swift 3.1, to allow packages to manage the transition from Swift 3 to Swift 4 compatibility. Motivation This proposal addresses three problems with one mechanism. First, when a package adopts new features of Swift or the Swift Package Manager, it may no longer be able to be compiled by an older version of the Swift tools, and older tools may not even be able to interpret its Package.swift manifest. Without a mechanism to handle this, a package author who tags a version of their package which uses new features may break the builds of all clients of that package who are using older tools unless that package adjusts its major semantic version, which would unnecessarily stop clients who are using the latest tools from getting that version. This is especially problematic during development of a new version of the Swift tools, when new features have been added which are not yet supported by the current release of the Swift tools. Second, one specific planned change for the Swift Package Manager is a revision of the Package.swift PackageDescription API for Swift 4, to make it conform to Swift conventions and to correct historical mistakes. In order to support backwards compatibility, the old version of the PackageDescription API must remain available. We need some way to determine which version of the PackageDescription API a package wishes to use. Finally, as the Package.swift manifest is itself written in Swift, some mechanism is needed to control which Swift language compatibility version should be used when interpreting the manifest. This cannot be determined by a property on the Package object in the manifest itself, as we must know what compatibility version to interpret the manifest with before we have access to data specified by Swift code in the manifest. Proposed solution Each package will specify a Swift version (the “Swift tools version”) which is the minimum version of the Swift tools currently needed to build that package. This minimum version will be specified in a file in the package, so it is managed in source control just like any other package data and may differ for different tagged versions of the package. When adopting new or revised PackageDescription API, or when making changes to a Package’s source code which require a new version of Swift, users will be expected to update the package’s Swift tools version to specify that it requires that version of the Swift tools. The Swift Package Manager will continue to include the Swift 3 version of the PackageDescription module for backwards compatibility, in addition to including the new version of the PackageDescription module, as designed in a forthcoming evolution proposal. The Swift tools version shall determine which version of the PackageDescription module will be used when interpreting the Package.swift manifest. The Swift Tools Version will also determine which Swift language compatibility version should be used when interpreting the Package.swift manifest. And it will determine the default Swift language compatibility version used to compile the package’s sources if not otherwise specified. Detailed design When resolving package dependencies, if the version of a dependency that would normally be chosen specifies a Swift tools version which is greater than the version in use, that version of the dependency will be considered ineligible and dependency resolution will continue with evaluating the next-best version. If no version of a dependency (which otherwise meets the version requirements from the package dependency graph) supports the version of the Swift tools in use, a dependency resolution error will result. New PackageDescription API will be added as needed for upcoming features. When new API is used in a Package.swift manifest, it will cause the package manager to validate that the Swift tools version of that package specifies a version of the tools which understands that API, or to emit an error with instructions to update the Swift tools version if not. Note that if a version-specific manifest is present for the older tools version, that tools version will validate as allowable even when newer features are adopted in the main Package.swift manifest. The Swift tools version will determine the default Swift language compatibility version used to compile the package’s Swift sources if unspecified, but the Swift language compatibility version for the package’s sources is otherwise decoupled from the Swift tools version. A separate Swift evolution proposal will describe how to specify a Swift language compatibility version for package sources. The Swift Package Manager may consider the Swift tools version of a package for other compatibility-related purposes as well. For example, if a bugfix in a new version of the Swift Package Manager might break older packages, the fixed behavior might only be applied to packages which have adopted the newer Swift tools version. A new swift package tools-version command will be added to manage the Swift tools version. This command will behave as follows: swift package tools-version will report the Swift tools version of the package. swift package tools-version --set &lt;value&gt; will set the Swift tools version to value. It will also print an informational message advising the user of any changes that this tools version change will necessitate, depending on what the prior and new tools versions were. For example, changing the tools version might require converting the Package.swift manifest to a different Swift language version, and to a different version of the PackageDescription API. swift package tools-version --set-current will set the Swift tools version to the version of the tools currently in use. If a package does not specify a Swift tools version, the Swift tools version is “3.0.0”. It is expected that in the future all Swift packages will specify a Swift tools version. swift package init will set the Swift tools version of a package it creates to the version of the tools in use. How the Swift tools version is specified The Swift tools version will be specified by a special comment in the first line of the Package.swift manifest. This is similar to how a DTD is defined for XML documents. To specify a tools version, a Package.swift file must begin with the string // swift-tools-version:, followed by a version number specifier. Though the Swift tools version refers to a Swift marketing version number and is not a proper semantic version, the version number specifier shall follow the syntax defined by semantic versioning 2.0.0, with an amendment that the patch version component shall be optional and shall be considered to be 0 if not specified. As we expect that patch versions will not affect tools compatibility, the package manager will automatically elide the patch version component when appropriate, including when setting a version using the swift package tools-version --set-current command, to avoid unnecessarily restricting package compatibility to specific patch versions. The semver syntax allows for an optional pre-release version component or build version component; those components will not be used by the package manager currently, but may be used in a future release to provide finer-grained compatibility controls during the development of a new version of Swift. After the version number specifier, an optional ; character may be present; it, and anything else after it until the end of the first line, will be ignored by this version of the package manager, but is reserved for the use of future versions of the package manager. The package manager will attempt to detect approximate misspellings of the Swift tools version comment. As such, it is an error if the first line of the file begins with //, contains the string swift-tools-version (with any capitalization), but is not otherwise a valid tools version comment. Any other first line of the file will not be considered to be a Swift tools version comment, in which case the Swift tools version will be considered to be 3.0.0. Examples The author of a package created with Swift 3 wishes to adopt the new Swift 4 product definitions API in their manifest. Using a Swift 4 toolchain, the author first runs swift package tools-version --update to make their package require the Swift 4.0 tools. They then make any changes to their Package.swift manifest needed to make it compatible with the Swift 4 language version and the revised Swift 4 Package Manager PackageDescription API. Since their package sources are still written with Swift 3, they should specify the Swift 3 language compatibility version in their manifest, if they didn’t already, so that it doesn’t start defaulting to building their sources as Swift 4 code. The author is now free to adopt new PackageDescription API in their Package.swift manifest. They are not required to update the language version of their package sources at the same time. A package author wishes to support both the Swift 3 and Swift 4 tools, while conditionally adopting Swift 4 language features. The author specifies both Swift language compatibility versions for their package sources (using a mechanism discussed in a separate evolution proposal). Because their package needs to support Swift 3 tools, the package’s Swift tools version must be set to 3.1. Their Package.swift manifest must continue to be compatible with the Swift 3 language, and must continue to use the Swift 3.1 version of the PackageDescription API. The author of a package created with the Swift 3 tools wishes to convert the package’s sources to the Swift 4 language version. They specify Swift 4 as their package’s language compatibility version (using a mechanism discussed in a separate evolution proposal). When they try to build their package, the package manager emits an error informing them that they must update their Swift tools version to 4.0 or later, because the Swift 4 tools are required to build a package when it no longer supports the Swift 3 language version. The author runs swift package tools-version --update to make their package require the Swift 4.0 tools. They then make any changes to their Package.swift manifest required to make it compatible with the Swift 4 language version and the revised Swift 4 Package Manager PackageDescription API. Impact on existing code There is no impact on existing packages. Since existing packages do not specify a Swift tools version, they will default to building their sources with the Swift 3 language compatibility mode, and will be able to be built by both Swift 3 and Swift 4 tools. Use of the package manager’s version-specific tag selection mechanism will no longer be necessary in many situations. Previously, authors needed to employ that mechanism in order to tag the last version of a package compatible with an old version of the Swift tools before adopting new Swift features, to avoid break clients of the package still using the old version of the Swift tools. Now, when adopting new Swift features, a package author merely needs to set their Swift tools version to that new version, and dependency resolution performed by an older version of the Swift tools (starting with Swift 3.1) will consider those new package versions ineligible. The existing version-specific tag selection mechanism may still be useful for authors who wish to publish new parallel versions of their package for multiple versions of the Swift tools. Use of the package manager’s version-specific manifest selection mechanism may still be useful for authors who wish to conditionally adopt new features of the Swift tools in their Package.swift manifest without needing to update their Swift tools version to exclude older versions of Swift. Packages which have used conditional compilation blocks in the Package.swift manifest to adopt new PackageDescription features while remaining compatible with older versions of the Swift tools will no longer be able to do so for future versions of Swift, and must instead use version-specific manifest selection. This is because when the newer tools interpret the Package.swift manifest, those tools will see that new PackageDescription APIs are in use, will not detect the alternate code behind the conditional compilation blocks, and will thus emit an error requiring the user to update the Swift tools version to a version which supports those new APIs. The following table shows an example of which Swift language version will be used to interpret the Package.swift manifest, and to interpret the package’s sources, based on the Swift tools in use and the parameters specified by the package. Swift Tools Swift Tools Version Swift Language Compatibility Version Language Version Used 3.1 Not Present Not Present Manifest: 3 Sources: 3 3.1 3.1 Not Present Manifest: 3 Sources: 3 3.1 3.1 3 Manifest: 3 Sources: 3 3.1 3.1 3, 4 Manifest: 3 Sources: 3 Any 3.1 4 Error 3.1 4.0 Any Error 4.0 Not Present Not Present Manifest: 3 Sources: 3 4.0 3.1 Not Present Manifest: 3 Sources: 3 4.0 3.1 3 Manifest: 3 Sources: 3 4.0 3.1 3, 4 Manifest: 3 Sources: 4 4.0 4.0 Not Present Manifest: 4 Sources: 4 4.0 4.0 3 Manifest: 4 Sources: 3 4.0 4.0 3, 4 Manifest: 4 Sources: 4 4.0 4.0 4 Manifest: 4 Sources: 4 Alternatives considered We considered a number of alternative approaches that might avoid the need for adding this new Swift tools version; however, we think that this proposal is compelling compared to the alternatives considered. Don’t change the PackageDescription manifest API If we chose not to change the PackageDescription API, we would not need a way to determine which version of the module to use when interpreting a manifest. However, we think that it is important for this API to be made compliant with the Swift language conventions, and to review the API with our community. It would be best to do this now, while the Swift package ecosystem is relatively young; in the future, when the ecosystem is more mature, it will be more painful to make significant changes to this API. Not changing this API would still leave the problem of figuring out which Swift language compatibility version to interpret the manifest in. It’s possible that Package.swift manifests won’t be significantly affected by Swift language changes in Swift 4, and could mostly work in either language compatibility mode without changes. However, we don’t know whether that will be the case, and it would be a significant risk to assume that it will be. Finally, we will need to add new API to the PackageDescription module to support new features, and without a Swift tools version, adoption of new features would break existing clients of a package that aren’t using the latest tools. Rely on conditional compilation blocks We could choose to ask package authors to use Swift conditional compilation blocks to make their manifests compatible with both Swift 3 and Swift 4. Unfortunately, this might be a lot of work for package authors, and result in a hard-to-read manifests, if the PackageDescription API changes or Swift 4 language changes are significant. Another major downside of this approach is that until package authors do the work of adding conditional compilation blocks, their packages would fail to build with the Swift 4 tools. In order to build with the Swift 4 tools, you’d both need to update your own packages with conditional compilation, and you’d need to wait for any packages you depend upon to do the same. This could be a major obstacle to adopting the Swift 4 tools. Finally, we are not convinced that all authors would bother to add conditional compilation blocks to preserve Swift 3 compatibility when they update their packages for the Swift 4 tools. Any packages which were updated but not given conditional compilation blocks would now break the builds of any clients still using the Swift 3 tools. Rely on semantic versioning We could expect that package authors bump their packages’ major semantic version when updating those packages for the Swift 4 tools, thereby preventing clients who were still using the Swift 3 tools from automatically getting the updated version of their dependency and failing to build. There are several problems with this approach. First, this does nothing to allow packages to be used with new Swift tools without needing to be updated for those tools. We don’t want package authors to need to immediately adopt the Swift 4 language compatibility version and PackageDescription API before they can build their package with the new tools. Using a Swift tools version allows us to support multiple versions of the PackageDescription API and the Swift language, so existing packages will continue to work with newer tools automatically. Second, this forces clients of a package to explicitly opt-in to updated versions of their dependencies, even if there was otherwise no API change. The Swift tools version mechanism that we have proposed allows packages to automatically get updated versions of their dependencies when using Swift tools that are new enough to be able to build them, which is preferable. Finally, we are not confident that all package authors would reliably update their semantic version when updating their package for newer tools. If they failed to do so, clients still using the older Swift tools would fail to build. Relying on the package manager’s existing versioning mechanisms In Swift 3, the package manager introduced two versioning mechanisms: version-specific tag selection, and version-specific manifest selection. These mechanisms can be used to publish updated versions of a package without breaking the builds of clients who are still using older Swift tools. We think that these mechanisms are still useful and can be used in concert with the Swift tools version, as described in the “Impact on existing code” section. However, they are insufficient to completely solve the versioning problem. These mechanisms allow a package to be updated for new Swift tools without breaking clients who are still using older Swift tools, but they do not allow a package that has not been updated to be built with new Swift tools. Again, we don’t want package authors to need to immediately adopt the Swift 4 language compatibility version and PackageDescription API before they can build their package with the new tools. These mechanisms are also opt-in and may not be known to all package authors. If a package author fails to explicitly adopt these mechanisms when updating a package, they will break the builds of clients that are still using older Swift tools. In contrast, the Swift tools version mechanism that we have proposed works by default without requiring package authors to know about extra opt-in mechanisms. Automatically re-interpret Package.swift manifest in different modes We considered having the package manager automatically try to reinterpret a Package.swift manifest in different modes until it finds a mode that can successfully interpret it, so that we wouldn’t need an explicit specifier of which Swift language compatibility version or PackageDescription module version the Package.swift manifest is using. We saw three major problems with this. First, this would make it very difficult to provide high quality diagnostics when a manifest has an error or warning. If the manifest cannot be interpreted cleanly in any of the supported modes, we’d have no way to know which mode it should have been interpreted in – or whether the required mode is even known to the version of the Swift tools in use. That means that the errors we provide might be incorrect with respect to the actual version of the Swift language or the PackageDescription module that the manifest targets. Second, any subtle incompatibilities introduced by a difference in Swift language compatibility versions could cause the manifest to interpret without errors in the wrong mode, but result in unexpected behavior. Finally, this could cause performance problems for the package manager. Because the package manager needs to interpret Package.swift manifests from potentially many packages during dependency resolution, forcing it to interpret each manifest multiple times could add an undesirable delay to the swift build or swift package update commands. Provide finer-grained versioning controls In this proposal we’ve provided a single versioning mechanism which controls multiple things: the Swift language compatibility version used to parse the manifest, the version of the PackageDescription module to use, and the minimum version of the tools which will consider a package version eligible during dependency resolution. We could instead provide separate controls for each of these things. However, we feel that doing so would add unnecessary complexity to the Swift package manager. We do not see a compelling use-case for needing to control these different features independently, so we are consolidating them into one version mechanism as a valuable simplification. Rename the PackageDescription module We considered giving the new version of the PackageDescription module a different name, and having users change the import statement in their Package.swift when they want to adopt the revised PackageDescription API. This would mean that the package manager would not automatically switch which version of the PackageDescription module to use based on the Swift tools version. However, this did not seem like a better experience for our users. It would also allow users to import both modules, which we do not want to support. And it would allow users to continue using the old PackageDescription API in a manifest that is otherwise updated for Swift 4, which we also do not want to support. Store the Swift tools version in a separate file Instead of storing the Swift tools version in a comment at the top of the Package.swift manifest, we considered storing it in a separate file. Possibilities considered were to either store it as JSON in a .swift-tools-version file, or to store it in a .swift-version file in the format already established by the swiftenv tool. Reasons we prefer to store this in the Package.swift manifest include: Keeping the Swift tools version in the same file as the rest of the manifest data eliminates the possibility of forgetting to include both the Package.swift manifest and a file specifying the Swift tools version in every commit which should affect both. Users may also find it more convenient to only need to commit a single file when making manifest changes. Users may like being able to see the Swift tools version when reading a Package.swift manifest, instead of needing to look in a separate file. Supporting the .swift-version standard would require supporting toolchain names as a stand-in for a Swift tools version, which complicates this mechanism significantly. Specify the Swift tools version with a more “Swifty” syntax Several alternative suggestions were given for how to spell the comment that specifies the Swift tools version. We could make it look like a line of Swift code (let toolsVersion = ToolsVersion._3_1), a compiler directive (#swift-pm(tools-version: 3.1)), or use camel case in the comment (// swiftToolsVersion: 3.1). We rejected the former two suggestions because this version is not actually going to be interpreted by the Swift compiler, so it’s misleading to make it appears as if it is a valid line of Swift code. Embedding metadata in a leading comment is a strategy with a clear precedent in XML &amp; SGML. For the latter suggestion, we are preferring kebab-case (swift-tools-version) because it is distinct from normal Swift naming, and more clearly stands out as its own special (tiny) language, which it is.",
    "url": "http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html",
    "relUrl": "/docs/2019-08-26-0152-package-manager-tools-version.html"
  },
  "152": {
    "id": "152",
    "title": "SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour",
    "content": "Compensate for the inconsistency of @NSCopying’s behaviour Proposal: SE-0153 Author: Torin Kwok Review Manager: Doug Gregor Status: Accepted Decision Notes: Rationale Bug: SR-4538 Introduction First of all, in Swift, the Objective-C copy property attribute translates to @NSCopying. Like Objective-C, in Swift, avoiding accessing ivar via setter methods in initializer is considered as the best practice. Unlike Objective-C, which gives developers the freedom to decide on whether assign a value to a property by invoking setter or by accessing ivar directly, accessing a property in Swift from within an initializer always does direct access to the storage rather than going through the setter, even if using dot syntax. However, as a side-effect, @NSCopying attribute does not work as consistently as we usually expected in Swift initializers after developers declared a property as @NSCopying. This proposal is intent on proposing several solutions to this inconsistency. Swift-evolution thread @NSCopying currently does not affect initializers (from The Week Of Monday 23 January 2017 Archive) @NSCopying currently does not affect initializers (from The Week Of Monday 30 January 2017 Archive) Motivation Here’s an example of the inconsistency mentioned above: class Person: NSObject, NSCopying { var firstName: String var lastName: String var job: String? init( firstName: String, lastName: String, job: String? = nil ) { self.firstName = firstName self.lastName = lastName self.job = job super.init() } /// Conformance to &lt;NSCopying&gt; protocol func copy( with zone: NSZone? = nil ) -&gt; Any { let theCopy = Person.init( firstName: firstName, lastName: lastName ) theCopy.job = job return theCopy } /// For convenience of debugging override var description: String { return &quot; (firstName) (lastName)&quot; + ( job != nil ? &quot;, (job!)&quot; : &quot;&quot; ) } } Person class has promised that it conforms to &lt;NSCopying&gt; protocol. let johnAppleseed = Person( firstName: &quot;John&quot;, lastName: &quot;Appleseed&quot;, job: &quot;CEO&quot; ) var refJohnAppleseed = johnAppleseed // assigning without copying semantic refJohnAppleseed.job = &quot;Engineer&quot; // `cloneJohnAppleseed` and `johnAppleseed` have the identical `job` ... print( refJohnAppleseed ) // Prints &quot;John Appleseed, Engineer&quot; print( johnAppleseed ) // Prints &quot;John Appleseed, Engineer&quot; too // ... and the assertion **would not** fail: assert( refJohnAppleseed === johnAppleseed ) // Assigning a copy of johnAppleseed to clonedJohnAppleseed, // which was returned by `copy( zone: ) -&gt; Any` var clonedJohnAppleseed = johnAppleseed/* refJohnAppleseed is also okay */.copy() as! Person clonedJohnAppleseed.job = &quot;Designer&quot; print( clonedJohnAppleseed ) // Prints &quot;John Appleseed, Designer&quot; print( johnAppleseed ) // Prints &quot;John Appleseed, Engineer&quot; // Alright as what you see, setting the job of `clonedJohnAppleseed` doesn&#39;t affect the // job stored in `johnAppleseed`. Up to now, everything seems to run right. However, problems will soon emerge once we begin introducing a new class consuming instances of Person class: class Department: NSObject { // Here, we&#39;re expecting that `self.employee` would automatically // store the deeply-copied instance of `Person` class @NSCopying var employee: Person init( employee candidate: Person ) { // CAUTION! That&#39;s the key point: // `self.employee` has been marked with `@NSCopying` attribute // but what would take place here is only the shallow-copying. // // In the other words, `self.employee` will share identical underlying // object with `candidate`. self.employee = candidate super.init() // Assertion will definitely fail since Swift do not actually // copy the value assigned to this property even though // `self.employee` has been marked as `@NSCoyping`: /* assert( self.employee !== employee ) */ } override var description: String { return &quot;A Department: [ ( (employee) ) ]&quot; } } Department’s designated initializer receives an external instance of Person and expects to assign its deeply-copied value to self.employee property. let isaacNewton = Person( firstName: &quot;Isaac&quot;, lastName: &quot;Newton&quot;, job: &quot;Mathematician&quot; ) let lab = Department.init( employee: isaacNewton ) isaacNewton.job = &quot;Astronomer&quot; print( isaacNewton ) // Prints &quot;Isaac Newton, Astronomer&quot; print( lab.employee ) // Prints &quot;Isaac Newton, Astronomer&quot; // Expected output printed here is &quot;Isaac Newton, Mathematician&quot; instead Setting the job of isaacNewton affects the job stored in lab.employee. That’s an unexpected behavior as we have declared employee property as @NSCopying. Obviously, @NSCopying semantic became effectless implicitly in the initializer of Department class. For the moment, if we indeed require copy we have to invoke copy() method explicitly on instances that want to be copied to make sure that classes’ properties are able to store deeply-copied results during the initialization: init( employee candidate: Person ) { // ... self.employee = candidate.copy() as! Person // ... } The reason why it is considered inconsistency is that @NSCopying contract will be well respected within the rest of class definition: lab.employee = isaacNewton isaacNewton.job = &quot;Physicist&quot; print( isaacNewton ) // Prints &quot;Isaac Newton, Physicist&quot; print( lab.employee ) // Prints &quot;Isaac Newton, Astronomer&quot; It is undeniably reasonable to enforce programmers to access instance variables directly from initializer methods because of the potential troubles made by setter methods’ additional side-effects when the initialization is not complete yet. However, I believe we at least should be warned by the Swift compiler when we assigned an instance of NSCopying conforming class to a class’s property declared as @NSCopying during the initialization. In Objective-C, developers can make a decision on this process explicitly by writing done either: - ( instancetype )initWithName: ( NSString* )name { // ... self-&gt;_name = [ name copy ]; // ... } or: - ( instancetype )initWithName: ( NSString* )name { // ... self.name = name; /* self.name has been qualified with @property ( copy ) */ // ... } Speaking of Swift, however, there is no stuff like -&gt; operator to access ivar directly. As a result, with property marked with @NSCopying attribute, developers who are new to this language, especially those who have had experience of writing Objective-C, are likely to automatically suppose it acts normally when they’re writing down code like self.employee = candidate in initializer. That’s bug-prone. Proposed solution Do the compiler magic to call copy( with: ) in the initializer so that @NSCopying attribute no longer subjects to the fact that setter methods would not be invoked in initializers. Copying should always take place after a property has been declared as @NSCopying. It seems like the most direct way to maintain the @NSCopying contract without changing the underlying direct-storage model. Source compatibility Projects written with prior versions of Swift that have not yet adopted this proposal may fail to be built due to the compile-time error. But overall, it will be easy to be resolved. IDEs’ Fix-it and auto migrator tools will deal with all works painlessly. Effect on ABI stability The proposal doesn’t change the ABI of existing language features. Alternatives Considered Compile-time checking Instead of introducing the copy within the initializer, have the compiler emit a compile-time error or warning if developers are performing an assignment operation from within an initializer between a property declared as @NSCopying and an instance of a &lt;NSCopying&gt; protocol conforming class. Also, speaking of GUI integrated development environments such as Xcode, leaving this kind of error or warning FIXABLE would be needed in order to make them can be quickly fixed by both IDEs and migrator tools through simply appending .copy() as! AutoInferredClassType. With the adjustment mentioned above, following code fragment, for instance, will no longer be successfully compiled: ... class Person: NSObject, NSCopying { /* ... */ } ... @NSCopying var employee: Person ... init( employee candidate: Person ) { // ... self.employee = candidate // ... } GUI IDE will be expected to leave developers a fixable error or warning, and thus if we hit the either red or yelloe point in Xcode, or something similar to those in other IDEs, they will automatically append the lacked statement: self.employee = candidate.copy() as! Person Inferring AutoInferredClassType from context should be the responsibility of compiler.",
    "url": "http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html",
    "relUrl": "/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html"
  },
  "153": {
    "id": "153",
    "title": "SE-0154 Provide Custom Collections for Dictionary Keys and Values",
    "content": "Provide Custom Collections for Dictionary Keys and Values Proposal: SE-0154 Author: Nate Cook Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Introduction This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance’s keys and values properties. New collection types provide efficient key lookup and mutable access to dictionary values, allowing in-place updates and copy-on-write optimization of stored values. The addition of these new types impacts the standard library ABI, since we won’t be able to use types aliases from the existing types for keys and values. Swift-evolution thread: [Proposal Draft] Provide Custom Collections for Dictionary Keys and Values Motivation This proposal address two problems: While a dictionary’s keys collection is fine for iteration, its implementation is inefficient when looking up a specific key, because LazyMapCollection doesn’t know how to forward lookups to the underlying dictionary storage. Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced. This proposal uses the following [String: [Int]] dictionary to demonstrate these problems: var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]] Inefficient dict.keys Search Swift coders normally test key membership using nil checks or underscored optional bindings: if dict[&quot;one&quot;] != nil { // ... } if let _ = dict[&quot;one&quot;] { // ... } These approaches provide the expected performance of a dictionary lookup but they read neither well nor “Swifty”. Checking the keys view reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary’s keys to find a match. if dict.keys.contains(&quot;one&quot;) { // ... } A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:). Inefficient Value Mutation Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;: // Direct re-assignment dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1] // Optional chaining dict[&quot;one&quot;]?.append(1) Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary, and is therefore less useful even if more streamlined. Furthermore, neither approach allows the array to grow in place—they introduce an unnecessary copy of the array’s contents even though dict is the sole holder of its storage. Adding mutation to a dictionary’s index-based subscripting isn’t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol. Proposed Solution This proposal adds custom collections for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new Keys collection introduces efficient key lookup, while a new Values collection provides a mutable collection interface to dictionary values. Both new collections are nested in the Dictionary type. These changes make the simple approach for testing whether a dictionary contains a key an efficient one: // Fast, not slow if dict.keys.contains(&quot;one&quot;) { // ... } As a mutable collection, values enables modification without copies or clumsy code: if let i = dict.index(forKey: &quot;one&quot;) { dict.values[i].append(1) // no copy here } else { dict[&quot;one&quot;] = [1] } Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as: // Using `dict.keys.index(of:)` if let i = dict.keys.index(of: &quot;one&quot;) { dict.values[i].append(1) } else { dict[&quot;one&quot;] = [1] } Detailed design The standard library introduces two new collection types: Dictionary.Keys and Dictionary.Values. A Dictionary’s keys and values properties change from LazyMapCollection to these new types. The new collection types are not directly constructable. They are presented only as views into a dictionary. struct Dictionary&lt;Key: Hashable, Value&gt;: ... { /// A collection view of a dictionary&#39;s keys. struct Keys: Collection { subscript(i: Index) -&gt; Key { get } // Other `Collection` requirements } /// A mutable collection view of a dictionary&#39;s values. struct Values: MutableCollection { subscript(i: Index) -&gt; Value { get set } // Other `Collection` requirements } var keys: Keys { get } var values: Values { get set } // Remaining Dictionary declarations } Impact on existing code The performance improvements of using the new Dictionary.Keys type and the mutability of the Dictionary.Values collection are both additive in nature. Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary’s keys or values property. In those cases, the fix would be to change the specified type. Alternatives considered Add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. This could potentially be handled by upcoming changes to copy-on-write semantics and/or inout access. Provide new APIs for updating dictionary values with a default value, eliminating the double-lookup for a missing key. The approach outlined in this proposal provides a way to remove one kind of double-lookup (mutating a value that exists) but doesn’t eliminate all of them (in particular, checking for the existence of a key before adding). These could be written in a variety of ways: // Using a &#39;SearchState&#39; type to remember key position dict.entries[&quot;one&quot;] .withDefault([]) .append(1) // Using a two-argument subscript dict[&quot;one&quot;, withDefault: []].append(1) // Using a closure with an inout argument dict.withValue(forKey: &quot;one&quot;) { (v: inout Value?) in if v != nil { v!.append(1) } else { v = [1] } } Restructure Dictionary’s collection interface such that the Element type of a dictionary is its Value type instead of a (Key, Value) tuple. That would allow the Dictionary type itself to be a mutable collection with an entries or keysAndValues view similar to the current collection interface. This interface might look a bit like this: let valuesOnly = Array(dict) // [[2, 2], [1], [3, 3, 3]] let keysAndValues = Array(dict.entries) // [(&quot;two&quot;, [2, 2]), (&quot;one&quot;, [1]), (&quot;three&quot;, [3, 3, 3])] let foo = dict[&quot;one&quot;] // Optional([1]) let i = dict.keys.index(of: &quot;one&quot;)! dict[i].append(1)",
    "url": "http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html",
    "relUrl": "/docs/2019-08-26-0154-dictionary-key-and-value-collections.html"
  },
  "154": {
    "id": "154",
    "title": "SE-0155 Normalize Enum Case Representation",
    "content": "Normalize Enum Case Representation Proposal: SE-0155 Authors: Daniel Duan, Joe Groff Review Manager: John McCall Status: Accepted with revisions Decision Notes: Rationale Previous Revision: 1 Bug: SR-4691 Introduction In Swift 3, associated values of an enum case are represented by a tuple. This implementation causes inconsistencies in case declaration, construction and pattern matching in several places. Enums, therefore, can be made more “regular” when we replace tuple as the representation of associated case values. This proposal aims to define the effect of doing so on various parts of the language. Swift-evolution thread: Normalize Enum Case Representation (rev. 2) Motivation When user declares a case for an enum, a function which constructs the corresponding case value is declared. We’ll refer to such functions as case constructors in this proposal. enum Expr { // this case declares the case constructor `Expr.elet(_:_:)` indirect case elet(locals: [(String, Expr)], body: Expr) } // f&#39;s signature is f(_: _), type is ([(String, Expr)], Expr) -&gt; Expr let f = Expr.elet // `f` is just a function f([], someExpr) // construct a `Expr.elet` There are many surprising aspects of enum constructors, however: After SE-0111, Swift function’s fully qualified name consists of its base name and all of its argument labels. User can use the full name of the function at use site. In the example above, locals and body are currently not part of the case constructors name, therefore the expected syntax is invalid. func f(x: Int, y: Int) {} f(x: y:)(0, 0) // Okay, this is equivalent to f(x: 0, y: 0) Expr.elet(locals: body:)([], someExpr) // this doesn&#39;t work in Swift 3 Case constructors cannot include a default value for each parameter. This is yet another feature available to functions. As previous mentioned, these are symptoms of associated values being a tuple instead of having its own distinct semantics. This problem manifests more in Swift 3’s pattern matching: A pattern with a single value would match and result in a tuple: // this works for reasons most user probably don&#39;t expect! if case .elet(let wat) = anExpr { eval(wat.body) } Labels in patterns are not enforced: // note: there&#39;s no label in the first sub-pattern if case .elet(let p, let body: q) = anExpr { // code } These extra rules makes pattern matching difficult to teach and to expand to other types. Proposed Solution We’ll add first class syntax (which largely resemble the syntax in Swift 3) for declaring associated values with labels. Tuple will no longer be used to represent the aggregate of associated values for an enum case. This means pattern matching for enum cases needs its own syntax as well (as opposed to piggybacking on tuple patterns, which remains in the language for tuples.). Detailed Design Compound Names For Enum Constructors Associated values’ labels should be part of the enum case’s constructor name. When constructing an enum value with the case name, label names must either be supplied in the argument list it self, or as part of the full name. Expr.elet(locals: [], body: anExpr) // Okay, the Swift 3 way. Expr.elet(locals: body:)([], anExpr) // Okay, equivalent to the previous line. Expr.elet(locals: body:)(locals: 0, body: 0) // This would be an error, however. Note that since the labels aren’t part of a tuple, they no longer participate in type checking, behaving consistently with functions. let f = Expr.elet // f has type ([(String, Expr)], Expr) -&gt; Expr f([], anExpr) // Okay! f(locals: [], body: anExpr) // Won&#39;t compile. Enum cases should have distinct full names. Therefore, shared base name will be allowed: enum SyntaxTree { case type(variables: [TypeVariable]) case type(instantiated: [Type]) } Using only the base name in pattern matching for the previous example would be ambiguous and result in an compile error. In this case, the full name must be supplied to disambiguate. case .type // error: ambiguous case .type(variables: let variables) // Okay Default Parameter Values For Enum Constructors From a user’s point view, declaring an enum case should remain the same as Swift 3 except now it’s possible to add = expression after the type of an associated value to convey a default value for that field. enum Animation { case fadeIn(duration: TimeInterval = 0.3) // Okay! } let anim = Animation.fadeIn() // Great! Updated syntax: union-style-enum-case = enum-case-name [enum-case-associated-value-clause]; enum-case-associated-value-clause = &quot;(&quot; &quot;)&quot; | &quot;(&quot; enum-case-associated-value-list &quot;)&quot;; enum-case-associated-value-list = enum-associated-value-element | enum-associated-value-element &quot;,&quot; enum-case-associated-value-list; enum-case-associated-value-element = element-name type-annotation [enum-case-element-default-value-clause] | type [enum-case-element-default-value-clause]; element-name = identifier; enum-case-element-default-value-clause = &quot;=&quot; expression; Alternative Payload-less Case Declaration In Swift 3, the following syntax is valid: enum Tree { case leaf() // the type of this constructor is confusing! } Tree.leaf has a very unexpected type to most Swift users: (()) -&gt; Tree We propose this syntax become illegal. User must explicitly declare associated value of type Void if needed: enum Tree { case leaf(Void) } Pattern Consistency (The following enum will be used throughout code snippets in this section). indirect enum Expr { case variable(name: String) case lambda(parameters: [String], body: Expr) } Compared to patterns in Swift 3, matching against enum cases will follow stricter rules. This is a consequence of no longer relying on tuple patterns. When an associated value has a label, the sub-pattern must include the label exactly as declared. There are two variants that should look familiar to Swift 3 users. Variant 1 allows user to bind the associated value to arbitrary name in the pattern by requiring the label: case .variable(name: let x) // okay case .variable(x: let x) // compile error; there&#39;s no label `x` case .lambda(parameters: let params, body: let body) // Okay case .lambda(params: let params, body: let body) // error: 1st label mismatches User may choose not to use binding names that differ from labels. In this variant, the corresponding value will bind to the label, resulting in this shorter form: case .variable(let name) // okay, because the name is the same as the label case .lambda(let parameters, let body) // this is okay too, same reason. case .variable(let x) // compiler error. label must appear one way or another. case .lambda(let params, let body) // compiler error, same reason as above. Only one of these variants may appear in a single pattern. Swift compiler will raise a compile error for mixed usage. case .lambda(parameters: let params, let body) // error, can not mix the two. Some patterns will no longer match enum cases. For example, all associated values can bind as a tuple in Swift 3, this will no longer work after this proposal: // deprecated: matching all associated values as a tuple if case let .lambda(f) = anLambdaExpr { evaluateLambda(parameters: f.parameters, body: f.body) } Source compatibility Despite a few additions, case declaration remain mostly source-compatible with Swift 3, with the exception of the change detailed in “Alternative Payload-less Case Declaration”. Syntax for case constructor at use site remain source-compatible. A large portion of pattern matching syntax for enum cases with associated values remain unchanged. But patterns for matching all values as a tuple, patterns that elide the label and binds to names that differ from the labels, patterns that include labels for some sub-patterns but the rest of them are deprecated by this proposal. Therefore this is a source breaking change. Effect on ABI stability and resilience After this proposal, enum cases may have compound names. This means the standard library will expose different symbols for enum constructors. The name mangling rules should also change accordingly. Alternative Considered Between case declaration and pattern matching, there exist many reasonable combinations of improvement. On one hand, we can optimize for consistency, simplicity and teachability by bringing in as much similarity between enum and other part of the language as possible. Many decisions in the first revision were made in favor if doing so. Through the feedbacks from swift-evolution, we found that some of the changes impedes the ergonomics of these features too much . In this section, we describe some of the alternatives that were raised and rejected in hope to strike a balance between the two end of the goals. We discussed allowing user to declare a parameter name (“internal names”) for each associated value. Such names may be used in various rules in pattern matching. Some feedback suggested they maybe used as property names when we make enum case subtypes of the enum and resembles a struct. This feature is not included in this proposal because parameter names are not very useful today. Using them in patterns actually don’t improve consistency as users don’t use them outside normal function definitions at all. If enum case gains a function body in a future proposal, it’d be better to define the semantics of parameter names then, as opposed to locking it down now. To maintain ergonomics/source compatibility, we could allow user to choose arbitrary bindings for each associated value. The problem is it makes the pattern deviate a lot from declaration and makes it hard for beginners to understand. This also decrease readability for seasoned users. Along the same line, a pattern that gets dropped is binding all associated values as a labeled tuple, which tuple pattern allowed in Swift 3. As T.J. Usiyan pointed out, implementation of the equality protocol would be simplified due to tuple’s conformance to Equatable. This feature may still be introduced with alternative syntax (perhaps related to splats) later without source-breakage. And the need to implement Equatable may also disappear with auto-deriving for Equatable conformance. The previous revision of this proposal mandated that the labeled form of sub-pattern (case .elet(locals: let x, body: let y)) be the only acceptable pattern. Turns out the community considers this to be too verbose in some cases. A drafted version of this proposal considered allowing “overloaded” declaration of enum cases (same full-name, but with associated values with different types). We ultimately decided that this feature is out of the scope of this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html",
    "relUrl": "/docs/2019-08-26-0155-normalize-enum-case-representation.html"
  },
  "155": {
    "id": "155",
    "title": "SE-0156 Class and Subtype existentials",
    "content": "Class and Subtype existentials Proposal: SE-0156 Authors: David Hart, Austin Zheng Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-4296 Introduction This proposal brings more expressive power to the type system by allowing Swift to represent existentials of classes and subtypes which conform to protocols. Mailing list discussion Motivation Currently, the only existentials which can be represented in Swift are conformances to a set of protocols, using the &amp; protocol composition syntax: Protocol1 &amp; Protocol2 On the other hand, Objective-C is capable of expressing existentials of classes and subclasses conforming to protocols with the following syntax: id&lt;Protocol1, Protocol2&gt; Base&lt;Protocol&gt;* We propose to provide similar expressive power to Swift, which will also improve the bridging of those types from Objective-C. Proposed solution The proposal keeps the existing &amp; syntax but allows one of the elements to be either AnyObject or of class type. The equivalent to the above Objective-C types would look like this: AnyObject &amp; Protocol1 &amp; Protocol2 Base &amp; Protocol As in Objective-C, the first line is an existential of classes which conform to Protocol1 and Protocol2, and the second line is an existential of subtypes of Base which conform to Protocol. Here are the new proposed rules for what is valid in a existential conjunction syntax: 1. An element in the protocol composition syntax can be the AnyObject keyword to enforce a class constraint: protocol P {} struct S : P {} class C : P {} class D { } let t: AnyObject &amp; P = S() // Compiler error: S is not of class type let u: AnyObject &amp; P = C() // Compiles successfully let v: P &amp; AnyObject = C() // Compiles successfully let w: P &amp; AnyObject = D() // Compiler error: class D does not conform to protocol P 2. An element in the protocol composition syntax can be a class type to enforce the existential to be a subtype of the class: protocol P {} struct S {} class C {} class D : P {} class E : C, P {} let u: S &amp; P // Compiler error: S is not of class type let v: C &amp; P = D() // Compiler error: D is not a subtype of C let w: C &amp; P = E() // Compiles successfully 3. If a protocol composition contains both a class type and AnyObject, the class type supersedes the AnyObject constraint: protocol P {} class C {} class D : C, P { } let u: AnyObject &amp; C &amp; P = D() // Okay: D is a subclass of C and conforms to P let v: C &amp; P = u // Okay: C &amp; P is equivalent to AnyObject &amp; C &amp; P let w: AnyObject &amp; C &amp; P = v // Okay: AnyObject &amp; C &amp; P is equivalent to C &amp; P 4. If a protocol composition contains two class types, either the class types must be the same or one must be a subclass of the other. In the latter case, the subclass type supersedes the superclass type: protocol P {} class C {} class D : C { } class E : C { } class F : D, P { } let t: C &amp; D &amp; P = F() // Okay: F is a subclass of D and conforms to P let u: D &amp; P = t // Okay: D &amp; P is equivalent to C &amp; D &amp; P let v: C &amp; D &amp; P = u // Okay: C &amp; D &amp; P is equivalent to D &amp; P let w: D &amp; E &amp; P // Compiler error: D is not a subclass of E or vice-versa 5. When a protocol composition type contains one or more typealiases, the validity of the type is determined by expanding the typealiases into their component protocols, class types, and AnyObject constraints, then following the rules described above: class C {} class D : C {} class E {} protocol P1 {} protocol P2 {} typealias TA1 = AnyObject &amp; P1 typealias TA2 = AnyObject &amp; P2 typealias TA3 = C &amp; P2 typealias TA4 = D &amp; P2 typealias TA5 = E &amp; P2 typealias TA5 = TA1 &amp; TA2 // Expansion: typealias TA5 = AnyObject &amp; P1 &amp; AnyObject &amp; P2 // Normalization: typealias TA5 = AnyObject &amp; P1 &amp; P2 // TA5 is valid typealias TA6 = TA1 &amp; TA3 // Expansion: typealias TA6 = AnyObject &amp; P1 &amp; C &amp; P2 // Normalization (AnyObject &lt; C): typealias TA6 = C &amp; P1 &amp; P2 // TA6 is valid typealias TA7 = TA3 &amp; TA4 // Expansion: typealias TA7 = C &amp; P2 &amp; D &amp; P2 // Normalization (C &lt; D): typealias TA7 = D &amp; P2 // TA7 is valid typealias TA8 = TA4 &amp; TA5 // Expansion: typealias TA8 = D &amp; P2 &amp; E &amp; P2 // Normalization: typealias TA8 = D &amp; E &amp; P2 // TA8 is invalid because the D and E constraints are incompatible class and AnyObject This proposal merges the concepts of class and AnyObject, which now have the same meaning: they represent an existential for classes. To get rid of the duplication, we suggest only keeping AnyObject around. To reduce source-breakage to a minimum, class could be redefined as typealias class = AnyObject and give a deprecation warning on class for the first version of Swift this proposal is implemented in. Later, class could be removed in a subsequent version of Swift. Inheritance clauses and typealias To improve readability and reduce confusion, a class conforming to a typealias which contains a class type constraint does not implicitly inherit the class type: inheritance should stay explicit. Here are a few examples to remind what the current rules are and to make the previous sentence clearer: The proposal does not change the rule which forbids using the protocol composition syntax in the inheritance clause: protocol P1 {} protocol P2 {} class C {} class D : P1 &amp; P2 {} // Compiler error class E : C &amp; P1 {} // Compiler error Class D in the previous example does not inherit a base class so it can be expressed using the inheritance/conformance syntax or through a typealias: class D : P1, P2 {} // Valid typealias P12 = P1 &amp; P2 class D : P12 {} // Valid Class E above inherits a base class. The inheritance must be explicitly declared in the inheritance clause and can’t be implicitly derived from a typealias: class E : C, P1 {} // Valid typealias CP1 = C &amp; P1 class E : CP1 {} // Compiler error: class &#39;E&#39; does not inherit from class &#39;C&#39; class E : C, CP1 {} // Valid: the inheritance is explicitly declared Source compatibility This change will not break Swift 3 compatibility mode because Objective-C types will continue to be imported as before. But in Swift 4 mode, all types bridged from Objective-C which use the equivalent Objective-C existential syntax could break code which does not meet the new protocol requirements. For example, the following Objective-C code: @interface MyViewController - (void)setup:(nonnull UIViewController&lt;UITableViewDataSource,UITableViewDelegate&gt;*)tableViewController; @end is imported into Swift-3 mode as: class MyViewController { func setup(tableViewController: UIViewController) {} } which allows calling the function with an invalid parameter: let myViewController = MyViewController() myViewController.setup(UIViewController()) The previous code continues to compile but still crashs if the Objective-C code calls a method of UITableViewDataSource or UITableViewDelegate. But if this proposal is accepted and implemented as-is, the Objective-C code will be imported in Swift 4 mode as: class MyViewController { func setup(tableViewController: UIViewController &amp; UITableViewDataSource &amp; UITableViewDelegate) {} } That would then cause the Swift code run in version 4 mode to fail to compile with an error which states that UIViewController does not conform to the UITableViewDataSource and UITableViewDelegate protocols. Alternatives considered An alternative solution to the class/AnyObject duplication was to keep both, redefine AnyObject as typealias AnyObject = class and favor the latter when used as a type name. The reviewed version of the proposal included rules that required the class type (or AnyObject) to be first within the protocol composition, e.g., AnyObject &amp; Protocol1 was well-formed but Protocol1 &amp; AnyObject would produce a compiler error. When accepting this proposal, the core team removed these rules; see the decision notes at the top for more information. Acknowledgements Thanks to Austin Zheng and Matthew Johnson who brought a lot of attention to existentials in this mailing-list and from whom most of the ideas in the proposal come from.",
    "url": "http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html",
    "relUrl": "/docs/2019-08-26-0156-subclass-existentials.html"
  },
  "156": {
    "id": "156",
    "title": "SE-0157 Support recursive constraints on associated types",
    "content": "Support recursive constraints on associated types Proposal: SE-0157 Authors: Douglas Gregor, Erica Sadun, Austin Zheng Review Manager: John McCall Status: Implemented (Swift 4.1) Decision Notes: Rationale Bug: SR-1445 Introduction This proposal lifts restrictions on associated types in protocols. Their constraints will be allowed to reference any protocol, including protocols that depend on the enclosing one (recursive constraints). Further reading: swift-evolution thread, Completing Generics Motivation Swift supports defining associated types on protocols using the associatedtype keyword. protocol Sequence { associatedtype Subsequence } Swift also supports defining constraints on those associated types, for example: protocol Foo { // For all types X conforming to Foo, X.SomeType must conform to Bar associatedtype SomeType: Bar } However, Swift does not currently support defining constraints on an associated type that recursively reference the enclosing protocol. It would make sense for SubSequence to be constrained to be a Sequence, as all subsequences are themselves sequences: // Will not currently compile protocol Sequence { associatedtype SubSequence: Sequence where Iterator.Element == SubSequence.Iterator.Element, SubSequence.SubSequence == SubSequence // Returns a subsequence containing all but the first &#39;n&#39; items // in the original sequence. func dropFirst(_ n: Int) -&gt; Self.SubSequence // ... } However, Swift currently doesn’t support expressing this constraint at the point where SubSequence is declared. Instead, we must specify it in documentation and/or at each site of use. This results in more verbose code and obscures intent: protocol Sequence { // SubSequences themselves must be Sequences. // The element type of the subsequence must be identical to the element type of the sequence. // The subsequence&#39;s subsequence type must be itself. associatedtype SubSequence func dropFirst(_ n: Int) -&gt; Self.SubSequence // ... } struct SequenceOfInts : Sequence { // This concrete implementation of `Sequence` happens to work correctly. // Implicitly: // The subsequence conforms to Sequence. // The subsequence&#39;s element type is the same as the parent sequence&#39;s element type. // The subsequence&#39;s subsequence type is the same as itself. func dropFirst(_ n: Int) -&gt; SimpleSubSequence&lt;Int&gt; { // ... } } struct SimpleSubSequence&lt;Element&gt; : Sequence { typealias SubSequence = SimpleSubSequence&lt;Element&gt; typealias Iterator.Element = Element // ... } Proposed solution The first part of the solution we propose is to lift this restriction. From the perspective of the end user, this is a relatively simple change. It is only a new feature in the sense that certain associated type definitions which were previously disallowed will now be accepted by the compiler. Implementation details regarding the compiler changes necessary to implement the first part of the solution can be found in this document. The second part of the solution involves updating the standard library to take advantage of the removal of this restriction. Such changes are made with SE-0142 in mind, and incorporate both recursive constraints and where clauses. The changes necessary for this are described in the Detailed Design section below. This second change will affect the sort of user code which is accepted by the compiler. User code which uses the affected protocols and types will require fewer generic parameter constraints to be considered valid. Conversely, user code which (incorrectly) uses the private protocols removed by this proposal, or which uses the affected public protocols in an incorrect manner, might cease to be accepted by the compiler after this change is implemented. Detailed design The following standard library protocols and types will change in order to support recursive protocol constraints. Note that since the specific collection types conform to Collection, and Collection refines Sequence, not all the constraints need to be defined on every collection-related associated type. Default values of all changed associated types remain the same, unless explicitly noted otherwise. All “Change associated type” entries reflect the complete, final state of the associated type definition, including removal of underscored protocols and addition of any new constraints. Arithmetic Change associated type: associatedtype Magnitude : Arithmetic BidirectionalCollection Remove conformance to _BidirectionalIndexable Change associated type: associatedtype SubSequence : BidirectionalCollection Change associated type: associatedtype Indices : BidirectionalCollection Collection Remove conformance to _Indexable Change associated type: associatedtype SubSequence : Collection where SubSequence.Index == Index Change associated type: associatedtype Indices : Collection where Indices.Iterator.Element == Index, Indices.Index == Index Default*Indices (all variants) Declarations changed to public struct Default*Indices&lt;Elements : *Collection&gt; : *Collection IndexingIterator Declaration changed to public struct IndexingIterator&lt;Elements : Collection&gt; : IteratorProtocol, Sequence LazyFilter*Collection (all variants) Add default associated type conformance: typealias SubSequence = ${Self}&lt;Base.SubSequence&gt; LazyMap*Collection (all variants) Add default associated type conformance: typealias SubSequence = ${Self}&lt;Base.SubSequence&gt; MutableCollection Change associated type: associatedtype SubSequence : MutableCollection RandomAccessCollection Change associated type: associatedtype SubSequence : RandomAccessCollection Change associated type: associatedtype Indices : RandomAccessCollection RangeReplaceableCollection Change associated type: associatedtype SubSequence : RangeReplaceableCollection Sequence Change associated type: associatedtype SubSequence : Sequence where Iterator.Element == SubSequence.Iterator.Element, SubSequence.SubSequence == SubSequence *Slice (all variants) Add default associated type conformance: typealias Indices = Base.Indices Source compatibility From a source compatibility perspective, this is a purely additive change if the user’s code is correctly written. It is possible that users may have written code which defines semantically incorrect associated types, which the compiler now rejects because of the additional constraints. We do not consider this scenario “source-breaking”. An example of code that currently compiles but is semantically invalid is an implementation of a range-replacable collection’s subsequence that isn’t itself range-replaceable. This is a constraint that cannot be enforced by the compiler without this change. For some time, the Data type in Foundation violated this constraint; user-written code that is similarly problematic will cease to compile using a Swift toolchain that includes these standard library and compiler changes. Impact on ABI stability Since this proposal involves modifying the standard library, it changes the ABI. In particular, ABI changes enabled by this proposal are critical to getting the standard library to a state where it more closely resembles the design envisioned by its engineers. Impact on API resilience This feature cannot be removed without breaking API compatibility, but since it forms a necessary step in crystallizing the standard library for future releases, it is very unlikely that it will be removed after being accepted. Alternatives considered n/a",
    "url": "http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html",
    "relUrl": "/docs/2019-08-26-0157-recursive-protocol-constraints.html"
  },
  "157": {
    "id": "157",
    "title": "SE-0158 Package Manager Manifest API Redesign",
    "content": "Package Manager Manifest API Redesign Proposal: SE-0158 Author: Ankit Aggarwal Review Manager: Rick Ballard Status: Implemented (Swift 4) Bug: SR-3949 Decision Notes: Rationale Introduction This is a proposal for redesigning the Package.swift manifest APIs provided by Swift Package Manager. This proposal only redesigns the existing public APIs and does not add any new functionality; any API to be added for new functionality will happen in separate proposals. Motivation The Package.swift manifest APIs were designed prior to the API Design Guidelines, and their design was not reviewed by the evolution process. Additionally, there are several small areas which can be cleaned up to make the overall API more “Swifty”. We would like to redesign these APIs as necessary to provide clean, conventions-compliant APIs that we can rely on in the future. Because we anticipate that the user community for the Swift Package Manager will grow considerably in Swift 4, we would like to make these changes now, before more packages are created using the old API. Proposed solution Note: Access modifier is omitted from the diffs and examples for brevity. The access modifier is public for all APIs unless specified. Remove successor() and predecessor() from Version. These methods neither have well defined semantics nor are used a lot (internally or publicly). For e.g., the current implementation of successor() always just increases the patch version. View diff diff struct Version { - func successor() -&gt; Version - func predecessor() -&gt; Version } Convert Version’s buildMetadataIdentifier property to an array. According to SemVer 2.0, build metadata is a series of dot separated identifiers. Currently this is represented as an optional string property in the Version struct. We propose to change this property to an array (similar to prereleaseIdentifiers property). To maintain backwards compatiblility in PackageDescription 3 API, we will keep the optional string as a computed property based on the new array property. We will also keep the version initializer that takes the buildMetadataIdentifier string. Make all properties of Package and Target mutable. Currently, Package has three immutable and four mutable properties, and Target has one immutable and one mutable property. We propose to make all properties mutable to allow complex customization on the package object after initial declaration. View diff and example Diff: diff final class Target { - let name: String + var name: String } final class Package { - let name: String + var name: String - let pkgConfig: String? + var pkgConfig: String? - let providers: [SystemPackageProvider]? + var providers: [SystemPackageProvider]? } Example: swift let package = Package( name: &quot;FooPackage&quot;, targets: [ Target(name: &quot;Foo&quot;, dependencies: [&quot;Bar&quot;]), ] ) #if os(Linux) package.targets[0].dependencies = [&quot;BarLinux&quot;] #endif Change Target.Dependency enum cases to lowerCamelCase. According to API design guidelines, everything other than types should be in lowerCamelCase. View diff and example Diff: diff enum Dependency { - case Target(name: String) + case target(name: String) - case Product(name: String, package: String?) + case product(name: String, package: String?) - case ByName(name: String) + case byName(name: String) } Example: diff let package = Package( name: &quot;FooPackage&quot;, targets: [ Target( name: &quot;Foo&quot;, dependencies: [ - .Target(name: &quot;Bar&quot;), + .target(name: &quot;Bar&quot;), - .Product(name: &quot;SwiftyJSON&quot;, package: &quot;SwiftyJSON&quot;), + .product(name: &quot;SwiftyJSON&quot;, package: &quot;SwiftyJSON&quot;), ] ), ] ) Add default parameter to the enum case Target.Dependency.product. The associated value package in the (enum) case product, is an optional String. It should have the default value nil so clients don’t need to write it if they prefer using explicit enum cases but don’t want to specify the package name i.e. it should be possible to write .product(name: &quot;Foo&quot;) instead of .product(name: &quot;Foo&quot;, package: nil). If SE-0155 is accepted, we can directly add a default value. Otherwise, we will use a static factory method to provide default value for package. Rename all enums cases to have a suffix Item and favor static methods. Since static methods are more extensible than enum cases right now, we should discourage use of direct use of enum initializers and provide a static method for each case. It is not possible to have overloads on enum cases, so as a convention we propose to rename all enum cases to have a suffix “Item” for future extensibility. Change SystemPackageProvider enum cases to lowerCamelCase and their payloads to array. According to API design guidelines, everything other than types should be in lowerCamelCase. This enum allows SwiftPM System Packages to emit hints in case of build failures due to absence of a system package. Currently, only one system package per system packager can be specified. We propose to allow specifying multiple system packages by changing the payload to be an array. View diff and example Diff: diff enum SystemPackageProvider { - case Brew(String) + case brew([String]) - case Apt(String) + case apt([String]) } Example: diff let package = Package( name: &quot;Copenssl&quot;, pkgConfig: &quot;openssl&quot;, providers: [ - .Brew(&quot;openssl&quot;), + .brew([&quot;openssl&quot;]), - .Apt(&quot;openssl-dev&quot;), + .apt([&quot;openssl&quot;, &quot;libssl-dev&quot;]), ] ) Remove implicit target dependency rule for test targets. There is an implicit test target dependency rule: a test target “FooTests” implicity depends on a target “Foo”, if “Foo” exists and “FooTests” doesn’t explicitly declare any dependency. We propose to remove this rule because: It is a non obvious “magic” rule that has to be learned. It is not possible for “FooTests” to remove dependency on “Foo” while having no other (target) dependency. It makes real dependencies less discoverable. It may cause issues when we get support for mechanically editing target dependencies. Use factory methods for creating objects. We propose to always use factory methods to create objects except for the main Package object. This gives a lot of flexibility and extensibility to the APIs because Swift’s type system can infer the top level type in a context and allow using the shorthand dot syntax. Concretely, we will make these changes: Add a factory method target to Target class and change the current initializer to private. View example and diff Example: diff let package = Package( name: &quot;Foo&quot;, target: [ - Target(name: &quot;Foo&quot;, dependencies: [&quot;Utility&quot;]), + .target(name: &quot;Foo&quot;, dependencies: [&quot;Utility&quot;]), ] ) Introduce a Product class with two subclasses: Executable and Library. These subclasses will be nested inside Product class instead of being a top level declaration in the module. Nesting will give us a namespace for products and it is easy to find all the supported products when the product types grows to a large number. We will add two factory methods to Product class: library and executable to create respective products. /// Represents a product. class Product { /// The name of the product. let name: String private init(name: String) { self.name = name } /// Represents an executable product. final class Executable: Product { /// The names of the targets in this product. let targets: [String] private init(name: String, targets: [String]) } /// Represents a library product. final class Library: Product { /// The type of library product. enum LibraryType: String { case `static` case `dynamic` } /// The names of the targets in this product. let targets: [String] /// The type of the library. /// /// If the type is unspecified, package manager will automatically choose a type. let type: LibraryType? private init(name: String, type: LibraryType? = nil, targets: [String]) } /// Create a library product. static func library(name: String, type: LibraryType? = nil, targets: [String]) -&gt; Library /// Create an executable product. static func executable(name: String, targets: [String]) -&gt; Library } View example Example: swift let package = Package( name: &quot;Foo&quot;, target: [ .target(name: &quot;Foo&quot;, dependencies: [&quot;Utility&quot;]), .target(name: &quot;tool&quot;, dependencies: [&quot;Foo&quot;]), ], products: [ .executable(name: &quot;tool&quot;, targets: [&quot;tool&quot;]), .library(name: &quot;Foo&quot;, targets: [&quot;Foo&quot;]), .library(name: &quot;FooDy&quot;, type: .dynamic, targets: [&quot;Foo&quot;]), ] ) Special syntax for version initializers. A simplified summary of what is commonly supported in other package managers: Package Manager x-ranges tilde (~ or ~&gt;) caret (^) npm Supported Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not. patch and minor updates Cargo Supported Same as above Same as above CocoaPods Not supported Same as above Not supported Carthage Not supported patch and minor updates Not supported Some general notes: Every package manager we looked at supports the tilde ~ operator in some form, and it’s generally recommended as “the right thing”, because package maintainers often fail to increment their major package version when they should, incrementing their minor version instead. See e.g. how Google created a 6-minute instructional video about this operator for CocoaPods. This is a form of version overconstraint; your package should be compatible with everything with the same major version, but people don’t trust that enough to rely on it. But version overconstraint is harmful, because it leads to “dependency hell” (unresolvable dependencies due to conflicting requirements for a package in the dependency graph). We’d like to encourage a better standard of behavior in the Swift Package Manager. In the future, we’d like to add tooling to let the package manager automatically help you use Semantic Versioning correctly, so that your clients can trust your major version. If we can get package maintainers to use SemVer correctly, through automatic enforcement in the future or community norms for now, then caret ^ becomes the best operator to use most of the time. That is, you should be able to specify a minimum version, and you should be willing to let your package use anything after that up to the next major version. This means you’ll get safe updates automatically, and you’ll avoid overconstraining and introducing dependency hell. Caret ^ and tilde ~ syntax is somewhat standard, but is syntactically non-obvious; we’d prefer a syntax that doesn’t require reading a manual for novices to understand, even if that means we break with the syntactic convention established by the other package managers which support caret ^ and tilde ~. We’d like to make it possible to follow the tilde ~ use case (with different syntax), but caret ^ should be the most convenient, to encourage its use. What we propose: We will introduce a factory method which takes a lower bound version and forms a range that goes upto the next major version (i.e. caret). // 1.0.0 ..&lt; 2.0.0 .package(url: &quot;/SwiftyJSON&quot;, from: &quot;1.0.0&quot;), // 1.2.0 ..&lt; 2.0.0 .package(url: &quot;/SwiftyJSON&quot;, from: &quot;1.2.0&quot;), // 1.5.8 ..&lt; 2.0.0 .package(url: &quot;/SwiftyJSON&quot;, from: &quot;1.5.8&quot;), We will introduce a factory method which takes Requirement, to conveniently specify common ranges. Requirement is an enum defined as follows: enum Requirement { /// The requirement is specified by an exact version. case exact(Version) /// The requirement is specified by a version range. case range(Range&lt;Version&gt;) /// The requirement is specified by a source control revision. case revision(String) /// The requirement is specified by a source control branch. case branch(String) /// Creates a specified for a range starting at the given lower bound /// and going upto next major version. static func upToNextMajor(from version: Version) -&gt; Requirement /// Creates a specified for a range starting at the given lower bound /// and going upto next minor version. static func upToNextMinor(from version: Version) -&gt; Requirement } Examples: // 1.5.8 ..&lt; 2.0.0 .package(url: &quot;/SwiftyJSON&quot;, .upToNextMajor(from: &quot;1.5.8&quot;)), // 1.5.8 ..&lt; 1.6.0 .package(url: &quot;/SwiftyJSON&quot;, .upToNextMinor(from: &quot;1.5.8&quot;)), // 1.5.8 .package(url: &quot;/SwiftyJSON&quot;, .exact(&quot;1.5.8&quot;)), This will also give us ability to add more complex features in future: Examples: Note that we’re not actually proposing these as part of this proposal. .package(url: &quot;/SwiftyJSON&quot;, .upToNextMajor(from: &quot;1.5.8&quot;).excluding(&quot;1.6.4&quot;)), .package(url: &quot;/SwiftyJSON&quot;, .exact(&quot;1.5.8&quot;, &quot;1.6.3&quot;)), We will introduce a factory method which takes Range&lt;Version&gt;, to specify arbitrary open range. // Constraint to an arbitrary open range. .package(url: &quot;/SwiftyJSON&quot;, &quot;1.2.3&quot;..&lt;&quot;1.2.6&quot;), We will introduce a factory method which takes ClosedRange&lt;Version&gt;, to specify arbitrary closed range. // Constraint to an arbitrary closed range. .package(url: &quot;/SwiftyJSON&quot;, &quot;1.2.3&quot;...&quot;1.2.8&quot;), As a slight modification to the branch proposal, we will add cases for specifying a branch or revision, rather than adding factory methods for them: .package(url: &quot;/SwiftyJSON&quot;, .branch(&quot;develop&quot;)), .package(url: &quot;/SwiftyJSON&quot;, .revision(&quot;e74b07278b926c9ec6f9643455ea00d1ce04a021&quot;)) We will remove all of the current factory methods: // Constraint to a major version. .Package(url: &quot;/SwiftyJSON&quot;, majorVersion: 1), // Constraint to a major and minor version. .Package(url: &quot;/SwiftyJSON&quot;, majorVersion: 1, minor: 2), // Constraint to an exact version. .Package(url: &quot;/SwiftyJSON&quot;, &quot;1.2.3&quot;), // Constraint to an arbitrary range. .Package(url: &quot;/SwiftyJSON&quot;, versions: &quot;1.2.3&quot;..&lt;&quot;1.2.6&quot;), // Constraint to an arbitrary closed range. .Package(url: &quot;/SwiftyJSON&quot;, versions: &quot;1.2.3&quot;...&quot;1.2.8&quot;), Adjust order of parameters on Package class: We propose to reorder the parameters of Package class to: name, pkgConfig, products, dependencies, targets, swiftLanguageVersions. The rationale behind this reorder is that the most interesting parts of a package are its product and dependencies, so they should be at the top. Targets are usually important during development of the package. Placing them at the end keeps it easier for the developer to jump to end of the file to access them. Note that the swiftLanguageVersions property will likely be removed once we support Build Settings, but that will be discussed in a separate proposal. View example Example: swift let package = Package( name: &quot;Paper&quot;, products: [ .executable(name: &quot;tool&quot;, targets: [&quot;tool&quot;]), .library(name: &quot;Paper&quot;, type: .static, targets: [&quot;Paper&quot;]), .library(name: &quot;PaperDy&quot;, type: .dynamic, targets: [&quot;Paper&quot;]), ], dependencies: [ .package(url: &quot;http://github.com/SwiftyJSON/SwiftyJSON&quot;, from: &quot;1.2.3&quot;), .package(url: &quot;../CHTTPParser&quot;, .upToNextMinor(from: &quot;2.2.0&quot;)), .package(url: &quot;http://some/other/lib&quot;, .exact(&quot;1.2.3&quot;)), ] targets: [ .target( name: &quot;tool&quot;, dependencies: [ &quot;Paper&quot;, &quot;SwiftyJSON&quot; ]), .target( name: &quot;Paper&quot;, dependencies: [ &quot;Basic&quot;, .target(name: &quot;Utility&quot;), .product(name: &quot;CHTTPParser&quot;), ]) ] ) Eliminate exclude in future (via custom layouts feature). We expect to remove the exclude property after we get support for custom layouts. The exact details will be in the proposal of that feature. Example manifests A regular manifest. let package = Package( name: &quot;Paper&quot;, products: [ .executable(name: &quot;tool&quot;, targets: [&quot;tool&quot;]), .library(name: &quot;Paper&quot;, targets: [&quot;Paper&quot;]), .library(name: &quot;PaperStatic&quot;, type: .static, targets: [&quot;Paper&quot;]), .library(name: &quot;PaperDynamic&quot;, type: .dynamic, targets: [&quot;Paper&quot;]), ], dependencies: [ .package(url: &quot;http://github.com/SwiftyJSON/SwiftyJSON&quot;, from: &quot;1.2.3&quot;), .package(url: &quot;../CHTTPParser&quot;, .upToNextMinor(from: &quot;2.2.0&quot;)), .package(url: &quot;http://some/other/lib&quot;, .exact(&quot;1.2.3&quot;)), ] targets: [ .target( name: &quot;tool&quot;, dependencies: [ &quot;Paper&quot;, &quot;SwiftyJSON&quot; ]), .target( name: &quot;Paper&quot;, dependencies: [ &quot;Basic&quot;, .target(name: &quot;Utility&quot;), .product(name: &quot;CHTTPParser&quot;), ]) ] ) A system package manifest. let package = Package( name: &quot;Copenssl&quot;, pkgConfig: &quot;openssl&quot;, providers: [ .brew([&quot;openssl&quot;]), .apt([&quot;openssl&quot;, &quot;libssl-dev&quot;]), ] ) Impact on existing code The above changes will be implemented only in the new Package Description v4 library. The v4 runtime library will release with Swift 4 and packages will be able to opt-in into it as described by SE-0152. There will be no automatic migration feature for updating the manifests from v3 to v4. To indicate the replacements of old APIs, we will annotate them using the @unavailable attribute where possible. Unfortunately, this will not cover all the changes for e.g. rename of the target dependency enum cases. All new packages created with swift package init command in Swift 4 tools will by default to use the v4 manifest. It will be possible to switch to v3 manifest version by changing the tools version using swift package tools-version --set 3.1. However, the manifest will needed to be adjusted to use the older APIs manually. Unless declared in the manifest, existing packages automatically default to the Swift 3 minimum tools version; since the Swift 4 tools will also include the v3 manifest API, they will build as expected. A package which needs to support both Swift 3 and Swift 4 tools will need to stay on the v3 manifest API and support the Swift 3 language version for its sources, using the API described in the proposal SE-0151. An existing package which wants to use the new v4 manifest APIs will need to bump its minimum tools version to 4.0 or later using the command $ swift package tools-version --set-current, and then modify the manifest file with the changes described in this proposal. Alternatives considered Add variadic overloads. Adding variadic overload allows omitting parenthesis which leads to less cognitive load on eyes, especially when there is only one value which needs to be specified. For e.g.: Target(name: &quot;Foo&quot;, dependencies: &quot;Bar&quot;) might looked better than: Target(name: &quot;Foo&quot;, dependencies: [&quot;Bar&quot;]) However, plurals words like dependencies and targets imply a collection which implies brackets. It also makes the grammar wrong. Therefore, we reject this option. Version exclusion. It is not uncommon to have a specific package version break something, and it is undesirable to “fix” this by adjusting the range to exclude it because this overly constrains the graph and can prevent picking up the version with the fix. This is desirable but it should be proposed separately. Inline package declaration. We should probably support declaring a package dependency anywhere we support spelling a package name. It is very common to only have one target require a dependency, and annoying to have to specify the name twice. This is desirable but it should be proposed separately. Introduce an “identity rule” to determine if an API should use an initializer or a factory method: Under this rule, an entity having an identity, will use a type initializer and everything else will use factory methods. Package, Target and Product are identities. However, a product referenced in a target dependency is not an identity. We rejected this because it may become a source of confusion for users. Another downside is that the product initializers will have to used with the dot notation (e.g.: .Executable(name: &quot;tool&quot;, targets: [&quot;tool&quot;])) which is a little awkward because we expect factory methods and enum cases to use the dot syntax. This can be solved by moving these products outside of Product class but we think having a namespace for product provides a lot of value. Upgrade SystemPackageProvider enum to a struct. We thought about upgrading SystemPackageProvider to a struct when we had the “identity” rule but since we’re dropping that, there is no need for this change. public struct SystemPackageProvider { enum PackageManager { case apt case brew } /// The system package manager. let packageManager: PackageManager /// The array of system packages. let packages: [String] init(_ packageManager: PackageManager, packages: [String]) }",
    "url": "http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html",
    "relUrl": "/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html"
  },
  "158": {
    "id": "158",
    "title": "SE-0159 Fix Private Access Levels",
    "content": "Fix Private Access Levels Proposal: SE-0159 Author: David Hart Review Manager: Doug Gregor Status: Rejected Decision Notes: Rationale Introduction This proposal presents the problems that came with the the access level modifications in SE-0025 and proposes reverting to Swift 2 behaviour. Motivation Since the release of Swift 3, the access level change of SE-0025 was met with dissatisfaction by a substantial proportion of the general Swift community. Those changes can be viewed as actively harmful, the new requirement for syntax/API changes. The private keyword is a “soft default” access modifier for restricting access within a file. Scoped access is not a good behavior for a “soft default” because it is extremely common to use several extensions within a file. A “soft default” (and therefore private) should work well with this idiom. It is fair to say that changing the behavior of private such that it does not work well with extensions meets the criteria of actively harmful in the sense that it subtly encourages overuse of scoped access control and discourages the more reasonable default by giving it the awkward name fileprivate. Compared to a file-based access level, the scoped-based access level adds meaningful information by hiding implementation details which do not concern other types or extensions in the same file. But is that distinction between private and fileprivate actively used by the larger community of Swift developers? And if it were used pervasively, would it be worth the cognitive load and complexity of keeping two very similar access levels in the language? This proposal argues that answer to both questions is no and therefore wish to simplify Swift’s access control story by removing scoped access and leaving more design breathing space for future discussions around submodules. Detailed design The private keyword should be reverted back to its Swift 2 file-based meaning and the fileprivate keyword should be deprecated. Source compatibility In Swift 3 compatibility mode, the compiler will continue to treat private and fileprivate as was previously the case. In Swift 4 mode, the compiler will deprecate the fileprivate keyword and revert the semantics of the private access level to be file based. The migrator will rename all uses of fileprivate to private. Cases where a type had private declarations with the same signature in different scopes will produce a compiler error. For example, the following piece of code compiles in Swift 3 compatibilty mode but generates a Invalid redeclaration of &#39;bar()&#39; error in Swift 4 mode. struct Foo { private func bar() {} } extension Foo { private func bar() {} } Alternatives Considered Deprecate fileprivate and modify the semantics of private to include same-type extension scopes in the same file. Deprecate fileprivate and modify the semantics of private to include same-type extension scopes in the same module. Revert private to be file-based and introduce the scope-based access level under a new name. Thanks I’d like to extend my thanks to Xiaodi Wu and Matthew Johnson for their respective contributions.",
    "url": "http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html",
    "relUrl": "/docs/2019-08-26-0159-fix-private-access-levels.html"
  },
  "159": {
    "id": "159",
    "title": "SE-0160 Limiting `@objc` inference",
    "content": "Limiting @objc inference Proposal: SE-0160 Author: Doug Gregor Review Manager: Chris Lattner Status: Implemented (Swift 4) Decision Notes: Rationale Previous Revisions: 1 Implementation: apple/swift#8379 Bug: SR-4481 Introduction One can explicitly write @objc on any Swift declaration that can be expressed in Objective-C. As a convenience, Swift also infers @objc in a number of places to improve interoperability with Objective-C and eliminate boilerplate. This proposal scales back the inference of @objc to only those cases where the declaration must be available to Objective-C to maintain semantic coherence of the model, e.g., when overriding an @objc method or implementing a requirement of an @objc protocol. Other cases currently supported (e.g., a method declared in a subclass of NSObject) would no longer infer @objc, but one could continue to write it explicitly to produce Objective-C entry points. Swift-evolution thread: here and here Motivation There are several observations motivating this proposal. The first is that Swift’s rules for inference of @objc are fairly baroque, and it is often unclear to users when @objc will be inferred. This proposal seeks to make the inference rules more straightforward. The second observation is that it is fairly easy to write Swift classes that inadvertently cause Objective-C selector collisions due to overloading, e.g., class MyNumber : NSObject { init(_ int: Int) { } init(_ double: Double) { } // error: initializer &#39;init&#39; with Objective-C selector &#39;init:&#39; // conflicts with previous declaration with the same Objective-C selector } The example above also illustrates the third observation, which is that code following the Swift API Design Guidelines will use Swift names that often translate into very poor Objective-C names that violate the Objective-C Coding Guidelines for Cocoa. Specifically, the Objective-C selectors for the initializers above should include a noun describing the first argument, e.g., initWithInteger: and initWithDouble:, which requires explicit @objc annotations anyway: class MyNumber : NSObject { @objc(initWithInteger:) init(_ int: Int) { } @objc(initWithDouble:) init(_ double: Double) { } } The final observation is that there is a cost for each Objective-C entry point, because the Swift compiler must create a “thunk” method that maps from the Objective-C calling convention to the Swift calling convention and is recorded within Objective-C metadata. This increases the size of the binary (preliminary tests on some Cocoa[Touch] apps found that 6-8% of binary size was in these thunks alone, some of which are undoubtedly unused), and can have some impact on load time (the dynamic linker has to sort through the Objective-C metadata for these thunks). Proposed solution The proposed solution is to limit the inference of @objc to only those places where it is required for semantic consistency of the programming model. Then, add some class-level and extension-level annotations to reduce boilerplate for cases where one wants to enable/disable @objc inference more widely. Constructs that (still) infer @objc Specifically, @objc will continue to be inferred for a declaration when: The declaration is an override of an @objc declaration, e.g., class Super { @objc func foo() { } } class Sub : Super { /* inferred @objc */ override func foo() { } } This inference is required so that Objective-C callers to the method Super.foo() will appropriately invoke the overriding method Sub.foo(). The declaration satisfies a requirement of an @objc protocol, e.g., @objc protocol MyDelegate { func bar() } class MyClass : MyDelegate { /* inferred @objc */ func bar() { } } This inference is required because anyone calling MyDelegate.bar(), whether from Objective-C or Swift, will do so via an Objective-C message send, so conforming to the protocol requires an Objective-C entry point. The declaration has the @IBAction or @IBOutlet attribute. This inference is required because the interaction with Interface Builder occurs entirely through the Objective-C runtime, and therefore depends on the existence of an Objective-C entrypoint. The declaration has the @NSManaged attribute. This inference is required because the interaction with CoreData occurs entirely through the Objective-C runtime, and therefore depends on the existence of an Objective-C entrypoint. The list above describes cases where Swift 3 already performs inference of @objc and will continue to do so if this proposal is accepted. Additional constructs that will infer @objc These are new cases that should infer @objc, but currently don’t in Swift. @objc should be inferred when: The declaration has the @GKInspectable attribute. This inference is required because the interaction with GameplayKit occurs entirely through the Objective-C runtime. The declaration has the @IBInspectable attribute. This inference is required because the interaction with Interface Builder occurs entirely through the Objective-C runtime. dynamic no longer infers @objc A declaration that is dynamic will no longer infer @objc. For example: class MyClass { dynamic func foo() { } // error: &#39;dynamic&#39; method must be &#39;@objc&#39; @objc dynamic func bar() { } // okay } This change is intended to separate current implementation limitations from future language evolution: the current implementation supports dynamic by always using the Objective-C message send mechanism, allowing replacement of dynamic implementations via the Objective-C runtime (e.g., class_addMethod and class_replaceMethod). In the future, it is plausible that the Swift language and runtime will evolve to support dynamic without relying on the Objective-C runtime, and it’s important that we leave the door open for that language evolution. This change therefore does two things. First, it makes it clear that the dynamic behavior is tied to the Objective-C runtime. Second, it means that well-formed Swift 4 code will continue to work in the same way should Swift gain the ability to provide dynamic without relying on Objective-C: at that point, the method foo() above will become well-formed, and the method bar() will continue to work as it does today through the Objective-C runtime. Indeed, this change is the right way forward even if Swift never supports dynamic in its own runtime, following the precedent of SE-0070, which required the Objective-C-only protocol feature “optional requirements” to be explicitly marked with @objc. NSObject-derived classes no longer infer @objc A declaration within an NSObject-derived class will no longer infer @objc. For example: class MyClass : NSObject { func foo() { } // not exposed to Objective-C in Swift 4 } This is the only major change of this proposal, because it means that a large number of methods that Swift 3 would have exposed to Objective-C (and would, therefore, be callable from Objective-C code in a mixed project) will no longer be exposed. On the other hand, this is the most unpredictable part of the Swift 3 model, because such methods infer @objc only when the method can be expressed in Objective-C. For example: extension MyClass { func bar(param: ObjCClass) { } // exposed to Objective-C in Swift 3; not exposed by this proposal func baz(param: SwiftStruct) { } // not exposed to Objective-C } With this proposal, neither method specifies @objc nor is either required by the semantic model to expose an Objective-C entrypoint, so they don’t infer @objc: there is no need to reason about the type of the parameter’s suitability in Objective-C. Re-enabling @objc inference within a class hierarchy Some libraries and systems still depend greatly on the Objective-C runtime’s introspection facilities. For example, XCTest uses Objective-C runtime metadata to find the test cases in XCTestCase subclasses. To support such systems, introduce a new attribute for classes in Swift, spelled @objcMembers, that re-enables @objc inference for the class, its extensions, its subclasses, and (by extension) all of their extensions. For example: @objcMembers class MyClass : NSObject { func foo() { } // implicitly @objc func bar() -&gt; (Int, Int) // not @objc, because tuple returns // aren&#39;t representable in Objective-C } extension MyClass { func baz() { } // implicitly @objc } class MySubClass : MyClass { func wibble() { } // implicitly @objc } extension MySubClass { func wobble() { } // implicitly @objc } This will be paired with an Objective-C attribute, spelled swift_objc_members, that allows imported Objective-C classes to be imported as @objcMembers: __attribute__((swift_objc_members)) @interface XCTestCase : XCTest /* ... */ @end will be imported into Swift as: @objcMembers class XCTestCase : XCTest { /* ... */ } Enabling/disabling @objc inference within an extension There might be certain regions of code for which all of (or none of) the entry points should be exposed to Objective-C. Allow either @objc or @nonobjc to be specified on an extension. The @objc or @nonobjc will apply to any member of that extension that does not have its own @objc or @nonobjc annotation. For example: class SwiftClass { } @objc extension SwiftClass { func foo() { } // implicitly @objc func bar() -&gt; (Int, Int) // error: tuple type (Int, Int) not // expressible in @objc. add @nonobjc or move this method to fix the issue } @objcMembers class MyClass : NSObject { func wibble() { } // implicitly @objc } @nonobjc extension MyClass { func wobble() { } // not @objc, despite @objcMembers } Note that @objc on an extension provides less-surprising behavior than the implicit @objc inference of Swift 3, because it indicates the intent to expose everything in that extension to Objective-C. If some member within that extension cannot be exposed to Objective-C, such as SwiftClass.bar(), the compiler will produce an error. Side benefit: more reasonable expectations for @objc protocol extensions Users are often surprised to realize that extensions of @objc protocols do not, in fact, produce Objective-C entrypoints: @objc protocol P { } extension P { func bar() { } } class C : NSObject, P { } let c = C() print(c.responds(to: Selector(&quot;bar&quot;))) // prints &quot;false&quot; The expectation that P.bar() has an Objective-C entry point is set by the fact that NSObject-derived Swift classes do implicitly create Objective-C entry points for declarations within class extensions when possible, but Swift does not (and, practically speaking, cannot) do the same for protocol extensions. A previous mini-proposal discussed here suggested requiring @nonobjc for members of @objc protocol extensions. However, limiting inference of @objc eliminates the expectation itself, addressing the problem from a different angle. Source compatibility The two changes that remove inference of @objc are both source-breaking in different ways. The dynamic change mostly straightforward: In Swift 4 mode, introduce an error when a dynamic declaration does not explicitly state @objc (or infer it based on one of the @objc inference rules that still applies in Swift 4), with a Fix-It to add the @objc. In Swift 3 compatibility mode, continue to infer @objc for dynamic methods. However, introduce a warning that such code will be ill-formed in Swift 4, along with a Fix-It to add the @objc. A Swift 3-to-4 migrator could employ the same logic as Swift 3 compatibility mode to update dynamic declarations appropriately. The elimination of inference of @objc for declarations in NSObject subclasses is more complicated. Considering again the three cases: In Swift 4 mode, do not infer @objc for such declarations. Source-breaking changes that will be introduced include: If #selector or #keyPath refers to one such declaration, an error will be produced on previously-valid code that the declaration is not @objc. In most cases, a Fix-It will suggest the addition of @objc. If a message is sent to one of these declarations via AnyObject, the compiler may produce an error (if no @objc entity by that name exists anywhere) or a failure might occur at runtime (if another, unrelated @objc entity exists with that same name). For example: class MyClass : NSObject { func foo() { } func bar() { } } class UnrelatedClass : NSObject { @objc func bar() { } } func test(object: AnyObject) { object.foo?() // Swift 3: can call method MyClass.foo() // Swift 4: compiler error, no @objc method &quot;foo()&quot; object.bar?() // Swift 3: can call MyClass.bar() or UnrelatedClass.bar() // Swift 4: can only call UnrelatedClass.bar() } If one of these declarations is written in a class extension and is overridden, the override will produce an error in Swift 4 because Swift’s class model does not support overriding declarations introduced in class extensions. For example: class MySuperclass : NSObject { } extension MySuperclass { func extMethod() { } // implicitly @objc in Swift 3, not in Swift 4 } class MySubclass : MySuperclass { override func extMethod() { } // Swift 3: okay // Swift 4: error &quot;declarations in extensions cannot override yet&quot; } Objective-C code in mixed-source projects won’t be able to call these declarations. Most problems caused by this will result in warnings or errors from the Objective-C compiler (due to unrecognized selectors); some may only be detected at runtime, similarly to the AnyObject case described above. Other tools and frameworks that rely on the presence of Objective-C entrypoints (e.g., via strings) but do not make use of Swift’s facilities for referring to them will fail. This case is particularly hard to diagnose well, and failures of this sort are likely to cause runtime failures (e.g., unrecoignized selectors) that only the developer can diagnose and correct. In Swift 3 compatibility mode, continue to infer @objc for these declarations. We can warn about uses of the @objc entrypoints in cases where the @objc is inferred in Swift 3 but will not be in Swift 4. A Swift 3-to-4 migrator is the hardest part of the story. The migrator should have a switch: a “conservative” option and a “minimal” option. The “conservative” option (which is the best default) simply adds explicit @objc annotations to every entity that was implicitly @objc in Swift 3 but would not implicitly be @objc in Swift Migrated projects won’t get the benefits of the more-limited @objc inference, but they will work out-of-the-box. The “minimal” option attempts to only add @objc in places where it is needed to maintain the semantics of the program. It would be driven by the diagnostics mentioned above (for #selector, #keyPath, AnyObject messaging, and overrides), but some manual intervention will be involved to catch the runtime cases. More discussion of the migration workflow follows. “Minimal” migration workflow To migrate a Swift 3 project to Swift 4 without introducing spurious Objective-C entry points, we can apply the following workflow: In Swift 4 mode, address all of the warnings about uses of declarations for which @objc was inferred based on the deprecated rule. Set the environment variable SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT to a value between 1 and 3 (see below) and test the application. Clean up any “deprecated @objc entrypoint` warnings. Migrate to Swift 4 with “minimal” migration, which at this point will only add @objc to explicitly dynamic declarations. The following subsections describe this migration in more detail. Step 1: Address compiler warnings The compiler can warn about most instances of the source-breaking changes outlined above. Here is an example that demonstrates the warnings in Swift code, all of which are generated by the Swift compiler: class MyClass : NSObject { func foo() { } var property: NSObject? = nil func baz() { } } extension MyClass { func bar() { } } class MySubClass : MyClass { override func foo() { } // okay override func bar() { } // warning: override of instance method // &#39;bar()&#39; from extension of &#39;MyClass&#39; depends on deprecated inference // of &#39;@objc&#39; } func test(object: AnyObject, mine: MyClass) { _ = #selector(MyClass.foo) // warning: argument of `#selector` // refers to instance method `foo()` in `MyClass` that uses deprecated // `@objc` inference _ = #keyPath(MyClass.property) // warning: argument of &#39;#keyPath&#39; // refers to property &#39;property&#39; in &#39;MyClass&#39; that uses deprecated // `@objc` inference _ = object.baz?() // warning: reference to instance // method &#39;baz()&#39; of &#39;MyClass&#39; that uses deprecated `@objc` inference } For mixed-source projects, the Swift compiler will annotate the generated Swift header with “deprecation” attributes, so that any references to those declarations from Objective-C code will also produce warnings. For example: #import &quot;MyApp-Swift.h&quot; void test(MyClass *mine) { [mine foo]; // warning: -[MyApp.MyClass foo] uses deprecated // &#39;@objc&#39; inference; add &#39;@objc&#39; to provide an Objective-C entrypoint } Step 2: Address (opt-in) runtime warnings Swift 3 compatibility mode augments each of the Objective-C entrypoints introduced based on the deprecated @objc inference rules with a call to a new runtime function swift_objc_swift3ImplicitObjCEntrypoint. This entry point can be used in two ways to find cases where an Objective-C entry point that will be eliminated by the migration to Swift 4: In a debugger, one can set a breakpoint on swift_objc_swift3ImplicitObjCEntrypoint to catch specific cases where the Objective-C entry point is getting called. One can set the environment variable SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT to one of three different values to cause the Swift runtime to log uses of these Objective-C entry points: Log calls to these entry points with a message such as: ***Swift runtime: entrypoint -[MyApp.MyClass foo] generated by implicit @objc inference is deprecated and will be removed in Swift 4 Log (as in #1) and emit a backtrace showing how that Objective-C entry point was invoked. Log with a backtrace (as in #2), then crash. This last stage is useful for automated testing leading up to the migration to Swift 4. Testing with logging enabled should uncover uses of the Objective-C entry points that use the deprecated rules. As explicit @objc is added to each case, the runtime warnings will go away. Step 3: Migrate to Swift 4 At this point, one can migrate to Swift 4. Building in Swift 4 will remove the Objective-C entry points for any remaining case where @objc was inferred based on the deprecated rules. Effect on ABI stability This proposal has no effect on the Swift ABI, because it only concerns the Objective-C entry points for Swift entities, which have always been governed by the already-set-in-stone Objective-C ABI. Whether a particular Swift entity is @objc or not does not affect its Swift ABI. Effect on API resilience The library evolution document notes that adding or removing @objc is not a resilient API change. Therefore, changing the inference behavior of @objc doesn’t really have an impact on API resilience beyond the normal concerns about errors of omission: prior to this proposal, forgetting to add @nonobjc meant that an API might be stuck vending an Objective-C entry point it didn’t want to expose; with this proposal, forgetting to add @objc means that an API might fail to be usable from Objective-C. The latter problem, at least, can be addressed by exposing an additional entrypoint. Moreover, adding an Objective-C entrypoint is “less” ABI-breaking that removing an Objective-C entrypoint, because the former is only breaking for open or dynamic members. Alternatives considered Aside from the obvious alternative of “do nothing”, there are ways to address some of the problems called out in the Motivation section without eliminating inference in the cases we’re talking about, or to soften the requirements on some constructs. Mangling Objective-C selectors Some of the problems with Objective-C selector collisions could be addressed by using “mangled” selector names for Swift-defined declarations. For example, given: class MyClass : NSObject { func print(_ value: Int) { } } Instead of choosing the Objective-C selector “print:” by default, which is likely to conflict, we could use a mangled selector name like __MyModule__MyClass__print__Int: that is unlikely to conflict with anything else in the program. However, this change would also be source-breaking for the same reasons that restricting @objc inference is: dynamic behavior that constructs Objective-C selectors or tools outside of Swift that expect certain selectors will break at run-time. Completely eliminating @objc inference Another alternative to this proposal is to go further and completely eliminate @objc inference. This would simplify the programming model further—it’s exposed to Objective-C only if it’s marked @objc—but at the cost of significantly more boilerplate for applications that use Objective-C frameworks. For example: class Sub : Super { @objc override func foo() { } // @objc is now required } class MyClass : MyDelegate { @objc func bar() { } // @objc is now required } I believe that this proposal strikes the right balance already, where @objc is inferred when it’s needed to maintain the semantic model, and can be explicitly added to document those places where the user is intentionally exposing an Objective-C entrypoint for some reason. Thus, explicitly writing @objc indicates intent without creating boilerplate. Acknowledgments Thanks to Brian King for noting the inference of dynamic and its relationship to this proposal. Revision history Version 1 of this proposal did not include the use of @objcMembers on classes or the use of @objc/@nonobjc on extensions to mass-annotate.",
    "url": "http://localhost:4000/docs/2019-08-26-0160-objc-inference.html",
    "relUrl": "/docs/2019-08-26-0160-objc-inference.html"
  },
  "160": {
    "id": "160",
    "title": "SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift",
    "content": "Smart KeyPaths: Better Key-Value Coding for Swift Proposal: SE-0161 Authors: David Smith, Michael LeHew, Joe Groff Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Previous Revision: 1 Introduction We propose a family of concrete Key Path types that represent uninvoked references to properties that can be composed to form paths through many values and directly get/set their underlying values. Motivation We Can Do Better than String On Darwin platforms Swift’s existing #keyPath() syntax provides a convenient way to safely refer to properties. Unfortunately, once validated, the expression becomes a String which has a number of important limitations: Loss of type information (requiring awkward Any APIs) Unnecessarily slow to parse Only applicable to NSObjects Limited to Darwin platforms Use/Mention Distinctions While methods can be referred to without invoking them (let x = foo.bar instead of let x = foo.bar()), this is not currently possible for properties and subscripts. Making indirect references to a properties’ concrete types also lets us expose metadata about the property, and in the future additional behaviors. More Expressive KeyPaths We would also like to support being able to use Key Paths to access into collections and other subscriptable types, which is not currently possible. Proposed solution We propose introducing a new expression similar to function type references (e.g. Type.method), but for properties and subscripts. To avoid ambiguities with type properties, we propose we escape such expressions using to indicate that you are talking about the property, not its invocation. A key path expression takes the general form &lt;Type&gt;.&lt;path&gt;, where &lt;Type&gt; is a type name, and &lt;path&gt; is a chain of one or more property, subscript, or optional chaining/forcing operators. If the type name can be inferred from context, then it can be elided, leaving .&lt;path&gt;. These property reference expressions produce KeyPath objects, rather than Strings. KeyPaths are a family of generic classes (structs and protocols here would be ideal, but requires generalized existentials) which encapsulate a property reference or chain of property references, including the type, mutability, property name(s), and ability to set/get values. Here’s a sample of it in use: class Person { var name: String var friends: [Person] = [] var bestFriend: Person? = nil init(name: String) { self.name = name } } var han = Person(name: &quot;Han Solo&quot;) var luke = Person(name: &quot;Luke Skywalker&quot;) luke.friends.append(han) // create a key path and use it let firstFriendsNameKeyPath = Person.friends[0].name let firstFriend = luke[keyPath: firstFriendsNameKeyPath] // &quot;Han Solo&quot; // or equivalently, with type inferred from context luke[keyPath: .friends[0].name] // &quot;Han Solo&quot; // The path must always begin with a dot, even if it starts with a // subscript component luke.friends[keyPath: .[0].name] // &quot;Han Solo&quot; luke.friends[keyPath: [Person].[0].name] // &quot;Han Solo&quot; // rename Luke&#39;s first friend luke[keyPath: firstFriendsNameKeyPath] = &quot;A Disreputable Smuggler&quot; // optional properties work too let bestFriendsNameKeyPath = Person.bestFriend?.name let bestFriendsName = luke[keyPath: bestFriendsNameKeyPath] // nil, if he is the last Jedi Detailed design Core KeyPath Types KeyPaths are a hierarchy of progressively more specific classes, based on whether we have prior knowledge of the path through the object graph we wish to traverse. Unknown Path / Unknown Root Type AnyKeyPath is fully type-erased, referring to ‘any route’ through an object/value graph for ‘any root’. Because of type-erasure many operations can fail at runtime and are thus optional. class AnyKeyPath: CustomDebugStringConvertible, Hashable { // MARK - Composition // Returns nil if path.rootType != self.valueType func appending(path: AnyKeyPath) -&gt; AnyKeyPath? // MARK - Runtime Information class var rootType: Any.Type class var valueType: Any.Type static func == (lhs: AnyKeyPath, rhs: AnyKeyPath) -&gt; Bool var hashValue: Int } Unknown Path / Known Root Type If we know a little more type information (what kind of thing the key path is relative to), then we can use PartialKeyPath&lt;Root&gt;, which refers to an ‘any route’ from a known root: class PartialKeyPath&lt;Root&gt;: AnyKeyPath { // MARK - Composition // Returns nil if Value != self.valueType func appending(path: AnyKeyPath) -&gt; PartialKeyPath&lt;Root&gt;? func appending&lt;Value, AppendedValue&gt;(path: KeyPath&lt;Value, AppendedValue&gt;) -&gt; KeyPath&lt;Root, AppendedValue&gt;? func appending&lt;Value, AppendedValue&gt;(path: ReferenceKeyPath&lt;Value, AppendedValue&gt;) -&gt; ReferenceKeyPath&lt;Root, AppendedValue&gt;? } Known Path / Known Root Type When we know both what the path is relative to and what it refers to, we can use KeyPath&lt;Root, Value&gt;. Thanks to the knowledge of the Root and Value types, all of the failable operations lose their Optional. public class KeyPath&lt;Root, Value&gt;: PartialKeyPath&lt;Root&gt; { // MARK - Composition func appending&lt;AppendedValue&gt;(path: KeyPath&lt;Value, AppendedValue&gt;) -&gt; KeyPath&lt;Root, AppendedValue&gt; func appending&lt;AppendedValue&gt;(path: WritableKeyPath&lt;Value, AppendedValue&gt;) -&gt; Self func appending&lt;AppendedValue&gt;(path: ReferenceWritableKeyPath&lt;Value, AppendedValue&gt;) -&gt; ReferenceWritableKeyPath&lt;Root, AppendedValue&gt; } Value/Reference Mutation Semantics Mutation Finally, we have a pair of subclasses encapsulating value/reference mutation semantics. These have to be distinct because mutating a copy of a value is not very useful, so we need to mutate an inout value. class WritableKeyPath&lt;Root, Value&gt;: KeyPath&lt;Root, Value&gt; { // MARK - Composition func appending&lt;AppendedPathValue&gt;(path: WritableKeyPath&lt;Value, AppendedPathValue&gt;) -&gt; WritableKeyPath&lt;Root, AppendedPathValue&gt; } class ReferenceWritableKeyPath&lt;Root, Value&gt;: WritableKeyPath&lt;Root, Value&gt; { override func appending&lt;AppendedPathValue&gt;(path: WritableKeyPath&lt;Value, AppendedPathValue&gt;) -&gt; ReferenceWritableKeyPath&lt;Root, AppendedPathValue&gt; } Access and Mutation Through KeyPaths To get or set values for a given root and key path we effectively add the following subscripts to all Swift types. extension Any { subscript(keyPath path: AnyKeyPath) -&gt; Any? { get } subscript&lt;Root: Self&gt;(keyPath path: PartialKeyPath&lt;Root&gt;) -&gt; Any { get } subscript&lt;Root: Self, Value&gt;(keyPath path: KeyPath&lt;Root, Value&gt;) -&gt; Value { get } subscript&lt;Root: Self, Value&gt;(keyPath path: WritableKeyPath&lt;Root, Value&gt;) -&gt; Value { set, get } } This allows for code like let someKeyPath = ... person[keyPath: someKeyPath] which is both appealingly readable, and doesn’t require read-modify-write copies (subscripts access self inout). Conflicts with existing subscripts are avoided by using a named parameter and generics to only accept key paths with a Root of the type in question. Referencing Key Paths Forming a KeyPath utilizes a new escape sigil . We feel this best serves our needs of disambiguating from existing #keyPath expressions (which will continue to produce Strings) and existing type properties. Optionals are handled via optional-chaining. Multiply dotted expressions are allowed as well, and work just as if they were composed via the appending methods on KeyPath. Forming a key path through subscripts (e.g. Array / Dictionary) will have the limitation that the parameter’s type(s) must be Hashable. Should the archival and serialization proposal be accepted, we would also like to include Codable with an eye towards being able to make key paths Codable themselves in the future. Performance The performance of interacting with a property/subscript via KeyPaths should be close to the cost of calling the property directly. Source compatibility This change is additive and there should no affect on existing source. Effect on ABI stability This feature adds the following requirements to ABI stability: mechanism to access key paths of public properties We think a protocol-based design would be preferable once the language has sufficient support for generalized existentials to make that ergonomic. By keeping the class hierarchy closed and the concrete implementations private to the implementation it should be tractable to provide compatibility with an open protocol-based design in the future. Effect on API resilience This should not significantly impact API resilience, as it merely provides a new mechanism for operating on existing APIs. Alternatives considered More Features Various drafts of this proposal have included additional features (decomposable key paths, prefix comparisons, support for custom KeyPath subclasses, creating a KeyPath from a String at runtime, KeyPaths conforming to Codable, bound key paths as a concrete type, etc.). We anticipate approaching these enhancements additively once the core KeyPath functionality is in place. Spelling We also explored many different spellings, each with different strengths. We have chosen the current syntax for the clarity and discoverability it provides in practice. Case #keyPath Function Type Reference Escape Fully qualified #keyPath(Person, .friends[0].name) Person.friends[0].name Person.friends[0].name Type Inferred #keyPath(.friends[0].name) Person.friends[0].name .friends[0].name While the crispness of the function-type-reference is appealing, it becomes ambigious when working with type properties. The escape-sigil variant avoids this, and remains quite readable. Why ? During review many different sigils were considered: No Sigil: This matches function type references, but suffers from ambiguity with wanting to actually call a type property. Having to type let foo: KeyPath&lt;Baz, Bar&gt; while consistent with function type references, really is not that great (even for function type references). Back Tick: Borrowing from lisp, back-tick was what we used in initial discussions of this proposal (it was easy to write on a white-board), but it was not chosen because it is hard to type in markdown, and comes dangerously close to conflicting with other parser intrinsics. Pound: We considered # as well, and while it is appealing, we’d like to save it for the future. # also has a slightly more computational connotation in Swift so far. For instance, #keyPath ‘identifies if its valid and returns a String’, #available does the necessary computation to verify availability and yields a boolean. Back Slash: Where # is computational, in Swift has more of a ‘behave differently for a moment’ connotation, and that seems to fit exactly what we want when forming a key path. Function Type References We think the disambiguating benefits of the escape-sigil would greatly benefit function type references, but such considerations are outside the scope of this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0161-key-paths.html",
    "relUrl": "/docs/2019-08-26-0161-key-paths.html"
  },
  "161": {
    "id": "161",
    "title": "SE-0162 Package Manager Custom Target Layouts",
    "content": "Package Manager Custom Target Layouts Proposal: SE-0162 Author: Ankit Aggarwal Review Manager: Rick Ballard Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-29 Introduction This proposal enhances the Package.swift manifest APIs to support custom target layouts, and removes a convention which allowed omission of targets from the manifest. Motivation The Package Manager uses a convention system to infer targets structure from disk layout. This works well for most packages, which can easily adopt the conventions, and frees users from needing to update their Package.swift file every time they add or remove sources. Adopting the conventions is more difficult for some packages, however – especially existing C libraries or large projects, which would be difficult to reorganize. We intend to give users a way to make such projects into packages without needing to conform to our conventions. The current convention rules make it very convenient to add new targets and source files by inferring them automatically from disk, but they also can be confusing, overly-implicit, and difficult to debug; for example, if the user does not follow the conventions correctly which determine their targets, they may wind up with targets they don’t expect, or not having targets they did expect, and either way their clients can’t easily see which targets are available by looking at the Package.swift manifest. We want to retain convenience where it really matters, such as easy addition of new source files, but require explicit declarations where being explicit adds significant value. We also want to make sure that the implicit conventions we keep are straightforward and easy to remember. Proposed solution We propose to stop inferring targets from disk. They must be explicitly declared in the manifest file. The inference was not very useful, as targets eventually need to be declared in order to use common features such as product and target dependencies, or build settings (which are planned for Swift 4). Explicit target declarations make a package easier to understand by clients, and allow us to provide good diagnostics when the layout on disk does not match the declarations. We propose to remove the requirement that name of a test target must have suffix “Tests”. Instead, test targets will be explicitly declared as such in the manifest file. We propose a list of pre-defined search paths for declared targets. When a target does not declare an explicit path, these directories will be used to search for the target. The name of the directory must match the name of the target. The search will be done in order and will be case-sensitive. Regular targets: package root, Sources, Source, src, srcs. Test targets: Tests, package root, Sources, Source, src, srcs. It is an error if a target is found in more than one of these paths. In such cases, the path should be explicitly declared using the path property proposed below. We propose to add a factory method testTarget to the Target class, to define test targets. .testTarget(name: &quot;FooTests&quot;, dependencies: [&quot;Foo&quot;]) We propose to add three properties to the Target class: path, sources and exclude. path: This property defines the path to the top-level directory containing the target’s sources, relative to the package root. It is not legal for this path to escape the package root, i.e., values like “../Foo”, “/Foo” are invalid. The default value of this property will be nil, which means the target will be searched for in the pre-defined paths. The empty string (“”) or dot (“.”) implies that the target’s sources are directly inside the package root. sources: This property defines the source files to be included in the target. The default value of this property will be nil, which means all valid source files found in the target’s path will be included. This can contain directories and individual source files. Directories will be searched recursively for valid source files. Paths specified are relative to the target path. Each source file will be represented by String type. In future, we will consider upgrading this to its own type to allow per-file build settings. The new type would conform to CustomStringConvertible, so existing declarations would continue to work (except where the strings were constructed programatically). exclude: This property can be used to exclude certain files and directories from being picked up as sources. Exclude paths are relative to the target path. This property has more precedence than sources property. Note: We plan to support globbing in future, but to keep this proposal short we are not proposing it right now. It is an error if the paths of two targets overlap (unless resolved with exclude). // This is an error: .target(name: &quot;Bar&quot;, path: &quot;Sources/Bar&quot;), .testTarget(name: &quot;BarTests&quot;, dependencies: [&quot;Bar&quot;], path: &quot;Sources/Bar/Tests&quot;), // This works: .target(name: &quot;Bar&quot;, path: &quot;Sources/Bar&quot;, exclude: [&quot;Tests&quot;]), .testTarget(name: &quot;BarTests&quot;, dependencies: [&quot;Bar&quot;], path: &quot;Sources/Bar/Tests&quot;), For C family library targets, we propose to add a publicHeadersPath property. This property defines the path to the directory containing public headers of a C target. This path is relative to the target path and default value of this property is include. This mechanism should be further improved in the future, but there are several behaviors, such as modulemap generation, which currently depend of having only one public headers directory. We will address those issues separately in a future proposal. All existing rules related to custom and automatic modulemap remain intact. Remove exclude from Package class. This property is no longer required because of the above proposed per-target exclude property. The templates provided by the swift package init subcommand will be updated according to the above rules, so that users do not need to manually add their first target to the manifest. Examples: Dummy manifest containing all Swift code. let package = Package( name: &quot;SwiftyJSON&quot;, targets: [ .target( name: &quot;Utility&quot;, path: &quot;Sources/BasicCode&quot; ), .target( name: &quot;SwiftyJSON&quot;, dependencies: [&quot;Utility&quot;], path: &quot;SJ&quot;, sources: [&quot;SwiftyJSON.swift&quot;] ), .testTarget( name: &quot;AllTests&quot;, dependencies: [&quot;Utility&quot;, &quot;SwiftyJSON&quot;], path: &quot;Tests&quot;, exclude: [&quot;Fixtures&quot;] ), ] ) LibYAML let packages = Package( name: &quot;LibYAML&quot;, targets: [ .target( name: &quot;libyaml&quot;, sources: [&quot;src&quot;] ) ] ) Node.js http-parser let packages = Package( name: &quot;http-parser&quot;, targets: [ .target( name: &quot;http-parser&quot;, publicHeaders: &quot;.&quot;, sources: [&quot;http_parser.c&quot;] ) ] ) swift-build-tool let packages = Package( name: &quot;llbuild&quot;, targets: [ .target( name: &quot;swift-build-tool&quot;, path: &quot;.&quot;, sources: [ &quot;lib/Basic&quot;, &quot;lib/llvm/Support&quot;, &quot;lib/Core&quot;, &quot;lib/BuildSystem&quot;, &quot;products/swift-build-tool/swift-build-tool.cpp&quot;, ] ) ] ) Impact on existing code These enhancements will be added to the version 4 manifest API, which will release with Swift 4. There will be no impact on packages using the version 3 manifest API. When packages update their minimum tools version to 4.0, they will need to update the manifest according to the changes in this proposal. There are two flat layouts supported in Swift 3: Source files directly in the package root. Source files directly inside a Sources/ directory. If packages want to continue using either of these flat layouts, they will need to explicitly set a target path to the flat directory; otherwise, a directory named after the target is expected. For example, if a package Foo has following layout: Package.swift Sources/main.swift Sources/foo.swift The updated manifest will look like this: // swift-tools-version:4.0 import PackageDescription let package = Package( name: &quot;Foo&quot;, targets: [ .target(name: &quot;Foo&quot;, path: &quot;Sources&quot;), ] ) Alternatives considered We considered making a more minimal change which disabled the flat layouts by default, and provided a top-level property to allow opting back in to them. This would allow us to discourage these layouts – which we would like to do before the package ecosystem grows – without needing to add a fully customizable API. However, we think the fuller API we’ve proposed here is fairly straightforward and provides the ability to make a number of existing projects into packages, so we think this is worth doing at this time.",
    "url": "http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html",
    "relUrl": "/docs/2019-08-26-0162-package-manager-custom-target-layouts.html"
  },
  "162": {
    "id": "162",
    "title": "SE-0163 String Revision: Collection Conformance, C Interop, Transcoding",
    "content": "String Revision: Collection Conformance, C Interop, Transcoding Proposal: SE-0163 Authors: Ben Cohen, Dave Abrahams Review Manager: John McCall Status: Implemented (Swift 4) Revision: 2 Previous Revision: 1 Decision Notes: Rationale #1, Rationale #2 Introduction This proposal is to implement a subset of the changes from the Swift 4 String Manifesto. Specifically: Make String conform to BidirectionalCollection Make String conform to RangeReplaceableCollection Create a Substring type for String.SubSequence Create a StringProtocol protocol to allow for generic operations over both types. Consolidate on a concise set of C interop methods. Revise the transcoding infrastructure. Sink Unicode-specific functionality into a Unicode namespace. Other existing aspects of String remain unchanged for the purposes of this proposal. Motivation This proposal follows up on a number of recommendations found in the manifesto: Collection conformance was dropped from String in Swift 2. After reevaluation, the feeling is that the minor discrepancies with required RangeReplaceableCollection semantics (the fact that some characters may merge when Strings are concatenated) are outweighed by the significant benefits of restoring these conformances. For more detail on the reasoning, see here While it is not a collection, the Swift 3 string does have slicing operations. String is currently serving as its own subsequence, allowing substrings to share storage with their “owner”. This can lead to memory leaks when small substrings of larger strings are stored long-term (see here for more detail on this problem). Introducing a separate type of Substring to serve as String.Subsequence is recommended to resolve this issue, in a similar fashion to ArraySlice. As noted in the manifesto, support for interoperation with nul-terminated C strings in Swift 3 is scattered and incoherent, with 6 ways to transform a C string into a String and four ways to do the inverse. These APIs should be replaced with a simpler set of methods on String. Proposed solution A new type, Substring, will be introduced. Similar to ArraySlice it will be documented as only for short- to medium-term storage: Important Long-term storage of Substring instances is discouraged. A substring holds a reference to the entire storage of a larger string, not just to the portion it presents, even after the original string’s lifetime ends. Long-term storage of a substring may therefore prolong the lifetime of elements that are no longer otherwise accessible, which can appear to be memory leakage. Aside from minor differences, such as having a SubSequence of Self and a larger size to describe the range of the subsequence, Substring will be near-identical from a user perspective. In order to be able to write extensions across both String and Substring, a new StringProtocol protocol to which the two types will conform will be introduced. For the purposes of this proposal, StringProtocol will be defined as a protocol to be used whenever you would previously extend String. It should be possible to substitute extension StringProtocol { ... } in Swift 4 wherever extension String { ... } was written in Swift 3, with one exception: any passing of self into an API that takes a concrete String will need to be rewritten as String(self). If Self is a String then this should effectively optimize to a no-op, whereas if Self is a Substring then this will force a copy, helping to avoid the “memory leak” problems described above. The exact nature of the protocol – such as which methods should be protocol requirements vs which can be implemented as protocol extensions, are considered implementation details and so not covered in this proposal. StringProtocol will conform to BidirectionalCollection. RangeReplaceableCollection conformance will be added directly onto the String and Substring types, as it is possible future StringProtocol-conforming types might not be range-replaceable (e.g. an immutable type that wraps a const char *). The C string interop methods will be updated to a variant of those described here: two withCString operations and two init(cString:) constructors, one each for UTF8 and for arbitrary encodings. The primary change is to remove “non-repairing” variants of construction from nul-terminated C strings. In both of the construction APIs, any invalid encoding sequence detected will have its longest valid prefix replaced by U+FFFD, the Unicode replacement character, per the Unicode specification. This covers the common case. The replacement can be done physically in the underlying storage and the validity of the result can be recorded in the String’s encoding such that future accesses need not be slowed down by possible error repair separately. Construction that is aborted when encoding errors are detected can be accomplished using APIs on the encoding. Additionally, an init that takes a collection of code units and an encoding will allow for construction of a String from arbitrary collections – for example, an UnsafeBufferPointer containing a non-nul-terminated C string. The current transcoding support will be updated to improve usability and performance. The primary changes will be: to allow transcoding directly from one encoding to another without having to triangulate through an intermediate scalar value to add the ability to transcode an input collection in reverse, allowing the different views on String to be made bi-directional to ensure that the APIs can be used to create performant bidirectional decoded and transcoded views of underlying code units. to replace the UnicodeCodec with a stateless Unicode.Encoding protocol having associated ForwardParser and ReverseParser types for decoding. The standard library currently lacks a Latin1 codec, so a enum Latin1: Unicode.Encoding type will be added. Detailed design The Unicode Namespace A Unicode “namespace” will be added for components related to low-level Unicode operations such as transcoding and grapheme breaking. Absent more direct language support, Unicode will, for the time being, be implemented as a caseless enum. [The caseless enum technique is precedented by CommandLine, which vends the equivalent of argc and argv for command-line applications.] enum Unicode { enum ASCII : Unicode.Encoding { ... } enum UTF8 : Unicode.Encoding { ... } enum UTF16 : Unicode.Encoding { ... } enum UTF32 : Unicode.Encoding { ... } ... enum ParseResult&lt;T&gt; { ... } struct Scalar { ... } } The names UTF8, UTF16, UTF32, and Scalar correspond to entities that exist in Swift 3. For backward compatibility they will be exposed to Swift 3 programs with their legacy spellings: @available(swift, obsoleted: 4.0, renamed: &quot;Unicode.UTF8&quot;) public typealias UTF8 = Unicode.UTF8 @available(swift, obsoleted: 4.0, renamed: &quot;Unicode.UTF16&quot;) public typealias UTF16 = Unicode.UTF16 @available(swift, obsoleted: 4.0, renamed: &quot;Unicode.UTF32&quot;) public typealias UTF32 = Unicode.UTF32 @available(swift, obsoleted: 4.0, renamed: &quot;Unicode.Scalar&quot;) public typealias UnicodeScalar = Unicode.Scalar Unicode-specific protocols will be presented as members of this namespace. Pending the addition of more direct language support, typealiases will be used to bring them in from underscored names in the Swift namespace. The intention is that diagnostics and documentation will display the nested, non-underscored names. protocol _UnicodeEncoding { ... } protocol _UnicodeParser { ... } extension Unicode { typealias Encoding = _UnicodeEncoding typealias Parser = _UnicodeParser } UnicodeCodec will be updated to refine Unicode.Encoding, and deprecated for Swift 4. Existing models of UnicodeCodec such as UTF8 will inherit Unicode.Encoding conformance for Swift 3. As noted below we anticipate adding many more Unicode-specific components to the Unicode namespace in the near future. String, Substring, and StringProtocol The following additions will be made to the standard library: protocol StringProtocol : BidirectionalCollection { // Implementation detail as described above } extension String : StringProtocol, RangeReplaceableCollection { typealias SubSequence = Substring subscript(bounds: Range&lt;String.Index&gt;) -&gt; Substring { ... } } struct Substring : StringProtocol, RangeReplaceableCollection { typealias SubSequence = Substring // near-identical API surface area to String } The slicing operations on String will be amended to return Substring: struct String { subscript(bounds: Range&lt;Index&gt;) -&gt; Substring { ... } } Note that properties or methods that due to their nature create new String storage (such as lowercased()) will not change. C string interopability will be consolidated on the following methods: extension String { /// Constructs a `String` having the same contents as `codeUnits`. /// /// - Parameter codeUnits: a collection of code units in /// the given `encoding`. /// - Parameter encoding: describes the encoding in which the code units /// should be interpreted. init&lt;C: Collection, Encoding: Unicode.Encoding&gt;( decoding codeUnits: C, as encoding: Encoding.Type ) where C.Iterator.Element == Encoding.CodeUnit /// Constructs a `String` having the same contents as `nulTerminatedUTF8`. /// /// - Parameter nulTerminatedUTF8: a sequence of contiguous UTF-8 encoded /// bytes ending just before the first zero byte (NUL character). init(cString nulTerminatedUTF8: UnsafePointer&lt;CChar&gt;) /// Constructs a `String` having the same contents as `nulTerminatedCodeUnits`. /// /// - Parameter nulTerminatedCodeUnits: a sequence of contiguous code units in /// the given `encoding`, ending just before the first zero code unit. /// - Parameter encoding: describes the encoding in which the code units /// should be interpreted. init&lt;Encoding: Unicode.Encoding&gt;( decodingCString nulTerminatedCodeUnits: UnsafePointer&lt;Encoding.CodeUnit&gt;, as: Encoding.Type) /// Invokes the given closure on the contents of the string, represented as a /// pointer to a null-terminated sequence of UTF-8 code units. func withCString&lt;Result&gt;( _ body: (UnsafePointer&lt;CChar&gt;) throws -&gt; Result) rethrows -&gt; Result /// Invokes the given closure on the contents of the string, represented as a /// pointer to a null-terminated sequence of code units in the given encoding. func withCString&lt;Result, Encoding: Unicode.Encoding&gt;( encodedAs: Encoding.Type, _ body: (UnsafePointer&lt;Encoding.CodeUnit&gt;) throws -&gt; Result ) rethrows -&gt; Result } Additionally, the current ability to pass a Swift String directly into methods that take a C string (UnsafePointer&lt;CChar&gt;) will remain as-is. Low-level Unicode Processing A new protocol, Unicode.Encoding, will be added to replace the current UnicodeCodec protocol. extension Unicode { typealias Encoding = _UnicodeEncoding } public protocol _UnicodeEncoding { /// The basic unit of encoding associatedtype CodeUnit : UnsignedInteger, FixedWidthInteger /// A valid scalar value as represented in this encoding associatedtype EncodedScalar : BidirectionalCollection where EncodedScalar.Iterator.Element == CodeUnit /// A unicode scalar value to be used when repairing /// encoding/decoding errors, as represented in this encoding. /// /// If the Unicode replacement character U+FFFD is representable in this /// encoding, `encodedReplacementCharacter` encodes that scalar value. static var encodedReplacementCharacter : EncodedScalar { get } /// Converts from encoded to encoding-independent representation static func decode(_ content: EncodedScalar) -&gt; Unicode.Scalar /// Converts from encoding-independent to encoded representation, returning /// `nil` if the scalar can&#39;t be represented in this encoding. static func encode(_ content: Unicode.Scalar) -&gt; EncodedScalar? /// Converts a scalar from another encoding&#39;s representation, returning /// `nil` if the scalar can&#39;t be represented in this encoding. /// /// A default implementation of this method will be provided /// automatically for any conforming type that does not implement one. static func transcode&lt;FromEncoding : UnicodeEncoding&gt;( _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type ) -&gt; EncodedScalar? /// A type that can be used to parse `CodeUnits` into /// `EncodedScalar`s. associatedtype ForwardParser : Unicode.Parser where ForwardParser.Encoding == Self /// A type that can be used to parse a reversed sequence of /// `CodeUnits` into `EncodedScalar`s. associatedtype ReverseParser : Unicode.Parser where ReverseParser.Encoding == Self } Parsing CodeUnits into EncodedScalars, in either direction, is done with models of Unicode.Parser: extension Unicode { typealias Parser = _UnicodeParser } /// Types that separate streams of code units into encoded Unicode /// scalar values. public protocol _UnicodeParser { /// The encoding with which this parser is associated associatedtype Encoding : Unicode.Encoding /// Constructs an instance that can be used to begin parsing `CodeUnit`s at /// any Unicode scalar boundary. init() /// Parses a single Unicode scalar value from `input`. mutating func parseScalar&lt;I : IteratorProtocol&gt;( from input: inout I ) -&gt; Unicode.ParseResult&lt;Encoding.EncodedScalar&gt; where I.Element == Encoding.CodeUnit } extension Unicode { /// The result of attempting to parse a `T` from some input. public enum ParseResult&lt;T&gt; { /// A `T` was parsed successfully case valid(T) /// The input was entirely consumed. case emptyInput /// An encoding error was detected. /// /// `length` is the number of underlying code units consumed by this /// error (when decoding, the length of the longest prefix that /// could be recognized of a valid encoding sequence). case error(length: Int) } } Higher-Level Unicode Processing The Unicode processing APIs proposed here are intentionally extremely low-level. We have proven that they are sufficient to implement higher-level constructs, but those designs are still baking and not yet ready for review. We expect to propose generic Iterator, Sequence, and Collection views that expose transcoded or segmented views of arbitrary underlying storage, as separate components in the Unicode namespace. Source compatibility Adding collection conformance to String should not materially impact source stability as it is purely additive: Swift 3’s String interface currently fulfills all of the requirements for a bidirectional range replaceable collection. Altering String’s slicing operations to return a different type is source breaking. The following mitigating steps are proposed: Add a deprecated subscript operator that will run in Swift 3 compatibility mode and which will return a String not a Substring. Add deprecated versions of all current slicing methods to similarly return a String. i.e.: extension String { @available(swift, obsoleted: 4) subscript(bounds: Range&lt;Index&gt;) -&gt; String { return String(characters[bounds]) } @available(swift, obsoleted: 4) subscript(bounds: ClosedRange&lt;Index&gt;) -&gt; String { return String(characters[bounds]) } } In a review of 77 popular Swift projects found on GitHub, these changes resolved any build issues in the 12 projects that assumed an explicit String type returned from slicing operations. Due to the change in internal implementation, this means that these operations will be O(n) rather than O(1). This is not expected to be a major concern, based on experiences from a similar change made to Java, but projects will be able to work around performance issues without upgrading to Swift 4 by explicitly typing slices as Substring, which will call the Swift 4 variant, and which will be available but not invoked by default in Swift 3 mode. The C string interoperability methods outside the ones described in the detailed design will remain in Swift 3 mode, be deprecated in Swift 4 mode, and be removed in a subsequent release. UnicodeCodec will be similarly deprecated. Effect on ABI stability As a fundamental currency type for Swift, it is essential that the String type (and its associated subsequence) is in a good long-term state before being locked down when Swift declares ABI stability. Shrinking the size of String to be 64 bits is an important part of the story. As full ABI stablity is not planned for Swift 4, it is currently unclear when the transition to a 64-bit memory layout will occur. Effect on API resilience Decisions about the API resilience of the String type are still to be determined, but are not adversely affected by this proposal. Alternatives considered For a more in-depth discussion of some of the trade-offs in string design, see the manifesto and associated evolution thread. This proposal does not yet introduce an implicit conversion from Substring to String. The decision on whether to add this will be deferred pending feedback on the initial implementation. The intention is to make a preview toolchain available for feedback, including on whether this implicit conversion is necessary, prior to the release of Swift 4.",
    "url": "http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html",
    "relUrl": "/docs/2019-08-26-0163-string-revision-1.html"
  },
  "163": {
    "id": "163",
    "title": "SE-0164 Remove final support in protocol extensions",
    "content": "Remove final support in protocol extensions Proposal: SE-0164 Author: Brian King Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-1762 Introduction This proposal disallows the final keyword when declaring functions in protocol extensions. Discussion took place on the Swift Evolution mailing list in the Remove support for final in protocol extensions thread. Motivation In the current version of Swift, the final keyword does not modify dispatch behavior in any way, and it does not generate an error message. This keyword has no use in Swift’s current protocol model. Functions in protocol extensions cannot be overridden and will always use direct dispatch. Jordan Rose described the history behind this behavior: We originally required `final` to signify that there was no dynamic dispatch going on. Once we started allowing protocol extension methods to fulfill requirements, it became more confusing than useful. Detailed design If adopted, the compiler will flag the use of the final keyword on functions declared within a protocol extension, and emit an error or warning. This behavior is consistent with final use in structures and enumerations. Source compatibility This change will impact source compatibility. Existing use of final in protocol extensions will raise a compilation error. The compiler will address this by source migration and fixits. When running in Swift 3 mode, a warning will be generated instead of an error. Effect on ABI stability This proposal does not affect ABI stability. Effect on API resilience This proposal does not affect API resilience. Alternatives considered There are no alternatives considered at this time.",
    "url": "http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html",
    "relUrl": "/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html"
  },
  "164": {
    "id": "164",
    "title": "SE-0165 Dictionary & Set Enhancements",
    "content": "Dictionary &amp; Set Enhancements Proposal: SE-0165 Author: Nate Cook Review Manager: Ben Cohen Status: Implemented (Swift 4) Decision Notes: Rationale Introduction This proposal comprises a variety of commonly (and less commonly) suggested improvements to the standard library’s Dictionary type, from merging initializers to dictionary-specific filter and mapValues methods. The proposed additions to Dictionary, and the corresponding changes to Set, are detailed in the sections below. Suggested Improvements: Merging initializers and methods Key-based subscript with default value Dictionary-specific map and filter Visible Dictionary capacity Grouping sequence elements Relevant changes to Set Detailed Design Sandbox with Prototype Source Compatibility 1. Merging initializers and methods The Dictionary type should allow initialization from a sequence of (Key, Value) tuples and offer methods that merge a sequence of (Key, Value) tuples into a new or existing dictionary, using a closure to combine values for duplicate keys. First message of discussion thread Initial proposal draft Prior standalone proposal (SE-100) Array and Set both have initializers that create a new instance from a sequence of elements. The Array initializer is useful for converting other sequences and collections to the “standard” collection type, while the Set initializer is essential for recovering set operations after performing any functional operations on a set. For example, filtering a set produces a collection without any set operations available. let numberSet = Set(1 ... 100) let fivesOnly = numberSet.lazy.filter { $0 % 5 == 0 } fivesOnly is a LazyFilterCollection&lt;Set&lt;Int&gt;&gt; instead of a Set—sending that back through the Set sequence initializer restores the expected methods. let fivesOnlySet = Set(numberSet.lazy.filter { $0 % 5 == 0 }) fivesOnlySet.isSubsetOf(numberSet) // true Dictionary, on the other hand, has no such initializer, so a similar operation leaves no room to recover dictionary functionality without building a mutable Dictionary via iteration or functional methods. These techniques also don’t support type inference from the source sequence, increasing verbosity. let numberDictionary = [&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4] let evenOnly = numberDictionary.lazy.filter { (_, value) in value % 2 == 0 } var viaIteration: [String: Int] = [:] for (key, value) in evenOnly { viaIteration[key] = value } let viaReduce: [String: Int] = evenOnly.reduce([:]) { (cumulative, kv) in var dict = cumulative dict[kv.key] = kv.value return dict } Beyond initialization, Array and Set both also provide a method to add a new block of elements to an existing collection. Array provides this via append(contentsOf:) for the common appending case or replaceSubrange(_:with:) for general inserting or replacing, while the unordered Set type lets you pass any sequence to unionInPlace(_:) to add elements to an existing set. Once again, Dictionary has no corresponding API – looping and adding elements one at a time as shown above is the only way to merge new elements into an existing dictionary. Proposed solution This proposal puts forward two new ways to convert (Key, Value) sequences to dictionary form: an initializer and a set of merging APIs that handle input data with duplicate keys. Sequence-based initializer The proposed solution would add a new initializer to Dictionary that accepts any sequence of (Key, Value) tuple pairs. init&lt;S: Sequence where S.Iterator.Element == (key: Key, value: Value)&gt;( uniqueKeysWithValues: S) With the proposed initializer, creating a Dictionary instance from a sequence of key/value pairs is as easy as creating an Array or Set: let viaProposed = Dictionary(uniqueKeysWithValues: evenOnly) Like Array.init(_:) and Set.init(_:), this is a full-width initializer. To ensure this, the initializer has a precondition that each key in the supplied sequence is unique, and traps whenever that condition isn’t met. When duplicate keys are possible in the input, the merging initializer described in the next section must be used instead. The new initializer allows for some convenient uses that aren’t currently possible. Initializing from a DictionaryLiteral (the type, not an actual literal) let literal: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4] let dictFromDL = Dictionary(uniqueKeysWithValues: literal) Converting an array to an indexed dictionary (popular on the thread) let names = [&quot;Cagney&quot;, &quot;Lacey&quot;, &quot;Bensen&quot;] let dict = Dictionary(uniqueKeysWithValues: names.enumerated().map { (i, val) in (i + 1, val) }) // [2: &quot;Lacey&quot;, 3: &quot;Bensen&quot;, 1: &quot;Cagney&quot;] Initializing from a pair of zipped sequences (examples abound) let letters = &quot;abcdef&quot;.characters.lazy.map(String.init) let dictFromZip = Dictionary(uniqueKeysWithValues: zip(letters, 1...10)) // [&quot;b&quot;: 2, &quot;e&quot;: 5, &quot;a&quot;: 1, &quot;f&quot;: 6, &quot;d&quot;: 4, &quot;c&quot;: 3] This particular use is currently blocked by SR-922. As a workaround, add .map {(key: $0, value: $1)}. Merging initializer and methods Creating a Dictionary from a dictional literal checks the keys for uniqueness, trapping on a duplicate. The sequence-based initializer shown above has the same requirement. let duplicates: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;a&quot;: 3, &quot;b&quot;: 4] let letterDict = Dictionary(uniqueKeysWithValues: duplicates) // error: Duplicate key found: &quot;a&quot; Because some use cases can be forgiving of duplicate keys, this proposal includes a second new initializer. This initializer allows the caller to supply, along with the sequence, a combining closure that’s called with the old and new values for any duplicate keys. init&lt;S: Sequence&gt;( _ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Iterator.Element == (key: Key, value: Value) This example shows how one could keep the first value of all those supplied for a duplicate key. let letterDict2 = Dictionary(duplicates, uniquingKeysWith: { (first, _) in first }) // [&quot;b&quot;: 2, &quot;a&quot;: 1] Or the largest value for any duplicate keys. let letterDict3 = Dictionary(duplicates, uniquingKeysWith: max) // [&quot;b&quot;: 4, &quot;a&quot;: 3] At other times the merging initializer could be used to combine values for duplicate keys. Donnacha Oisín Kidney wrote a neat frequencies() method for sequences as an example of such a use in the thread. extension Sequence where Iterator.Element: Hashable { func frequencies() -&gt; [Iterator.Element: Int] { return Dictionary(self.lazy.map { v in (v, 1) }, uniquingKeysWith: +) } } [1, 2, 2, 3, 1, 2, 4, 5, 3, 2, 3, 1].frequencies() // [2: 4, 4: 1, 5: 1, 3: 3, 1: 3] This proposal also includes new mutating and non-mutating methods for Dictionary that merge the contents of a sequence of (Key, Value) tuples into an existing dictionary, merge(_:uniquingKeysWith:) and merging(_:uniquingKeysWith:). mutating func merge&lt;S: Sequence&gt;( _ other: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Iterator.Element == (key: Key, value: Value) func merging&lt;S: Sequence&gt;( _ other: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows -&gt; [Key: Value] where S.Iterator.Element == (key: Key, value: Value) As above, there are a wide variety of uses for the merge. // Adding default values let defaults: [String: Bool] = [&quot;foo&quot;: false, &quot;bar&quot;: false, &quot;baz&quot;: false] var options: [String: Bool] = [&quot;foo&quot;: true, &quot;bar&quot;: false] options.merge(defaults) { (old, _) in old } // options is now [&quot;foo&quot;: true, &quot;bar&quot;: false, &quot;baz&quot;: false] // Summing counts repeatedly var bugCounts: [String: Int] = [&quot;bees&quot;: 9, &quot;ants&quot;: 112, ...] while bugCountingSource.hasMoreData() { bugCounts.merge(bugCountingSource.countMoreBugs(), uniquingKeysWith: +) } 2. Key-based subscript with default value Another common challenge with dictionaries is iteratively making changes to key/value pairs that may or may not already be present. For example, to iteratively add count the frequencies of letters in a string, one might write something like the following: let source = &quot;how now brown cow&quot; var frequencies: [Character: Int] = [:] for c in source.characters { if frequencies[c] == nil { frequencies[c] = 1 } else { frequencies[c]! += 1 } } Testing for nil and assigning through the force unwrapping operator are awkward at best for such a common operation. Furthermore, the Optional&lt;Value&gt; return type of the current keyed subscript complicates efficiencies that could be gained for this type of modify action under a future ownership model. Proposed solution A keyed subscript with a default value neatly simplifies this usage. Instead of checking for nil, one can pass the default value along with the key as a default subscript parameter. let source = &quot;how now brown cow&quot; var frequencies: [Character: Int] = [:] for c in source.characters { frequencies[c, default: 0] += 1 } The return type of this subscript is a non-optional Value. Note that accessing the subscript as a getter does not store the default value in the dictionary—the following two lines are equivalent: let x = frequencies[&quot;a&quot;, default: 0] let y = frequencies[&quot;a&quot;] ?? 0 3. Dictionary-specific map and filter The standard map and filter methods, while always useful and beloved, aren’t ideal when applied to dictionaries. In both cases, the desired end-result is frequently another dictionary instead of an array of key-value pairs—even with the sequence-based initializer proposed above this is an inefficient way of doing things. Additionally, the standard map method doesn’t gracefully support passing a function when transforming only the values of a dictionary. The transform function must accept and return key/value pairs, necessitating a custom closure in nearly every case. Assuming the addition of a sequence-based initializer, the current filter and map look like the following: let numbers = [&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4] let evens = Dictionary(numbers.lazy.filter { $0.value % 2 == 0 })! // [&quot;four&quot;: 4, &quot;two&quot;: 2] let strings = Dictionary(numbers.lazy.map { (k, v) in (k, String(v)) })! // [&quot;three&quot;: &quot;3&quot;, &quot;four&quot;: &quot;4&quot;, &quot;one&quot;: &quot;1&quot;, &quot;two&quot;: &quot;2&quot;] Proposed solution This proposal adds two new methods for Dictionary: A mapValues method that keeps a dictionary’s keys intact while transforming the values. Mapping a dictionary’s key/value pairs can’t always produce a new dictionary, due to the possibility of key collisions, but mapping only the values can produce a new dictionary with the same underlying layout as the original. let strings = numbers.mapValues(String.init) // [&quot;three&quot;: &quot;3&quot;, &quot;four&quot;: &quot;4&quot;, &quot;one&quot;: &quot;1&quot;, &quot;two&quot;: &quot;2&quot;] A Dictionary-returning filter method. While transforming the keys and values of a dictionary can result in key collisions, filtering the elements of a dictionary can at worst replicate the entire dictionary. let evens = numbers.filter { $0.value % 2 == 0 } // [&quot;four&quot;: 4, &quot;two&quot;: 2] Both of these can be made significantly more efficient than their Sequence-sourced counterparts. For example, the mapValues method can simply copy the portion of the storage that holds the keys to the new dictionary before transforming the values. 4. Visible dictionary capacity As you add elements to a dictionary, it automatically grows its backing storage as necessary. This reallocation is a significant operation—unlike arrays, where the existing elements can be copied to a new block of storage en masse, every key/value pair must be moved over individually, recalculating the hash value for the key to find its position in the larger backing buffer. While dictionaries uses an exponential growth strategy to make this as efficient as possible, beyond the init(minimumCapacity:) initializer they do not expose a way to reserve a specific capacity. In addition, adding a key/value pair to a dictionary is guaranteed not to invalidate existing indices as long as the capacity doesn’t change, yet we don’t provide any way of seeing a dictionary’s current or post-addition capacity. Proposed solution Dictionary should add a capacity property and a reserveCapacity(_:) method, like those used in range-replaceable collections. The capacity of a dictionary is the number of elements it can hold without reallocating a larger backing storage, while calling reserveCapacity(_:) allocates a large enough buffer to hold the requested number of elements without reallocating. var numbers = [&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4] numbers.capacity // 6 numbers.reserveCapacity(20) numbers.capacity // 24 Because hashed collections use extra storage capacity to reduce the likelihood and cost of collisions, the value of the capacity property won’t be equal to the actual size of the backing storage. Likewise, the capacity after calling reserveCapacity(_:) will be at least as large as the argument, but usually larger. (In its current implementation, Dictionary always has a power of 2-sized backing storage.) 5. Grouping sequence elements As a final Dictionary-related issue, grouping elements in a sequence by some computed key is a commonly requested addition that we can add as part of this omnibus proposal. Call a new Dictionary(grouping:by:) initializer with a closure that converts each value in a sequence to a hashable type T; the result is a dictionary with keys of type T and values of type [Iterator.Element]. let names = [&quot;Patti&quot;, &quot;Aretha&quot;, &quot;Anita&quot;, &quot;Gladys&quot;] // By first letter Dictionary(grouping: names, by: { $0.characters.first! }) // [&quot;P&quot;: [&quot;Patti&quot;], &quot;G&quot;: [&quot;Gladys&quot;], &quot;A&quot;: [&quot;Aretha&quot;, &quot;Anita&quot;]] // By name length Dictionary(grouping: names) { $0.utf16.count } // [5: [&quot;Patti&quot;, &quot;Anita&quot;], 6: [&quot;Aretha&quot;, &quot;Gladys&quot;]] 6. Apply relevant changes to Set As the Set and Dictionary types are similar enough to share large chunks of their implementations, it makes sense to look at which of these Dictionary enhancements can also be applied to Set. Of the symbols proposed above, the following additions would also be useful and appropriate for the Set type: Add a Set-specific filter method that returns a new set—this would function essentially as a predicate-based intersection method. Add a capacity property and reserveCapacity() method, for the reasons listed above. Detailed design With the exception of the proposed capacity property and method, the proposed additions to Dictionary, Set, and Sequence are available in this Swift Sandbox. Note that this prototype is not a proposed implementation; rather a way to try out the behavior of the proposed changes. Collected in one place, these are the new APIs for Dictionary, Set, and Sequence: struct Dictionary&lt;Key: Hashable, Value&gt; { typealias Element = (key: Key, value: Value) // existing declarations /// Creates a new dictionary using the key/value pairs in the given sequence. /// If the given sequence has any duplicate keys, the result is `nil`. init&lt;S: Sequence&gt;(uniqueKeysWithValues: S) where S.Iterator.Element == Element /// Creates a new dictionary using the key/value pairs in the given sequence, /// using a combining closure to determine the value for any duplicate keys. init&lt;S: Sequence&gt;( _ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Iterator.Element == Element /// Creates a new dictionary where the keys are the groupings returned by /// the given closure and the values are arrays of the elements that /// returned each specific key. init&lt;S: Sequence&gt;( grouping values: S, by keyForValue: (S.Iterator.Element) throws -&gt; Key ) rethrows where Value == [S.Iterator.Element] /// Merges the key/value pairs in the given sequence into the dictionary, /// using a combining closure to determine the value for any duplicate keys. mutating func merge&lt;S: Sequence&gt;( _ other: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Iterator.Element == Element /// Returns a new dictionary created by merging the key/value pairs in the /// given sequence into the dictionary, using a combining closure to determine /// the value for any duplicate keys. func merging&lt;S: Sequence&gt;( _ other: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows -&gt; [Key: Value] where S.Iterator.Element == Element /// Accesses the element with the given key, or the specified default value, /// if the dictionary doesn&#39;t contain the given key. subscript(key: Key, default defaultValue: Value) -&gt; Value { get set } /// Returns a new dictionary containing the key/value pairs that satisfy /// the given predicate. func filter(_ isIncluded: (Key, Value) throws -&gt; Bool) rethrows -&gt; [Key: Value] /// Returns a new dictionary containing the existing keys and the results of /// mapping the given closure over the dictionary&#39;s values. func mapValues&lt;T&gt;(_ transform: (Value) throws -&gt; T) rethrows -&gt; [Key: T] /// The number of key/value pairs that can be stored by the dictionary without /// reallocating storage. var capacity: Int { get } /// Ensures that the dictionary has enough storage for `capacity` key/value /// pairs. var reserveCapacity(_ capacity: Int) } struct Set&lt;Element: Hashable&gt; { // existing declarations /// Returns a new set containing the elements that satisfy the given predicate. func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; Set /// The number of elements that can be stored by the set without /// reallocating storage. var capacity: Int { get } /// Ensures that the set has enough storage for `capacity` elements. var reserveCapacity(_ capacity: Int) } Alternatives Considered An earlier version of this proposal declared the first merging initializer as failable, returning nil when a sequence with duplicate keys was passed. That initializer is really only appropriate when working with known unique keys, however, as there isn’t a feasible recovery path when there can be duplicate keys. That leaves two possibilities: The source input can never have duplicate keys, and the programmer has to write ! or unwrap in some other way, or The source input can have duplicate keys, in which case the programmer should be using init(merging:mergingValues:) instead. An earlier version of this proposal included the addition of two new top-level functions to the standard library: first(_:_:) and last(_:_:), which return their first and last arguments, respectively. These new functions would be passed instead of a custom closure to a merging method or initializer: let firstWins = Dictionary(merging: duplicates, mergingValues: first) // [&quot;b&quot;: 2, &quot;a&quot;: 1] let lastWins = Dictionary(merging: duplicates, mergingValues: last) // [&quot;b&quot;: 4, &quot;a&quot;: 3] As an alternative to the first(_:_:) and last(_:_:) functions, at the cost of three additional overloads for the merging initializer and methods, we could allow users to specify the useFirst and useLast cases of a MergeCollisionStrategy enumeration. extension Dictionary { /// The strategy to use when merging a sequence of key-value pairs into a dictionary. enum MergeCollisionStrategy { /// If there is more than one instance of a key in the sequence to merge, use /// only the first value for the dictionary. case useFirst /// If there is more than one instance of a key in the sequence to merge, use /// only the last value for the dictionary. case useLast } init&lt;S: Sequence&gt;( merging keysAndValues: S, mergingValues strategy: MergeCollisionStrategy ) // other merging overloads } In use, this overload would look similar to the functional version, but may aid in discoverability: let firstWins = Dictionary(merging: duplicates, mergingValues: .useFirst) // [&quot;b&quot;: 2, &quot;a&quot;: 1] let lastWins = Dictionary(merging: duplicates, mergingValues: .useLast) // [&quot;b&quot;: 4, &quot;a&quot;: 3] An earlier version of this proposal included a change to both collections’ remove(at:) method, such that it would return both the removed element and the next valid index in the iteration sequence. This change lets a programmer write code that would remove elements of a dictionary or a set in place, which can’t currently be done with as much efficiency due to index invalidation: var i = dict.startIndex while i != dict.endIndex { if shouldRemove(dict[i]) { (_, i) = dict.remove(at: i) } else { dict.formIndex(after: &amp;i) } } This change to remove(at:) has been deferred to a later proposal that can better deal with the impact on existing code. The reviewed version of this proposal had different spelling of the merging initializers and methods: init&lt;S: Sequence where S.Iterator.Element == (key: Key, value: Value)&gt;( _ keysAndValues: S) init&lt;S: Sequence&gt;( merging keysAndValues: S, mergingValues combine: (Value, Value) throws -&gt; Value ) rethrows where S.Iterator.Element == (key: Key, value: Value) mutating func merge&lt;S: Sequence&gt;( _ other: S, mergingValues combine: (Value, Value) throws -&gt; Value ) rethrows where S.Iterator.Element == (key: Key, value: Value) func merged&lt;S: Sequence&gt;( with other: S, mergingValues combine: (Value, Value) throws -&gt; Value ) rethrows -&gt; [Key: Value] where S.Iterator.Element == (key: Key, value: Value) In addition, the Dictionary(grouping:by:) initializer was proposed as a grouped(by:) method on the Sequence protocol. The rationale for accepting the proposal explains the reasons for these changes. Source compatibility All the proposed additions are purely additive and should impose only a minimal source compatibility burden. The addition of same-type returning filter(_:) methods to Dictionary and Set could cause problems if code is relying on the previous behavior of returning an array. For example, the following code would break after this change: let digits = Set(0..&lt;10) let evens = digits.filter { $0 % 2 == 0 } functionThatTakesAnArray(evens) To mitigate the impact of this on code compiled in Swift 3 mode, Dictionary and Set will have an additional overload of the Array-returning filter(_:) that is marked as obsoleted in Swift 4. This will allow Swift 3 code to continue to compile and work as expected: extension Set { @available(swift, obsoleted: 4) func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; [Element] @available(swift, introduced: 4) func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt; }",
    "url": "http://localhost:4000/docs/2019-08-26-0165-dict.html",
    "relUrl": "/docs/2019-08-26-0165-dict.html"
  },
  "165": {
    "id": "165",
    "title": "SE-0166 Swift Archival & Serialization",
    "content": "Swift Archival &amp; Serialization Proposal: SE-0166 Authors: Itai Ferber, Michael LeHew, Tony Parker Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift#9004 Introduction Foundation’s current archival and serialization APIs (NSCoding, NSJSONSerialization, NSPropertyListSerialization, etc.), while fitting for the dynamism of Objective-C, do not always map optimally into Swift. This document lays out the design of an updated API that improves the developer experience of performing archival and serialization in Swift. Specifically: It aims to provide a solution for the archival of Swift struct and enum types It aims to provide a more type-safe solution for serializing to external formats, such as JSON and plist Motivation The primary motivation for this proposal is the inclusion of native Swift enum and struct types in archival and serialization. Currently, developers targeting Swift cannot participate in NSCoding without being willing to abandon enum and struct types — NSCoding is an @objc protocol, conformance to which excludes non-class types. This can be limiting in Swift because small enums and structs can be an idiomatic approach to model representation; developers who wish to perform archival have to either forgo the Swift niceties that constructs like enums provide, or provide an additional compatibility layer between their “real” types and their archivable types. Secondarily, we would like to refine Foundation’s existing serialization APIs (NSJSONSerialization and NSPropertyListSerialization) to better match Swift’s strong type safety. From experience, we find that the conversion from the unstructured, untyped data of these formats into strongly-typed data structures is a good fit for archival mechanisms, rather than taking the less safe approach that 3rd-party JSON conversion approaches have taken (described further in an appendix below). We would like to offer a solution to these problems without sacrificing ease of use or type safety. Agenda This proposal is the first stage of three that introduce different facets of a whole Swift archival and serialization API: This proposal describes the basis for this API, focusing on the protocols that users adopt and interface with The next stage will propose specific API for new encoders The final stage will discuss how this new API will interop with NSCoding as it is today SE-0167 provides stages 2 and 3. Proposed solution We will be introducing the Encodable and Decodable protocols, adoption of which will allow end user types to participate in encoding and decoding: // Codable implies Encodable and Decodable // If all properties are Codable, protocol implementation is automatically generated by the compiler: public struct Location : Codable { public let latitude: Double public let longitude: Double } public enum Animal : Int, Codable { case chicken = 1 case dog case turkey case cow } public struct Farm : Codable { public let name: String public let location: Location public let animals: [Animal] } With developer participation, we will offer encoders and decoders (described in SE-0167, not here) that take advantage of this conformance to offer type-safe serialization of user models: let farm = Farm(name: &quot;Old MacDonald&#39;s Farm&quot;, location: Location(latitude: 51.621648, longitude: 0.269273), animals: [.chicken, .dog, .cow, .turkey, .dog, .chicken, .cow, .turkey, .dog]) let payload: Data = try JSONEncoder().encode(farm) do { let farm = try JSONDecoder().decode(Farm.self, from: payload) // Extracted as user types: let coordinates = &quot; (farm.location.latitude, farm.location.longitude)&quot; } catch { // Encountered error during deserialization } This gives developers access to their data in a type-safe manner and a recognizable interface. Detailed design We will be introducing the following new types to the Swift standard library: protocol Encodable &amp; protocol Decodable: Adopted by types to opt into archival. Implementation can be synthesized by the compiler in cases where all properties are also Encodable or Decodable protocol CodingKey: Adopted by types used as keys for keyed containers, replacing String keys with semantic types. Implementation can be synthesized by the compiler in most cases protocol Encoder: Adopted by types which can take Encodable values and encode them into a native format protocol KeyedEncodingContainerProtocol: Adopted by types which provide a concrete way to store encoded values by CodingKey. Types adopting Encoder should provide types conforming to KeyedEncodingContainerProtocol to vend struct KeyedEncodingContainer&lt;Key : CodingKey&gt;: A concrete type-erased box for exposing KeyedEncodingContainerProtocol types; this is a type consumers of the API interact with directly protocol UnkeyedEncodingContainer: Adopted by types which provide a concrete way to stored encoded values with no keys. Types adopting Encoder should provide types conforming to UnkeyedEncodingContainer to vend protocol SingleValueEncodingContainer: Adopted by types which provide a concrete way to store a single encoded value. Types adopting Encoder should provide types conforming to SingleValueEncodingContainer to vend protocol Decoder: Adopted by types which can take payloads in a native format and decode Decodable values out of them protocol KeyedDecodingContainerProtocol: Adopted by types which provide a concrete way to retrieve encoded values from storage by CodingKey. Types adopting Decoder should provide types conforming to KeyedDecodingContainerProtocol to vend struct KeyedDecodingContainer&lt;Key : CodingKey&gt;: A concrete type-erased box for exposing KeyedDecodingContainerProtocol types; this is a type consumers of the API interact with directly protocol UnkeyedDecodingContainer: Adopted by types which provide a concrete way to retrieve encoded values from storage with no keys. Types adopting Decoder should provide types conforming to UnkeyedDecodingContainer to vend protocol SingleValueDecodingContainer: Adopted by types which provide a concrete way to retrieve a single encoded value from storage. Types adopting Decoder should provide types conforming to SingleValueDecodingContainer to vend struct CodingUserInfoKey: A String RawRepresentable struct for representing keys to use in Encoders’ and Decoders’ userInfo dictionaries To support user types, we expose the Encodable and Decodable protocols: /// Conformance to `Encodable` indicates that a type can encode itself to an external representation. public protocol Encodable { /// Encodes `self` into the given encoder. /// /// If `self` fails to encode anything, `encoder` will encode an empty keyed container in its place. /// /// - parameter encoder: The encoder to write data to. /// - throws: An error if any values are invalid for `encoder`&#39;s format. func encode(to encoder: Encoder) throws } /// Conformance to `Decodable` indicates that a type can decode itself from an external representation. public protocol Decodable { /// Initializes `self` by decoding from `decoder`. /// /// - parameter decoder: The decoder to read data from. /// - throws: An error if reading from the decoder fails, or if read data is corrupted or otherwise invalid. init(from decoder: Decoder) throws } /// Conformance to `Codable` indicates that a type can convert itself into and out of an external representation. public typealias Codable = Encodable &amp; Decodable By adopting these protocols, user types opt in to this system. Structured types (i.e. types which encode as a collection of properties) encode and decode their properties in a keyed manner. Keys are semantic String-convertible enums which map properties to encoded names. Keys must conform to the CodingKey protocol: /// Conformance to `CodingKey` indicates that a type can be used as a key for encoding and decoding. public protocol CodingKey { /// The string to use in a named collection (e.g. a string-keyed dictionary). var stringValue: String { get } /// Initializes `self` from a string. /// /// - parameter stringValue: The string value of the desired key. /// - returns: An instance of `Self` from the given string, or `nil` if the given string does not correspond to any instance of `Self`. init?(stringValue: String) /// The int to use in an indexed collection (e.g. an int-keyed dictionary). var intValue: Int? { get } /// Initializes `self` from an integer. /// /// - parameter intValue: The integer value of the desired key. /// - returns: An instance of `Self` from the given integer, or `nil` if the given integer does not correspond to any instance of `Self`. init?(intValue: Int) } For performance, where relevant, keys may be Int-convertible, and Encoders may choose to make use of Ints over Strings as appropriate. Framework types should provide keys which have both for flexibility and performance across different types of Encoders. By default, CodingKey conformance can be derived for enums which have no raw type and no associated values, or String or Int backing: enum Keys1 : CodingKey { case a // (stringValue: &quot;a&quot;, intValue: nil) case b // (stringValue: &quot;b&quot;, intValue: nil) // The compiler automatically generates the following: var stringValue: String { switch self { case .a: return &quot;a&quot; case .b: return &quot;b&quot; } } init?(stringValue: String) { switch stringValue { case &quot;a&quot;: self = .a case &quot;b&quot;: self = .b default: return nil } } var intValue: Int? { return nil } init?(intValue: Int) { return nil } } enum Keys2 : String, CodingKey { case c = &quot;foo&quot; // (stringValue: &quot;foo&quot;, intValue: nil) case d // (stringValue: &quot;d&quot;, intValue: nil) // stringValue, init?(stringValue:), intValue, and init?(intValue:) are generated by the compiler as well } enum Keys3 : Int, CodingKey { case e = 4 // (stringValue: &quot;e&quot;, intValue: 4) case f // (stringValue: &quot;f&quot;, intValue: 5) case g = 9 // (stringValue: &quot;g&quot;, intValue: 9) // stringValue, init?(stringValue:), intValue, and init?(intValue:) are generated by the compiler as well } Coding keys which are not enums, have associated values, or have other raw representations must implement these methods manually. In addition to automatic CodingKey requirement synthesis for enums, Encodable &amp; Decodable requirements can be automatically synthesized for certain types as well: Types conforming to Encodable whose properties are all Encodable get an automatically generated String-backed CodingKey enum mapping properties to case names. Similarly for Decodable types whose properties are all Decodable Types falling into (1) — and types which manually provide a CodingKey enum (named CodingKeys, directly, or via a typealias) whose cases map 1-to-1 to Encodable/Decodable properties by name — get automatic synthesis of init(from:) and encode(to:) as appropriate, using those properties and keys Types which fall into neither (1) nor (2) will have to provide a custom key type if needed and provide their own init(from:) and encode(to:), as appropriate This synthesis can always be overridden by a manual implementation of any protocol requirements. Many types will either allow for automatic synthesis of all of codability (1), or provide a custom key subset and take advantage of automatic method synthesis (2). Encoding and Decoding Types which are Encodable encode their data into a container provided by their Encoder: /// An `Encoder` is a type which can encode values into a native format for external representation. public protocol Encoder { /// Returns an encoding container appropriate for holding multiple values keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - returns: A new keyed encoding container. /// - precondition: May not be called after a prior `self.unkeyedContainer()` call. /// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call. func container&lt;Key : CodingKey&gt;(keyedBy type: Key.Type) -&gt; KeyedEncodingContainer&lt;Key&gt; /// Returns an encoding container appropriate for holding multiple unkeyed values. /// /// - returns: A new empty unkeyed container. /// - precondition: May not be called after a prior `self.container(keyedBy:)` call. /// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call. func unkeyedContainer() -&gt; UnkeyedEncodingContainer /// Returns an encoding container appropriate for holding a single primitive value. /// /// - returns: A new empty single value container. /// - precondition: May not be called after a prior `self.container(keyedBy:)` call. /// - precondition: May not be called after a prior `self.unkeyedContainer()` call. /// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call. func singleValueContainer() -&gt; SingleValueEncodingContainer /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } } // Continuing examples from before; below is automatically generated by the compiler if no customization is needed. public struct Location : Codable { private enum CodingKeys : CodingKey { case latitude case longitude } public func encode(to encoder: Encoder) throws { // Generic keyed encoder gives type-safe key access: cannot encode with keys of the wrong type. var container = encoder.container(keyedBy: CodingKeys.self) // The encoder is generic on the key -- free key autocompletion here. try container.encode(latitude, forKey: .latitude) try container.encode(longitude, forKey: .longitude) } } public struct Farm : Codable { private enum CodingKeys : CodingKey { case name case location case animals } public func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(name, forKey: .name) try container.encode(location, forKey: .location) try container.encode(animals, forKey: .animals) } } Similarly, Decodable types initialize from data read from their Decoder’s container: /// A `Decoder` is a type which can decode values from a native format into in-memory representations. public protocol Decoder { /// Returns the data stored in `self` as represented in a container keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. func container&lt;Key : CodingKey&gt;(keyedBy type: Key.Type) throws -&gt; KeyedDecodingContainer&lt;Key&gt; /// Returns the data stored in `self` as represented in a container appropriate for holding values with no keys. /// /// - returns: An unkeyed container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. func unkeyedContainer() throws -&gt; UnkeyedDecodingContainer /// Returns the data stored in `self` as represented in a container appropriate for holding a single primitive value. /// /// - returns: A single value container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a single value container. func singleValueContainer() throws -&gt; SingleValueDecodingContainer /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } } // Continuing examples from before; below is automatically generated by the compiler if no customization is needed. public struct Location : Codable { public init(from decoder: Decoder) throws { var container = try decoder.container(keyedBy: CodingKeys.self) latitude = try container.decode(Double.self, forKey: .latitude) longitude = try container.decode(Double.self, forKey: .longitude) } } public struct Farm : Codable { public init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) name = try container.decode(String.self, forKey: .name) location = try container.decode(Location.self, forKey: .location) animals = try container.decode([Animal].self, forKey: .animals) } } Keyed Containers Keyed containers are the primary interface that most Codable types interact with for encoding and decoding. Through these, Codable types have strongly-keyed access to encoded data by using keys that are semantically correct for the operations they want to express. Since semantically incompatible keys will rarely (if ever) share the same key type, it is impossible to mix up key types within the same container (as is possible with String keys), and since the type is known statically, keys get autocompletion by the compiler. /// Conformance to `KeyedEncodingContainerProtocol` indicates that a type provides a view into an `Encoder`&#39;s storage and is used to hold the encoded properties of an `Encodable` type in a keyed manner. /// /// Encoders should provide types conforming to `KeyedEncodingContainerProtocol` for their format. public protocol KeyedEncodingContainerProtocol { associatedtype Key : CodingKey /// Encodes the given value for the given key. /// /// - parameter value: The value to encode. /// - parameter key: The key to associate the value with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode&lt;T : Encodable&gt;(_ value: T?, forKey key: Key) throws /// Encodes the given value for the given key. /// /// - parameter value: The value to encode. /// - parameter key: The key to associate the value with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode(_ value: Bool?, forKey key: Key) throws mutating func encode(_ value: Int?, forKey key: Key) throws mutating func encode(_ value: Int8?, forKey key: Key) throws mutating func encode(_ value: Int16?, forKey key: Key) throws mutating func encode(_ value: Int32?, forKey key: Key) throws mutating func encode(_ value: Int64?, forKey key: Key) throws mutating func encode(_ value: UInt?, forKey key: Key) throws mutating func encode(_ value: UInt8?, forKey key: Key) throws mutating func encode(_ value: UInt16?, forKey key: Key) throws mutating func encode(_ value: UInt32?, forKey key: Key) throws mutating func encode(_ value: UInt64?, forKey key: Key) throws mutating func encode(_ value: Float?, forKey key: Key) throws mutating func encode(_ value: Double?, forKey key: Key) throws mutating func encode(_ value: String?, forKey key: Key) throws /// Encodes the given object weakly for the given key. /// /// For `Encoder`s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future). /// /// For formats which don&#39;t support this feature, the default implementation encodes the given object unconditionally. /// /// - parameter object: The object to encode. /// - parameter key: The key to associate the object with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encodeWeak&lt;T : AnyObject &amp; Encodable&gt;(_ object: T?, forKey key: Key) throws /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } } /// `KeyedEncodingContainer` is a type-erased box for `KeyedEncodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly. public struct KeyedEncodingContainer&lt;K : CodingKey&gt; : KeyedEncodingContainerProtocol { associatedtype Key = K /// Initializes `self` with the given container. /// /// - parameter container: The container to hold. init&lt;Container : KeyedEncodingContainerProtocol&gt;(_ container: Container) where Container.Key == Key // + methods from KeyedEncodingContainerProtocol } /// Conformance to `KeyedDecodingContainerProtocol` indicates that a type provides a view into a `Decoder`&#39;s storage and is used to hold the encoded properties of a `Decodable` type in a keyed manner. /// /// Decoders should provide types conforming to `KeyedDecodingContainerProtocol` for their format. public protocol KeyedDecodingContainerProtocol { associatedtype Key : CodingKey /// All the keys the `Decoder` has for this container. /// /// Different keyed containers from the same `Decoder` may return different keys here; it is possible to encode with multiple key types which are not convertible to one another. This should report all keys present which are convertible to the requested type. var allKeys: [Key] { get } /// Returns whether the `Decoder` contains a value associated with the given key. /// /// The value associated with the given key may be a null value as appropriate for the data format. /// /// - parameter key: The key to search for. /// - returns: Whether the `Decoder` has an entry for the given key. func contains(_ key: Key) -&gt; Bool /// Decodes a value of the given type for the given key. /// /// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below. /// /// - parameter type: The type of value to decode. /// - parameter key: The key that the decoded value is associated with. /// - returns: A value of the requested type, if present for the given key and convertible to the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key or if the value is null. func decode(_ type: Bool.Type, forKey key: Key) throws -&gt; Bool func decode(_ type: Int.Type, forKey key: Key) throws -&gt; Int func decode(_ type: Int8.Type, forKey key: Key) throws -&gt; Int8 func decode(_ type: Int16.Type, forKey key: Key) throws -&gt; Int16 func decode(_ type: Int32.Type, forKey key: Key) throws -&gt; Int32 func decode(_ type: Int64.Type, forKey key: Key) throws -&gt; Int64 func decode(_ type: UInt.Type, forKey key: Key) throws -&gt; UInt func decode(_ type: UInt8.Type, forKey key: Key) throws -&gt; UInt8 func decode(_ type: UInt16.Type, forKey key: Key) throws -&gt; UInt16 func decode(_ type: UInt32.Type, forKey key: Key) throws -&gt; UInt32 func decode(_ type: UInt64.Type, forKey key: Key) throws -&gt; UInt64 func decode(_ type: Float.Type, forKey key: Key) throws -&gt; Float func decode(_ type: Double.Type, forKey key: Key) throws -&gt; Double func decode(_ type: String.Type, forKey key: Key) throws -&gt; String func decode&lt;T : Decodable&gt;(_ type: T.Type, forKey key: Key) throws -&gt; T /// Decodes a value of the given type for the given key, if present. /// /// This method returns `nil` if the container does not have a value associated with `key`, or if the value is null. The difference between these states can be distinguished with a `contains(_:)` call. /// /// - parameter type: The type of value to decode. /// - parameter key: The key that the decoded value is associated with. /// - returns: A decoded value of the requested type, or `nil` if the `Decoder` does not have an entry associated with the given key, or if the value is a null value. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -&gt; Bool? func decodeIfPresent(_ type: Int.Type, forKey key: Key) throws -&gt; Int? func decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -&gt; Int8? func decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -&gt; Int16? func decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -&gt; Int32? func decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -&gt; Int64? func decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -&gt; UInt? func decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -&gt; UInt8? func decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -&gt; UInt16? func decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -&gt; UInt32? func decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -&gt; UInt64? func decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -&gt; Float? func decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -&gt; Double? func decodeIfPresent(_ type: String.Type, forKey key: Key) throws -&gt; String? func decodeIfPresent&lt;T : Decodable&gt;(_ type: T.Type, forKey key: Key) throws -&gt; T? /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } } /// `KeyedDecodingContainer` is a type-erased box for `KeyedDecodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly. public struct KeyedDecodingContainer&lt;K : CodingKey&gt; : KeyedDecodingContainerProtocol { associatedtype Key = K /// Initializes `self` with the given container. /// /// - parameter container: The container to hold. init&lt;Container : KeyedDecodingContainerProtocol&gt;(_ container: Container) where Container.Key == Key // + methods from KeyedDecodingContainerProtocol } These encode(_:forKey:) and decode(_:forKey:) overloads give strong, static type guarantees about what is encodable (preventing accidental attempts to encode an invalid type), and provide a list of primitive types which are common to all encoders and decoders that users can rely on. When the conditional conformance feature lands in Swift, the ability to express that “a collection of things which are Codable is Codable” will allow collections (Array, Dictionary, etc.) to be extended and fall into these overloads as well. Unkeyed Containers For some types, when the source and destination of a payload can be guaranteed to agree on the payload layout and format (e.g. in cross-process communication, where both sides agree on the payload format), it may be appropriate to eschew the encoding of keys and encode sequentially, without keys. In this case, a type may choose to make use of an unkeyed container for its properties: /// Conformance to `UnkeyedEncodingContainer` indicates that a type provides a view into an `Encoder`&#39;s storage and is used to hold the encoded properties of an `Encodable` type sequentially, without keys. /// /// Encoders should provide types conforming to `UnkeyedEncodingContainer` for their format. public protocol UnkeyedEncodingContainer { /// Encodes the given value. /// /// - parameter value: The value to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode&lt;T : Encodable&gt;(_ value: T?) throws /// Encodes the given value. /// /// - parameter value: The value to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode(_ value: Bool?) throws mutating func encode(_ value: Int?) throws mutating func encode(_ value: Int8?) throws mutating func encode(_ value: Int16?) throws mutating func encode(_ value: Int32?) throws mutating func encode(_ value: Int64?) throws mutating func encode(_ value: UInt?) throws mutating func encode(_ value: UInt8?) throws mutating func encode(_ value: UInt16?) throws mutating func encode(_ value: UInt32?) throws mutating func encode(_ value: UInt64?) throws mutating func encode(_ value: Float?) throws mutating func encode(_ value: Double?) throws mutating func encode(_ value: String?) throws /// Encodes the given object weakly. /// /// For `Encoder`s that implement this functionality, this will only encode the given object if it is encoded unconditionally elsewhere in the payload (either previously or in the future). /// /// For formats which don&#39;t support this feature, the default implementation encodes the given object unconditionally. /// /// - parameter object: The object to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encodeWeak&lt;T : AnyObject &amp; Encodable&gt;(_ object: T?) throws /// Encodes the elements of the given sequence. /// /// A default implementation of these is given in an extension. /// /// - parameter sequence: The sequences whose contents to encode. /// - throws: An error if any of the contained values throws an error. mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Bool mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Int // ... mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element : Encodable /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } } /// Conformance to `UnkeyedDecodingContainer` indicates that a type provides a view into a `Decoder`&#39;s storage and is used to hold the encoded properties of a `Decodable` type sequentially, without keys. /// /// Decoders should provide types conforming to `UnkeyedDecodingContainer` for their format. public protocol UnkeyedDecodingContainer { /// Returns the number of elements (if known) contained within this container. var count: Int? { get } /// Returns whether there are no more elements left to be decoded in the container. var isAtEnd: Bool { get } /// Decodes a value of the given type. /// /// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below. /// /// - parameter type: The type of value to decode. /// - returns: A value of the requested type, if present for the given key and convertible to the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. /// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode. mutating func decode(_ type: Bool.Type) throws -&gt; Bool mutating func decode(_ type: Int.Type) throws -&gt; Int mutating func decode(_ type: Int8.Type) throws -&gt; Int8 mutating func decode(_ type: Int16.Type) throws -&gt; Int16 mutating func decode(_ type: Int32.Type) throws -&gt; Int32 mutating func decode(_ type: Int64.Type) throws -&gt; Int64 mutating func decode(_ type: UInt.Type) throws -&gt; UInt mutating func decode(_ type: UInt8.Type) throws -&gt; UInt8 mutating func decode(_ type: UInt16.Type) throws -&gt; UInt16 mutating func decode(_ type: UInt32.Type) throws -&gt; UInt32 mutating func decode(_ type: UInt64.Type) throws -&gt; UInt64 mutating func decode(_ type: Float.Type) throws -&gt; Float mutating func decode(_ type: Double.Type) throws -&gt; Double mutating func decode(_ type: String.Type) throws -&gt; String mutating func decode&lt;T : Decodable&gt;(_ type: T.Type) throws -&gt; T /// Decodes a value of the given type, if present. /// /// This method returns `nil` if the container has no elements left to decode, or if the value is null. The difference between these states can be distinguished by checking `isAtEnd`. /// /// - parameter type: The type of value to decode. /// - returns: A decoded value of the requested type, or `nil` if the value is a null value, or if there are no more elements to decode. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. mutating func decodeIfPresent(_ type: Bool.Type) throws -&gt; Bool? mutating func decodeIfPresent(_ type: Int.Type) throws -&gt; Int? mutating func decodeIfPresent(_ type: Int8.Type) throws -&gt; Int8? mutating func decodeIfPresent(_ type: Int16.Type) throws -&gt; Int16? mutating func decodeIfPresent(_ type: Int32.Type) throws -&gt; Int32? mutating func decodeIfPresent(_ type: Int64.Type) throws -&gt; Int64? mutating func decodeIfPresent(_ type: UInt.Type) throws -&gt; UInt? mutating func decodeIfPresent(_ type: UInt8.Type) throws -&gt; UInt8? mutating func decodeIfPresent(_ type: UInt16.Type) throws -&gt; UInt16? mutating func decodeIfPresent(_ type: UInt32.Type) throws -&gt; UInt32? mutating func decodeIfPresent(_ type: UInt64.Type) throws -&gt; UInt64? mutating func decodeIfPresent(_ type: Float.Type) throws -&gt; Float? mutating func decodeIfPresent(_ type: Double.Type) throws -&gt; Double? mutating func decodeIfPresent(_ type: String.Type) throws -&gt; String? mutating func decodeIfPresent&lt;T : Decodable&gt;(_ type: T.Type) throws -&gt; T? /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } } Unkeyed encoding is fragile and generally not appropriate for archival without specific format guarantees, so keyed encoding remains the recommended approach (and is why CodingKey enums are synthesized by default unless otherwise declined). Single Value Containers For other types, an array or dictionary container may not even make sense (e.g. values which are RawRepresentable as a single primitive value). Those types may encode and decode directly as a single value, instead of requesting an outer container: /// A `SingleValueEncodingContainer` is a container which can support the storage and direct encoding of a single non-keyed value. public protocol SingleValueEncodingContainer { /// Encodes a single value of the given type. /// /// - parameter value: The value to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. /// - precondition: May not be called after a previous `self.encode(_:)` call. mutating func encode(_ value: Bool) throws mutating func encode(_ value: Int) throws mutating func encode(_ value: Int8) throws mutating func encode(_ value: Int16) throws mutating func encode(_ value: Int32) throws mutating func encode(_ value: Int64) throws mutating func encode(_ value: UInt) throws mutating func encode(_ value: UInt8) throws mutating func encode(_ value: UInt16) throws mutating func encode(_ value: UInt32) throws mutating func encode(_ value: UInt64) throws mutating func encode(_ value: Float) throws mutating func encode(_ value: Double) throws mutating func encode(_ value: String) throws } /// A `SingleValueDecodingContainer` is a container which can support the storage and direct decoding of a single non-keyed value. public protocol SingleValueDecodingContainer { /// Decodes a single value of the given type. /// /// - parameter type: The type to decode as. /// - returns: A value of the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value cannot be converted to the requested type. func decode(_ type: Bool.Type) throws -&gt; Bool func decode(_ type: Int.Type) throws -&gt; Int func decode(_ type: Int8.Type) throws -&gt; Int8 func decode(_ type: Int16.Type) throws -&gt; Int16 func decode(_ type: Int32.Type) throws -&gt; Int32 func decode(_ type: Int64.Type) throws -&gt; Int64 func decode(_ type: UInt.Type) throws -&gt; UInt func decode(_ type: UInt8.Type) throws -&gt; UInt8 func decode(_ type: UInt16.Type) throws -&gt; UInt16 func decode(_ type: UInt32.Type) throws -&gt; UInt32 func decode(_ type: UInt64.Type) throws -&gt; UInt64 func decode(_ type: Float.Type) throws -&gt; Float func decode(_ type: Double.Type) throws -&gt; Double func decode(_ type: String.Type) throws -&gt; String } // Continuing example from before; below is automatically generated by the compiler if no customization is needed. public enum Animal : Int, Codable { public func encode(to encoder: Encoder) throws { // Encode as a single value; no keys. try encoder.singleValueContainer().encode(self.rawValue) } public init(from decoder: Decoder) throws { // Decodes as a single value; no keys. let intValue = try decoder.singleValueContainer().decode(Int.self) if let value = Self(rawValue: intValue) { self = value } else { throw CocoaError.error(.coderReadCorrupt) } } } In the example given above, since Animal uses a single value container, [.chicken, .dog, .cow, .turkey, .dog, .chicken, .cow, .turkey, .dog] would encode directly as [1, 2, 4, 3, 2, 1, 4, 3, 2]. Nesting In practice, some types may also need to control how data is nested within their container, or potentially nest other containers within their container. Keyed containers allow this by returning nested containers of differing types: // Continuing from before public protocol KeyedEncodingContainerProtocol { /// Stores a keyed encoding container for the given key and returns it. /// /// - parameter keyType: The key type to use for the container. /// - parameter key: The key to encode the container for. /// - returns: A new keyed encoding container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy keyType: NestedKey.Type, forKey key: Key) -&gt; KeyedEncodingContainer&lt;NestedKey&gt; /// Stores an unkeyed encoding container for the given key and returns it. /// /// - parameter key: The key to encode the container for. /// - returns: A new unkeyed encoding container. mutating func nestedUnkeyedContainer(forKey key: Key) -&gt; UnkeyedEncodingContainer } public protocol KeyedDecodingContainerProtocol { /// Returns the data stored for the given key as represented in a container keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - parameter key: The key that the nested container is associated with. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy type: NestedKey.Type, forKey key: Key) throws -&gt; KeyedDecodingContainer&lt;NestedKey&gt; /// Returns the data stored for the given key as represented in an unkeyed container. /// /// - parameter key: The key that the nested container is associated with. /// - returns: An unkeyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. func nestedUnkeyedContainer(forKey key: Key) throws -&gt; UnkeyedDecodingContainer } This can be common when coding against specific external data representations: // User type for interfacing with a specific JSON API. JSON API expects encoding as {&quot;id&quot;: ..., &quot;properties&quot;: {&quot;name&quot;: ..., &quot;timestamp&quot;: ...}}. Swift type differs from encoded type, and encoding needs to match a spec: struct Record : Codable { // We care only about these values from the JSON payload let id: Int let name: String let timestamp: Double // ... private enum Keys : CodingKey { case id case properties } private enum PropertiesKeys : CodingKey { case name case timestamp } public func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: Keys.self, type: .dictionary) try container.encode(id, forKey: .id) // Set a dictionary for the &quot;properties&quot; key let nested = container.nestedContainer(keyedBy: PropertiesKeys.self, forKey: .properties) try nested.encode(name, forKey: .name) try nested.encode(timestamp, forKey: .timestamp) } public init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: Keys.self) id = try container.decode(Int.self, forKey: .id) let nested = try container.nestedContainer(keyedBy: PropertiesKeys.self, forKey: .properties) name = try nested.decode(String.self, forKey: .name) timestamp = try nested.decode(Double.self, forKey: .timestamp) } } Unkeyed containers allow for the same types of nesting: // Continuing from before public protocol UnkeyedEncodingContainer { /// Encodes a nested container keyed by the given type and returns it. /// /// - parameter keyType: The key type to use for the container. /// - returns: A new keyed encoding container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy keyType: NestedKey.Type) -&gt; KeyedEncodingContainer&lt;NestedKey&gt; /// Encodes an unkeyed encoding container and returns it. /// /// - returns: A new unkeyed encoding container. mutating func nestedUnkeyedContainer() -&gt; UnkeyedEncodingContainer } public protocol UnkeyedDecodingContainer { /// Decodes a nested container keyed by the given type. /// /// - parameter type: The key type to use for the container. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy type: NestedKey.Type) throws -&gt; KeyedDecodingContainer&lt;NestedKey&gt; /// Decodes an unkeyed nested container. /// /// - returns: An unkeyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. mutating func nestedUnkeyedContainer() throws -&gt; UnkeyedDecodingContainer } Dynamic Context-Based Behavior In some cases, types may need context in order to decide on their external representation. Some types may choose a different representation based on the encoding format that they are being read from or written to, and others based on other runtime contextual information. To facilitate this, Encoders and Decoders expose user-supplied context for consumption: /// Represents a user-defined key for providing context for encoding and decoding. public struct CodingUserInfoKey : RawRepresentable, Hashable { typealias RawValue = String let rawValue: String init?(rawValue: String) } // Continuing from before: public protocol Encoder { /// Any contextual information set by the user for encoding. var userInfo: [CodingUserInfoKey : Any] { get } } public protocol Decoder { /// Any contextual information set by the user for decoding. var userInfo: [CodingUserInfoKey : Any] { get } } Consuming types may then support setting contextual information to inform their encoding and decoding: public struct Person : Encodable { public static let codingUserInfoKey = CodingUserInfoKey(&quot;com.foocorp.person.codingUserInfoKey&quot;) public struct UserInfo { let shouldEncodePrivateFields: Bool // ... } func encode(to encoder: Encoder) throws { if let context = encoder.userInfo[Person.codingUserInfoKey] as? Person.UserInfo { if context.shouldEncodePrivateFields { // Do something special. } } // Fall back to default. } } let encoder = ... encoder.userInfo[Person.codingUserInfoKey] = Person.UserInfo(...) let data = try encoder.encode(person) Encoders and Decoders may choose to expose contextual information about their configuration as part of the context as well if necessary. Inheritance Inheritance in this system is supported much like it is with NSCoding — on encoding, objects which inherit from a type that is Encodable encode super using their encoder, and pass a decoder to super.init(from:) on decode if they inherit from a type that is Decodable. With the existing NSCoding API, this is most often done like so, by convention: - (void)encodeWithCoder:(NSCoder *)encoder { [super encodeWithCoder:encoder]; // ... encode properties } - (instancetype)initWithCoder:(NSCoder *)decoder { if ((self = [super initWithCoder:decoder])) { // ... decode properties } return self; } In practice, this approach means that the properties of self and the properties of super get encoded into the same container: if self encodes values for keys &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;, and super encodes &quot;d&quot;, &quot;e&quot;, and &quot;f&quot;, the resulting object is encoded as {&quot;a&quot;: ..., &quot;b&quot;: ..., &quot;c&quot;: ..., &quot;d&quot;: ..., &quot;e&quot;: ..., &quot;f&quot;: ...}. This approach has two drawbacks: Things which self encodes may overwrite super’s (or vice versa, depending on when -[super encodeWithCoder:] is called self and super may not encode into different container types (e.g. self in a sequential fashion, and super in a keyed fashion) The second point is not an issue for NSKeyedArchiver, since all values encode with keys (sequentially coded elements get autogenerated keys). This proposed API, however, allows for self and super to explicitly request conflicting containers (.array and .dictionary, which may not be mixed, depending on the data format). To remedy both of these points, we adopt a new convention for inheritance-based coding — encoding super as a sub-object of self: public class MyCodable : SomethingCodable { public func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) // ... encode some properties // superEncoder() gives `super` a nested container to encode into (for // a predefined key). try super.encode(to: container.superEncoder()) } public init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) // ... decode some properties // Allow `super` to decode from the nested container. try super.init(from: container.superDecoder()) } } If a shared container is desired, it is still possible to call super.encode(to: encoder) and super.init(from: decoder), but we recommend the safer containerized option. superEncoder() and superDecoder() are provided on containers to provide handles to nested containers for super to use. // Continuing from before public protocol KeyedEncodingContainerProtocol { /// Stores a new nested container for the default `super` key and returns a new `Encoder` instance for encoding `super` into that container. /// /// Equivalent to calling `superEncoder(forKey:)` with `Key(stringValue: &quot;super&quot;, intValue: 0)`. /// /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder() -&gt; Encoder /// Stores a new nested container for the given key and returns a new `Encoder` instance for encoding `super` into that container. /// /// - parameter key: The key to encode `super` for. /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder(forKey key: Key) -&gt; Encoder } public protocol KeyedDecodingContainerProtocol { /// Returns a `Decoder` instance for decoding `super` from the container associated with the default `super` key. /// /// Equivalent to calling `superDecoder(forKey:)` with `Key(stringValue: &quot;super&quot;, intValue: 0)`. /// /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the default `super` key, or if the stored value is null. func superDecoder() throws -&gt; Decoder /// Returns a `Decoder` instance for decoding `super` from the container associated with the given key. /// /// - parameter key: The key to decode `super` for. /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key, or if the stored value is null. func superDecoder(forKey key: Key) throws -&gt; Decoder } public protocol UnkeyedEncodingContainer { /// Encodes a nested container and returns an `Encoder` instance for encoding `super` into that container. /// /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder() -&gt; Encoder } public protocol UnkeyedDecodingContainer { /// Decodes a nested container and returns a `Decoder` instance for decoding `super` from that container. /// /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode. mutating func superDecoder() throws -&gt; Decoder } Primitive Codable Conformance The encoding container types offer overloads for working with and processing the API’s primitive types (String, Int, Double, etc.). However, for ease of implementation (both in this API and others), it can be helpful for these types to conform to Codable themselves. Thus, along with these overloads, we will offer Codable conformance on these types: extension Bool : Codable { public init(from decoder: Decoder) throws { self = try decoder.singleValueContainer().decode(Bool.self) } public func encode(to encoder: Encoder) throws { try encoder.singleValueContainer().encode( self) } } // Repeat for others... This conformance allows one to write functions which accept Codable types without needing specific overloads for the fifteen primitive types as well. Since Swift’s function overload rules prefer more specific functions over generic functions, the specific overloads are chosen where possible (e.g. encode(&quot;Hello, world!&quot;, forKey: .greeting) will choose encode(_: String, forKey: Key) over encode&lt;T : Codable&gt;(_: T, forKey: Key)). Additional Extensions Along with the primitive Codable conformance above, extensions on Codable RawRepresentable types whose RawValue is a primitive types will provide default implementations for encoding and decoding: public extension RawRepresentable where RawValue == Bool, Self : Codable { public init(from decoder: Decoder) throws { let decoded = try decoder.singleValueContainer().decode(RawValue.self) guard let value = Self(rawValue: decoded) else { throw CocoaError.error(.coderReadCorrupt) } self = value } public func encode(to encoder: Encoder) throws { try encoder.singleValueContainer().encode(self.rawValue) } } // Repeat for others... This allows for trivial Codable conformance of enum types (and manual RawRepresentable implementations) with primitive backing. Source compatibility This proposal is additive — existing code will not have to change due to this API addition. This implementation can be made available in both Swift 4 and the Swift 3 compatibility mode. Effect on ABI stability The addition of this API will not be an ABI-breaking change. However, this will add limitations for changes in future versions of Swift, as parts of the API will have to remain unchanged between versions of Swift (barring some additions, discussed below). Effect on API resilience Much like new API added to the standard library, once added, many changes to this API will be ABI- and source-breaking changes. In particular, changes which change the types or names of methods or arguments, add required methods on protocols or classes, or remove supplied default implementations will break client behavior. The following types may not have methods added to them without providing default implementations: Encodable Decodable CodingKey Encoder KeyedEncodingContainerProtocol KeyedEncodingContainer UnkeyedEncodingContainer SingleValueEncodingContainer Decoder KeyedDecodingContainerProtocol KeyedDecodingContainer UnkeyedEncodingContainer SingleValueDecodingContainer Various extensions to Swift primitive types (Bool, Int, Double, etc.) and to RawRepresentable types (where RawValue == Bool, == Int, == Double, etc.) may also not be removed. In general, changes to the proposed types will be restricted as described in the library evolution document in the Swift repository. Alternatives considered The following are a few of the more notable approaches considered for the problem: Leverage the existing NSCoding implementation by adding support for struct and enum types, either through NSCoding itself, or through a similar protocol. Although technically feasible, this can feel like a “missed opportunity” for offering something better tuned for Swift. This approach would also not offer any additional integration with JSONSerialization and PropertyListSerialization, unless JSON and plist archivers were added to offer support. The following type-erased, declarative approach: // Similar hack to AnyHashable; these wrap values which have not yet been // encoded, or not yet decoded. struct AnyEncodable { ... } struct AnyDecodable { ... } protocol CodingPrimitive {} protocol PrimitiveCodable { /* same as above */ } protocol OrderedCodable { init(from: [AnyDecodable]) throws var encoded: [AnyEncodable] { get } } protocol KeyedCodable { init(from: [String: AnyDecodable]) throws var encoded: [String: AnyEncodable] { get } } // Same as above protocol OrderedEncoder { ... } protocol OrderedDecoder { ... } protocol KeyedEncoder { ... } protocol KeyedDecoder { ... } // Sample: struct Location: OrderedCodable { let latitude: Double let longitude: Double init(from array: [AnyDecodable]) throws { guard array.count == 2 else { /* throw */ } // These `.as()` calls perform the actual decoding, and fail by // throwing an error. let latitude = try array[0].as(Double.self) let longitude = try array[1].as(Double.self) try self.init(latitutde: latitude, longitude: longitude) } var encoded: [AnyEncodable] { // With compiler support, AnyEncodable() can be automatic. return [AnyEncodable(latitude), AnyEncodable(longitude)] } } struct Farm: KeyedCodable { let name: String let location: Location let animals: [Animal] init(from dictionary: [String: AnyDecodable]) throws { guard let name = dictionary[&quot;name&quot;], let location = dictionary[&quot;location&quot;], let animals = dictionary[&quot;animals&quot;] else { /* throw */ } self.name = try name.as(String.self) self.location = try location.as(Location.self) self.animals = try animals.asArrayOf(Animal.self) } var encoded: [String: AnyEncodable] { // Similarly, AnyEncodable() should go away. return [&quot;name&quot;: AnyEncodable(name), &quot;location&quot;: AnyEncodable(location), &quot;animals&quot;: AnyEncodable(animals)] } } Although the more declarative nature of this approach can be appealing, this suffers from the same problem that JSONSerialization currently does: as-casting. Getting an intermediate type-erased value requires casting to get a “real” value out. Doing this with an as?-cast requires compiler support to interject code to decode values of a given type out of their type-erased containers (similar to what happens today with AnyHashable). If the user requests a value of a different type than what is stored, however, the as?-cast will fail by returning nil — there is no meaningful way to report the failure. Getting the code to throw in cases like this requires methods on AnyDecodable (as shown above), but these can be confusing (when should you use .as() and when should you use as??). Modifications can be made to improve this: protocol OrderedCodable { // AnyDecodable can wrap anything, including [AnyDecodable]; unwrapping // these can be tedious, so we want to give default implementations // that do this. // Default implementations for these are given in terms of the // initializer below. init?(from: AnyDecodable?) throws init(from: AnyDecodable) throws init(from: [AnyDecodable]) throws var encoded: [AnyEncodable] { get } } protocol KeyedCodable { // AnyDecodable can wrap anything, including [String: AnyDecodable]; // unwrapping these can be tedious, so we want to give default // implementations that do this. // Default implementations for these are given in terms of the // initializer below. init?(from: AnyDecodable?) throws init(from: AnyDecodable) throws init(from: [String: AnyDecodable]) throws var encoded: [String: AnyEncodable] { get } } // Sample: struct Location: OrderedCodable { // ... init(from array: [AnyDecodable]) throws { guard array.count == 2 else { /* throw */ } let latitude = try Double(from: array[0]) let longitude = try Double(from: array[1]) try self.init(latitude: latitude, longitude: longitude) } // ... } struct Farm: KeyedCodable { // ... init(from dictionary: [String: AnyDecodable]) throws { guard let name = try String(from: dictionary[&quot;name&quot;]), let Location = try Location(from: dictionary[&quot;location&quot;]) let animals = try [Animal](from: dictionary[&quot;animals&quot;]) else { /* throw */ } self.name = name self.location = location self.animals = animals } // ... } By providing the new initializer methods, we can perform type casting via initialization, rather than by explicit casts. This pushes the .as() calls into the Swift primitives (CodingPrimitives, Array, Dictionary), hiding them from end users. However, this has a different problem, namely that by offering the same type-erased initializers, OrderedCodable and KeyedCodable now conflict, and it is impossible to conform to both. The declarative benefits here are not enough to outweigh the fact that this does not effectively remove the need to as?-cast. The following approach, which relies on compiler code generation: protocol Codable { /// `EncodedType` is an intermediate representation of `Self` -- it has /// the properties from `Self` that need to be archived and unarchived /// (and performs that archival work), but represents at type that is /// not yet domain-validated like `self` is. associatedtype EncodedType: CodingRepresentation init(from encoded: EncodedType) var encoded: EncodedType { get } } protocol CodingPrimitive {} protocol CodingRepresentation {} protocol PrimitiveCodingRepresentation: CodingRepresentation { /* Similar to PrimitiveCodable above */ } protocol OrderedCodingRepresentation: CodingRepresentation { /* Similar to OrderedCodable above */ } protocol KeyedCodingRepresentation: CodingRepresentation { /* Similar to KeyedCodable above */ } // Sample: struct Location : Codable { let latitude: Double let longitude: Double // // Ideally, the following could be generated by the compiler (in simple // cases; developers can choose to implement subsets of the following // code based on where they might need to perform customizations. init(from encoded: Encoded) throws { latitude = encoded.latitude longitude = encoded.longitude } var encoded: Encoded { return Encoded(self) } // Keyed coding is the default generated by the compiler; consumers who // want OrderedCodingRepresentation need to provide their own encoded // type. struct Encoded: OrderedCodingRepresentation { let latitude: String let longitude: String init(_ location: Location) { latitude = location.latitude longitude = location.longitude } init(from: KeyedDecoder) throws { ... } func encode(to: KeyedEncoder) { ... } } // } This approach separates encoding and decoding into constituent steps: Converting self into a representation fit for encoding (EncodedType, particularly if EncodedType has different properties from Self) Converting that representation into data (encode(into:)) Converting arbitrary bytes into validated types (EncodedType.init(from:)) Converting validated data and types into a domain-validated value (Self.init(from:)). These steps can be generated by the compiler in simple cases, with gradations up to the developer providing implementations for all of these. With this approach, it would be possible to: Have a type where all code generation is left to the compiler Have a type where EncodedType is autogenerated, but the user implements init(from:) (allowing for custom domain validation on decode) or var encoded, or both Have a type where the user supplies EncodedType, Self.init(from:), and var encoded, but the compiler generates EncodedType.init(from:) and EncodedType.encode(into:). This allows the user to control what properties EncodedType has (or control its conformance to one of the CodingRepresentation types) without having to perform the actual encode and decode calls Have a type where the user supplies everything, giving them full control of encoding and decoding (for implementing archive versioning and other needs) While cases 1 and 2 save on boilerplate, types which need to be customized have significantly more boilerplate to write by hand. The following approach, which delineates between keyed encoding (with String keys) and ordered encoding (this is the approach proposed in v1 and v2 of this proposal): protocol PrimitiveCodable { associatedtype Atom: CodingAtom var atomValue: Atom { get } init(atomValue value: Atom) } protocol OrderedCodable { init(from decoder: OrderedDecoder) throws func encode(into encoder: OrderedEncoder) } protocol KeyedCodable { init(from decoder: KeyedDecoder) throws func encode(into encoder: KeyedEncoder) } protocol OrderedEncoder { func encode&lt;Value&gt;(_ value: Value?) where Value: CodingAtom func encode&lt;Value&gt;(_ value: Value?) where Value: PrimitiveCodable func encode&lt;Value&gt;(_ value: Value?) where Value: OrderedCodable func encode&lt;Value&gt;(_ value: Value?) where Value: KeyedCodable func encode&lt;Value&gt;(_ value: Value?) where Value: OrderedCodable &amp; KeyedCodable } protocol OrderedDecoder { var count: Int { get } func decode&lt;Value&gt;(_ type: Value.Type) throws -&gt; Value? where Value: CodingAtom func decode&lt;Value&gt;(_ type: Value.Type) throws -&gt; Value? where Value: PrimitiveCodable func decode&lt;Value&gt;(_ type: Value.Type) throws -&gt; Value? where Value: OrderedCodable func decode&lt;Value&gt;(_ type: Value.Type) throws -&gt; Value? where Value: KeyedCodable func decode&lt;Value&gt;(_ type: Value.Type) throws -&gt; Value? where Value: OrderedCodable &amp; KeyedCodable } protocol KeyedEncoder { func encode&lt;Value&gt;(_ value: Value?, forKey key: String) where Value: CodingPrimitive func encode&lt;Value&gt;(_ value: Value?, forKey key: String) where Value: PrimitiveCodable func encode&lt;Value&gt;(_ value: Value?, forKey key: String) where Value: OrderedCodable func encode&lt;Value&gt;(_ value: Value?, forKey key: String) where Value: KeyedCodable func encode&lt;Value&gt;(_ value: Value?, forKey key: String) where Value: OrderedCodable &amp; KeyedCodable } protocol KeyedDecoder { var allKeys: [String] { get } func hasValue(forKey key: String) -&gt; Bool func decode&lt;Value&gt;(_ type: Value.Type, forKey key: String) throws -&gt; Value? where Value: CodingPrimitive func decode&lt;Value&gt;(_ type: Value.Type, forKey key: String) throws -&gt; Value? where Value: PrimitiveCodable func decode&lt;Value&gt;(_ type: Value.Type, forKey key: String) throws -&gt; Value? where Value: OrderedCodable func decode&lt;Value&gt;(_ type: Value.Type, forKey key: String) throws -&gt; Value? where Value: KeyedCodable func decode&lt;Value&gt;(_ type: Value.Type, forKey key: String) throws -&gt; Value? where Value: OrderedCodable &amp; KeyedCodable } Although this semantically separates between different types of encoding, the multiple protocols can be confusing, and it is not immediately apparent which to adopt and use. This also specifically calls out a difference between string-keyed and non-keyed coding, which is unnecessary. A closure-based version of the current approach which scopes keyed encoders/decoders to call sites via closures: protocol Encoder { func encode(as value: Bool) throws // ... func with&lt;Key&gt;(keys type: Key.Type, _ block: (KeyedEncoder&lt;Key&gt;) throws -&gt; Void) rethrows // ... } internal struct Record : Codable { let id: Int let name: String let timestamp: Double // ... public func encode(into encoder: Encoder) throws { try encoder.with(keys: Keys.self) { keyedEncode in try keyedEncode.encode(id, forKey: .id) try keyedEncode.encode(.dictionary, forKey: .properties, keys: PropertiesKeys.self) { properties in try properties.encode(name, forKey: .name) try properties.encode(timestamp, forKey: .timestamp) } } } } However, this cannot currently be applied to decoding: public init(from decoder: Decoder) throws { // This closure implicitly references self. Since Swift has no // guarantees that this closure will get called exactly once, self must // be fully initialized before this call. // // This would require all instance variables to be vars with default // values. try decoder.with(keys: Keys.self) { keyedDecoder in id = try keyedDecoder.decode(Int.self, forKey: .id) // ... } } Although it is not currently possible to initialize self within a closure in Swift, this may be added in the future as annotations make these guarantees possible. A previous approach similar to the current approach with single value encode calls available directly on Encoder, and a KeyedEncoder type instead of KeyedEncodingContainer: public protocol Encoder { func keyed&lt;Key : CodingKey&gt;(by: Key.Type) throws -&gt; KeyedEncoder&lt;Key&gt; func encode(as: Bool) throws func encode(as: Int) throws func encode(as: Int8) throws func encode(as: Int16) throws func encode(as: Int32) throws // ... } public class KeyedEncoder&lt;Key : CodingKey&gt; { // Identical to KeyedEncodingContainer } Appendix JSONSerialization Friction and Third-Party Solutions (Motivation) The following example usage of JSONSerialization is taken from the README of SwiftyJSON, a third-party library that many developers use to interface with JSON models: if let statusesArray = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [[String: Any]], let user = statusesArray[0][&quot;user&quot;] as? [String: Any], let username = user[&quot;name&quot;] as? String { // Finally we got the username } SwiftyJSON attempts to elide the verbosity of casting by offering the following solution instead: let json = JSON(data: dataFromNetworking) if let userName = json[0][&quot;user&quot;][&quot;name&quot;].string { // Now you got your value } This friction is not necessarily a design flaw in the API, simply a truth of interfacing between JavaScript and JSON’s generally untyped, unstructured contents, and Swift’s strict typing. Some libraries, like SwiftyJSON, do this at the cost of type safety; others, like ObjectMapper and Argo below, maintain type safety by offering archival functionality for JSON types: // Taken from https://github.com/Hearst-DD/ObjectMapper class User: Mappable { var username: String? var age: Int? var weight: Double! var array: [AnyObject]? var dictionary: [String : AnyObject] = [:] var bestFriend: User? // Nested User object var friends: [User]? // Array of Users var birthday: NSDate? required init?(map: Map) { } // Mappable func mapping(map: Map) { username &lt;- map[&quot;username&quot;] age &lt;- map[&quot;age&quot;] weight &lt;- map[&quot;weight&quot;] array &lt;- map[&quot;arr&quot;] dictionary &lt;- map[&quot;dict&quot;] bestFriend &lt;- map[&quot;best_friend&quot;] friends &lt;- map[&quot;friends&quot;] birthday &lt;- (map[&quot;birthday&quot;], DateTransform()) } } struct Temperature: Mappable { var celsius: Double? var fahrenheit: Double? init?(map: Map) { } mutating func mapping(map: Map) { celsius &lt;- map[&quot;celsius&quot;] fahrenheit &lt;- map[&quot;fahrenheit&quot;] } } or the more functional // Taken from https://github.com/thoughtbot/Argo struct User { let id: Int let name: String let email: String? let role: Role let companyName: String let friends: [User] } extension User: Decodable { static func decode(j: JSON) -&gt; Decoded&lt;User&gt; { return curry(User.init) &lt;^&gt; j &lt;| &quot;id&quot; &lt;*&gt; j &lt;| &quot;name&quot; &lt;*&gt; j &lt;|? &quot;email&quot; // Use ? for parsing optional values &lt;*&gt; j &lt;| &quot;role&quot; // Custom types that also conform to Decodable just work &lt;*&gt; j &lt;| [&quot;company&quot;, &quot;name&quot;] // Parse nested objects &lt;*&gt; j &lt;|| &quot;friends&quot; // parse arrays of objects } } // Wherever you receive JSON data: let json: Any? = try? NSJSONSerialization.JSONObjectWithData(data, options: []) if let j: Any = json { let user: User? = decode(j) } There are tradeoffs made here as well. ObjectMapper requires that all of your properties be optional, while Argo relies on a vast collection of custom operators and custom curried initializer functions to do its work. (While not shown in the snippet above, User.init code in reality is effectively implemented as User.init(id)(name)(email)(role)(companyName)(friends).) We would like to provide a solution that skirts neither type safety, nor ease-of-use and -implementation. Unabridged API /// Conformance to `Encodable` indicates that a type can encode itself to an external representation. public protocol Encodable { /// Encodes `self` into the given encoder. /// /// If `self` fails to encode anything, `encoder` will encode an empty keyed container in its place. /// /// - parameter encoder: The encoder to write data to. /// - throws: An error if any values are invalid for `encoder`&#39;s format. func encode(to encoder: Encoder) throws } /// Conformance to `Decodable` indicates that a type can decode itself from an external representation. public protocol Decodable { /// Initializes `self` by decoding from `decoder`. /// /// - parameter decoder: The decoder to read data from. /// - throws: An error if reading from the decoder fails, or if read data is corrupted or otherwise invalid. init(from decoder: Decoder) throws } /// Conformance to `Codable` indicates that a type can convert itself into and out of an external representation. public typealias Codable = Encodable &amp; Decodable /// Conformance to `CodingKey` indicates that a type can be used as a key for encoding and decoding. public protocol CodingKey { /// The string to use in a named collection (e.g. a string-keyed dictionary). var stringValue: String { get } /// Initializes `self` from a string. /// /// - parameter stringValue: The string value of the desired key. /// - returns: An instance of `Self` from the given string, or `nil` if the given string does not correspond to any instance of `Self`. init?(stringValue: String) /// The int to use in an indexed collection (e.g. an int-keyed dictionary). var intValue: Int? { get } /// Initializes `self` from an integer. /// /// - parameter intValue: The integer value of the desired key. /// - returns: An instance of `Self` from the given integer, or `nil` if the given integer does not correspond to any instance of `Self`. init?(intValue: Int) } /// An `Encoder` is a type which can encode values into a native format for external representation. public protocol Encoder { /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// Any contextual information set by the user for encoding. var userInfo: [CodingUserInfoKey : Any] { get } /// Returns an encoding container appropriate for holding multiple values keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - returns: A new keyed encoding container. /// - precondition: May not be called after a prior `self.unkeyedContainer()` call. /// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call. func container&lt;Key : CodingKey&gt;(keyedBy type: Key.Type) -&gt; KeyedEncodingContainer&lt;Key&gt; /// Returns an encoding container appropriate for holding multiple unkeyed values. /// /// - returns: A new empty unkeyed container. /// - precondition: May not be called after a prior `self.container(keyedBy:)` call. /// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call. func unkeyedContainer() -&gt; UnkeyedEncodingContainer /// Returns an encoding container appropriate for holding a single primitive value. /// /// - returns: A new empty single value container. /// - precondition: May not be called after a prior `self.container(keyedBy:)` call. /// - precondition: May not be called after a prior `self.unkeyedContainer()` call. /// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call. func singleValueContainer() -&gt; SingleValueEncodingContainer } /// A `Decoder` is a type which can decode values from a native format into in-memory representations. public protocol Decoder { /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// Any contextual information set by the user for decoding. var userInfo: [CodingUserInfoKey : Any] { get } /// Returns the data stored in `self` as represented in a container keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. func container&lt;Key : CodingKey&gt;(keyedBy type: Key.Type) throws -&gt; KeyedDecodingContainer&lt;Key&gt; /// Returns the data stored in `self` as represented in a container appropriate for holding values with no keys. /// /// - returns: An unkeyed container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. func unkeyedContainer() throws -&gt; UnkeyedDecodingContainer /// Returns the data stored in `self` as represented in a container appropriate for holding a single primitive value. /// /// - returns: A single value container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a single value container. func singleValueContainer() throws -&gt; SingleValueDecodingContainer } /// Conformance to `KeyedEncodingContainerProtocol` indicates that a type provides a view into an `Encoder`&#39;s storage and is used to hold the encoded properties of an `Encodable` type in a keyed manner. /// /// Encoders should provide types conforming to `KeyedEncodingContainerProtocol` for their format. public protocol KeyedEncodingContainerProtocol { associatedtype Key : CodingKey /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// Encodes the given value for the given key. /// /// - parameter value: The value to encode. /// - parameter key: The key to associate the value with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode&lt;T : Encodable&gt;(_ value: T?, forKey key: Key) throws /// Encodes the given value for the given key. /// /// - parameter value: The value to encode. /// - parameter key: The key to associate the value with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode(_ value: Bool?, forKey key: Key) throws mutating func encode(_ value: Int?, forKey key: Key) throws mutating func encode(_ value: Int8?, forKey key: Key) throws mutating func encode(_ value: Int16?, forKey key: Key) throws mutating func encode(_ value: Int32?, forKey key: Key) throws mutating func encode(_ value: Int64?, forKey key: Key) throws mutating func encode(_ value: UInt?, forKey key: Key) throws mutating func encode(_ value: UInt8?, forKey key: Key) throws mutating func encode(_ value: UInt16?, forKey key: Key) throws mutating func encode(_ value: UInt32?, forKey key: Key) throws mutating func encode(_ value: UInt64?, forKey key: Key) throws mutating func encode(_ value: Float?, forKey key: Key) throws mutating func encode(_ value: Double?, forKey key: Key) throws mutating func encode(_ value: String?, forKey key: Key) throws /// Encodes the given object weakly for the given key. /// /// For `Encoder`s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future). /// /// For formats which don&#39;t support this feature, the default implementation encodes the given object unconditionally. /// /// - parameter object: The object to encode. /// - parameter key: The key to associate the object with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encodeWeak&lt;T : AnyObject &amp; Encodable&gt;(_ object: T?, forKey key: Key) throws /// Stores a keyed encoding container for the given key and returns it. /// /// - parameter keyType: The key type to use for the container. /// - parameter key: The key to encode the container for. /// - returns: A new keyed encoding container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy keyType: NestedKey.Type, forKey key: Key) -&gt; KeyedEncodingContainer&lt;NestedKey&gt; /// Stores an unkeyed encoding container for the given key and returns it. /// /// - parameter key: The key to encode the container for. /// - returns: A new unkeyed encoding container. mutating func nestedUnkeyedContainer(forKey key: Key) -&gt; UnkeyedEncodingContainer /// Stores a new nested container for the default `super` key and returns a new `Encoder` instance for encoding `super` into that container. /// /// Equivalent to calling `superEncoder(forKey:)` with `Key(stringValue: &quot;super&quot;, intValue: 0)`. /// /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder() -&gt; Encoder /// Stores a new nested container for the given key and returns a new `Encoder` instance for encoding `super` into that container. /// /// - parameter key: The key to encode `super` for. /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder(forKey key: Key) -&gt; Encoder } /// `KeyedEncodingContainer` is a type-erased box for `KeyedEncodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly. public struct KeyedEncodingContainer&lt;K : CodingKey&gt; : KeyedEncodingContainerProtocol { associatedtype Key = K /// Initializes `self` with the given container. /// /// - parameter container: The container to hold. init&lt;Container : KeyedEncodingContainerProtocol&gt;(_ container: Container) where Container.Key == Key /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// Encodes the given value for the given key. /// /// - parameter value: The value to encode. /// - parameter key: The key to associate the value with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode&lt;T : Encodable&gt;(_ value: T?, forKey key: Key) throws /// Encodes the given value for the given key. /// /// - parameter value: The value to encode. /// - parameter key: The key to associate the value with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode(_ value: Bool?, forKey key: Key) throws mutating func encode(_ value: Int?, forKey key: Key) throws mutating func encode(_ value: Int8?, forKey key: Key) throws mutating func encode(_ value: Int16?, forKey key: Key) throws mutating func encode(_ value: Int32?, forKey key: Key) throws mutating func encode(_ value: Int64?, forKey key: Key) throws mutating func encode(_ value: UInt?, forKey key: Key) throws mutating func encode(_ value: UInt8?, forKey key: Key) throws mutating func encode(_ value: UInt16?, forKey key: Key) throws mutating func encode(_ value: UInt32?, forKey key: Key) throws mutating func encode(_ value: UInt64?, forKey key: Key) throws mutating func encode(_ value: Float?, forKey key: Key) throws mutating func encode(_ value: Double?, forKey key: Key) throws mutating func encode(_ value: String?, forKey key: Key) throws /// Encodes the given object weakly for the given key. /// /// For `Encoder`s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future). /// /// For formats which don&#39;t support this feature, the default implementation encodes the given object unconditionally. /// /// - parameter object: The object to encode. /// - parameter key: The key to associate the object with. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encodeWeak&lt;T : AnyObject &amp; Encodable&gt;(_ object: T?, forKey key: Key) throws /// Stores a keyed encoding container for the given key and returns it. /// /// - parameter keyType: The key type to use for the container. /// - parameter key: The key to encode the container for. /// - returns: A new keyed encoding container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy keyType: NestedKey.Type, forKey key: Key) -&gt; KeyedEncodingContainer&lt;NestedKey&gt; /// Stores an unkeyed encoding container for the given key and returns it. /// /// - parameter key: The key to encode the container for. /// - returns: A new unkeyed encoding container. mutating func nestedUnkeyedContainer(forKey key: Key) -&gt; UnkeyedEncodingContainer /// Stores a new nested container for the default `super` key and returns a new `Encoder` instance for encoding `super` into that container. /// /// Equivalent to calling `superEncoder(forKey:)` with `Key(stringValue: &quot;super&quot;, intValue: 0)`. /// /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder() -&gt; Encoder /// Stores a new nested container for the given key and returns a new `Encoder` instance for encoding `super` into that container. /// /// - parameter key: The key to encode `super` for. /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder(forKey key: Key) -&gt; Encoder } /// Conformance to `KeyedDecodingContainerProtocol` indicates that a type provides a view into a `Decoder`&#39;s storage and is used to hold the encoded properties of a `Decodable` type in a keyed manner. /// /// Decoders should provide types conforming to `KeyedDecodingContainerProtocol` for their format. public protocol KeyedDecodingContainerProtocol { associatedtype Key : CodingKey /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// All the keys the `Decoder` has for this container. /// /// Different keyed containers from the same `Decoder` may return different keys here; it is possible to encode with multiple key types which are not convertible to one another. This should report all keys present which are convertible to the requested type. var allKeys: [Key] { get } /// Returns whether the `Decoder` contains a value associated with the given key. /// /// The value associated with the given key may be a null value as appropriate for the data format. /// /// - parameter key: The key to search for. /// - returns: Whether the `Decoder` has an entry for the given key. func contains(_ key: Key) -&gt; Bool /// Decodes a value of the given type for the given key. /// /// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below. /// /// - parameter type: The type of value to decode. /// - parameter key: The key that the decoded value is associated with. /// - returns: A value of the requested type, if present for the given key and convertible to the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key or if the value is null. func decode(_ type: Bool.Type, forKey key: Key) throws -&gt; Bool func decode(_ type: Int.Type, forKey key: Key) throws -&gt; Int func decode(_ type: Int8.Type, forKey key: Key) throws -&gt; Int8 func decode(_ type: Int16.Type, forKey key: Key) throws -&gt; Int16 func decode(_ type: Int32.Type, forKey key: Key) throws -&gt; Int32 func decode(_ type: Int64.Type, forKey key: Key) throws -&gt; Int64 func decode(_ type: UInt.Type, forKey key: Key) throws -&gt; UInt func decode(_ type: UInt8.Type, forKey key: Key) throws -&gt; UInt8 func decode(_ type: UInt16.Type, forKey key: Key) throws -&gt; UInt16 func decode(_ type: UInt32.Type, forKey key: Key) throws -&gt; UInt32 func decode(_ type: UInt64.Type, forKey key: Key) throws -&gt; UInt64 func decode(_ type: Float.Type, forKey key: Key) throws -&gt; Float func decode(_ type: Double.Type, forKey key: Key) throws -&gt; Double func decode(_ type: String.Type, forKey key: Key) throws -&gt; String func decode&lt;T : Decodable&gt;(_ type: T.Type, forKey key: Key) throws -&gt; T /// Decodes a value of the given type for the given key, if present. /// /// This method returns `nil` if the container does not have a value associated with `key`, or if the value is null. The difference between these states can be distinguished with a `contains(_:)` call. /// /// - parameter type: The type of value to decode. /// - parameter key: The key that the decoded value is associated with. /// - returns: A decoded value of the requested type, or `nil` if the `Decoder` does not have an entry associated with the given key, or if the value is a null value. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -&gt; Bool? func decodeIfPresent(_ type: Int.Type, forKey key: Key) throws -&gt; Int? func decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -&gt; Int8? func decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -&gt; Int16? func decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -&gt; Int32? func decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -&gt; Int64? func decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -&gt; UInt? func decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -&gt; UInt8? func decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -&gt; UInt16? func decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -&gt; UInt32? func decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -&gt; UInt64? func decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -&gt; Float? func decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -&gt; Double? func decodeIfPresent(_ type: String.Type, forKey key: Key) throws -&gt; String? func decodeIfPresent&lt;T : Decodable&gt;(_ type: T.Type, forKey key: Key) throws -&gt; T? /// Returns the data stored for the given key as represented in a container keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - parameter key: The key that the nested container is associated with. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy type: NestedKey.Type, forKey key: Key) throws -&gt; KeyedDecodingContainer&lt;NestedKey&gt; /// Returns the data stored for the given key as represented in an unkeyed container. /// /// - parameter key: The key that the nested container is associated with. /// - returns: An unkeyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. func nestedUnkeyedContainer(forKey key: Key) throws -&gt; UnkeyedDecodingContainer /// Returns a `Decoder` instance for decoding `super` from the container associated with the default `super` key. /// /// Equivalent to calling `superDecoder(forKey:)` with `Key(stringValue: &quot;super&quot;, intValue: 0)`. /// /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the default `super` key, or if the stored value is null. func superDecoder() throws -&gt; Decoder /// Returns a `Decoder` instance for decoding `super` from the container associated with the given key. /// /// - parameter key: The key to decode `super` for. /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key, or if the stored value is null. func superDecoder(forKey key: Key) throws -&gt; Decoder } /// `KeyedDecodingContainer` is a type-erased box for `KeyedDecodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly. public struct KeyedDecodingContainer&lt;K : CodingKey&gt; : KeyedDecodingContainerProtocol { associatedtype Key = K /// Initializes `self` with the given container. /// /// - parameter container: The container to hold. init&lt;Container : KeyedDecodingContainerProtocol&gt;(_ container: Container) where Container.Key == Key /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// All the keys the `Decoder` has for this container. /// /// Different keyed containers from the same `Decoder` may return different keys here; it is possible to encode with multiple key types which are not convertible to one another. This should report all keys present which are convertible to the requested type. var allKeys: [Key] { get } /// Returns whether the `Decoder` contains a value associated with the given key. /// /// The value associated with the given key may be a null value as appropriate for the data format. /// /// - parameter key: The key to search for. /// - returns: Whether the `Decoder` has an entry for the given key. func contains(_ key: Key) -&gt; Bool /// Decodes a value of the given type for the given key. /// /// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below. /// /// - parameter type: The type of value to decode. /// - parameter key: The key that the decoded value is associated with. /// - returns: A value of the requested type, if present for the given key and convertible to the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key or if the value is null. func decode(_ type: Bool.Type, forKey key: Key) throws -&gt; Bool func decode(_ type: Int.Type, forKey key: Key) throws -&gt; Int func decode(_ type: Int8.Type, forKey key: Key) throws -&gt; Int8 func decode(_ type: Int16.Type, forKey key: Key) throws -&gt; Int16 func decode(_ type: Int32.Type, forKey key: Key) throws -&gt; Int32 func decode(_ type: Int64.Type, forKey key: Key) throws -&gt; Int64 func decode(_ type: UInt.Type, forKey key: Key) throws -&gt; UInt func decode(_ type: UInt8.Type, forKey key: Key) throws -&gt; UInt8 func decode(_ type: UInt16.Type, forKey key: Key) throws -&gt; UInt16 func decode(_ type: UInt32.Type, forKey key: Key) throws -&gt; UInt32 func decode(_ type: UInt64.Type, forKey key: Key) throws -&gt; UInt64 func decode(_ type: Float.Type, forKey key: Key) throws -&gt; Float func decode(_ type: Double.Type, forKey key: Key) throws -&gt; Double func decode(_ type: String.Type, forKey key: Key) throws -&gt; String func decode&lt;T : Decodable&gt;(_ type: T.Type, forKey key: Key) throws -&gt; T /// Decodes a value of the given type for the given key, if present. /// /// This method returns `nil` if the container does not have a value associated with `key`, or if the value is null. The difference between these states can be distinguished with a `contains(_:)` call. /// /// - parameter type: The type of value to decode. /// - parameter key: The key that the decoded value is associated with. /// - returns: A decoded value of the requested type, or `nil` if the `Decoder` does not have an entry associated with the given key, or if the value is a null value. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -&gt; Bool? func decodeIfPresent(_ type: Int.Type, forKey key: Key) throws -&gt; Int? func decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -&gt; Int8? func decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -&gt; Int16? func decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -&gt; Int32? func decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -&gt; Int64? func decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -&gt; UInt? func decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -&gt; UInt8? func decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -&gt; UInt16? func decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -&gt; UInt32? func decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -&gt; UInt64? func decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -&gt; Float? func decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -&gt; Double? func decodeIfPresent(_ type: String.Type, forKey key: Key) throws -&gt; String? func decodeIfPresent&lt;T : Decodable&gt;(_ type: T.Type, forKey key: Key) throws -&gt; T? /// Returns the data stored for the given key as represented in a container keyed by the given key type. /// /// - parameter type: The key type to use for the container. /// - parameter key: The key that the nested container is associated with. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy type: NestedKey.Type, forKey key: Key) throws -&gt; KeyedDecodingContainer&lt;NestedKey&gt; /// Returns the data stored for the given key as represented in an unkeyed container. /// /// - parameter key: The key that the nested container is associated with. /// - returns: An unkeyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. func nestedUnkeyedContainer(forKey key: Key) throws -&gt; UnkeyedDecodingContainer /// Returns a `Decoder` instance for decoding `super` from the container associated with the default `super` key. /// /// Equivalent to calling `superDecoder(forKey:)` with `Key(stringValue: &quot;super&quot;, intValue: 0)`. /// /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the default `super` key, or if the stored value is null. func superDecoder() throws -&gt; Decoder /// Returns a `Decoder` instance for decoding `super` from the container associated with the given key. /// /// - parameter key: The key to decode `super` for. /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key, or if the stored value is null. func superDecoder(forKey key: Key) throws -&gt; Decoder } /// Conformance to `UnkeyedEncodingContainer` indicates that a type provides a view into an `Encoder`&#39;s storage and is used to hold the encoded properties of an `Encodable` type sequentially, without keys. /// /// Encoders should provide types conforming to `UnkeyedEncodingContainer` for their format. public protocol UnkeyedEncodingContainer { /// The path of coding keys taken to get to this point in encoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// Encodes the given value. /// /// - parameter value: The value to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode&lt;T : Encodable&gt;(_ value: T?) throws /// Encodes the given value. /// /// - parameter value: The value to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encode(_ value: Bool?) throws mutating func encode(_ value: Int?) throws mutating func encode(_ value: Int8?) throws mutating func encode(_ value: Int16?) throws mutating func encode(_ value: Int32?) throws mutating func encode(_ value: Int64?) throws mutating func encode(_ value: UInt?) throws mutating func encode(_ value: UInt8?) throws mutating func encode(_ value: UInt16?) throws mutating func encode(_ value: UInt32?) throws mutating func encode(_ value: UInt64?) throws mutating func encode(_ value: Float?) throws mutating func encode(_ value: Double?) throws mutating func encode(_ value: String?) throws /// Encodes the given object weakly. /// /// For `Encoder`s that implement this functionality, this will only encode the given object if it is encoded unconditionally elsewhere in the payload (either previously or in the future). /// /// For formats which don&#39;t support this feature, the default implementation encodes the given object unconditionally. /// /// - parameter object: The object to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. mutating func encodeWeak&lt;T : AnyObject &amp; Encodable&gt;(_ object: T?) throws /// Encodes the elements of the given sequence. /// /// A default implementation of these is given in an extension. /// /// - parameter sequence: The sequences whose contents to encode. /// - throws: An error if any of the contained values throws an error. mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Bool mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Int mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Int8 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Int16 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Int32 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Int64 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == UInt mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == UInt8 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == UInt16 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == UInt32 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == UInt64 mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Float mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == Double mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element == String mutating func encode&lt;Sequence : Swift.Sequence&gt;(contentsOf sequence: Sequence) throws where Sequence.Iterator.Element : Encodable /// Encodes a nested container keyed by the given type and returns it. /// /// - parameter keyType: The key type to use for the container. /// - returns: A new keyed encoding container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy keyType: NestedKey.Type) -&gt; KeyedEncodingContainer&lt;NestedKey&gt; /// Encodes an unkeyed encoding container and returns it. /// /// - returns: A new unkeyed encoding container. mutating func nestedUnkeyedContainer() -&gt; UnkeyedEncodingContainer /// Encodes a nested container and returns an `Encoder` instance for encoding `super` into that container. /// /// - returns: A new `Encoder` to pass to `super.encode(to:)`. mutating func superEncoder() -&gt; Encoder } /// Conformance to `UnkeyedDecodingContainer` indicates that a type provides a view into a `Decoder`&#39;s storage and is used to hold the encoded properties of a `Decodable` type sequentially, without keys. /// /// Decoders should provide types conforming to `UnkeyedDecodingContainer` for their format. public protocol UnkeyedDecodingContainer { /// The path of coding keys taken to get to this point in decoding. /// A `nil` value indicates an unkeyed container. var codingPath: [CodingKey?] { get } /// Returns the number of elements (if known) contained within this container. var count: Int? { get } /// Returns whether there are no more elements left to be decoded in the container. var isAtEnd: Bool { get } /// Decodes a value of the given type. /// /// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below. /// /// - parameter type: The type of value to decode. /// - returns: A value of the requested type, if present for the given key and convertible to the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. /// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode. mutating func decode(_ type: Bool.Type) throws -&gt; Bool mutating func decode(_ type: Int.Type) throws -&gt; Int mutating func decode(_ type: Int8.Type) throws -&gt; Int8 mutating func decode(_ type: Int16.Type) throws -&gt; Int16 mutating func decode(_ type: Int32.Type) throws -&gt; Int32 mutating func decode(_ type: Int64.Type) throws -&gt; Int64 mutating func decode(_ type: UInt.Type) throws -&gt; UInt mutating func decode(_ type: UInt8.Type) throws -&gt; UInt8 mutating func decode(_ type: UInt16.Type) throws -&gt; UInt16 mutating func decode(_ type: UInt32.Type) throws -&gt; UInt32 mutating func decode(_ type: UInt64.Type) throws -&gt; UInt64 mutating func decode(_ type: Float.Type) throws -&gt; Float mutating func decode(_ type: Double.Type) throws -&gt; Double mutating func decode(_ type: String.Type) throws -&gt; String mutating func decode&lt;T : Decodable&gt;(_ type: T.Type) throws -&gt; T /// Decodes a value of the given type, if present. /// /// This method returns `nil` if the container has no elements left to decode, or if the value is null. The difference between these states can be distinguished by checking `isAtEnd`. /// /// - parameter type: The type of value to decode. /// - returns: A decoded value of the requested type, or `nil` if the value is a null value, or if there are no more elements to decode. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type. mutating func decodeIfPresent(_ type: Bool.Type) throws -&gt; Bool? mutating func decodeIfPresent(_ type: Int.Type) throws -&gt; Int? mutating func decodeIfPresent(_ type: Int8.Type) throws -&gt; Int8? mutating func decodeIfPresent(_ type: Int16.Type) throws -&gt; Int16? mutating func decodeIfPresent(_ type: Int32.Type) throws -&gt; Int32? mutating func decodeIfPresent(_ type: Int64.Type) throws -&gt; Int64? mutating func decodeIfPresent(_ type: UInt.Type) throws -&gt; UInt? mutating func decodeIfPresent(_ type: UInt8.Type) throws -&gt; UInt8? mutating func decodeIfPresent(_ type: UInt16.Type) throws -&gt; UInt16? mutating func decodeIfPresent(_ type: UInt32.Type) throws -&gt; UInt32? mutating func decodeIfPresent(_ type: UInt64.Type) throws -&gt; UInt64? mutating func decodeIfPresent(_ type: Float.Type) throws -&gt; Float? mutating func decodeIfPresent(_ type: Double.Type) throws -&gt; Double? mutating func decodeIfPresent(_ type: String.Type) throws -&gt; String? mutating func decodeIfPresent&lt;T : Decodable&gt;(_ type: T.Type) throws -&gt; T? /// Decodes a nested container keyed by the given type. /// /// - parameter type: The key type to use for the container. /// - returns: A keyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container. mutating func nestedContainer&lt;NestedKey : CodingKey&gt;(keyedBy type: NestedKey.Type) throws -&gt; KeyedDecodingContainer&lt;NestedKey&gt; /// Decodes an unkeyed nested container. /// /// - returns: An unkeyed decoding container view into `self`. /// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container. mutating func nestedUnkeyedContainer() throws -&gt; UnkeyedDecodingContainer /// Decodes a nested container and returns a `Decoder` instance for decoding `super` from that container. /// /// - returns: A new `Decoder` to pass to `super.init(from:)`. /// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode. mutating func superDecoder() throws -&gt; Decoder } /// A `SingleValueEncodingContainer` is a container which can support the storage and direct encoding of a single non-keyed value. public protocol SingleValueEncodingContainer { /// Encodes a single value of the given type. /// /// - parameter value: The value to encode. /// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format. /// - precondition: May not be called after a previous `self.encode(_:)` call. mutating func encode(_ value: Bool) throws mutating func encode(_ value: Int) throws mutating func encode(_ value: Int8) throws mutating func encode(_ value: Int16) throws mutating func encode(_ value: Int32) throws mutating func encode(_ value: Int64) throws mutating func encode(_ value: UInt) throws mutating func encode(_ value: UInt8) throws mutating func encode(_ value: UInt16) throws mutating func encode(_ value: UInt32) throws mutating func encode(_ value: UInt64) throws mutating func encode(_ value: Float) throws mutating func encode(_ value: Double) throws mutating func encode(_ value: String) throws } /// A `SingleValueDecodingContainer` is a container which can support the storage and direct decoding of a single non-keyed value. public protocol SingleValueDecodingContainer { /// Decodes a single value of the given type. /// /// - parameter type: The type to decode as. /// - returns: A value of the requested type. /// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value cannot be converted to the requested type. func decode(_ type: Bool.Type) throws -&gt; Bool func decode(_ type: Int.Type) throws -&gt; Int func decode(_ type: Int8.Type) throws -&gt; Int8 func decode(_ type: Int16.Type) throws -&gt; Int16 func decode(_ type: Int32.Type) throws -&gt; Int32 func decode(_ type: Int64.Type) throws -&gt; Int64 func decode(_ type: UInt.Type) throws -&gt; UInt func decode(_ type: UInt8.Type) throws -&gt; UInt8 func decode(_ type: UInt16.Type) throws -&gt; UInt16 func decode(_ type: UInt32.Type) throws -&gt; UInt32 func decode(_ type: UInt64.Type) throws -&gt; UInt64 func decode(_ type: Float.Type) throws -&gt; Float func decode(_ type: Double.Type) throws -&gt; Double func decode(_ type: String.Type) throws -&gt; String } /// Represents a user-defined key for providing context for encoding and decoding. public struct CodingUserInfoKey : RawRepresentable, Hashable { typealias RawValue = String let rawValue: String init?(rawValue: String) init(_ value: String) } // Repeat for all primitive types... extension Bool : Codable { public init(from decoder: Decoder) throws { self = try decoder.singleValueContainer().decode(Bool.self) } public func encode(to encoder: Encoder) throws { try encoder.singleValueContainer().encode( self) } } // Repeat for all primitive types... public extension RawRepresentable where RawValue == Bool, Self : Codable { public init(from decoder: Decoder) throws { let decoded = try decoder.singleValueContainer().decode(RawValue.self) guard let value = Self(rawValue: decoded) else { throw CocoaError.error(.coderReadCorrupt) } self = value } public func encode(to encoder: Encoder) throws { try encoder.singleValueContainer().encode(self.rawValue) } }",
    "url": "http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html",
    "relUrl": "/docs/2019-08-26-0166-swift-archival-serialization.html"
  },
  "166": {
    "id": "166",
    "title": "SE-0167 Swift Encoders",
    "content": "Swift Encoders Proposal: SE-0167 Authors: Itai Ferber, Michael LeHew, Tony Parker Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift#9005 Introduction As part of the proposal for a Swift archival and serialization API (SE-0166), we are also proposing new API for specific new encoders and decoders, as well as introducing support for new Codable types in NSKeyedArchiver and NSKeyedUnarchiver. This proposal composes the latter two stages laid out in SE-0166. Motivation With the base API discussed in SE-0166, we want to provide new encoders for consumers of this API, as well as provide a consistent story for bridging this new API with our existing NSCoding implementations. We would like to offer a base level of support that users can depend on, and set a pattern that third parties can follow in implementing and extending their own encoders. Proposed solution We will: Add two new encoders and decoders to support encoding Swift value trees in JSON and property list formats Add support for passing Codable Swift values to NSKeyedArchiver and NSKeyedUnarchiver, and add Codable conformance to our Swift value types Detailed design New Encoders and Decoders JSON One of the key motivations for the introduction of this API was to allow safer interaction between Swift values and their JSON representations. For values which are Codable, users can encode to and decode from JSON with JSONEncoder and JSONDecoder: open class JSONEncoder { // MARK: Top-Level Encoding /// Encodes the given top-level value and returns its JSON representation. /// /// - parameter value: The value to encode. /// - returns: A new `Data` value containing the encoded JSON data. /// - throws: `CocoaError.coderInvalidValue` if a non-comforming floating-point value is encountered during archiving, and the encoding strategy is `.throw`. /// - throws: An error if any value throws an error during encoding. open func encode&lt;T : Encodable&gt;(_ value: T) throws -&gt; Data // MARK: Customization /// The formatting of the output JSON data. public enum OutputFormatting { /// Produce JSON compacted by removing whitespace. This is the default formatting. case compact /// Produce human-readable JSON with indented output. case prettyPrinted } /// The strategy to use for encoding `Date` values. public enum DateEncodingStrategy { /// Defer to `Date` for choosing an encoding. This is the default strategy. case deferredToDate /// Encode the `Date` as a UNIX timestamp (as a JSON number). case secondsSince1970 /// Encode the `Date` as UNIX millisecond timestamp (as a JSON number). case millisecondsSince1970 /// Encode the `Date` as an ISO-8601-formatted string (in RFC 3339 format). @available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *) case iso8601 /// Encode the `Date` as a string formatted by the given formatter. case formatted(DateFormatter) /// Encode the `Date` as a custom value encoded by the given closure. /// /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty `.default` container in its place. case custom((_ value: Date, _ encoder: Encoder) throws -&gt; Void) } /// The strategy to use for encoding `Data` values. public enum DataEncodingStrategy { /// Encoded the `Data` as a Base64-encoded string. This is the default strategy. case base64 /// Encode the `Data` as a custom value encoded by the given closure. /// /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty `.default` container in its place. case custom((_ value: Data, _ encoder: Encoder) throws -&gt; Void) } /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN). public enum NonConformingFloatEncodingStrategy { /// Throw upon encountering non-conforming values. This is the default strategy. case `throw` /// Encode the values using the given representation strings. case convertToString(positiveInfinity: String, negativeInfinity: String, nan: String) } /// The output format to produce. Defaults to `.compact`. open var outputFormatting: OutputFormatting /// The strategy to use in encoding dates. Defaults to `.deferredToDate`. open var dateEncodingStrategy: DateEncodingStrategy /// The strategy to use in encoding binary data. Defaults to `.base64`. open var dataEncodingStrategy: DataEncodingStrategy /// The strategy to use in encoding non-conforming numbers. Defaults to `.throw`. open var nonConformingFloatEncodingStrategy: NonConformingFloatEncodingStrategy /// Contextual information to expose during encoding. open var userInfo: [CodingUserInfoKey : Any] } open class JSONDecoder { // MARK: Top-Level Decoding /// Decodes a top-level value of the given type from the given JSON representation. /// /// - parameter type: The type of the value to decode. /// - parameter data: The data to decode from. /// - returns: A value of the requested type. /// - throws: `CocoaError.coderReadCorrupt` if values requested from the payload are corrupted, or if the given data is not valid JSON. /// - throws: An error if any value throws an error during decoding. open func decode&lt;T : Decodable&gt;(_ type: T.Type, from data: Data) throws -&gt; Value // MARK: Customization /// The strategy to use for decoding `Date` values. public enum DateDecodingStrategy { /// Defer to `Date` for decoding. This is the default strategy. case deferredToDate /// Decode the `Date` as a UNIX timestamp from a JSON number. case secondsSince1970 /// Decode the `Date` as UNIX millisecond timestamp from a JSON number. case millisecondsSince1970 /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format). @available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *) case iso8601 /// Decode the `Date` as a string parsed by the given formatter. case formatted(DateFormatter) /// Decode the `Date` as a custom value decoded by the given closure. case custom((_ decoder: Decoder) throws -&gt; Date) } /// The strategy to use for decoding `Data` values. public enum DataDecodingStrategy { /// Decode the `Data` from a Base64-encoded string. This is the default strategy. case base64 /// Decode the `Data` as a custom value decoded by the given closure. case custom((_ decoder: Decoder) throws -&gt; Data) } /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN). public enum NonConformingFloatDecodingStrategy { /// Throw upon encountering non-conforming values. This is the default strategy. case `throw` /// Decode the values from the given representation strings. case convertFromString(positiveInfinity: String, negativeInfinity: String, nan: String) } /// The strategy to use in decoding dates. Defaults to `.deferredToDate`. open var dateDecodingStrategy: DateDecodingStrategy /// The strategy to use in decoding binary data. Defaults to `.base64`. open var dataDecodingStrategy: DataDecodingStrategy /// The strategy to use in decoding non-conforming numbers. Defaults to `.throw`. open var nonConformingFloatDecodingStrategy: NonConformingFloatDecodingStrategy /// Contextual information to expose during decoding. open var userInfo: [CodingUserInfoKey : Any] } Usage: var encoder = JSONEncoder() encoder.dateEncodingStrategy = .iso8601 encoder.dataEncodingStrategy = .custom(myBase85Encoder) // Since JSON does not natively allow for infinite or NaN values, we can customize strategies for encoding these non-conforming values. encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: &quot;INF&quot;, negativeInfinity: &quot;-INF&quot;, nan: &quot;NaN&quot;) // MyValue conforms to Codable let topLevel = MyValue(...) let payload: Data do { payload = try encoder.encode(topLevel) } catch { // Some value threw while encoding. } // ... var decoder = JSONDecoder() decoder.dateDecodingStrategy = .iso8601 decoder.dataDecodingStrategy = .custom(myBase85Decoder) // Look for and match these values when decoding `Double`s or `Float`s. decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: &quot;INF&quot;, negativeInfinity: &quot;-INF&quot;, nan: &quot;NaN&quot;) let topLevel: MyValue do { topLevel = try decoder.decode(MyValue.self, from: payload) } catch { // Data was corrupted, or some value threw while decoding. } It should be noted here that JSONEncoder and JSONDecoder do not themselves conform to Encoder and Decoder; instead, they contain private nested types which do conform to Encoder and Decoder, which are passed to values’ encode(to:) and init(from:). This is because JSONEncoder and JSONDecoder must present a different top-level API than they would at intermediate levels. Property List We also intend to support the property list format, with PropertyListEncoder and PropertyListDecoder: open class PropertyListEncoder { // MARK: Top-Level Encoding /// Encodes the given top-level value and returns its property list representation. /// /// - parameter value: The value to encode. /// - returns: A new `Data` value containing the encoded property list data. /// - throws: An error if any value throws an error during encoding. open func encode&lt;T : Encodable&gt;(_ value: T) throws -&gt; Data // MARK: Customization /// The output format to write the property list data in. Defaults to `.binary`. open var outputFormat: PropertyListSerialization.PropertyListFormat /// Contextual information to expose during encoding. open var userInfo: [CodingUserInfoKey : Any] } open class PropertyListDecoder { // MARK: Top-Level Decoding /// Decodes a top-level value of the given type from the given property list representation. /// /// - parameter type: The type of the value to decode. /// - parameter data: The data to decode from. /// - returns: A value of the requested type. /// - throws: `CocoaError.coderReadCorrupt` if values requested from the payload are corrupted, or if the given data is not a valid property list. /// - throws: An error if any value throws an error during decoding. open func decode&lt;T : Decodable&gt;(_ type: T.Type, from data: Data) throws -&gt; Value /// Decodes a top-level value of the given type from the given property list representation. /// /// - parameter type: The type of the value to decode. /// - parameter data: The data to decode from. /// - parameter format: The parsed property list format. /// - returns: A value of the requested type along with the detected format of the property list. /// - throws: `CocoaError.coderReadCorrupt` if values requested from the payload are corrupted, or if the given data is not a valid property list. /// - throws: An error if any value throws an error during decoding. open func decode&lt;T : Decodable&gt;(_ type: Value.Type, from data: Data, format: inout PropertyListSerialization.PropertyListFormat) throws -&gt; Value // MARK: Customization /// Contextual information to expose during decoding. open var userInfo: [CodingUserInfoKey : Any] } Usage: let encoder = PropertyListEncoder() let topLevel = MyValue(...) let payload: Data do { payload = try encoder.encode(topLevel) } catch { // Some value threw while encoding. } // ... let decoder = PropertyListDecoder() let topLevel: MyValue do { topLevel = try decoder.decode(MyValue.self, from: payload) } catch { // Data was corrupted, or some value threw while decoding. } Like with JSON, PropertyListEncoder and PropertyListDecoder also provide private nested types which conform to Encoder and Decoder for performing the archival. Foundation-Provided Errors Along with providing the above encoders and decoders, we would like to promote the use of a common set of error codes and messages across all new encoders and decoders. A common vocabulary of expected errors allows end-users to write code agnostic about the specific encoder/decoder implementation they are working with, whether first-party or third-party: extension CocoaError.Code { /// Thrown when a value incompatible with the output format is encoded. public static var coderInvalidValue: CocoaError.Code /// Thrown when a value of a given type is requested but the encountered value is of an incompatible type. public static var coderTypeMismatch: CocoaError.Code /// Thrown when read data is corrupted or otherwise invalid for the format. This value already exists today. public static var coderReadCorrupt: CocoaError.Code /// Thrown when a requested key or value is unexpectedly null or missing. This value already exists today. public static var coderValueNotFound: CocoaError.Code } // These reexpose the values above. extension CocoaError { public static var coderInvalidValue: CocoaError.Code public static var coderTypeMismatch: CocoaError.Code } The localized description strings associated with the two new error codes are: .coderInvalidValue: “The data is not valid for encoding in this format.” .coderTypeMismatch: “The data couldn’t be read because it isn’t in the correct format.” (Precedent from NSCoderReadCorruptError.) All of these errors will include the coding key path that led to the failure in the error’s userInfo dictionary under NSCodingPathErrorKey, along with a non-localized, developer-facing failure reason under NSDebugDescriptionErrorKey. NSKeyedArchiver &amp; NSKeyedUnarchiver Changes Although our primary objectives for this new API revolve around Swift, we would like to make it easy for current consumers to make the transition to Codable where appropriate. As part of this, we would like to bridge compatibility between new Codable types (or newly-Codable-adopting types) and existing NSCoding types. To do this, we want to introduce changes to NSKeyedArchiver and NSKeyedUnarchiver in Swift that allow archival of Codable types intermixed with NSCoding types: // These are provided in the Swift overlay, and included in swift-corelibs-foundation. extension NSKeyedArchiver { public func encodeCodable(_ codable: Encodable?, forKey key: String) { ... } } extension NSKeyedUnarchiver { public func decodeCodable&lt;T : Decodable&gt;(_ type: T.Type, forKey key: String) -&gt; T? { ... } } NOTE: Since these changes are being made in extensions in the Swift overlay, it is not yet possible for these methods to be overridden. These can therefore not be added to NSCoder, since NSKeyedArchiver and NSKeyedUnarchiver would not be able to provide concrete implementations. In order to call these methods, it is necessary to downcast from an NSCoder to NSKeyedArchiver/NSKeyedUnarchiver directly. Since subclasses of NSKeyedArchiver and NSKeyedUnarchiver in Swift will inherit these implementations without being able to override them (which is wrong), we will NSRequiresConcreteImplementation() dynamically in subclasses. The addition of these methods allows the introduction of Codable types into existing NSCoding structures, allowing for a transition to Codable types where appropriate. Refining encode(_:forKey:) Along with these extensions, we would like to refine the import of -[NSCoder encodeObject:forKey:], which is currently imported into Swift as encode(_: Any?, forKey: String). This method currently accepts Objective-C and Swift objects conforming to NSCoding (non-conforming objects produce a runtime error), as well as bridgeable Swift types (Data, String, Array, etc.); we would like to extend it to support new Swift Codable types, which would otherwise produce a runtime error upon call. -[NSCoder encodeObject:forKey:] will be given a new Swift name of encodeObject(_:forKey:), and we will provide a replacement encode(_: Any?, forKey: String) in the overlay which will funnel out to either encodeCodable(_:forKey:) or encodeObject(_:forKey:) as appropriate. This should maintain source compatibility for end users already calling encode(_:forKey:), as well as behavior compatibility for subclassers of NSCoder and NSKeyedArchiver who may be providing their own encode(_:forKey:). Semantics of Codable Types in Archives There are a few things to note about including Codable values in NSKeyedArchiver archives: Bridgeable Foundation types will always bridge before encoding. This is to facilitate writing Foundation types in a compatible format from both Objective-C and Swift On decode, these types will decode either as their Objective-C or Swift version, depending on user need (decodeObject(forKey:) will decode as an Objective-C object; decodeCodable(_:forKey:) as a Swift value) User types, which are not bridgeable, do not write out a $class and can only be decoded in Swift. In the future, we may add API to allow Swift types to provide an Objective-C class to decode as, effectively allowing for user bridging across archival Foundation Types Adopting Codable The following Foundation Swift types will be adopting Codable, and will encode as their bridged types when encoded through NSKeyedArchiver, as mentioned above: AffineTransform Calendar CharacterSet Date DateComponents DateInterval Decimal IndexPath IndexSet Locale Measurement Notification PersonNameComponents TimeZone URL URLComponents URLRequest UUID Along with these, the Array, Dictionary, and Set types will gain Codable conformance (as part of the Conditional Conformance feature), and encode through NSKeyedArchiver as NSArray, NSDictionary, and NSSet respectively. Source compatibility The majority of this proposal is additive. The changes to NSKeyedArchiver are intended to be non-source-breaking changes, and non-behavior-breaking changes for subclasses in Objective-C and Swift. Effect on ABI stability The addition of this API will not be an ABI-breaking change. However, this will add limitations for changes in future versions of Swift, as parts of the API will have to remain unchanged between versions of Swift (barring some additions, discussed below). Effect on API resilience Much like new API added to the standard library, once added, some changes to this API will be ABI- and source-breaking changes. Changes to the new encoder and decoder classes provided above will be restricted as described in the library evolution document in the Swift repository; in particular, the removal of methods or nested types or changes to argument types will break client behavior. Additionally, additions to provided options enums will be a source-breaking change for users performing an exhaustive switch over their cases; removal of cases will be ABI-breaking.",
    "url": "http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html",
    "relUrl": "/docs/2019-08-26-0167-swift-encoders.html"
  },
  "167": {
    "id": "167",
    "title": "SE-0168 Multi-Line String Literals",
    "content": "Multi-Line String Literals Proposal: SE-0168 Authors: John Holdsworth, Brent Royal-Gordon, Tyler Cloutier Review Manager: Joe Groff Status: Implemented (Swift 4) Implementation: apple/swift#8813 Decision Notes: Rationale Bugs: SR-170, SR-4701, SR-4708, SR-4874 Introduction This proposal introduces multi-line string literals to Swift source code. This has been discussed a few times on swift-evolution most recently putting forward a number of different syntaxes that could achieve this goal each of which has their own use case and constituency for discussion. Swift-evolution thread Motivation Multi-line String literals are a common programming-language feature that is, to date, still missing in Swift. Whether generating XML/JSON messages or building usage messages in Swift scripts, providing string literals that extend over multiple lines offers a simple way to represent text without having to manually break lines using string concatenation. Concatenation is ungainly and may result in slow compilation. Proposed solution After consideration this proposal puts forward a single simple syntax for inclusion: &quot;&quot;&quot;long strings&quot;&quot;&quot;. This has the advantage that it is well supported by the syntax highlighters on GitHub and existing editors and is a relatively minor change to the Swift Lexer. Interpolation would work as before. Long strings Long strings are strings delimited by &quot;&quot;&quot;triple quotes&quot;&quot;&quot; that can contain newlines and individual &quot; characters without the need to escape them. assert( xml == &quot;&quot;&quot; &lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt; (author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; &quot;&quot;&quot; ) To allow free formatting of the literal an indentation stripping operation is applied whereby any whitespace characters in front of the closing delimiter are removed from each of the lines in the literal. As part of this process any initial linefeed is also removed. This allows the developer to paste literal content directly into the string without modification. Some concern has been expressed about could introduce confusion if the prefixing indentation of each line does not contain the same whitespace characters, though this can be checked for by a compiler warning. Detailed design These changes are envisaged to be mostly confined to the Swift tokeniser: lib/Parse/Lexer.cpp. The new string literals would be presented to the grammar as simply being string literals. This has been explored in a PR for a prototype toolchain and seems to be a robust approach. Other details are explored in the prototype such as escaping the newline in literals resulting in it not being included in the final literal. Impact on existing code As this proposal is additive it does not affect existing code. Alternatives considered Two other alternative syntaxes were discussed in the swift-evolution thread. It became apparent that each syntax had its own, at times, non-overlapping constituency of supporters. Continuation quotes The basic idea of continuation quotes is straightforward. If a quoted string literal is not closed by “ before the end of the line and the first non-whitespace character on the next line is “ it is taken to be a continuation of the previous literal. let xml = &quot;&lt;?xml version= &quot;1.0 &quot;?&gt; &quot;&lt;catalog&gt; &quot; &lt;book id= &quot;bk101 &quot; empty= &quot; &quot;&gt; &quot; &lt;author&gt; (author)&lt;/author&gt; &quot; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &quot; &lt;genre&gt;Computer&lt;/genre&gt; &quot; &lt;price&gt;44.95&lt;/price&gt; &quot; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot; &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt; &quot; &lt;/book&gt; &quot;&lt;/catalog&gt; &quot;&quot; The advantage of this format is it gives precise control of exactly what is included in the literal. It also allows code to be formatted in an aesthetically pleasing manner. Its main disadvantage is that some external editors will not be familiar with the format and will be unable to correctly syntax highlight literals. Heredoc Taking a precedent from other languages, a syntax such as the following could be used to introduce literals into a codebase. assert( xml == &lt;&lt;&quot;XML&quot; ) &lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt; (author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML The same indentation stripping rules would be applied as for long strings. This syntax has the advantage of being able to paste content in directly and the additional advantage that the literal is separated from the line of code using it, increasing clarity. Its main disadvantage is a more practical one: it is a more major departure for the compiler in that tokens in the AST are no longer in source file order. Testing has, however, shown the toolchain to be surprisingly robust in dealing with this change once a few assertions were removed.",
    "url": "http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html",
    "relUrl": "/docs/2019-08-26-0168-multi-line-string-literals.html"
  },
  "168": {
    "id": "168",
    "title": "SE-0169 Improve Interaction Between `private` Declarations and Extensions",
    "content": "Improve Interaction Between private Declarations and Extensions Proposal: SE-0169 Authors: David Hart, Chris Lattner Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Previous Revision: 1 Bug: SR-4616 Introduction In Swift 3, a declaration marked private may be accessed by anything nested in the scope of the private declaration. For example, a private property or method defined on a struct may be accessed by other methods defined within that struct. This model was introduced by SE-0025 and with nearly a year of experience using this model, it has worked well in almost all cases. The primary case it falls down is when the implementation of a type is split into a base definition and a set of extensions. Because of the SE-0025 model, extensions to the type are not allowed to access private members defined on that type. This proposal recommends extending private access control so that members defined in an extension of a type have the same access as members defined on the type itself, so long as the type and extension are in the same source file. We expect this to dramatically reduce the number of uses of fileprivate in practice. Motivation SE-0025 defined the private access control level to be used for scoped access, and introduced fileprivate for the case when a declaration needs to be visible across declarations, but not only within a file. The goal of the proposal was for fileprivate to be used rarely. However, that goal of the proposal has not been realized: Swift encourages developers to use extensions as a logical grouping mechanism and requires them for conditional conformances. Because of this, the SE-0025 design makes fileprivate more necessary than expected, and reduces the appeal of using extensions. The prevalence of fileprivate in practice has caused mixed reactions from Swift developers, culminating in proposal SE-0159 which suggested reverting the access control model to Swift 2’s design. That proposal was rejected for two reasons: scoped access is something that many developers use and value, and because it was seen as too large of a change given Swift 4’s source compatibility goals. In contrast to SE-0159, this proposal is an extremely narrow change (which is almost completely additive) to the SE-0025 model, which embraces the extension-oriented design of Swift. The authors believe that this change will not preclude introduction of submodules in the future. Detailed Design For purposes of access control, extensions to any given type T within a file are considered to be a single access control scope, and if T is defined within the file, the extensions use the same access control scope as T. This has two ramifications: Declarations in one of these extensions get access to the private members of the type. If the declaration in the extension itself is defined as private, then they are accessible to declarations in the type, and other extensions of that type (in the same file). Here is a simple code example that demonstrates this: struct S { private var p: Int func f() { use(g()) // ok, g() is accessible within S } } extension S { private func g() { use(p) // ok, g() has access to p, since it is in an extension on S. } } extension S { func h() { use(g()) // Ok, h() has access to g() since it defined in the access control scope for S. } } Please note: This visibility does not extend to subclasses of a class in the same file, it only affects extensions of the type itself. Constrained extensions are extensions, so this visibility does extend to them as well. For example, the body of extension Optional where Wrapped == String { } would have access to private members of Optional, assuming the extension is defined in the same file as Optional. This proposal does change the behavior of extensions that are not in the same file as the type - those extensions are merged together into a single access control scope: // FileA.swift struct A { private var aMember : Int } // FileB.swift extension A { private func foo() { bar() // ok, foo() does have access to bar() } } extension A { private func bar() { aMember = 42 // not ok, private members may not be accessed outside their file. } } This proposal does not change access control behavior for types nested within each other. As in Swift 3, inner types have access to the private members of outer types, but outer types cannot refer to private members of inner types. For example: struct Outer { private var outerValue = 42 struct Inner { private var innerValue = 57 func innerTest(_ o: Outer) { print(o.outerValue) // still ok. } } func test(_ i: Inner) { print(i.innerValue) // still an error } } Source Compatibility In Swift 3 compatibility mode, the compiler will continue to treat private as before. In Swift 4 mode, the compiler will modify the semantics of private to follow the rules of this proposal. No migration will be necessary as this proposal merely broadens the visibility of private. Cases where a type had private declarations with the same signature in the same type/extension but in different scopes will produce a compiler error in Swift 4. For example, the following piece of code compiles in Swift 3 compatibilty mode but generates a Invalid redeclaration of &#39;bar()&#39; error in Swift 4 mode: struct Foo { private func bar() {} } extension Foo { private func bar() {} } Alternatives Considered Access control has been hotly debated on the swift-evolution mailing list, both in the Swift 3 cycle (leading to SE-0025 and most recently in Swift 4 which led to SE-0159. There have been too many proposals to summarize here, including the introduction of a scoped keyword. The core team has made it clear that most of those proposals are not in scope for discussion in Swift 4 (or any later release), given the significant impact on source compatibility. This is the primary reason for this narrow scope proposal. A future direction that may be interesting to consider and debate (as a separate proposal, potentially after Swift 4) is whether extensions within the same file as a type should be treated as parts of the extended type in general. This would allow idioms like this, for example: struct Foo { var x: Int } // ... extension Foo { var y: Int } However, this is specifically not part of this proposal at this time. It is merely a possible avenue to consider in the future. Another alternative considered is to allow private members of a type to be accessible to extensions outside of the current source file: either within the current module, or anywhere in the program. This is rejected because it violates an important principle of our access control system: that private is narrower than fileprivate. Allowing private to be narrower in some ways, but broader in other ways (allow access across files) would lead to a more confusing and fractured model.",
    "url": "http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html",
    "relUrl": "/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html"
  },
  "169": {
    "id": "169",
    "title": "SE-0170 NSNumber bridging and Numeric types",
    "content": "NSNumber bridging and Numeric types Proposal: SE-0170 Author: Philippe Hausler Review Manager: Ben Cohen Status: Implemented (Swift 4) Decision Notes: Rationale Revision history v1 Initial version Introduction NSNumber has been a strange duck in the Swift world especially when it has come to bridging and interacting with other protocols. An attempt was made to make a type preserving NSNumber subclass; however that defeated numerous optimizations in Foundation and also caused some rather unfortunate disparity between where and how the NSNumbers were created. Motivation Swift should have a consistent experience across all the SDK. No matter if you are using Objective-C in your app/framework in addition to Swift or not the behavior should be easily understood and consistent. Furthermore performance optimizations like tagged pointers or other fast-path accessors in Objective-C or CoreFoundation based code should just work no matter the context in which a NSNumber is created. There are some really spooky behaviors as of current; here are a few extreme examples - Example 1 let n = NSNumber(value: Int64.max) if n is Int16 { // this is true as of the current build of Swift! } Example 2 let n = NSNumber(value: Int64.max) if n is Int16 { // this is true as of the current build of Swift! } else if n is Int64 { // Ideally we should get to here } Example 3 let n = NSNumber(value: Int64(42)) if let value = n as? UInt8 { // This makes sense if NSNumber is viewed as an abstract numeric box } But there are some subtle failures that occur as well - Example 4 // Serialization behind the scenes causes numeric failures if we were 100% strict open class MyDocument : NSDocument { var myStateValue: Int16 = 0 public static func restoreWindow(withIdentifier identifier: String, state: NSCoder, completionHandler: @escaping (NSWindow?, Error?) -&gt; Swift.Void) { myStateValue = state.decodeObject(forKey: &quot;myStateValue&quot;) as! Int16 // this is expected to pass since we encoded a Int16 value and we expect at least to get an Int16 out. } open func encodeRestorableState(with coder: NSCoder) { coder.encodeObject(myStateValue, forKey: &quot;myStateValue&quot;) } } Example 5 // lets say you have a remote server you have no control over except getting JSON requests back // the format specifies that the response will have a timestamp in a value that is the integral number of milliseconds since 1970 // e.g. { &quot;timestamp&quot; : 1487980252519 } is valid JSON, but a recent server upgrade changes it to be &quot;timestamp&quot; : 1487980252519.0 } which is also valid JSON // initially code could be written validly as let payload = JSONSerialization.jsonObject(with: response, options: []) as? [String : Int] // but a remote server change could break things if we were strict and requires this code change let payload = JSONSerialization.jsonObject(with: response, options: []) as? [String : Double] // But the responses are still integral! Example 6 let itDoesntDoWhatYouThinkItDoes = Int8(NSNumber(value: Int64.max)) // counterintuitively (as legacy baggage of C) this is Int8(-1) All of these examples boil down to the simple question: what does as? mean for NSNumber. It is worth noting that is should follow the same logic as as?. Proposed solution as? for NSNumber should mean “Can I safely express the value stored in this opaque box called a NSNumber as the value I want?”. Solution Example 1 // The trivial case of &quot;what you put in the box is what you get out&quot; let n = NSNumber(value: UInt32(543)) let v = n as? UInt32 // v is UInt32(543) Solution Example 2 // The trivial case of the other way around from Solution Example 1 let v: UInt32 = 543 let n = v as NSNumber // n == NSNumber(value: 543) Solution Example 3 // Safe &quot;casting&quot; let n = NSNumber(value: UInt32(543)) let v = n as? Int16 // v is Int16(543) In this case n is storing a value of 543 obtained from a UInt32. Asking the question “Can I safely express the value stored in this opaque box called a NSNumber as the value I want?”; we have 543, can it be expressed safely as a Int16? Absolutely! Solution Example 4 // Failures when casting that lose the value stored let n = NSNumber(value: UInt32(543)) let v = n as? Int8 // v is nil In this case n is storing a value of 543 obtained from a UInt32 but when asked can it be safely represented as the requested type Int8 the answer is; of course not. Solution Example 5 let v = Int8(NSNumber(value: Int64.max)) // v is nil because Int64.max cannot be safely expressed as Int8 Detailed design The following methods will be changed in swift 4 because the behavior is truncating, not an assertion of exactly: extension Int8 { init(_ number: NSNumber) } extension UInt8 { init(_ number: NSNumber) } extension Int16 { init(_ number: NSNumber) } extension UInt16 { init(_ number: NSNumber) } extension Int32 { init(_ number: NSNumber) } extension UInt32 { init(_ number: NSNumber) } extension Int64 { init(_ number: NSNumber) } extension UInt64 { init(_ number: NSNumber) } extension Float { init(_ number: NSNumber) } extension Double { init(_ number: NSNumber) } extension CGFloat { init(_ number: NSNumber) } extension Bool { init(_ number: NSNumber) } extension Int { init(_ number: NSNumber) } extension UInt { init(_ number: NSNumber) } To the optional variants as such: extension Int8 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension UInt8 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Int16 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension UInt16 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Int32 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension UInt32 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Int64 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension UInt64 { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Float { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Double { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension CGFloat { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Bool { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension Int { init?(exactly number: NSNumber) init(truncating number: NSNumber) } extension UInt { init?(exactly number: NSNumber) init(truncating number: NSNumber) } The behavior of exactly will be an exact bitwise representation for stored integer types such that any initialization must be able to express the initialized type with the stored representation in the NSNumber or it will fail and return nil. The truncating versions on the other hand will be similar to fetching the value via that type accessor. e.g. Int8(truncating: myNSNumber) will be tantamount to calling int8Value on said number Impact on existing code The one big repercussion is that the bridging methods cannot be versioned for swift 3 and swift 4 availability so we must pick one implementation or another for the bridging. Swift 4 modules or frameworks must bridge in the same manner as Swift 3 since the implementation is the behavioral difference, not the calling module. There are a number of places in frameworks where NSNumbers are used to provide results. For example CoreData queries can potentially yield NSNumbers, Coding and Archival use NSNumbers for storage under the hood, Serialization uses NSNumbers for numeric representations (there are many more that apply these are just a few that can easily lead to corruption or malformed data when users accidentally truncate via the current bridging behavior). Overall I am of the belief that any case that this would break existing code it was potentially incorrect behavior on the part of the developer using the bridge of NSNumber and if it is not the facilities of NSNumber are still present (you can still call NSNumber(value: Int64.max).int8Value to get -1 if that is what you really mean. That way is unambiguous and distinctly clear for maintainable code and reduces the overall magic/spooky behavior. Source compatibility This does change the result of cast via as? so it does not change source compatibility but it does change runtime compatibility. In the end, round tripped NSNumbers into collections that bridge across are relatively rare and it is much more common to get NSNumbers out of APIs. The original as? cast required developers to be aware of potential failure by syntax, the change here is a safer way of expressing values for all numbers in one uniform methodology that is both more performant as well as more correct in more common cases. In short the runtime effect is a step in the right direction. Effect on ABI stability This change should have no direct impact upon ABI. Effect on API resilience The initializers that had no decoration are marked as deprecated so the remaining portion is considered additive only. Considerations for Objective-C platforms This brings in line the concepts of the existing Objective-C APIs to the intent that was originally used for NSNumber and the usage. Bridging NSNumbers (for platforms that support it and cases that are supported) should always respect the concept of tagged pointers. In just property list cases alone it is approximately a 2% performance loss to avoid the tagged pointer cases; just by using swift there should be little to no performance penalty for sending these types either direction on the bridge in comparison to the equivalent Objective-C implementations. Considerations for Linux platforms We do not have bridging on Linux so the as? cast is less important; but if it were to have bridging this would be the desired functionality. Alternatives considered We have explored making NSNumbers created in Swift to be strongly type preserving. This unfortunately results in a severe inconsistency between APIs implemented in Swift and those implemented in Objective-C. Instead of having a disparate behavior depending on the spooky action determined in an opaque framework it is better to have a simple story no matter what language the NSNumber was made in and no matter what facility it was created with. To do so we have only one real way of representing numeric types; meet halfway in the middle between erasing all type information and requiring a pedantic matching of type information and always allow a safe expression of the numeric value. Using initializers for Integer or FloatingPoint protocol adopters on NSNumber was considered but was determined out of scope for this change and may be considered separately from the behavior of NSNumber bridging.",
    "url": "http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html",
    "relUrl": "/docs/2019-08-26-0170-nsnumber_bridge.html"
  },
  "170": {
    "id": "170",
    "title": "SE-0171 Reduce with `inout`",
    "content": "Reduce with inout Proposal: SE-0171 Author: Chris Eidhof Review Manager: Ben Cohen Status: Implemented (Swift 4) Decision Notes: Rationale Introduction A new variant of reduce should be added to the standard library. Instead of taking a combine function that is of type (A, Iterator.Element) -&gt; A, the full type and implementation of the added reduce will be: extension Sequence { func reduce&lt;A&gt;(into initial: A, _ combine: (inout A, Iterator.Element) -&gt; ()) -&gt; A { var result = initial for element in self { combine(&amp;result, element) } return result } } Swift-evolution thread: Reduce with inout Motivation The current version of reduce needs to make copies of the result type for each element in the sequence. The proposed version can eliminate the need to make copies (when the inout is optimized away). Proposed solution The first benefit of the proposed solution is efficiency. The new version of reduce can be used to write efficient implementations of methods that work on Sequence. For example, consider an implementation of uniq, which filters adjacent equal entries: extension Sequence where Iterator.Element: Equatable { func uniq() -&gt; [Iterator.Element] { return reduce(into: []) { (result: inout [Iterator.Element], element) in if result.last != element { result.append(element) } } } } In the code above, the optimizer will usually optimize the inout array into an UnsafeMutablePointer, or when inlined, into a simple mutable variable. With that optimization, the complexity of the algorithm is O(n). The same algorithm, but implemented using the existing variant of reduce, will be O(n²), because instead of append, it copies the existing array in the expression result + [element]: extension Sequence where Iterator.Element: Equatable { func uniq() -&gt; [Iterator.Element] { return reduce([]) { (result: [Iterator.Element], element) in guard result.last != element else { return result } return result + [element] } } } The second benefit is that the new version of reduce is more natural when dealing with mutating methods. For example, consider a function that computes frequencies in a Sequence: extension Sequence where Iterator.Element: Hashable { func frequencies() -&gt; [Iterator.Element: Int] { return reduce(into: [:]) { (result: inout [Iterator.Element:Int], element) in if let value = result[element] { result[element] = value + 1 } else { result[element] = 1 } } } } Without the inout parameter, we’d first have to make a var copy of the existing result, and have to remember to return that copy instead of the result. (The method above is probably clearer when written with a for-loop, but that’s not the point). Source compatibility This is purely additive, we don’t propose removing the existing reduce. Additionaly, because the first argument will have a label into, it doesn’t add any extra burden to the type checker. Effect on ABI stability N/A Effect on API resilience N/A Alternatives considered We considered removing the existing reduce, but the problem with that is two-fold. First, removing it breaks existing code. Second, it’s useful for algorithms that don’t use mutating methods within combine. We considered overloading reduce, but that would stress the type checker too much. There has been a really active discussion about the naming of the first parameter. Naming it mutating: could deceive people into thinking that the value would get mutated in place. Naming it mutatingCopyOf: is also tricky: even though a copy of the struct gets mutated, copying is always implicit when using structs, and it wouldn’t copy an instance of a class. into: seems the best name so far. Under active discussion: the naming of this method. See the swift-evolution thread.",
    "url": "http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html",
    "relUrl": "/docs/2019-08-26-0171-reduce-with-inout.html"
  },
  "171": {
    "id": "171",
    "title": "SE-0172 One-sided Ranges",
    "content": "One-sided Ranges Proposal: SE-0172 Authors: Ben Cohen, Dave Abrahams, Brent Royal-Gordon Review Manager: Doug Gregor Status: Implemented (Swift 4) Decision Notes: Rationale Introduction This proposal introduces the concept of a “one-sided” range, created via prefix/postfix versions of the existing range operators. It also introduces a new protocol, RangeExpression, to simplify the creation of methods that take different kinds of ranges. Motivation It is common, given an index into a collection, to want a slice up to or from that index versus the start/end. For example (assuming String is once more a Collection): let s = &quot;Hello, World!&quot; let i = s.index(of: &quot;,&quot;)! let greeting = s[s.startIndex..&lt;i] When performing lots of slicing like this, the verbosity of repeating s.startIndex is tiresome to write and harmful to readability. Swift 3’s solution to this is a family of methods: let greeting = s.prefix(upTo: i) let withComma = s.prefix(through: i) let location = s.suffix(from: i) The two very different-looking ways to perform a similar task is jarring. And as methods, the result cannot be used as an l-value. A variant of the one-sided slicing syntax found in Python (i.e. s[i:]) is proposed to resolve this. Proposed solution Introduce a one-sided range syntax, where the “missing” side is inferred to be the start/end: // half-open right-handed range let greeting = s[..&lt;i] // closed right-handed range let withComma = s[...i] // left-handed range (no need for half-open variant) let location = s[i...] Additionally, when the index is a countable type, i... should form a Sequence that counts up from i indefinitely. This is useful in forming variants of Sequence.enumerated() when you either want them non-zero-based i.e. zip(1..., greeting), or want to flip the order i.e. zip(greeting, 0...). This syntax would supercede the existing prefix and suffix operations that take indices, which will be deprecated in a later release. Note that the versions that take distances are not covered by this proposal, and would remain. This will require the introduction of new range types (e.g. PartialRangeThrough). There are already multiple range types (e.g. ClosedRange, CountableHalfOpenRange), which require overloads to allow them to be used wherever a Range can be. To unify these different range types, a new protocol, RangeExpression will be created and all ranges conformed to it. Existing overloads taking concrete types other than Range can then be replaced with a single generic method that takes a RangeExpression, converts it to a Range, and then forward the method on. A generic version of ~= will also be implemented for all range expressions: switch i { case 9001...: print(&quot;It’s over NINE THOUSAAAAAAAND&quot;) default: print(&quot;There&#39;s no way that can be right!&quot;) } The existing concrete overloads that take ranges other than Range will be deprecated in favor of generic ones that take a RangeExpression. Detailed design Add the following to the standard library: (a fuller work-in-progress implementation can be found here: https://github.com/apple/swift/pull/8710) NOTE: The following is subject to change depending on pending compiler features. Methods may actually be on underscored protocols, and then moved once recursive protocols are implemented. Types may be collapsed using conditional conformance. This should not matter from a usage perspective – users are not expected to use these types directly or override any of the behaviors in their own types. Any final implementation will follow the below in spirit if not in practice. public protocol RangeExpression { associatedtype Bound: Comparable /// Returns `self` expressed as a range of indices within `collection`. /// /// -Parameter collection: The collection `self` should be /// relative to. /// /// -Returns: A `Range&lt;Bound&gt;` suitable for slicing `collection`. /// The return value is *not* guaranteed to be inside /// its bounds. Callers should apply the same preconditions /// to the return value as they would to a range provided /// directly by the user. func relative&lt;C: _Indexable&gt;(to collection: C) -&gt; Range&lt;Bound&gt; where C.Index == Bound func contains(_ element: Bound) -&gt; Bool } extension RangeExpression { public static func ~= (pattern: Self, value: Bound) -&gt; Bool } prefix operator ..&lt; public struct PartialRangeUpTo&lt;T: Comparable&gt;: RangeExpression { public init(_ upperBound: T) { self.upperBound = upperBound } public let upperBound: T } extension Comparable { public static prefix func ..&lt;(x: Self) -&gt; PartialRangeUpTo&lt;Self&gt; } prefix operator ... public struct PartialRangeThrough&lt;T: Comparable&gt;: RangeExpression { public init(_ upperBound: T) public let upperBound: T } extension Comparable { public static prefix func ...(x: Self) -&gt; PartialRangeThrough&lt;Self&gt; } postfix operator ... public struct PartialRangeFrom&lt;T: Comparable&gt;: RangeExpression { public init(_ lowerBound: T) public let lowerBound: T } extension Comparable { public static postfix func ...(x: Self) -&gt; PartialRangeFrom&lt;Self&gt; } // The below relies on Conditional Conformance. Pending that feature, // this may require an additional CountablePartialRangeFrom type temporarily. extension PartialRangeFrom: Sequence where Index: _Strideable, Index.Stride : SignedInteger extension Collection { public subscript&lt;R: RangeExpression&gt;(r: R) -&gt; SubSequence where R.Bound == Index { get } } extension MutableCollection { public subscript&lt;R: RangeExpression&gt;(r: R) -&gt; SubSequence where R.Bound == Index { get set } } extension RangeReplaceableColleciton { public mutating func replaceSubrange&lt;C: Collection, R: RangeExpression&gt;( _ subrange: ${Range}&lt;Index&gt;, with newElements: C ) where C.Iterator.Element == Iterator.Element, R.Bound == Index public mutating func removeSubrange&lt;R: RangeExpression&gt;( _ subrange: ${Range}&lt;Index&gt; ) where R.Bound == Index } Additionally, these new ranges will implement appropriate protocols such as CustomStringConvertible. It is important to note that these new methods and range types are extensions only. They are not protocol requirements, as they should not need to be customized for specific collections. They exist only as shorthand to expand out to the full slicing operation. Where PartialRangeFrom is a Sequence, it is left up to the type of Index to control the behavior when the type is incremented past its bounds. In the case of an Int, the iterator will trap when iterating past Int.max. Other types, such as a BigInt that could be incremented indefinitely, would behave differently. The prefix and suffix methods that take an index are currently protocol requirements, but should not be. This proposal will fix that as a side-effect. Source compatibility The new operators/types are purely additive so have no source compatibility consequences. Replacing the overloads taking concrete ranges other than Range with a single generic version is source compatible. prefix and suffix will be deprecated in Swift 4 and later removed. Effect on ABI stability The prefix/suffix methods being deprecated should be eliminated before declaring ABI stability. Effect on API resilience The new operators/types are purely additive so have no resilience consequences. Alternatives considered i... is favored over i..&lt; because the latter is ugly. We have to pick one, two would be redundant and likely to cause confusion over which is the “right” one. Either would be reasonable on pedantic correctness grounds – (i as Int)... includes Int.max consistent with ..., whereas a[i...] is interpreted as a[i..&lt;a.endIndex] consistent with i..&lt;. It might be nice to consider extend this domain-specific language inside the subscript in other ways. For example, to be able to incorporate the index distance versions of prefix, or add distance offsets to the indices used within the subscript. This proposal explicitly avoids proposals in this area. Such ideas would be considerably more complex to implement, and would make a good project for investigation by an interested community member, but would not fit within the timeline for Swift 4.",
    "url": "http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html",
    "relUrl": "/docs/2019-08-26-0172-one-sided-ranges.html"
  },
  "172": {
    "id": "172",
    "title": "SE-0173 Add `MutableCollection.swapAt(_:_:)`",
    "content": "Add MutableCollection.swapAt(_:_:) Proposal: SE-0173 Author: Ben Cohen Review Manager: Ted Kremenek Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift#9119 Introduction As part of the introduction of the Law of Exclusivity, the current swap(_:_:) function must be addressed, as this most common uses of swap directly violate the law. This proposal introduces an alternative: a method on MutableCollection that takes two indices for swapping two elements in the same collection. Motivation The primary purpose of the current swap function is to swap two elements within a mutable collection. It was originally created to support the sort algorithm, which is why it is declared in stdlib/sort.swift.gyb. Here is some typical usage from that file: while hi != lo { swap(&amp;elements[lo], &amp;elements[hi]) Under changes proposed as part of the ownership manifesto, this will no longer be legal Swift: a single variable (in this case, elements) cannot be passed as two different inout arguments to the same function. For more background on exclusivity and ownership, see the manifesto Proposed solution Introduce a new method on MutableCollection to the standard library that swaps the elements from two indices: while hi != lo { elements.swapAt(lo, hi) As well as resolving the conflict with the proposed language change, this appears to improve readability. Existing usage on two elements in a collection will need to be migrated to the new method. While swap was only intended to be used on collections, it is possible to use it on other variables. However, the recommended style for these uses is to not use a function at all: var a = 0 var b = 1 swap(&amp;a,&amp;b) // can be rewritten as: (a,b) = (b,a) The existing swap method will remain, as under some circumstances it may result in a performance gain, particularly if move-only types are introduced in a later release. Detailed design Add the following method to the standard library: protocol MutableCollection { /// Exchange the values at indices `i` and `j`. /// /// Has no effect when `i` and `j` are equal. public mutating func swapAt(_ i: Index, _ j: Index) } The current swap is required to fatalError on attempts to swap an element with itself for implementation reasons. This pushes the burden to check this first onto the caller. While swapping an element with itself is often a logic errror (for example, in a sort algorithm where you have a fenceposts bug), it is occasionally a valid situation (for example, it can occur easily in an implementation of shuffle). This implementation removes the precondition. Deprecate the existing swap, and obsolete it in a later version of Swift. Source compatibility This is purely additive so should not be source breaking. Effect on ABI stability None. Effect on API resilience N/A Alternatives considered A number of possible alternative names for this method were considered: elements.swap(i, with: j) elements.swap(at: i, j) elements.swapElements(i, j) elements.swap(elements: i, j) elements.swapAt(i, with: j) was chosen on the basis of it reading most fluently, combined with adhering to the relevant parts of the naming guidelines: “Omit all labels when arguments can’t be usefully distinguished” and: “When the first argument forms part of a prepositional phrase, give it an argument label…An exception arises when the first two arguments represent parts of a single abstraction….In such cases, begin the argument label after the preposition, to keep the abstraction clear.”",
    "url": "http://localhost:4000/docs/2019-08-26-0173-swap-indices.html",
    "relUrl": "/docs/2019-08-26-0173-swap-indices.html"
  },
  "173": {
    "id": "173",
    "title": "SE-0174 Change `filter` to return an associated type",
    "content": "Change filter to return an associated type Proposal: SE-0174 Author: Ben Cohen Review Manager: Doug Gregor Status: Accepted Decision Notes: Rationale Bug: SR-3444 Introduction This proposal changes the filter operation on Sequence to return an associated type, and adds a default implementation to RangeReplaceableCollection to return the same type as the filtered collection. Motivation The recently accepted SE-165 introduced a version of filter on Dictionary that returned a Dictionary. This had both performance and usability benefits: in most cases, a Dictionary is what the user wanted from the filter, and creating one directly from the filter operation is much more efficient than first creating an array then creating a Dictionary from it. However, this does result in some inconsistencies. Users may be surprised that this one specific collection returns Self, while other collections that would benefit from the same change still return [Element]. And some collections, such as String, might also benefit from usability and performance win similar to Dictionary. Additionally, these wins will be lost in generic code – if you pass a Dictionary into an algorithm that takes a Sequence, then when you filter it, you will still get an Array. Proposed solution The existing protocol requirement on filter will be changed to return an associated type, Filtered. The extension providing a default implementation will remain as-is, resulting in an inferred value for Filtered of [Element]. Dictionary will automatically infer a filtered type of Dictionary as a result of this change. A default implementation on RangeReplaceableCollection will be provided, using init() and append(_:), so all range-replaceable collections will have a Filtered of Self. Per SE-163, this will include String. Note, many sequences (for example, strides or ranges), cannot represent a filtered self as Self and will continue to return an array. If this is a performance problem, lazy remains a good solution. Detailed design Add a Filtered associated type to Sequence, and change the requirement to return it: protocol Sequence { associatedtype Filtered /// Returns an filtered sequence containing, in order, the elements of the /// sequence that satisfy the given predicate. /// /// In this example, `filter` is used to include only names shorter than /// five characters. /// /// let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;] /// let shortNames = cast.filter { $0.characters.count &lt; 5 } /// print(shortNames) /// // Prints &quot;[&quot;Kim&quot;, &quot;Karl&quot;]&quot; /// /// - Parameter isIncluded: A closure that takes an element of the /// sequence as its argument and returns a Boolean value indicating /// whether the element should be included in the returned sequence. /// - Returns: An array of the elements that `includeElement` allowed. func filter( _ isIncluded: (Iterator.Element) throws -&gt; Bool ) rethrows -&gt; Filtered } Add a default implementation of filter to RangeReplaceableCollection returning Self: extension RangeReplaceableCollection { func filter(_ isIncluded: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self { var result = Self() for element in self { if try isIncluded(element) { result.append(element) } } return result } } Specific concrete collections may choose to implement a faster version, but this is an implementation detail. Source compatibility This change is subtly source breaking. In most cases users will not notice. They may be be relying on an array being returned (albeit often in order to then transform it back into the original type), but this version will still be available (via the extension on Sequence) and will be called if forced through type context. The only code that will break is if this operation spans multple lines: // filtered used to be [Character], now String let filtered = &quot;abcd&quot;.filter { $0 == &quot;a&quot; } useArray(filtered) // won&#39;t compile Because of this, the new implementation of RangeReplaceableCollection.filter will only be available in Swift 4. Effect on ABI stability This change will affect the ABI of Sequence and needs to be made before declaring ABI stability. Effect on API resilience N/A Alternatives considered Status-quo. There are benefits to the consistency of always returning [Element]. It could be worthwhile to make a similar change to map, but this is beyond the capabilities of the current generics system because map does not preserve the element type (more specifically, you cannot express a type that is Self except with a different Element in order to provide the default implementation on RangeReplaceableCollection).",
    "url": "http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html",
    "relUrl": "/docs/2019-08-26-0174-filter-range-replaceable.html"
  },
  "174": {
    "id": "174",
    "title": "SE-0175 Package Manager Revised Dependency Resolution",
    "content": "Package Manager Revised Dependency Resolution Proposal: SE-0175 Author: Rick Ballard Review Manager: Ankit Aggarwal Status: Implemented (Swift 4) Decision Notes: Rationale Introduction This proposal makes the package manager’s dependency resolution behavior clearer and more intuitive. It removes the pinning commands (swift package pin &amp; swift package unpin), replaces the swift package fetch command with a new swift package resolve command with improved behavior, and replaces the optional Package.pins file with a Package.resolved file which is always created during dependency resolution. Motivation When SE-0145 Package Manager Version Pinning was proposed, it was observed that the proposal was overly complex. In particular, it introduced a configuration option allowing some packages to have autopinning on (the default), while others turned it off; this option affected the behavior of other commands (like swift package update, which has a --repin flag that does nothing for packages that use autopinning). This configuration option has proved to be unnecessarily confusing. In the existing design, when autopinning is on (which is true by default) the swift package pin command can’t be used to pin packages at specific revisions while allowing other packages to be updated. In particular, if you edit your package’s version requirements in the Package.swift manifest, there is no way to resolve your package graph to conform to those new requirements without automatically repinning all packages to the latest allowable versions. Thus, specific, intentional pins can not be preserved without turning off autopinning. The problems here stem from trying to use one mechanism (pinning) to solve two different use cases: wanting to record and share resolved dependency versions, vs wanting to keep a badly-behaved package at a specific version. We think the package manager could be simplified by splitting these two use cases out into different mechanisms (“resolved versions” vs “pinning”), instead of using an “autopinning” option which makes these two features mutually-exclusive and confusing. Additionally, some dependency resolution behaviors were not well-specified and do not behave well. The package manager is lax about detecting changes to the versions specified in the Package.swift manifest or Package.pins pinfile, and fails to automatically update packages when needed, or to issue errors if the version requirements are unsatisfiable, until the user explicitly runs swift package update, or until a new user without an existing checkout attempts to build. We’d like to clarify and revise the rules around when and how the package manager performs dependency resolution. Proposed solution The pinning feature will be removed. This removes the swift package pin and swift package unpin commands, the --repin flag to swift package update, and use of the Package.pins file. In a future version of the package manager we may re-introduce pinning. If we do, pins will only be recorded in the Package.pins file when explicitly set with swift package pin, and any pinned dependencies will not be updated by the swift package update command; instead, they would need to be unpinned to be updated. This would be a purely additive feature which packages could use in addition to the resolved versions feature when desired. A new “resolved versions” feature will be added, which behaves very similarly to how pinning previously behaved when autopinning was on. The version of every resolved dependency will be recorded in a Package.resolved file in the top-level package, and when this file is present in the top-level package it will be used when performing dependency resolution, rather than the package manager finding the latest eligible version of each package. swift package update will update all dependencies to the latest eligible versions and update the Package.resolved file accordingly. Resolved versions will always be recorded by the package manager. Some users may chose to add the Package.resolved file to their package’s .gitignore file. When this file is checked in, it allows a team to coordinate on what versions of the dependencies they should use. If this file is gitignored, each user will separately choose when to get new versions based on when they run the swift package update command, and new users will start with the latest eligible version of each dependency. Either way, for a package which is a dependency of other packages (e.g. a library package), that package’s Package.resolved file will not have any effect on its client packages. The existing swift package fetch command will be deprecated, removed from the help message, and removed completely in a future release of the Package Manager. In its place, a new swift package resolve command will be added. The behavior of resolve will be to resolve dependencies, taking into account the current version restrictions in the Package.swift manifest and Package.resolved resolved versions file, and issuing an error if the graph cannot be resolved. For packages which have previously resolved versions recorded in the Package.resolved file, the resolve command will resolve to those versions as long as they are still eligible. If the resolved versions file changes (e.g. because a teammate pushed a new version of the file) the next resolve command will update packages to match that file. After a successful resolve command, the checked out versions of all dependencies and the versions recorded in the resolved versions file will match. In most cases the resolve command will perform no changes unless the Package.swift manifest or Package.resolved file have changed. The following commands will implicitly invoke the swift package resolve functionality before running, and will cancel with an error if dependencies cannot be resolved: swift build swift test swift package generate-xcodeproj The swift package show-dependencies command will also implicitly invoke swift package resolve, but it will show whatever information about the dependency graph is available even if the resolve fails. The swift package edit command will implicitly invoke swift package resolve, but if the resolve fails yet did identify and fetch a package with the package name the command supplied, the command will allow that package to be edited anyway. This is useful if you wish to use the edit command to edit version requirements and fix an unresolvable dependency graph. swift package unedit will unedit the package and then perform a resolve. Detailed design The resolve command is allowed to automatically add new dependencies to the resolved versions file, and to remove dependencies which are no longer in the dependency graph. It can also automatically update the recorded versions of any package whose previously-resolved version is no longer allowed by the version requirements from the Package.swift manifests. When changed version requirements force a dependency to be automatically re-resolved, the latest eligible version will be chosen; any other dependencies affected by that change will prefer to remain at their previously-resolved versions as long as those versions are eligible, and will otherwise update likewise. The Package.resolved resolved versions file will record the git revision used for each resolved dependency in addition to its version. In future versions of the package manager we may use this information to detect when a previously-resolved version of a package resolves to a new revision, and warn the user if this happens. The swift package resolve command will not actually perform a git fetch on any dependencies unless it needs to in order to correctly resolve dependencies. As such, if all dependencies are already resolved correctly and allowed by the version constraints in the Package.swift manifest and Package.resolved resolved versions file, the resolve command will not need to do anything (e.g. a normal swift build won’t hit the network or make unnecessary changes during its implicit resolve). If a dependency is in edit mode, it is allowed to have a different version checked out than that recorded in the resolved versions file. The version recorded for an edited package will not change automatically. If a swift package update operation is performed while any packages are in edit mode, the versions of those edited packages will be removed from the resolved versions file, so that when those packages leave edit mode the next resolution will record a new version for them. Any packages in the dependency tree underneath an edited package will also have their resolved version removed by swift package update, as otherwise the resolved versions file might record versions that wouldn’t have been chosen without whatever edited package modifications have been made. Alternatives considered We considered repurposing the existing fetch command for this new behavior, instead of renaming the command to resolve. However, the name fetch is defined by git to mean getting the latest content for a repository over the network. Since this package manager command does not always actually fetch new content from the network, it is confusing to use the name fetch. In the future, we may offer additional control over when dependency resolution is allowed to perform network access, and we will likely use the word fetch in flag names that control that behavior. We considered continuing to write out the Package.pins file for packages whose Swift tools version was less than 4.0, for maximal compatibility with the Swift 3.1 tools. However, as the old pinning behavior was a workflow feature and not a fundamental piece of package compatibility, we do not consider it necessary to support in the 4.0 tools. We considered keeping the pin and unpin commands, with the new behavior as discussed briefly in this proposal. While we think we may wish to bring this feature back in the future, we do not consider it critical for this release; the workflow it supports (updating all packages except a handful which have been pinned) is not something most users will need, and there are workarounds (e.g. specify an explicit dependency in the Package.swift manifest). We considered using an install verb instead of resolve, as many other package managers use install for a very similar purpose. However, almost all of those package managers are for non-compiled languages, where downloading the source to a dependency is functionally equivalent to “installing” it as a product ready for use. In contrast, Swift is a compiled language, and our dependencies must be built (e.g. into libraries) before they can be installed. As such, install would be a misnomer for this workflow. In the future we may wish to add an install verb which actually does install built products, similar to make install. Why we didn’t use “Package.lock” We considered using the .lock file extension for the new resolved versions file, to be consistent with many other package managers. We expect that the decision not to use this extension will be controversial, as following established precedent is valuable. However, we think that a “lockfile” is a very poor name for this concept, and that using that name would cause confusion when we re-introduce pins. Specifically: Calling this a “lock” implies a stronger lockdown of dependencies than is supported by the actual behavior. As a simple update command will reset the locks, and a change to the specified versions in Package.swift will override them, they’re not really “locked” at all. This is misleading. When we re-introduce pinning, it would be very confusing to have both “locks” and “pins”. Having “resolved versions” and “pins” is not so confusing. The term “lock” is already overloaded between POSIX file locks and locks in concurrent programming. For comparison, here is a list of other package managers which implement similar behavior and their name for this file: Package Manager Language Resolved versions file name Yarn JS yarn.lock Composer PHP composer.lock Cargo Rust Cargo.lock Bundler Ruby Gemfile.lock CocoaPods ObjC/Swift Podfile.lock Glide Go glide.lock Pub Dart pubspec.lock Mix Elixir mix.lock rebar3 Erlang rebar.lock Carton Perl carton.lock Carthage ObjC/Swift Cartfile.resolved Pip Python requirements.txt NPM JS npm-shrinkwrap.json Meteor JS versions Some arguments for using “.lock” instead of “.resolved” are: Users of other package managers will already be familiar with the terminology and behavior. For packages which support multiple package managers, it will be possible to put “*.lock” into the gitignore file instead of needing a separate entry for “*.resolved”. However, we do not feel that these arguments outweigh the problems with the term “lock”. If providing feedback asking that we reconsider this decision, please be clear about why the above decision is incorrect, with new information not already considered.",
    "url": "http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html",
    "relUrl": "/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html"
  },
  "175": {
    "id": "175",
    "title": "SE-0176 Enforce Exclusive Access to Memory",
    "content": "Enforce Exclusive Access to Memory Proposal: SE-0176 Author: John McCall Review Manager: Ben Cohen Status: Implemented (Swift 4) Previous Revision: 1 Previous Discussion: Email Thread Introduction In Swift 3, it is possible to modify a variable while it’s being used or modified by another part of the program. This can lead to unexpected and confusing results. It also forces a great deal of conservatism onto the implementation of the compiler and the standard libraries, which must generally ensure the basic soundness of the program (no crashes or undefined behavior) even in unusual circumstances. We propose that Swift should instead enforce a general rule that potential modifications of variables must be exclusive with any other access to that variable. This proposal is a core part of the Ownership feature, which was described in the ownership manifesto. That document presents the high-level objectives of Ownership, develops a more rigorous theory of memory access in Swift, and applies it in detail to a variety of different language features. In that document, the rule we’re proposing here is called the Law of Exclusivity. We will not be going into that level of detail in this proposal. Instead, we will lay out the basic rule, how it will be enforced, and the implications for programming in Swift. It should be possible to understand this proposal without actually having read the ownership manifesto at all. That said, if you are interested in the technical details, that document is probably the right place to turn. Motivation Instantaneous and non-instantaneous accesses On a basic level, Swift is an imperative language which allows programmers to directly access mutable memory. Many of the language features that access memory, like simply loading from or assigning to a variable, are “instantaneous”. This means that, from the perspective of the current thread, the operation completes without any other code being able to interfere. For example, when you assign to a stored property, the current value is just replaced with the new value. Because arbitrary other code can’t run during an instantaneous access, it’s never possible for two instantaneous accesses to overlap each other (without introducing concurrency, which we’ll talk about later). That makes them very easy to reason about. However, not all accesses are instantaneous. For example, when you call a mutating method on a stored property, it’s really one long access to the property: self just becomes another way of referring to the property’s storage. This access isn’t instantaneous because all of the code in the method executes during it, so if that code manages to access the same property again, the accesses will overlap. There are several language features like this already in Swift, and Ownership will add a few more. Examples of problems due to overlap Here’s an example: // These are simple global variables. var global: Int = 0 var total: Int = 0 extension Int { // Mutating methods access the variable they were called on // for the duration of the method. mutating func increaseByGlobal() { // Any accesses they do will overlap the access to that variable. total += self // Might access &#39;total&#39; through both &#39;total&#39; and &#39;self&#39; self += global // Might access &#39;global&#39; through both &#39;global&#39; and &#39;self&#39; } } If self is total or global, the low-level semantics of this method don’t change, but the programmer’s high-level understanding of it almost certainly does. A line that superficially seems to not change ‘global’ might suddenly start doubling it! And the data dependencies between the two lines instantly go from simple to very complex. That’s very important information for someone maintaining this method, who might be tempted to re-arrange the code in ways that seem equivalent. That kind of maintenance can get very frustrating because of overlap like this. The same considerations apply to the language implementation. The possibility of overlap means the language has to make pessimistic assumptions about the loads and stores in this method. For example, the following code avoids a seemingly-redundant load, but it’s not actually equivalent because of overlap: let value = self total += value self = value + global Because these variables just have type Int, the cost of this pessimism is only an extra load. If the types were more complex, like String, it might mean doing extra copies of the String value, which would translate to extra retains and releases of the string’s buffer; in a more complex example, that could even lead to the underlying data being copied unnecessarily. In the above examples, we’ve made the potentially-overlapping accesses obvious, but they don’t have to be. For example, here is another method that takes a closure as an argument: extension Array { mutating func modifyElements(_ closure: (inout Element) -&gt; ()) { var i = startIndex while i != endIndex { closure(&amp;self[i]) i = index(after: i) } } } This method’s implementation seems straightforwardly correct, but unfortunately it doesn’t account for overlap. Absolutely nothing prevents the closure from modifying self during the iteration, which means that i can suddenly become an invalid index, which could lead to all sorts of unwanted behavior. Even if this never happen in reality, the fact that it’s possible means that the implementation is blocked from pursuing all sorts of important optimizations. For example, the compiler has an optimization that “hoists” the uniqueness check on a copy-on-write collection from the inside of a loop (where it’s run on each iteration) to the outside (so that it’s only checked once, before the loop begins). But that optimization can’t be applied in this example because the closure might change or copy self. The only realistic way to tell the compiler that that can’t happen is to enforce exclusivity on self. The same considerations that apply to self in a mutating method also apply to inout parameters. For example: open class Person { open var title: String } func collectTitles(people: [Person], into set: inout Set&lt;String&gt;) { for person in people { set.insert(person.title) } } This function mutates a set of strings, but it also repeatedly calls a class method. The compiler cannot know how this method is implemented, because it is open and therefore overridable from an arbitrary module. Therefore, because of overlap, the compiler must pessimistically assume that each of these method calls might somehow find a way to modify the original variable that set was bound to. (And if the method did manage to do so, the resulting strange behavior would probably be seen as a bug by the caller of collectTitles.) Eliminating non-instantaneous accesses? If non-instantaneous accesses create all of these problems with overlapping accesses, should we just eliminate non-instantaneous accesses completely? Well, no, and there’s two big reasons why not. In order to make something like a mutating method not access the original storage of self for the duration of the method, we would need to make it access a temporary copy instead, which we would assign back to the storage after the method is complete. That is, suppose we had the following Swift code: var numbers = [Int]() numbers.appendABunchOfStuff() Currently, behind the scenes, this is implemented somewhat like the following C code: struct Array numbers = _Array_init(); _Array_appendABunchOfStuff(&amp;numbers); You can see clearly how _Array_appendABunchOfStuff will be working directly with the storage of numbers, creating the abstract possibility of overlapping accesses to that variable. To prevent this in general, we would need to pass a temporary copy instead: struct Array numbers = _Array_init(); struct Array temp = _Array_copy(numbers); _Array_appendABunchOfStuff(&amp;temp); _Array_assign(&amp;numbers, temp); Like we said, there’s two big problems with this. The first problem is that it’s awful for performance. Even for a normal type, doing extra copies is wasteful, but doing it with Array is even worse because it’s a copy-on-write type. The extra copy here means that there will be multiple references to the buffer, which means that _Array_appendABunchOfStuff will be forced to copy the buffer instead of modifying it in place. Removing these kinds of copies, and making it easier to reason about when they happen, is a large part of the goal of the Ownership feature. The second problem is that it doesn’t even eliminate the potential confusion. Suppose that _Array_appendABunchOfStuff somehow reads or writes to numbers (perhaps because numbers is captured in a closure, or it’s actually a global variable or a class property or something else that can be potentially accessed from anywhere). Because the method is now modifying the copy in temp, any reads it makes from numbers won’t see any of the changes it’s made to temp, and any changes it makes to numbers will be silently lost when it returns and the caller unconditionally overwrites numbers with temp. Consequences of non-instantaneous accesses So we have to accept that accesses can be non-instantaneous. That means programmers can write code that would naturally cause overlapping accesses to the same variable. We currently allow this to happen and make a best effort to live with the consequences. The costs, in general, are a lot of complexity and lost performance. For example, the Array type has an optimization in its subscript operator which allows callers to directly access the storage of array elements. This is a very important optimization which, among other things, allows arrays to efficiently hold values of copy-on-write types. However, because the caller can execute arbitrary code while they’re working with the array element storage, and that code might do something like assign a new value to the original array variable and therefore drop the last reference to the array buffer, this optimization has to create a new strong reference to the buffer until the caller is done with the element, which itself causes a whole raft of complexity. Similarly, when the compiler is optimizing a mutating method, it has to assume that an arbitrary call might completely rewrite self. This makes it very difficult to perform any meaningful optimization at all, especially in generic code. It also means that the compiler must generally emit a large number of conservative copies just in case things are modified in unexpected ways. Furthermore, the possibility of overlapping accesses has a continued impact on language evolution. Many of the features laid out in the Ownership manifesto rely on static guarantees that Swift simply cannot make without stronger rules about when a variable can be modified. Therefore we think it best to simply disallow overlapping accesses as best as we can. Proposed solution We should add a rule to Swift that two accesses to the same variable are not allowed to overlap unless both accesses are reads. By “variable”, we mean any kind of mutable memory: global variables, local variables, class and struct properties, and so on. This rule should be enforced as strongly as possible, depending on what sort of variable it is: Local variables, inout parameters, and struct properties can generally enforce the rule statically. The compiler can analyze all the accesses to the variable and emit an error if it sees any conflicts. Class properties and global variables will have to enforce the rule dynamically. The runtime can keep track of what accesses are underway and report any conflicts. Local variables will sometimes have to use dynamic enforcement when they are captured in closures. Unsafe pointers will not use any active enforcement; it is the programmer’s responsibility to follow the rule. No enforcement is required for immutable memory, like a let binding or property, because all accesses must be reads. Examples: var x = 0, y = 0 // NOT A CONFLICT. These two accesses to &#39;x&#39; are both reads. // Each completes instantaneously, so the accesses do not overlap and // therefore do not conflict. Even if they were not instantaneous, they // are both reads and therefore do no conflict. let z = x + x // NOT A CONFLICT. The right-hand side of the assignment is a read of // &#39;x&#39; which completes instantaneously. The assignment is a write to &#39;x&#39; // which completes instantaneously. The accesses do not overlap and // therefore do not conflict. x = x // NOT A CONFLICT. The right-hand side is a read of &#39;x&#39; which completes // instantaneously. Calling the operator involves passing &#39;x&#39; as an inout // argument; this is a write access for the duration of the call, but it does // not begin until immediately before the call, after the right-hand side is // fully evaluated. Therefore the accesses do not overlap and do not conflict. x += x // CONFLICT. Passing &#39;x&#39; as an inout argument is a write access for the // duration of the call. Passing the same variable twice means performing // two overlapping write accesses to that variable, which therefore conflict. swap(&amp;x, &amp;x) extension Int { mutating func assignResultOf(_ function: () -&gt; Int) { self = function() } } // CONFLICT. Calling a mutating method on a value type is a write access // that lasts for the duration of the method. The read of &#39;x&#39; in the closure // is evaluated while the method is executing, which means it overlaps // the method&#39;s formal access to &#39;x&#39;. Therefore these accesses conflict. x.assignResultOf { x + 1 } Detailed design Concurrency Swift has always considered read/write and write/write races on the same variable to be undefined behavior. It is the programmer’s responsibility to avoid such races in their code by using appropriate thread-safe programming techniques. We do not propose changing that. Dynamic enforcement is not required to detect concurrent conflicting accesses, and we propose that by default it should not make any effort to do so. This should allow the dynamic bookkeeping to avoid synchronizing between threads; for example, it can track accesses in a thread-local data structure instead of a global one protected by locks. Our hope is that this will make dynamic access-tracking cheap enough to enable by default in all programs. The implementation should still be permitted to detect concurrent conflicting accesses, of course. Some programmers may wish to use an opt-in thread-safe enforcement mechanism instead, at least in some build configurations. Any future concurrency design in Swift will have the elimination of such races as a primary goal. To the extent that it succeeds, it will also define away any specific problems for exclusivity. Value types Calling a method on a value type is an access to the entire value: a write if it’s a mutating method, a read otherwise. This is because we have to assume that a method might read or write an arbitrary part of the value. Trying to formalize rules like “this method only uses these properties” would massively complicate the language. For similar reasons, using a computed property or subscript on a value type generally has to be treated as an access to the entire value. Whether the access is a read or write depends on how the property/subscript is used and whether either the getter or the setter is mutating. Accesses to different stored properties of a struct or different elements of a tuple are allowed to overlap. However, note that modifying part of a value type still requires exclusive access to the entire value, and that acquiring that access might itself prevent overlapping accesses. For example: struct Pair { var x: Int var y: Int } class Paired { var pair = Pair(x: 0, y: 0) } let object = Paired() swap(&amp;object.pair.x, &amp;object.pair.y) Here, initiating the write-access to object.pair for the first argument will prevent the write-access to object.pair for the second argument from succeeding because of the dynamic enforcement used for the property. Attempting to make dynamic enforcement aware of the fact that these accesses are modifying different sub-components of the property would be prohibitive, both in terms of the additional performance cost and in terms of the complexity of the implementation. However, this limitation can be worked around by binding object.pair to an inout parameter: func modifying&lt;T&gt;(_ value: inout T, _ function: (inout T) -&gt; ()) { function(&amp;value) } modifying(&amp;object.pair) { pair in swap(&amp;pair.x, &amp;pair.y) } This works because now there is only a single access to object.pair and because, once the the inout parameter is bound to that storage, accesses to the parameter within the function can use purely static enforcement. We expect that workarounds like this will only rarely be required. Note that two different properties can only be assumed to not conflict when they are both known to be stored. This means that, for example, it will not be allowed to have overlapping accesses to different properties of a resilient value type. This is not expected to be a significant problem for programmers. Arrays Collections do not receive any special treatment in this proposal. For example, Array’s indexed subscript is an ordinary computed subscript on a value type. Accordingly, mutating an element of an array will require exclusive access to the entire array, and therefore will disallow any other simultaneous accesses to the array, even to different elements. For example: var array = [[1,2], [3,4,5]] // NOT A CONFLICT. These accesses to the elements of &#39;array&#39; each // complete instantaneously and do not overlap each other. Even if they // did overlap for some reason, they are both reads and therefore // do not conflict. print(array[0] + array[1]) // NOT A CONFLICT. The access done to read &#39;array[1]&#39; completes // before the modifying access to &#39;array[0]&#39; begins. Therefore, these // accesses do not conflict. array[0] += array[1] // CONFLICT. Passing &#39;array[i]&#39; as an inout argument performs a // write access to it, and therefore to &#39;array&#39;, for the duration of // the call. This call makes two such accesses to the same array variable, // which therefore conflict. swap(&amp;array[0], &amp;array[1]) // CONFLICT. Calling a non-mutating method on &#39;array[0]&#39; performs a // read access to it, and thus to &#39;array&#39;, for the duration of the method. // Calling a mutating method on &#39;array[1]&#39; performs a write access to it, // and thus to &#39;array&#39;, for the duration of the method. These accesses // therefore conflict. array[0].forEach { array[1].append($0) } It’s always been somewhat fraught to do simultaneous accesses to an array because of copy-on-write. The fact that you should not create an array and then fork off a bunch of threads that assign into different elements concurrently has been independently rediscovered by a number of different programmers. (Under this proposal, we will still not be reliably detecting this problem by default, because it is a race condition; see the section on concurrency.) The main new limitation here is that some idioms which did work on a single thread are going to be forbidden. This may just be a cost of progress, but there are things we can do to mitigate the problem. In the long term, the API of Array and other collections should be extended to ensure that there are good ways of achieving the tasks that exclusivity enforcement has made difficult. It will take experience living with exclusivity in order to understand the problems and propose the right API additions. In the short term, these problems can be worked around with withUnsafeMutableBufferPointer. We do know that swapping two array elements will be problematic, and accordingly we are (separately proposing)[https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md] to add a swapAt method to MutableCollection that takes two indices rather than two inout arguments. The Swift 3 compatibility mode should recognize the swap-of-elements pattern and automatically translate it to use swapAt, and the 3-to-4 migrator should perform this rewrite automatically. Class properties Unlike value types, calling a method on a class doesn’t formally access the entire class instance. In fact, we never try to enforce exclusivity of access on the whole object at all; we only enforce it for individual stored properties. Among other things, this means that an access to a class property never conflicts with an access to a different property. There are two major reasons for this difference between value and reference types. The first reason is that it’s important to allow overlapping method calls to a single class instance. It’s quite common for an object to have methods called on it concurrently from different threads. These methods may access different properties, or they may synchronize their accesses to the same properties using locks, dispatch queues, or some other thread-safe technique. Regardless, it’s a widespread pattern. The second reason is that there’s no benefit to trying to enforce exclusivity of access to the entire class instance. For a value type to be mutated, it has to be held in a variable, and it’s often possible to reason quite strongly about how that variable is used. That means that the exclusivity rule that we’re proposing here allows us to make some very strong guarantees for value types, generally making them an even tighter, lower-cost abstraction. In contrast, it’s inherent to the nature of reference types that references can be copied pretty arbitrarily throughout a program. The assumptions we want to make about value types depend on having unique access to the variable holding the value; there’s no way to make a similar assumption about reference types without knowing that we have a unique reference to the object, which would radically change the programming model of classes and make them unacceptable for the concurrent patterns described above. Disabling dynamic enforcement. We could add an attribute which allows dynamic enforcement to be downgraded to an unsafe-pointer-style undefined-behavior rule on a variable-by-variable basis. This would allow programmers to opt out of the expense of dynamic enforcement when it is known to be unnecessary (e.g. because exclusivity is checked at some higher level) or when the performance burden is simply too great. There is some concern that adding this attribute might lead to over-use and that we should only support it if we are certain that the overheads cannot be reduced in some better way. Since the rule still applies, and it’s merely no longer being checked, it makes sense to borrow the “checked” and “unchecked” terminology from the optimizer settings. class TreeNode { @exclusivity(unchecked) var left: TreeNode? @exclusivity(unchecked) var right: TreeNode? } Closures A closure (including both local function declarations and closure expressions, whether explicit or autoclosure) is either “escaping” or “non-escaping”. Currently, a closure is considered non-escaping only if it is: a closure expression which is immediately called, a closure expression which is passed as a non-escaping function argument, or a local function which captures something that is not allowed to escape, like an inout parameter. It is likely that this definition will be broadened over time. A variable is said to be escaping if it is captured in an escaping closure; otherwise, it is non-escaping. Escaping variables generally require dynamic enforcement instead of static enforcement. This is because Swift cannot reason about when an escaping closure will be called and thus when the variable will be accessed. There are some circumstances where static enforcement may still be allowed, for example when Swift can reason about how the variable will be used after it is escaped, but this is only possible as a best-effort improvement for special cases, not as a general rule. In contrast, non-escaping variables can always use static enforcement. (In order to achieve this, we must impose a new restriction on recursive uses of non-escaping closures; see below.) This guarantee aligns a number of related semantic and performance goals. For example, a non-escaping variable does not need to be allocated on the heap; by also promising to only use static enforcement for the variable, we are essentially able to guarantee that the variable will have C-like performance, which can be important for some kinds of program. This guarantee also ensures that only static enforcement is needed for inout parameters, which cannot be captured in escaping closures; this substantially simplifies the implementation model for capturing inout parameters. Diagnosing dynamic enforcement violations statically In general, Swift is permitted to upgrade dynamic enforcement to static enforcement when it can prove that two accesses either always or never conflict. This is analogous to Swift’s rules about integer overflow. For example, if Swift can prove that two accesses to a global variable will always conflict, then it can report that error statically, even though global variables use dynamic enforcement: var global: Int swap(&amp;global, &amp;global) // Two overlapping modifications to &#39;global&#39; Swift is not required to prove that both accesses will actually be executed dynamically in order to report a violation statically. It is sufficient to prove that one of the accesses cannot ever be executed without causing a conflict. For example, in the following example, Swift does not need to prove that mutate actually calls its argument function: // The inout access lasts for the duration of the call. global.mutate { return global + 1 } When a closure is passed as a non-escaping function argument or captured in a closure that is passed as a non-escaping function argument, Swift may assume that any accesses made by the closure will be executed during the call, potentially conflicting with accesses that overlap the call. Restrictions on recursive uses of non-escaping closures In order to achieve the goal of guaranteeing the use of static enforcement for variables that are captured only by non-escaping closures, we do need to impose an additional restriction on the use of such closures. This rule is as follows: A non-escaping closure A may not be recursively invoked during the execution of a non-escaping closure B which captures the same local variable or inout parameter unless: A is defined within B or A is a local function declaration which is referenced directly by B. For clarity, we will call this rule the Non-Escaping Recursion Restriction, or NRR. The NRR is sufficient to prove that non-escaping variables captured by B will not be interfered with unless B delegates to something which is locally known by B to have access to those variables. This, together with the fact that the uses of B itself can be statically analyzed by its defining function, is sufficient to allow static enforcement for the non-escaping variables it captures. (It also enables some powerful analyses of captured variables within non-escaping closures; we do not need to get into that here.) Because of the tight restrictions on how non-escaping closures can be used in Swift today, it’s already quite difficult to violate the NRR. The following user-level restrictions are sufficient to ensure that the NRR is obeyed: A function may not call a non-escaping function parameter passing a non-escaping function parameter as an argument. For the purposes of this rule, a closure which captures a non-escaping function parameter is treated the same as the parameter. We will call this rule the Non-Escaping Parameter Call Restriction, or NPCR. Programmers using withoutActuallyEscaping should take care not to allow the result to be recursively invoked. The NPCR is a conservative over-approximation: that is, there is code which does not violate the NRR which will be considered ill-formed under the NPCR. This is unfortunate but inevitable. Here is an example of the sort of code that will be disallowed under the NPCR: func recurse(fn: (() -&gt; ()) -&gt; ()) { // Invoke the closure, passing a closure which, if invoked, // will invoke the closure again. fn { fn { } } } func apply&lt;T&gt;(argProvider: () -&gt; T, fn: (() -&gt; T) -&gt; T) { // Pass the first argument function to the second. fn(argProvider) } Note that it’s quite easy to come up with ways to use these functions that wouldn’t violate the NRR. For example, if either argument to apply is not a closure, the call cannot possibly violate the NRR. Nonetheless, we feel that the NPCR is a reasonable restriction: Functions like recurse that apply a function to itself are pretty much just of theoretical interest. Recursion is an important programming tool, but nobody writes it like this because it’s just unnecessarily more difficult to reason about. Functions like apply that take two closures are not uncommon, but they’re likely to either invoke the closures sequentially, which would not violate the NPCR, or else be some sort of higher-order combinator, which would require the closures to be @escaping and thus also not violate the NPCR. Note that passing two non-escaping functions as arguments to the same call does not violate the NPCR. This is because the NPCR will be enforced, recursively, in the callee. (Imported C functions which take non-escaping block parameters can, of course, easily violate the NPCR. They can also easily allow the block to escape. We do not believe there are any existing functions or methods on our target platforms that directly violate the NPCR.) In general, programmers who find the NPCR an unnecessarily overbearing restriction can simply declare their function parameter to be @escaping or, if they are certain that their code will not violate the NRR, use withoutActuallyEscaping to disable the NPCR check. Source compatibility In order to gain the performance and language-design benefits of exclusivity, we will have to enforce it in all language modes. Therefore, exclusivity will eventually demand a source break. We can mitigate some of the impact of this break by implicitly migrating code matching certain patterns to use different patterns that are known to satisfy the exclusivity rule. For example, it would be straightforward to automatically translate calls like swap(&amp;array[i], &amp;array[j]) to array.swapAt(i, j). Whether this makes sense for any particular migration remains to be seen; for example, swap does not appear to be used very often in practice outside of specific collection algorithms. Overall, we do not expect that a significant amount of code will violate exclusivity. This has been borne out so far by our testing. Often the examples that do violate exclusivity can easily be rewritten to avoid conflicts. In some of these cases, it may make sense to do the rewrite automatically to avoid source-compatibility problems. Effect on ABI stability and resilience In order to gain the performance and language-desing benefits of exclusivity, we must be able to assume that it is followed faithfully in various places throughout the ABI. Therefore, exclusivity must be enforced before we commit to a stable ABI, or else we’ll be stuck with the current conservatism around inout and mutating methods forever.",
    "url": "http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html",
    "relUrl": "/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html"
  },
  "176": {
    "id": "176",
    "title": "SE-0177 Add clamp(to:) to the stdlib",
    "content": "Add clamp(to:) to the stdlib Proposal: SE-0177 Author: Nicholas Maccharoli Review Manager: TBD Status: Returned for revision Introduction This proposal aims to add functionality to the standard library for clamping a value to a provided Range. The proposed function would allow the user to specify a range to clamp a value to where if the value fell within the range, the value would be returned as is, if the value being clamped exceeded the upper or lower bound then the upper or lower bound would be returned respectively. Swift-evolution thread: Add a clamp function to Algorithm.swift Motivation There have been quite a few times in my professional and personal programming life where I reached for a function to limit a value to a given range and was disappointed that it was not part of the standard library. There already exists an extension to CountableRange in the standard library implementing clamped(to:) that will limit the calling range to that of the provided range, so having the same functionality but just for types that conform to the Comparable protocol would be conceptually consistent. Having functionality like clamped(to:) added to Comparable as a protocol extension would benefit users of the Swift language who wish to guarantee that a value is kept within bounds, perhaps one example of this coming in handy would be to limit the result of some calculation between two acceptable numerical limits, say the bounds of a coordinate system. Proposed solution The proposed solution is to add a clamped(to:) function to the Swift Standard Library as an extension to Comparable and to Strideable. The function would return a value within the bounds of the provided range, if the value clamped(to:) is being called on falls within the provided range then the original value would be returned. If the value was less or greater than the bounds of the provided range then the respective lower or upper bound of the range would be returned. Clamping on an empty range simply returns the value clamped to the lowerBound / upperBound of the Range no different from clamping on a non-empty range. Given a clamped(to:) function existed it could be called in the following way, yielding the results in the adjacent comments: // Closed range variant 100.clamped(to: 0...50) // 50 100.clamped(to: 200...300) // 200 100.clamped(to: 0...150) // 100 // Half-Open range variant 100.clamped(to: 0..&lt;50) // 49 100.clamped(to: 200..&lt;300) // 200 100.clamped(to: 0..&lt;150) // 100 100.clamped(to: 42..&lt;42) // 42 Detailed design The implementation of clamped(to:) that is being proposed is composed of two protocol extensions; one protocol extension on Comparable and another on Strideable. The implementation for clamped(to:) as an extension to Comparable accepting a range of type ClosedRange&lt;Self&gt; would look like the following: extension Comparable { func clamped(to range: ClosedRange&lt;Self&gt;) -&gt; Self { if self &gt; range.upperBound { return range.upperBound } else if self &lt; range.lowerBound { return range.lowerBound } else { return self } } } The implementation of clamped(to:) as an extension on Strideable would be confined to cases where the stride is of type Integer. The implementation would be as follows: extension Strideable where Stride: Integer { func clamped(to range: Range&lt;Self&gt;) -&gt; Self { let clampRange: ClosedRange&lt;Self&gt; if range.lowerBound == range.upperBound { clampRange = range.lowerBound...range.upperBound } else { clampRange = range.lowerBound...(range.upperBound - 1) } return clamped(to: clampRange) } } Source compatibility This feature is purely additive; it has no effect on source compatibility. Effect on ABI stability This feature is purely additive; it has no effect on ABI stability. Effect on API resilience The proposed function would become part of the API but purely additive. Alternatives considered Aside from doing nothing, no other alternatives were considered.",
    "url": "http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html",
    "relUrl": "/docs/2019-08-26-0177-add-clamped-to-method.html"
  },
  "177": {
    "id": "177",
    "title": "SE-0178 Add `unicodeScalars` property to `Character`",
    "content": "Add unicodeScalars property to Character Proposal: SE-0178 Author: Ben Cohen Review Manager: Ted Kremenek Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift#9675 Introduction This proposal adds a unicodeScalars view to Character, similar to that on String. Motivation The Character element type of String is currently a black box that provides little functionality besides comparison, literal construction, and to be used as an argument to String.init. Many operations on String could be neatly/readably implemented as operations on each character in the string, if Character exposed its scalars more directly. Many useful things can be determined by examining the scalars in a grapheme (for example is this an ASCII character?). For example, today you can write this: let s = &quot;one two three&quot; s.split(separator: &quot; &quot;) But you cannot write this: let ws = CharacterSet.whitespacesAndNewlines s.split { $0.unicodeScalars.contains(where: ws.contains) } Proposed solution Add a unicodeScalars property to Character, presenting a lazy view of the scalars in the character, along similar lines to the one on String. Unlike the view on String, this will not be a mutable view – it will be read-only. The preferred method for creating and manipulating non-literal Character values will be through String. While there may be some good use cases to manipulating a Character directly, these are outweighed by the complexity of ensuring the invariant that it contain exactly one grapheme. Detailed design Add the following nested type to Character: extension Character { public struct UnicodeScalarView : BidirectionalCollection { public struct Index public var startIndex: Index { get } public var endIndex: Index { get } public func index(after i: Index) -&gt; Index public func index(before i: Index) -&gt; Index public subscript(i: Index) -&gt; UnicodeScalar } public var unicodeScalars: UnicodeScalarView { get } } Additionally, this type will conform to appropriate convenience protocols such as CustomStringConvertible. All initializers will be declared internal, as unlike the String equivalent, this type will only ever be vended by Character. Source compatibility Purely additive, so no impact. Effect on ABI stability Purely additive, so no impact. Effect on API resilience Purely additive, so no impact. Alternatives considered Adding other views, such as utf8 or utf16, was considered but not deemed useful enough compared to using these operations on String instead. In the future, this feature could be used to implement convenience methods such as isASCII on Character. This could be done additively, given this building block, and is outside the scope of this initial proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html",
    "relUrl": "/docs/2019-08-26-0178-character-unicode-view.html"
  },
  "178": {
    "id": "178",
    "title": "SE-0179 Swift `run` Command",
    "content": "Swift run Command Proposal: SE-0179 Author: David Hart Review Manager: Daniel Dunbar Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift-package-manager#1187 Introduction The proposal introduces a new swift run command to build and run an executable defined in the current package. Motivation It is common to want to build and run an executable during development. For now, one must first build it and then execute it from the build folder: $ swift build $ .build/debug/myexecutable In Swift 4, the Swift Package Manager will build to a different path, containing a platform sub-folder (.build/macosx-x86_64/debug for mac and .build/linux-x86_64/debug for linux), making it more cumbersome to run the executable from the command line. To improve the development workflow, the proposal suggests introducing a new first-level swift run command that will build if necessary and then run an executable defined in the Package.swift manifest, reducing the above steps to just one. Proposed solution The swift run command would be defined as: $ swift run --help OVERVIEW: Build and run executable USAGE: swift run [options] [executable [arguments]] OPTIONS: --build-path Specify build/cache directory [default: ./.build] --chdir, -C Change working directory before any other operation --color Specify color mode (auto|always|never) [default: auto] --configuration, -c Build with configuration (debug|release) [default: debug] --enable-prefetching Enable prefetching in resolver --skip-build Skip building the executable product --verbose, -v Increase verbosity of informational output -Xcc Pass flag through to all C compiler invocations -Xlinker Pass flag through to all linker invocations -Xswiftc Pass flag through to all Swift compiler invocations --help Display available options If needed, the command will build the product before running it. As a result, it can be passed any options swift build accepts. As for swift test, it also accepts an extra --skip-build option to skip the build phase. After the options, the command optionally takes the name of an executable product defined in the Package.swift manifest and introduced in SE-0146. If called without an executable and the manifest defines one and only one executable product, it will default to running that one. In any other case, the command fails. If the executable is explicitly defined, all remaining arguments are passed as-is to the executable. $ swift run # .build/debug/exe $ swift run exe # .build/debug/exe $ swift run exe arg1 arg2 # .build/debug/exe arg1 arg2 Alternatives considered One alternative to the Swift 4 change of build folder would be for the Swift Package Manager to create and update a symlink at .build/debug and .build/release that point to the latest build folder for that configuration. Although that should probably be done to retain backward-compatibility with tools that depended on the build location, it does not completely invalidate the usefulness of the run command.",
    "url": "http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html",
    "relUrl": "/docs/2019-08-26-0179-swift-run-command.html"
  },
  "179": {
    "id": "179",
    "title": "SE-0180 String Index Overhaul",
    "content": "String Index Overhaul Proposal: SE-0180 Author: Dave Abrahams Review Manager: Ted Kremenek Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift#9806 Previous Revision: 1 Introduction Today String shares an Index type with its CharacterView but not with its UTF8View, UTF16View, or UnicodeScalarView. This proposal redefines String.UTF8View.Index, String.UTF16View.Index, and String.CharacterView.Index as typealiases for String.Index, and exposes a public encodedOffset property and initializer that can be used to serialize and deserialize positions in a String or Substring. Swift-evolution thread: Pitch: String Index Overhaul Motivation The different index types are supported by a set of Index initializers, which are failable whenever the source index might not correspond to a position in the target view: if let j = String.UnicodeScalarView.Index( someUTF16Position, within: s.unicodeScalars) { ... } The current API is as follows: public extension String.Index { init?(_: String.UnicodeScalarIndex, within: String) init?(_: String.UTF16Index, within: String) init?(_: String.UTF8Index, within: String) } public extension String.UTF16View.Index { init?(_: String.UTF8Index, within: String.UTF16View) init(_: String.UnicodeScalarIndex, within: String.UTF16View) init(_: String.Index, within: String.UTF16View) } public extension String.UTF8View.Index { init?(_: String.UTF16Index, within: String.UTF8View) init(_: String.UnicodeScalarIndex, within: String.UTF8View) init(_: String.Index, within: String.UTF8View) } public extension String.UnicodeScalarView.Index { init?(_: String.UTF16Index, within: String.UnicodeScalarView) init?(_: String.UTF8Index, within: String.UnicodeScalarView) init(_: String.Index, within: String.UnicodeScalarView) } These initializers are supplemented by a corresponding set of convenience conversion methods: if let j = someUTF16Position.samePosition(in: s.unicodeScalars) { ... } with the following API: public extension String.Index { func samePosition(in: String.UTF8View) -&gt; String.UTF8View.Index func samePosition(in: String.UTF16View) -&gt; String.UTF16View.Index func samePosition( in: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index } public extension String.UTF16View.Index { func samePosition(in: String) -&gt; String.Index? func samePosition(in: String.UTF8View) -&gt; String.UTF8View.Index? func samePosition( in: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index? } public extension String.UTF8View.Index { func samePosition(in: String) -&gt; String.Index? func samePosition(in: String.UTF16View) -&gt; String.UTF16View.Index? func samePosition( in: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index? } public extension String.UnicodeScalarView.Index { func samePosition(in: String) -&gt; String.Index? func samePosition(in: String.UTF8View) -&gt; String.UTF8View.Index func samePosition(in: String.UTF16View) -&gt; String.UTF16View.Index } The result is a great deal of API surface area for apparently little gain in ordinary code, that normally only interchanges indices among views when the positions match up exactly (i.e. when the conversion is going to succeed). Also, the resulting code is needlessly awkward. Finally, the opacity of these index types makes it difficult to record String or Substring positions in files or other archival forms, and reconstruct the original positions with respect to a deserialized String or Substring. Proposed solution All String views will use a single index type (String.Index), so that positions can be interchanged without awkward explicit conversions: let html: String = &quot;See &lt;a href= &quot;http://swift.org &quot;&gt;swift.org&lt;/a&gt;&quot; // Search the UTF16, instead of characters, for performance reasons: let open = &quot;&lt;&quot;.utf16.first!, close = &quot;&gt;&quot;.utf16.first! let tagStart = html.utf16.index(of: open) let tagEnd = html.utf16[tagStart...].index(of: close) // Slice the String with the UTF-16 indices to retrieve the tag. let tag = html[tagStart...tagEnd] A property and an intializer will be added to String.Index, exposing the offset of the index in code units (currently only UTF-16) from the beginning of the string: let n: Int = html.endIndex.encodedOffset let end = String.Index(encodedOffset: n) assert(end == String.endIndex) Comparison and Subscript Semantics When two indices being compared correspond to positions that are valid in any single String view, comparison semantics are already fully specified by the Collection requirements. The other cases occur when indices fall between Unicode scalar boundaries in views having distinct encodings. For example, the string &quot; u{1f773}&quot; (“🝳”) is encoded as 0xD83D, 0xDF73 in UTF-16 and 0xF0, 0x9F, 0x9D, 0xB3 in UTF-8, and there is no obvious way to compare the second positions in each of those sequences. The proposed rule is that such indices are compared by comparing their encodedOffsets. Such index values are not totally ordered but do satisfy strict weak ordering requirements, which is sufficient for algorithms such as sort to exhibit sensible behavior. We might consider loosening the specified requirements on these algorithms and on Comparable to support strict weak ordering, but for now we can treat such index pairs as being formally outside the domain of comparison, like any other indices from completely distinct collections. With respect to subscripts, an index that does not fall on an exact boundary in a given String or Substring view will be treated as falling at its encodedOffset in the underlying code units, with the actual contents of the result being an emergent property of applying the usual Unicode rules for decoding those code units. For example, when slicing a string with an index i that falls between two Character boundaries, i.encodedOffset is treated as a position in the string’s underlying code units, and the Characters of the result are determined by performing standard Unicode grapheme breaking on the resulting sequence of code units. let s = &quot;e u{301}galite u{301}&quot; // &quot;égalité&quot; let i = Array(s.unicodeScalars.indices) print(s[i[1]...]) // &quot;◌́galité&quot; print(s[..&lt;i.last!]) // &quot;égalite&quot; print(s[i[1]) // &quot;◌́&quot; Similarly, assignment to a slice of a string is performed by replacing the corresponding code units, and again the resulting Characters are determined by re-applying standard grapheme breaking rules. Replacing the failable APIs listed above that detect whether an index represents a valid position in a given view, and enhancement that explicitly round index positions to nearby boundaries in a given view, are left to a later proposal. For now, we do not propose to remove the existing index conversion APIs. Detailed design String.Index acquires an encodedOffset property and initializer: public extension String.Index { /// Creates a position corresponding to the given offset in a /// `String`&#39;s underlying (UTF-16) code units. init(encodedOffset: Int) /// The position of this index expressed as an offset from the /// beginning of the `String`&#39;s underlying (UTF-16) code units. var encodedOffset: Int } Index types of String.UTF8View, String.UTF16View, and String.UnicodeScalarView are replaced by String.Index: public extension String.UTF8View { typealias Index = String.Index } public extension String.UTF16View { typealias Index = String.Index } public extension String.UnicodeScalarView { typealias Index = String.Index } Because the index types are collapsing, index conversion methods and initializers are reduced to the following: public extension String.Index { init?(_: String.Index, within: String) init?(_: String.Index, within: String.UTF8View) init?(_: String.Index, within: String.UTF16View) init?(_: String.Index, within: String.UnicodeScalarView) func samePosition(in: String) -&gt; String.Index? func samePosition(in: String.UTF8View) -&gt; String.Index? func samePosition(in: String.UTF16View) -&gt; String.Index? func samePosition(in: String.UnicodeScalarView) -&gt; String.Index? } Source compatibility Because of the collapse of index types, existing non-failable APIs become failable. To avoid breaking Swift 3 code, the following overloads of existing functions are added, allowing the resulting optional indices to be used where previously non-optional indices were used. These overloads were driven by making the new APIs work with existing code, including the Swift source compatibility test suite, and should be viewed as migration aids only, rather than additions to the Swift 3 API. extension Optional where Wrapped == String.Index { @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional indices&quot;) public static func ..&lt;( lhs: String.Index?, rhs: String.Index? ) -&gt; Range&lt;String.Index&gt; { return lhs! ..&lt; rhs! } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional indices&quot;) public static func ...( lhs: String.Index?, rhs: String.Index? ) -&gt; ClosedRange&lt;String.Index&gt; { return lhs! ... rhs! } } // backward compatibility for index interchange. extension String.UTF16View { @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public func index(after i: Index?) -&gt; Index { return index(after: i) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public func index( _ i: Index?, offsetBy n: IndexDistance) -&gt; Index { return index(i!, offsetBy: n) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional indices&quot;) public func distance(from i: Index?, to j: Index?) -&gt; IndexDistance { return distance(from: i!, to: j!) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public subscript(i: Index?) -&gt; Unicode.UTF16.CodeUnit { return self[i!] } } extension String.UTF8View { @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public func index(after i: Index?) -&gt; Index { return index(after: i!) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public func index(_ i: Index?, offsetBy n: IndexDistance) -&gt; Index { return index(i!, offsetBy: n) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional indices&quot;) public func distance( from i: Index?, to j: Index?) -&gt; IndexDistance { return distance(from: i!, to: j!) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public subscript(i: Index?) -&gt; Unicode.UTF8.CodeUnit { return self[i!] } } // backward compatibility for index interchange. extension String.UnicodeScalarView { @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public func index(after i: Index?) -&gt; Index { return index(after: i) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public func index(_ i: Index?, offsetBy n: IndexDistance) -&gt; Index { return index(i!, offsetBy: n) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional indices&quot;) public func distance(from i: Index?, to j: Index?) -&gt; IndexDistance { return distance(from: i!, to: j!) } @available( swift, deprecated: 3.2, obsoleted: 4.0, message: &quot;Any String view index conversion can fail in Swift 4; please unwrap the optional index&quot;) public subscript(i: Index?) -&gt; Unicode.Scalar { return self[i!] } } Q: Will existing correct Swift 3 applications stop compiling due to this change? A: it is possible but unlikely. The existing index conversion APIs are relatively rarely used, and the overloads listed above handle the common cases in Swift 3 compatibility mode. Q: Will applications still compile but produce different behavior than they used to? A: No. Q: Is it possible to automatically migrate from the old syntax to the new syntax? A: Yes, although usages of these APIs may be rare enough that it isn’t worth the trouble. Q: Can Swift applications be written in a common subset that works both with Swift 3 and Swift 4 to aid in migration? A: Yes, the Swift 4 APIs will all be available in Swift 3 mode. Effect on ABI stability This proposal changes the ABI of the standard library. Effect on API resilience This proposal makes no changes to the resilience of any APIs. Alternatives considered The only alternative considered was no action.",
    "url": "http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html",
    "relUrl": "/docs/2019-08-26-0180-string-index-overhaul.html"
  },
  "180": {
    "id": "180",
    "title": "SE-0181 Package Manager C/C++ Language Standard Support",
    "content": "Package Manager C/C++ Language Standard Support Proposal: SE-0181 Author: Ankit Aggarwal Review Manager: Daniel Dunbar Status: Implemented (Swift 4) Decision Notes: Rationale Implementation: apple/swift-package-manager#1264 Introduction This proposal adds support for declaring the language standard for C and C++ targets in a SwiftPM package. Motivation The C++ language standard is one of the most important build setting needed to compile C++ targets. We want to add some mechanism to declare it until we get the complete build settings feature, which is deferred from the Swift 4 release. Proposed solution We will add support to the package manifest declaration to specify the C and C++ language standards: let package = Package( name: &quot;CHTTP&quot;, ... cLanguageStandard: .c89, cxxLanguageStandard: .cxx11 ) These settings will apply to all the C and C++ targets in the package. The default value of these properties will be nil, i.e., a language standard flag will not be passed when invoking the C/C++ compiler. Once we get the build settings feature, we will deprecate these properties. Detailed design The C/C++ language standard will be defined by the enums below and updated as per the Clang compiler repository. public enum CLanguageStandard { case c89 case c90 case iso9899_1990 case iso9899_199409 case gnu89 case gnu90 case c99 case iso9899_1999 case gnu99 case c11 case iso9899_2011 case gnu11 } public enum CXXLanguageStandard { case cxx98 case cxx03 case gnucxx98 case gnucxx03 case cxx11 case gnucxx11 case cxx14 case gnucxx14 case cxx1z case gnucxx1z } Impact on existing code There will be no impact on existing packages because this is a new API and the default behaviour remains unchanged. Alternatives considered We considered adding this property at target level but we think that will pollute the target namespace. Moreover, this is a temporary measure until we get the build settings feature.",
    "url": "http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html",
    "relUrl": "/docs/2019-08-26-0181-package-manager-cpp-language-version.html"
  },
  "181": {
    "id": "181",
    "title": "SE-0182 String Newline Escaping",
    "content": "String Newline Escaping Proposal: SE-0182 Authors: John Holdsworth, David Hart, Adrian Zubarev Review Manager: Chris Lattner Status: Implemented (Swift 4) Implementation: apple/swift#11080 Decision Notes: Rationale Previous Proposal: SE-0168 Introduction This proposal is a refinement of SE-0168 which introduces the ability to escape newlines in single and multi-line strings to improve readability and maintenance of source material containing excessively long lines. Swift-evolution thread: Discussion thread Motivation Escaping newlines in multi-line strings was removed from the SE-0168 proposal by the Core Team with the following rational: Discussion on the list raised the idea of allowing a line to end with to “escape” the newline and elide it from the value of the literal; the core team had concerns about only allowing that inside multi-line literals and felt that that could also be considered later as an additive feature. Adding them to multi-line strings would have introduced an inconsistency with respect to conventional string literals. This proposal conforms both multi-line and conventional string construction to allow newline escaping, enabling developers to split text over multiple source lines without introducing new line breaks. This approach enhances source legibility. For example: // Excessively long line that requires scrolling to read let text = &quot;&quot;&quot; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &quot;&quot;&quot; // Shorter lines that are easier to read, but represent the same long line let text = &quot;&quot;&quot; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &quot;&quot;&quot; Incorporating a string continuation character is well founded, used in other development languages, and carries little risk of confusing naive users. Detailed design This proposal introduces as a line continuation character which escapes newlines matching the following regular-expression: / [ t]* n/. In other terms, line continuation requires a character, followed by zero or more horizontal whitespace characters, followed by a newline character. All those characters are omitted from the resulting string. As a consequence, these rules follow: All whitespace characters between and the newline are disregarded. All whitespace characters before are included in the string as is. An escape character at the end of the last line of a literal is an error, as no newlines follow. For example: let str1 = &quot;&quot;&quot;↵ line one ↵ line two ↵ line three↵ &quot;&quot;&quot;↵ let str2 = &quot;line one ↵ line two ↵ line three&quot;↵ assert(str1 == &quot;line one line two line three&quot;) assert(str2 == &quot;line one line two line three&quot;) assert(str1 == str2) This does not affect the indentation removal feature of multiline strings and does not suggest that indentation removal should be added to conventional strings but it does give them consistent treatment. Source compatibility This proposal does not affect existing source, because it is purely additive - enabling syntax that is not currently allowed in Swift. Effect on ABI stability This proposal does not affect ABI stability. Effect on API resilience This proposal does not affect ABI resilience. Alternatives considered It has been heavily debated between the authors of the proposals whether newline escaping should be supported in single-line strings. One argument against it is that the lack of indentation stripping in single-line strings forces strings to include no indentation, hindering the readability of code by visually breaking scopes when returning the column 1: class Messager { let defaultMessage = &quot;This is a long string that will wrap over multiple lines. Because we don&#39;t strip indentation like with multi-line strings, the author has no choice but to remove all indentation.&quot; func send(message: String?) { precondition(message == nil || !message!.isEmpty, &quot;You can&#39;t send an empty message, it has no meaning.&quot;) print(message ?? defaultMessage) } } Another argument against it is that lines that are sufficiently long and/or complex could use multi-line string literals with newline escaping, so there is no need to include them in single quoted strings. A counter-argument is that it is important to keep single and triple quoted strings consistent with each other.",
    "url": "http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html",
    "relUrl": "/docs/2019-08-26-0182-newline-escape-in-strings.html"
  },
  "182": {
    "id": "182",
    "title": "SE-0183 Substring performance affordances",
    "content": "Substring performance affordances Proposal: SE-0183 Author: Ben Cohen Review Manager: Chris Lattner Status: Implemented (Swift 4) Decision Notes: Rationale Bug: SR-4933 Introduction This proposal modifies a small number of methods in the standard library that are commonly used with the Substring type: Modify the init on floating point and integer types, to construct them from StringProtocol rather than String. Change join to be an extension where Element: StringProtocol Have Substring.filter to return a String Motivation Swift 4 introduced Substring as the slice type for String. Previously, String had been its own slice type, but this leads to issues where string buffers can be unexpectedly retained. This approach was adopted instead of the alternative of having the slicing operation make a copy. A copying slicing operation would have negative performance consequences, and would also conflict with the requirement that Collection be sliceable in constant time. In cases where an API requires a String, the user must construct a new String from a Substring. This can be thought of as a “deferral” of the copy that was avoided at the time of the slice. There are a few places in the standard library where it is notably inefficient to force a copy of a substring in order to use it with a string: joining substrings, and converting substrings to integers. In particular, these operations are likely to be used inside a loop over a number of substrings extracted from a string – for example, splitting a string into substrings, then rejoining them. Additionally, per SE-163, operations on Substring that produce a fresh string (such as .uppercase) should return a String. This changes Substring.filter to do so. Proposed solution Add the following to the standard library: extension FixedWidthInteger { public init?&lt;S : StringProtocol&gt;(_ text: S, radix: Int = 10) } extension Float/Double/Float80 { public init?&lt;S : StringProtocol&gt;(_ text: S, radix: Int = 10) } extension Sequence where Element: StringProtocol { public func joined(separator: String = &quot;&quot;) -&gt; String } extension Substring { public func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; String } These additions are deliberately narrow in scope. They are not intended to solve a general problem of being able to interchange substrings for strings (or more generally slices for collections) generically in different APIs. See the alternatives considered section for more on this. Source compatibility No impact, these are generalizing an existing API to a protocol (in case of numeric conversion/joining) or modify a type newly introduced in Swift 4 (in case of filter). Effect on ABI stability The switch from conrete to generic types needs to be made before ABI stability. Alternatives considered The goal of this proposal is to generalize existing methods that are specific to string processing. Further affordances, such as implicit or explicit conversions of String to Substring, might solve this problem more generally but are considered out of scope for this proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html",
    "relUrl": "/docs/2019-08-26-0183-substring-affordances.html"
  },
  "183": {
    "id": "183",
    "title": "SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size",
    "content": "Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size Proposal: SE-0184 Author: Kelvin Ma (“Taylor Swift”) Review Manager: Doug Gregor Status: Implemented (Swift 4.1) Implementation: apple/swift#12200 Decision Notes: Rationale Introduction This document is a spin-off from a much larger original proposal, which covers only those aspects of SE-0184 which do not deal with partial buffer memory state. Designing the partial buffer memory state API clearly requires more work, and has been left out of the scope of this document. Swift’s pointer types are an important interface for low-level memory manipulation, but the current API design is not very consistent, complete, or convenient. In some places, poor naming choices and overengineered function signatures compromise memory safety by leading users to believe that they have allocated or freed memory when in fact, they have not. This proposal seeks to improve the Swift pointer API by ironing out naming inconsistencies, adding missing methods, and reducing excessive verbosity, offering a more convenient, more sensible, and less bug-prone API. Swift-evolution threads: Pitch: Improved Swift pointers, Pitch: More Improved Swift pointers Implementation branch: kelvin13:se-0184a Background There are four binary memorystate operations: initialization, move-initialization, assignment, and move-assignment, and two unary memorystate operations: deinitialization and type rebinding. The binary operations can be grouped according to how they affect the source buffer and the destination buffer. Copy operations only read from the source buffer, leaving it unchanged. Move operations deinitialize the source memory, decrementing the reference count by 1 if the memory type is not a trivial type. Retaining operations initialize the destination memory, incrementing the reference count by 1 if applicable. Releasing operations deinitialize the destination memory before reinitializing it with the new values, resulting in a net change in the reference count of 0, if applicable.   Copy (+0) Move (−1) Retaining (+1) initialize move-initialize Releasing (+0) assign move-assign Raw pointers also have a unique operation, bytewise-copying, which we will lump together with the memorystate functions, but does not actually change a pointer’s memory state. Most of these operations become more relevant in the discussion of partial buffer memory state, which is not in the scope of this document. This document only proposes changes related to memory allocation, type-rebinding, and two special unary forms of initialization and assignment which initialize memory to a fixed, repeating value. Motivation Right now, UnsafeMutableBufferPointer is kind of a black box when it comes to producing and modifying instances of it. Much of the API present on UnsafeMutablePointer is absent on its buffer variant. To create, bind, allocate, initialize, and deallocate them, you have to extract baseAddresses and counts. This is unfortunate because UnsafeMutableBufferPointer provides a handy container for tracking the size of a memory buffer, but to actually make use of this information, the buffer pointer must be disassembled. In practice, this means the use of memory buffers requires frequent (and annoying) conversion back and forth between buffer pointers and base address–count pairs. For example, buffer allocation requires the creation of a temporary UnsafeMutablePointer instance. This means that the following “idiom” is very common in Swift code: let buffer = UnsafeMutableBufferPointer&lt;UInt8&gt;(start: UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: byteCount), count: byteCount) Aside from being extremely long and unwieldy, and requiring the creation of a temporary, byteCount must appear twice. You can’t even cast buffer pointer types to their mutable or immutable forms without creating a temporary. var mutableBuffer = UnsafeMutableBufferPointer(start: UnsafeMutablePointer(mutating: immutableBuffer.baseAddress!), count: immutableBuffer.count) Currently, memory is deallocated by an instance method on UnsafeMutablePointer, deallocate(count:). Like much of the Swift pointer API, performing this operation on a buffer pointer requires extracting baseAddress! and count. It is very common for the allocation code above to be immediately followed by: defer { buffer.baseAddress?.deallocate(capacity: buffer.count) } The ? is sometimes exchanged with an ! depending on the personality of the author, as normally, neither operator is meaningful here — the baseAddress is never nil if the buffer pointer was created around an instance of UnsafeMutablePointer. This method is extremely problematic because nearly all users, on first seeing the signature of deallocate(capacity:), will naturally conclude from the capacity label that deallocate(capacity:) is equivalent to some kind of realloc() that can only shrink the buffer. However this is not the actual behavior — deallocate(capacity:) actually ignores the capacity argument and just calls free() on self. The current API is not only awkward and suboptimal, it is misleading. You can write perfectly legal Swift code that shouldn’t segfault, but still can, for example var ptr = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: 1000000) ptr.initialize(to: 13, count: 1000000) ptr.deallocate(capacity: 500000) // deallocate the second half of the memory block ptr[0] // segmentation fault where the first 500000 addresses should still be valid if the documentation is to be read literally. Users who are aware of this behavior may also choose to disregard the capacity argument and write things like this: defer { buffer.baseAddress?.deallocate(capacity: 42) } which is functionally equivalent. However this will lead to disastrous source breakage if the implementation of deallocate(capacity:) is ever “corrected”. Since the API would not change, such code would still compile, but suddenly start failing at runtime. Thus, the current API, combined with incorrect documentation, is serving as a vector for introducing memory bugs into Swift code. Finally, some of the naming choices in the current API deserve a second look. While the original API intended to introduce a naming convention where bytes refers to uninitialized memory, capacity to uninitialized elements, and count to initialized elements, the actual usage of the three words does not always agree. In copyBytes(from:count:), count refers to the number of bytes, which may or may not be initialized. Similarly, the UnsafeMutableRawBufferPointer allocate(count:) type method includes a count argument which actually refers to uninitialized bytes. The argument label to: is also excessively overloaded; sometimes it refers to a type T.Type, and sometimes it refers to a repeated value parameter. This becomes problematic when both parameters appear in the same method, as in initializeMemory&lt;T&gt;(as:at:count:to). Proposed solution The ultimate goal of the API redesign is to bring all of the functionality in UnsafeMutablePointer and UnsafeMutableRawPointer to their buffer types, UnsafeMutableBufferPointer and UnsafeMutableRawBufferPointer. Operations which are covered by this proposal are in bold. The full toolbox of methods that we could possibly support includes: allocation deallocation initialization move-initialization assignment move-assignment deinitialization type rebinding bytewise copying Because copy operations (initialization and assignment) don’t mutate the source argument, they can also come in a form which takes a repeated-value source instead of a buffer source. initialization (repeated-value) assignment (repeated-value) UnsafeMutablePointer and UnsafeMutableRawPointer already contain repeated-value methods for initialization in the form of initialize(to:count:) and initializeMemory&lt;T&gt;(as:at:count:to:). This proposal will add the assignment analogues. For reasons explained later, the argument label for the repeated-value parameter will be referred to as repeating:, not to:. UnsafePointer&lt;Pointee&gt; func deallocate() func withMemoryRebound&lt;T, Result&gt;(to:capacity:_:) -&gt; Result UnsafePointer does not get an allocator static method, since you almost always want a mutable pointer to newly allocated memory. Its type rebinding method is also written as a decorator, taking a trailing closure, for memory safety. Most immutable pointer types currently do not have a deallocation method. This proposal adds them, fixing SR-3309. Note, immutable raw buffer pointers already support this API. UnsafeMutablePointer&lt;Pointee&gt; static func allocate&lt;Pointee&gt;(capacity:) -&gt; UnsafeMutablePointer&lt;Pointee&gt; func deallocate() func initialize(repeating:count:) func initialize(to:) func assign(repeating:count:) func withMemoryRebound&lt;T, Result&gt;(to:capacity:_:) -&gt; Result Like UnsafePointer, UnsafeMutablePointer’s type rebinding method is written as a decorator. Previously, the single-element repeated-initialization case was supported by a default argument of 1 on initialize(repeating:count:)’s count: parameter, but it was decided this was too confusing in terms of API readability. For example, calls to initialize(repeating:count:) and its corresponding method on UnsafeMutableBufferPointer were prone to look the same. plainPointer.initialize(repeating: pointee) bufferPointer.initialize(repeating: repeatedValue) Increasing API surface by adding this method is justified by the large number of calls to initialize(to:count:) in the standard library (and likely other code) which rely on the default argument of 1. We do not need to add a corresponding assignPointee(to:) method since this can be done with the assignment operator. ptr.pointee = newValue UnsafeRawPointer func deallocate() func bindMemory&lt;T&gt;(to:capacity:) -&gt; UnsafePointer&lt;T&gt; UnsafeMutableRawPointer static func allocate(byteCount:alignment:) -&gt; UnsafeMutableRawPointer func deallocate() func initializeMemory&lt;T&gt;(as:repeating:count:) -&gt; UnsafeMutablePointer&lt;T&gt; func bindMemory&lt;T&gt;(to:capacity:) -&gt; UnsafeMutablePointer&lt;T&gt; Currently, UnsafeMutableRawPointer’s methods take an at: offset argument that is interpreted in strides. This argument is not currently in use in the entire Swift standard library, and we believe that it is not useful in practice. Unlike UnsafeMutablePointer, we do not add a single-instance initialize method to UnsafeMutableRawPointer, as such a method would probably not be useful. However, we still remove the default argument of 1 from the count: argument in initializeMemory&lt;T&gt;(as:repeating:count:) to prevent confusion with calls to its buffer variant. UnsafeBufferPointer&lt;Element&gt; func deallocate() func withMemoryRebound&lt;T, Result&gt;(to:_:) -&gt; Result The buffer type rebind method dynamically computes the new count by performing multiplication and integer division, since the target type may have a different stride than the original type. This is in line with existing precedent in the generic buffer method initializeMemory&lt;S&gt;(as:from:) on UnsafeMutableRawBufferPointer. Note: calling deallocate() on a buffer pointer is only defined behavior if the buffer pointer references a complete heap memory block. This operation may become supported in a wider variety of cases in the future if Swift gets a more sophisticated heap allocation backend. UnsafeMutableBufferPointer&lt;Element&gt; static func allocate&lt;Element&gt;(capacity:) -&gt; UnsafeMutableBufferPointer&lt;Element&gt; func deallocate() func initialize(repeating:) func assign(repeating:) func withMemoryRebound&lt;T, Result&gt;(to:_:) -&gt; Result The buffer type rebind method works the same way as in UnsafeBufferPointer. (Type rebinding never cares about mutability.) UnsafeRawBufferPointer func deallocate() func bindMemory&lt;T&gt;(to:) -&gt; UnsafeBufferPointer&lt;T&gt; UnsafeMutableRawBufferPointer static func allocate(byteCount:alignment:) -&gt; UnsafeMutableRawBufferPointer func deallocate() func initializeMemory&lt;T&gt;(as:repeating:) -&gt; UnsafeMutableBufferPointer&lt;T&gt; func bindMemory&lt;T&gt;(to:) -&gt; UnsafeMutableBufferPointer&lt;T&gt; note: initializeMemory(as:repeating:) performs integer division on self.count (just like bindMemory(to:)) note: the return value of initializeMemory(as:repeating:) should be marked as @discardableResult. We also make several miscellaneous changes to the API in order to tidy things up. rename copyBytes(from:count:) and copyBytes(from:) to copyMemory(from:byteCount:) and copyMemory(from:) This brings the method names in line with the rest of the raw pointer API. add an init(mutating:) initializer to UnsafeMutableBufferPointer This makes it much easier to make a mutable copy of an immutable buffer pointer. Such an initializer already exists on UnsafeMutableRawBufferPointer, so adding one to UnsafeMutableBufferPointer is also necessary for consistency. The reverse initializer, from UnsafeMutableBufferPointer to UnsafeBufferPointer should also be added for completeness. deprecate the sized deallocation API Removing capacity from deallocate(capacity:) will end the confusion over what deallocate() does, making it obvious that deallocate() will free the entire memory block at self, just as if free() were called on it. The old deallocate(capacity:) method should be marked as deprecated and eventually removed since it currently encourages dangerously incorrect code. This avoids misleading future users, encourages current users to address this potentially catastrophic memory bug, and leaves the possibility open for us to add a deallocate(capacity:) method in the future, or perhaps even a reallocate(toCapacity:) method. Along similar lines, the bytes and alignedTo parameters should be removed from the deallocate(bytes:alignedTo:) method on UnsafeMutableRawPointer and UnsafeRawPointer. As discussed earlier, an unsized deallocate() method should be added to all pointer types, even immutable ones, as Swift’s memory model does not require memory to be mutable for deallocation. note: the deallocation size parameters were originally included in early versions of Swift in order to support a more sophisticated hypothetical heap allocator backend that we wanted to have in the future. (Swift currently calls malloc(_:) and free().) While such a backend would theoretically run more efficiently than the C backend, overengineering Swift to support it in the future has proven to be a detriment to users right now. By removing the size parameters now, we make it easier and safer to reintroduce such an API in the future without inadvertently causing silent source breakage. note: changes to deallocation methods are not listed in the type-by-type overview below. All items in the following list are either non-source breaking, or trivially automigratable. UnsafePointer&lt;Pointee&gt; Existing methods func withMemoryRebound&lt;T, Result&gt;(to:capacity:_:) -&gt; Result New methods +++ func deallocate() UnsafeMutablePointer&lt;Pointee&gt; Existing methods static func allocate&lt;Pointee&gt;(capacity:) -&gt; UnsafeMutablePointer&lt;Pointee&gt; func withMemoryRebound&lt;T, Result&gt;(to:capacity:_:) -&gt; Result Renamed methods func initialize(to:count:) +++ func initialize(repeating:count:) New methods +++ func deallocate() +++ func initialize(to:) +++ func assign(repeating:count:) UnsafeRawPointer Existing methods func bindMemory&lt;T&gt;(to:capacity:) -&gt; UnsafePointer&lt;T&gt; New methods +++ func deallocate() UnsafeMutableRawPointer Existing methods func bindMemory&lt;T&gt;(to:capacity:) -&gt; UnsafeMutablePointer&lt;T&gt; New methods +++ func deallocate() Renamed methods and dropped arguments static func allocate(bytes:alignedTo:) -&gt; UnsafeMutableRawPointer +++ static +++ func allocate(byteCount:alignment:) -&gt; UnsafeMutableRawPointer func initializeMemory&lt;T&gt;(as:at:count:to:) -&gt; UnsafeMutablePointer&lt;T&gt; +++ func initializeMemory&lt;T&gt;(as:repeating:count:) -&gt; UnsafeMutablePointer&lt;T&gt; func copyBytes(from:count:) +++ func copyMemory(from:byteCount:) UnsafeBufferPointer&lt;Element&gt; New methods +++ func deallocate() +++ withMemoryRebound&lt;T, Result&gt;(to:_:) -&gt; Result UnsafeMutableBufferPointer&lt;Element&gt; New methods +++ static +++ func allocate&lt;Element&gt;(capacity:) -&gt; UnsafeMutableBufferPointer&lt;Element&gt; +++ func deallocate() +++ func initialize(repeating:) +++ func assign(repeating:) +++ func withMemoryRebound&lt;T, Result&gt;(to:_:) -&gt; Result UnsafeRawBufferPointer Existing methods deallocate() New methods +++ func bindMemory&lt;T&gt;(to:) -&gt; UnsafeBufferPointer&lt;T&gt; UnsafeMutableRawBufferPointer Existing methods deallocate() Renamed methods and new/renamed arguments static func allocate(count:) -&gt; UnsafeMutableRawBufferPointer +++ static +++ func allocate(byteCount:alignment:) -&gt; UnsafeMutableRawBufferPointer func copyBytes(from:) +++ func copyMemory(from:) New methods +++ func initializeMemory&lt;T&gt;(as:repeating:) -&gt; UnsafeMutableBufferPointer&lt;T&gt; +++ func bindMemory&lt;T&gt;(to:) -&gt; UnsafeMutableBufferPointer&lt;T&gt; What this proposal does not do attempt to fully partial initialization This proposal does not attempt to fill in most of the memory state APIs for buffer pointers, as doing so necessitates designing a partial initialization system, as well as a possible buffer slice rework. address problems relating to the generic Sequence buffer API Buffer pointers are currently missing generic assign&lt;S&gt;(from:S) and initializeMemory&lt;S&gt;(as:S.Element.Type, from:S) methods. The existing protocol oriented API also lacks polish and is inconvenient to use. (For example, it returns tuples.) This is an issue that can be tackled separately from the lower-level buffer-pointer-to-buffer-pointer API. Detailed design struct UnsafePointer&lt;Pointee&gt; { +++ func deallocate() func withMemoryRebound&lt;T, Result&gt;(to:T.Type, capacity:Int, _ body:(UnsafePointer&lt;T&gt;) -&gt; Result) -&gt; Result } struct UnsafeMutablePointer&lt;Pointee&gt; { static func allocate&lt;Pointee&gt;(capacity:Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt; func deallocate(capacity:Int) +++ func deallocate() func initialize(to:Pointee, count:Int = 1) +++ func initialize(repeating:Pointee, count:Int) +++ func initialize(to:Pointee) func initialize(from:UnsafePointer&lt;Pointee&gt;, count:Int) func moveInitialize(from:UnsafeMutablePointer&lt;Pointee&gt;, count:Int) +++ func assign(repeating:Pointee, count:Int) func assign(from:UnsafePointer&lt;Pointee&gt;, count:Int) func moveAssign(from:UnsafeMutablePointer&lt;Pointee&gt;, count:Int) func deinitialize(count:Int) func withMemoryRebound&lt;T, Result&gt;(to:T.Type, capacity:Int, _ body:(UnsafeMutablePointer&lt;T&gt;) -&gt; Result) -&gt; Result } struct UnsafeRawPointer { func deallocate(bytes:Int, alignedTo:Int) +++ func deallocate() func bindMemory&lt;T&gt;(to:T.Type, count:Int) -&gt; UnsafeMutablePointer&lt;T&gt; } struct UnsafeMutableRawPointer { static func allocate(bytes:Int, alignedTo:Int) -&gt; UnsafeMutableRawPointer +++ static +++ func allocate(byteCount:Int, alignment:Int) -&gt; UnsafeMutableRawPointer func deallocate(bytes:Int, alignedTo:Int) +++ func deallocate() func initializeMemory&lt;T&gt;(as:T.Type, at:Int = 0, count:Int = 1, to:T) -&gt; UnsafeMutablePointer&lt;T&gt; +++ func initializeMemory&lt;T&gt;(as:T.Type, repeating:T, count:Int) -&gt; UnsafeMutablePointer&lt;T&gt; func initializeMemory&lt;T&gt;(as:T.Type, from:UnsafePointer&lt;T&gt;, count:Int) -&gt; UnsafeMutablePointer&lt;T&gt; func moveInitializeMemory&lt;T&gt;(as:T.Type, from:UnsafeMutablePointer&lt;T&gt;, count:Int) -&gt; UnsafeMutablePointer&lt;T&gt; func bindMemory&lt;T&gt;(to:T.Type, count:Int) -&gt; UnsafeMutablePointer&lt;T&gt; func copyBytes(from:UnsafeRawPointer, count:Int) +++ func copyMemory(from:UnsafeRawPointer, byteCount:Int) } struct UnsafeBufferPointer&lt;Element&gt; { +++ init(_:UnsafeMutableBufferPointer&lt;Element&gt;) +++ func deallocate() +++ func withMemoryRebound&lt;T, Result&gt; +++ (to:T.Type, _ body:(UnsafeBufferPointer&lt;T&gt;) -&gt; Result) } struct UnsafeMutableBufferPointer&lt;Element&gt; { +++ init(mutating:UnsafeBufferPointer&lt;Element&gt;) +++ static +++ func allocate&lt;Element&gt;(capacity:Int) -&gt; UnsafeMutableBufferPointer&lt;Element&gt; +++ func initialize(repeating:Element) +++ func assign(repeating:Element) +++ func withMemoryRebound&lt;T, Result&gt; +++ (to:T.Type, _ body:(UnsafeMutableBufferPointer&lt;T&gt;) -&gt; Result) } struct UnsafeRawBufferPointer { func deallocate() +++ func bindMemory&lt;T&gt;(to:T.Type) -&gt; UnsafeBufferPointer&lt;T&gt; } struct UnsafeMutableRawBufferPointer { static func allocate(count:Int) -&gt; UnsafeMutableRawBufferPointer +++ static func allocate(byteCount:Int, alignment:Int) -&gt; UnsafeMutableRawBufferPointer func deallocate() +++ func initializeMemory&lt;T&gt;(as:T.Type, repeating:T) -&gt; UnsafeMutableBufferPointer&lt;T&gt; +++ func bindMemory&lt;T&gt;(to:T.Type) -&gt; UnsafeMutableBufferPointer&lt;T&gt; func copyBytes(from:UnsafeRawBufferPointer) +++ func copyMemory(from:UnsafeRawBufferPointer) } Source compatibility Everything is additive except the following. Can we deprecate all of the original functions in Swift 5, then drop those from the binary later in Swift 6? add deallocate() to all pointer types, replacing any existing deallocation methods The migrator needs to drop the existing capacity and alignedTo arguments. in UnsafeMutableRawPointer.allocate(count:alignedTo:) rename count to byteCount and alignedTo to alignment in UnsafeMutableRawBufferPointer.allocate(count:) rename count to byteCount and add an alignment parameter This change is source breaking but can be trivially automigrated. The alignment: parameter can be filled in with MemoryLayout&lt;UInt&gt;.stride. fix the arguments to initialize(repeating:Pointee, count:Int) Note: initialize(to:Pointee) is backward compatible whenever the caller relied on a default count = 1. An annotation could otherwise rename to to repeating, but we don’t want that to interfere with the default count case, so this might need to be a migrator rule. fix the ordering of the arguments in initializeMemory&lt;Element&gt;(as:at:count:to:), rename to: to repeating:, and remove the at: argument This change is source breaking but can be trivially automigrated. The to argument changes position and is relabeled as repeating. The migrator could be taught to convert the at: argument into pointer arithmetic on self. However, we found no code on Github that uses the at: argument, so it is low priority. rename copyBytes(from:count:) to copyMemory(from:byteCount:) This change is source breaking but can be trivially automigrated. Effect on ABI stability Removing sized deallocators changes the existing ABI, as will renaming some of the methods and their argument labels. Effect on API resilience Some proposed changes in this proposal change the public API. Removing sized deallocators right now will break ABI, but offers increased ABI and API stability in the future as reallocator methods can be added in the future without having to rename deallocate(capacity:) which currently occupies a “reallocator” name, but has “free()” behavior. Alternatives considered keeping sized deallocators and fixing the stdlib implementation instead Instead of dropping the capacity parameter from deallocate(capacity:), we could fix the underlying implementation so that the function actually deallocates capacity’s worth of memory. However this would be catastrophically, and silently, source-breaking as existing code would continue compiling, but suddenly start leaking or segfaulting at runtime. deallocate(capacity:) can always be added back at a later date without breaking ABI or API, once users have been forced to address this potential bug. adding an initializer UnsafeMutableBufferPointer&lt;Element&gt;.init(allocatingCount:) instead of a type method to UnsafeMutableBufferPointer The allocator could be expressed as an initializer instead of a type method. However since allocation involves acquisition of an external resource, perhaps it is better to keep with the existing convention that allocation is performed differently than regular buffer pointer construction. using the argument label value: instead of repeating: in methods such as initialize(repeating:count:) (originally initialize(to:count:)) The label value: or toValue: doesn’t fully capture the repeating nature of the argument, and is inconsistent with Array.init(repeating:count:). While value: sounds less strange when count == 1, on consistency and technical correctness, repeating: is the better term. Furthermore, value is a common variable name, meaning that function calls with value: as the label would be prone to looking like this: ptr.initialize(value: value)",
    "url": "http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html",
    "relUrl": "/docs/2019-08-26-0184-unsafe-pointers-add-missing.html"
  },
  "184": {
    "id": "184",
    "title": "SE-0185 Synthesizing `Equatable` and `Hashable` conformance",
    "content": "Synthesizing Equatable and Hashable conformance Proposal: SE-0185 Author: Tony Allevato Review Manager: Chris Lattner Status: Implemented (Swift 4.1) Implementation: apple/swift#9619 Decision Notes: Rationale Introduction Developers have to write large amounts of boilerplate code to support equatability and hashability of complex types. This proposal offers a way for the compiler to automatically synthesize conformance to Equatable and Hashable to reduce this boilerplate, in a subset of scenarios where generating the correct implementation is known to be possible. Swift-evolution thread: Universal Equatability, Hashability, and Comparability Motivation Building robust types in Swift can involve writing significant boilerplate code to support hashability and equatability. By eliminating the complexity for the users, we make Equatable/Hashable types much more appealing to users and allow them to use their own types in contexts that require equatability and hashability with no added effort on their part (beyond declaring the conformance). Equality is pervasive across many types, and for each one users must implement the == operator such that it performs a fairly rote memberwise equality test. As an example, an equality test for a basic struct is fairly uninteresting: struct Person: Equatable { static func == (lhs: Person, rhs: Person) -&gt; Bool { return lhs.firstName == rhs.firstName &amp;&amp; lhs.lastName == rhs.lastName &amp;&amp; lhs.birthDate == rhs.birthDate &amp;&amp; ... } } What’s worse is that this operator must be updated if any properties are added, removed, or changed, and since it must be manually written, it’s possible to get it wrong, either by omission or typographical error. Likewise, hashability is necessary when one wishes to store a type in a Set or use one as a multi-valued Dictionary key. Writing high-quality, well-distributed hash functions is not trivial so developers may not put a great deal of thought into them—especially as the number of properties increases—not realizing that their performance could potentially suffer as a result. And as with equality, writing it manually means there is the potential for it to not only be inefficient, but incorrect as well. In particular, the code that must be written to implement equality for enums is quite verbose: enum Token: Equatable { case string(String) case number(Int) case lparen case rparen static func == (lhs: Token, rhs: Token) -&gt; Bool { switch (lhs, rhs) { case (.string(let lhsString), .string(let rhsString)): return lhsString == rhsString case (.number(let lhsNumber), .number(let rhsNumber)): return lhsNumber == rhsNumber case (.lparen, .lparen), (.rparen, .rparen): return true default: return false } } } Crafting a high-quality hash function for this enum would be similarly inconvenient to write. Swift already derives Equatable and Hashable conformance for a small subset of enums: those for which the cases have no associated values (which includes enums with raw types). Two instances of such an enum are equal if they are the same case, and an instance’s hash value is its ordinal: enum Foo { case zero, one, two } let x = (Foo.one == Foo.two) // evaluates to false let y = Foo.one.hashValue // evaluates to 1 Likewise, conformance to RawRepresentable is automatically derived for enums with a raw type, and the recently approved Encodable/Decodable protocols also support synthesis of their operations when possible. Since there is precedent for synthesized conformances in Swift, we propose extending it to these fundamental protocols. Proposed solution In general, we propose that a type synthesize conformance to Equatable/Hashable if all of its members are Equatable/Hashable. We describe the specific conditions under which these conformances are synthesized below, followed by the details of how the conformance requirements are implemented. Requesting synthesis is opt-in Users must opt-in to automatic synthesis by declaring their type as Equatable or Hashable without implementing any of their requirements. This conformance must be part of the original type declaration or in an extension in the same file (to ensure that private and fileprivate members can be accessed from the extension). Any type that declares such conformance and satisfies the conditions below will cause the compiler to synthesize an implementation of ==/hashValue for that type. Making the synthesis opt-in—as opposed to automatic derivation without an explicit declaration—provides a number of benefits: The syntax for opting in is natural; there is no clear analogue in Swift today for having a type opt out of a feature. It requires users to make a conscious decision about the public API surfaced by their types. Types cannot accidentally “fall into” conformances that the user does not wish them to; a type that does not initially support Equatable can be made to at a later date, but the reverse is a breaking change. The conformances supported by a type can be clearly seen by examining its source code; nothing is hidden from the user. We reduce the work done by the compiler and the amount of code generated by not synthesizing conformances that are not desired and not used. As will be discussed later, explicit conformance significantly simplifies the implementation for recursive types. There is one exception to this rule: the current behavior will be preserved that enum types with cases that have no associated values (including those with raw values) conform to Equatable/Hashable without the user explicitly declaring those conformances. While this does add some inconsistency to enums under this proposal, changing this existing behavior would be source-breaking. The question of whether such enums should be required to opt-in as well can be revisited at a later date if so desired. Synthesis is supported in same-file extensions to ensure that generic types can synthesize a conditional conformance, since the properties may only satisfy the requirements for synthesis (see below) with extra bounds: struct Bad&lt;T&gt;: Equatable { // synthesis not possible, T is not Equatable var x: T } struct Good&lt;T&gt; { var x: T } extension Good: Equatable where T: Equatable {} // synthesis works, T is Equatable Overriding synthesized conformances Any user-provided implementations of == or hashValue will override the default implementations that would be provided by the compiler. Conditions where synthesis is allowed For brevity, let P represent either the protocol Equatable or Hashable in the descriptions below. Synthesized requirements for enums For an enum, synthesis of P’s requirements is based on the conformances of its cases’ associated values. Computed properties are not considered. The following rules determine whether P’s requirements can be synthesized for an enum: The compiler does not synthesize P’s requirements for an enum with no cases because it is not possible to create instances of such types. The compiler synthesizes P’s requirements for an enum with one or more cases if and only if all of the associated values of all of its cases conform to P. Synthesized requirements for structs For a struct, synthesis of P’s requirements is based on the conformances of only its stored instance properties. Neither static properties nor computed instance properties (those with custom getters) are considered. The following rules determine whether P’s requirements can be synthesized for a struct: The compiler trivially synthesizes P’s requirements for a struct with no stored properties. (All instances of a struct with no stored properties can be considered equal and hash to the same value if the user opts in to this.) The compiler synthesizes P’s requirements for a struct with one or more stored properties if and only if all of the types of all of its stored properties conform to P. Considerations for recursive types By making the synthesized conformances opt-in, recursive types have their requirements fall into place with no extra effort. In any cycle belonging to a recursive type, every type in that cycle must declare its conformance explicitly. If a type does so but cannot have its conformance synthesized because it does not satisfy the conditions above, then it is simply an error for that type and not something that must be detected earlier by the compiler in order to reason about all the other types involved in the cycle. (On the other hand, if conformance were implicit, the compiler would have to fully traverse the entire cycle to determine eligibility, which would make implementation much more complex). Implementation details An enum T: Equatable that satisfies the conditions above will receive a synthesized implementation of static func == (lhs: T, rhs: T) -&gt; Bool that returns true if and only if lhs and rhs are the same case and have payloads that are memberwise-equal. An enum T: Hashable that satisfies the conditions above will receive a synthesized implementation of var hashValue: Int { get } that uses an unspecified hash function† to compute the hash value by incorporating the case’s ordinal (i.e., definition order) followed by the hash values of its associated values as its terms, also in definition order. A struct T: Equatable that satisfies the conditions above will receive a synthesized implementation of static func == (lhs: T, rhs: T) -&gt; Bool that returns true if and only if lhs.x == rhs.x for all stored properties x in T. If the struct has no stored properties, this operator simply returns true. A struct T: Hashable that satisfies the conditions above will receive a synthesized implementation of var hashValue: Int { get } that uses an unspecified hash function† to compute the hash value by incorporating the hash values of the fields as its terms, in definition order. If the struct has no stored properties, this property evaluates to a fixed value not specified here. † The choice of hash function is left as an implementation detail, not a fixed part of the design; as such, users should not depend on specific characteristics of its behavior. The most likely implementation would call the standard library’s _mixInt function on each member’s hash value and then combine them with exclusive-or (^), which mirrors the way Collection types are hashed today. Source compatibility By making the conformance opt-in, this is a purely additive change that does not affect existing code. We also avoid source-breaking changes by not changing the behavior for enums with no associated values, which will continue to implicitly conform to Equatable and Hashable even without explicitly declaring the conformance. Effect on ABI stability This feature is purely additive and does not change ABI. Effect on API resilience N/A. Alternatives considered In order to realistically scope this proposal, we considered but ultimately deferred the following items, some of which could be proposed additively in the future. Synthesis for class types and tuples We do not synthesize conformances for class types. The conditions above become more complicated in inheritance hierarchies, and equality requires that static func == be implemented in terms of an overridable instance method for it to be dispatched dynamically. Even for final classes, the conditions are not as clear-cut as they are for value types because we have to take superclass behavior into consideration. Finally, since objects have reference identity, memberwise equality may not necessarily imply that two instances are equal. We do not synthesize conformances for tuples at this time. While this would nicely round out the capabilities of value types, allow the standard library to remove the hand-crafted implementations of == for up-to-arity-6 tuples, and allow those types to be used in generic contexts where Equatable conformance is required, adding conformances to non-nominal types would require additional work. Omitting fields from synthesized conformances Some commenters have expressed a desire to tag certain properties of a struct from being included in automatically generated equality tests or hash value computations. This could be valuable, for example, if a property is merely used as an internal cache and does not actually contribute to the “value” of the instance. Under the rules above, if this cached value was equatable, a user would have to override == and hashValue and provide their own implementations to ignore it. Such a feature, which could be implemented with an attribute such as @transient, would likely also play a role in other protocols like Encodable/Decodable. This could be done as a purely additive change on top of this proposal, so we propose not doing this at this time. Implicit derivation An earlier draft of this proposal made derived conformances implicit (without declaring Equatable/Hashable explicitly). This has been changed because—in addition to the reasons mentioned earlier in the proposal—Encodable/Decodable provide a precedent for having the conformance be explicit. More importantly, however, determining derivability for recursive types is significantly more difficult if conformance is implicit, because it requires examining the entire dependency graph for a particular type and to properly handle cycles in order to decide if the conditions are satisfied. Support for Comparable The original discussion thread also included Comparable as a candidate for automatic generation. Unlike equatability and hashability, however, comparability requires an ordering among the members being compared. Automatically using the definition order here might be too surprising for users, but worse, it also means that reordering properties in the source code changes the code’s behavior at runtime. (This is true for hashability as well if a multiplicative hash function is used, but hash values are not intended to be persistent and reordering the terms does not produce a significant behavioral change.) Acknowledgments Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo Jimenez for providing great real-world examples of boilerplate needed to support equatability for some value types, Mark Sands for necromancing the swift-evolution thread that convinced me to write this up, and everyone on swift-evolution since then for giving me feedback on earlier drafts.",
    "url": "http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html",
    "relUrl": "/docs/2019-08-26-0185-synthesize-equatable-hashable.html"
  },
  "185": {
    "id": "185",
    "title": "SE-0186 Remove ownership keyword support in protocols",
    "content": "Remove ownership keyword support in protocols Proposal: SE-0186 Author: Greg Spiers Review Manager: Ted Kremenek Status: Implemented (Swift 4.1) Implementation: apple/swift#11744 Review thread on swift-evolution Bug: SR-479 Decision Notes: Rationale Introduction This proposal removes support for the keywords weak and unowned for property declarations in a protocol. Swift-evolution thread: Ownership on protocol property requirements thread. Motivation Currently it’s possible to use the weak/unowned keywords for a property requirement in a protocol. This can lead to confusion as specifying one of these keywords does not enforce or raise any warnings in the adopting type of that protocol: class A {} protocol P { weak var weakVar: A? { get set } } class B: P { var weakVar: A? // Not declared weak, no compiler warning/error } This can lead to unexpected and surprising behaviour from the point of view of users. The keywords themselves are currently meaningless inside of a protocol but look like they would have an effect when the protocol is adopted. This change is consistent with removing keywords that do not have any meaning like final in protocol extensions: SE-0164. Proposed solution Although the case could be made that the keywords should have meaning in a protocol, as they are currently implemented today they don’t have an effect. This proposal aims to cleanup the misleading syntax and isn’t meant to remove functionality only correct to existing behaviour. This proposal suggests removing support for weak and unowned in a protocol. Detailed design In existing Swift modes, 3 and 4, the compiler will warn about the use of weak and unowned in a protocol and suggest a fix to remove the keywords. In Swift 5 mode the compiler will error and offer a fixit to remove the keywords. Source compatibility This is a source breaking change but one that would only correct code that already has broken assumptions. For existing Swift modes, 3 and 4, the compiler will raise a compilation warning instead of an error. Effect on ABI stability This proposal does not affect ABI stability. Effect on API resilience This proposal does not affect API resilience. Alternatives considered There is an argument in making weak and unowned have meaning in a protocol but this does open up other questions and is probably better as a topic of a separate discussion/proposal. As this would be additive it can be addressed at a later point when we have a clearer understanding.",
    "url": "http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html",
    "relUrl": "/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html"
  },
  "186": {
    "id": "186",
    "title": "SE-0187 Introduce Sequence.compactMap(_:)",
    "content": "Introduce Sequence.compactMap(_:) Proposal: SE-0187 Author: Max Moiseev Review Manager: John McCall Status: Implemented (Swift 4.1) Implementation: apple/swift#12819 Decision Notes: Review #0, Review #1, Review #2, Rationale Previous Revision: 1 Introduction We propose to deprecate the controversial version of a Sequence.flatMap method and provide the same functionality under a different, and potentially more descriptive, name. Motivation The Swift standard library currently defines 3 distinct overloads for flatMap: Sequence.flatMap&lt;S&gt;(_: (Element) -&gt; S) -&gt; [S.Element] where S : Sequence Optional.flatMap&lt;U&gt;(_: (Wrapped) -&gt; U?) -&gt; U? Sequence.flatMap&lt;U&gt;(_: (Element) -&gt; U?) -&gt; [U] The last one, despite being useful in certain situations, can be (and often is) misused. Consider the following snippet: struct Person { var age: Int var name: String } func getAges(people: [Person]) -&gt; [Int] { return people.flatMap { $0.age } } What happens inside getAges is: thanks to the implicit promotion to Optional, the result of the closure gets wrapped into a .some, then immediately unwrapped by the implementation of flatMap, and appended to the result array. All this unnecessary wrapping and unwrapping can be easily avoided by just using map instead. func getAges(people: [Person]) -&gt; [Int] { return people.map { $0.age } } It gets even worse when we consider future code modifications, like the one where Swift 4 introduced a String conformance to the Collection protocol. The following code used to compile (due to the flatMap overload in question). func getNames(people: [Person]) -&gt; [String] { return people.flatMap { $0.name } } But it no longer does, because now there is a better overload that does not involve implicit promotion. In this particular case, the compiler error would be obvious, as it would point at the same line where flatMap is used. Imagine however if it was just a let names = people.flatMap { $0.name } statement, and the names variable were used elsewhere. The compiler error would be misleading. Proposed solution We propose to deprecate the controversial overload of flatMap and re-introduce the same functionality under a new name. The name being compactMap(_:) as we believe it best describes the intent of this function. For reference, here are the alternative names from other languages: Haskell, Idris  mapMaybe :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b] Ocaml (Core and Batteries)  filter_map : &#39;a t -&gt; f:(&#39;a -&gt; &#39;b option) -&gt; &#39;b t F#  List.choose : (&#39;T -&gt; &#39;U option) -&gt; &#39;T list -&gt; &#39;U list Rust  fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt;  where F: FnMut(Self::Item) -&gt; Option&lt;B&gt; Scala  def collect[B](pf: PartialFunction[A, B]): List[B] Filtering nil elements from the Sequence is very common, therefore we also propose adding a Sequence.compact() function. This function should only be available for sequences of optional elements, which is not expressible in current Swift syntax. Until we have the missing features, using xs.compactMap { $0 } is an option. Source compatibility Since the old function will still be available (although deprecated) all the existing code will compile, producing a deprecation warning and a fix-it. Effect on ABI stability This is an additive API change, and does not affect ABI stability. Effect on API resilience Ideally, the deprecated flatMap overload would not exist at the time when ABI stability is declared, but in the worst case, it will be available in a deprecated form from a library post-ABI stability. Alternatives considered It was attempted in the past to warn about this kind of misuse and do the right thing instead by means of a deprecated overload with a non-optional-returning closure. The attempt failed due to another implicit promotion (this time to Any). The following alternative names for this function were considered: mapNonNil(_:)  Does not communicate what happens to nil’s mapSome(_:)  Reads more like «map some elements of the sequence, but not the others» rather than «process only the ones that produce an Optional.some» filterMap(_:) Considered confusing, due to similarity with filter, but without any control over what gets filtered out. Besides, even though it can be implemented as a series of calls to filter and map, the order of these calls is different from what the filterMap name suggests.",
    "url": "http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html",
    "relUrl": "/docs/2019-08-26-0187-introduce-filtermap.html"
  },
  "187": {
    "id": "187",
    "title": "SE-0188 Make Standard Library Index Types Hashable",
    "content": "Make Standard Library Index Types Hashable Proposal: SE-0188 Author: Nate Cook Review Manager: Ben Cohen Status: Implemented (Swift 4.1) Implementation: apple/swift#12777 Introduction Key-path expressions can now include subscripts to reference individual positions in collections and other subscriptable types, but only when the subscript parameters are Hashable. To provide maximum utility, the standard library index types should all have Hashable conformance added. Swift-evolution “thread:” [draft] Make Standard Library Index Types Hashable Motivation You can only use subscripts in key-path expressions when the subscript parameter type is Hashable. This means that you can use a subscript as part of a key-path expression with an array, which uses Int as its index type, but not with a string, which uses a custom index type. let numbers = [10, 20, 30, 40, 50] let firstValue = [Int].[0] print(numbers[keyPath: firstValue]) // 10 let string = &quot;Helloooo!&quot; let firstChar = String.[string.startIndex] // error: subscript index of type &#39;String.Index&#39; in a key path must be Hashable Proposed solution This proposal would add Hashable conformance to all the index types in the standard library. With that done, [Int], String, and all other standard libary collections would have the same behavior when using subscripts in key paths. Detailed design For index types that wrap an internal offset or other value, adding Hashable conformance will be simple. For index types that wrap another index type, such as ReversedIndex, Hashable conformance must wait until the implementation of conditional conformance is complete. This is the breakdown of the standard library’s index types: Simple Index Types Int (already Hashable) Dictionary.Index Set.Index String.Index Wrapping Index Types ClosedRangeIndex FlattenCollectionIndex LazyDropWhileIndex LazyFilterIndex LazyPrefixWhileIndex ReversedIndex AnyIndex, which type erases any index type at run-time, would not be hashable since it might wrap a non-hashable type. Source compatibility This is an additive change in the behavior of standard library index types, so it should pose no source compatibility burden. Specifically, this proposal does not change the requirements for an index type in the Collection protocol, so collections and custom index types that have been written in prior versions of Swift will be unaffected. Effect on ABI stability &amp; API resilience Beyond an additional conformance for the types mentioned above, this proposal has no effect on ABI stability or API resilience. Alternatives considered None.",
    "url": "http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html",
    "relUrl": "/docs/2019-08-26-0188-stdlib-index-types-hashable.html"
  },
  "188": {
    "id": "188",
    "title": "SE-0189 Restrict Cross-module Struct Initializers",
    "content": "Restrict Cross-module Struct Initializers Proposal: SE-0189 Author: Jordan Rose Review Manager: Ted Kremenek Status: Implemented (Swift 4.1) Implementation: apple/swift#12834 Pre-review discussion: Restrict Cross-module Struct Initializers Swift Evolution Review Thread Decision Notes: Rationale Introduction Adding a property to a public struct in Swift ought to not be a source-breaking change. However, a client in another target can currently extend a struct with a new initializer that directly initializes the struct’s fields. This proposal forbids that, requiring any cross-target initializers to use self.init(…) or assign to self instead. This matches an existing restriction for classes, where cross-module initializers must be convenience initializers. Motivation Swift structs are designed to be flexible, allowing library authors to change their implementation between releases. This goes all the way to changing the set of stored properties that make up the struct. Since initializers have to initialize every stored property, they have two options: Assign each property before returning or using self. Assign all properties at once by using self.init(…) or self = …. The former requires knowing every stored property in the struct. If all of those properties happen to be public, however, a client in another target can implement their own initializer, and suddenly adding a new stored property (public or not) becomes a source-breaking change. Additionally, initializers are often used with let properties to enforce a struct’s invariants. Consider this (contrived) example: public struct BalancedPair { public let positive: Int public let negative: Int public init(absoluteValue: Int) { assert(absoluteValue &gt;= 0) self.positive = absoluteValue self.negative = -absoluteValue } } At this point a user of BalancedPair ought to be able to assume that positive and negative always hold opposite values. However, an unsuspecting (or malicious) client could add their own initializer that breaks this invariant: import ContrivedExampleKit extension BalancedPair { init(positiveOnly value: Int) { self.positive = value self.negative = 0 } } Anything that prevents the library author from enforcing the invariants of their type is a danger and contrary to the spirit of Swift. Proposed solution If an initializer is declared in a different module from a struct, it must use self.init(…) or self = … before returning or accessing self. Failure to do so will produce a warning in Swift 4 and an error in Swift 5. The recommendation for library authors who wish to continue allowing this is to explicitly declare a public memberwise initializer for clients in other modules to use. C structs C structs are not exempt from this rule, but all C structs are imported with a memberwise initializer anyway. This still does not guarantee source compatibility because C code owners occasionally decide to split up or rename members of existing structs, but this proposal does not make that situation worse. Most C structs also have a no-argument initializer that fills the struct with zeros unless one of the members is marked _Nonnull. Source compatibility This makes existing code invalid in Swift 5, which is a source compatibility break. This makes adding a stored property to a struct a source-compatible change (except for Swift 4 clients that choose to ignore the warning). Effect on ABI stability This is required for structs to avoid exposing the layout of their properties in a library’s binary interface. Effect on Library Evolution It is now a binary-compatible change to add a public or non-public stored property to a struct. It is still not a binary-compatible change to remove a public stored property from a struct. Alternatives considered Do nothing We’ve survived so far, so we can live without this for libraries that don’t have binary compatibility concerns, but not being able to enforce invariants is still a motivating reason to do this proposal. Distinguish between “structs with a fixed set of stored properties” and “structs that may get new stored properties later” This actually is a distinction we want to make for code in frameworks with binary compatibility constraints, where the ability to add new members to a struct forces client code to use extra indirection. (We’ve been spelling this @_fixed_layout, though that’s just a placeholder.) However, enforcing invariants may still be relevant for such a “fixed-layout” struct, and a library author can get nearly the same effect simply by defining a public memberwise initializer, something that’s common to do anyway. (If performance is a concern, the initializer can also be marked inlinable.) We don’t think there should ever be a reason to annotate a struct as “fixed-layout” in a source package, and we wouldn’t want this to become one. Allow stored-property-wise initialization just for C structs C structs are similar to the “fixed-layout” structs described above in that their layout is known at compile time, and since that’s just a property of C there’s no annotation cost. However, allowing this would create an unnecessary distinction between C structs and Swift structs. Additionally, there have been requests in the past for a C-side annotation to restrict access to the implicit no-argument and memberwise initializers provided by the Swift compiler. This has been motivated by C structs that do effectively have invariants; just as C++ allows a library author to restrict how a struct may be initialized, so could Swift. This is just a possible future change (and probably unlikely to happen in Swift 5), but it works better with this proposal than without it. Add an exception for unit tests An earlier version of the proposal included an exception for structs in modules imported as @testable, allowing unit tests to bypass the restriction that required calling an existing initializer. However, this can already be accomplished by providing an initializer marked internal in the original library. public struct ExportConfiguration { public let speed: Int public let signature: String public init(from fileURL: URL) {…} internal init(manualSpeed: Int, signature: String) {…} } import XCTest @testable import MyApp class ExportTests: XCTestCase { func testSimple() { // Still avoids having to load from a file. let config = ExportConfiguration(manualSpeed: 5, signature: &quot;abc&quot;) let op = ExportOperation(config) } } The downside is that the initializer is available to the rest of the module, which probably is not supposed to call it. Allowing per-stored-property initializers for @testable imports is an additive feature; if it turns out to be a common pain point, we can add it in a later proposal. Leaving it out means @testable remains primarily about access control.",
    "url": "http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html",
    "relUrl": "/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html"
  },
  "189": {
    "id": "189",
    "title": "SE-0190 Target environment platform condition",
    "content": "Target environment platform condition Proposal: SE-0190 Authors: Erica Sadun, Graydon Hoare Review Manager: Ted Kremenek Status: Implemented (Swift 4.1) Swift Evolution Review Thread Implementation: apple/swift#12964 Decision Notes: Rationale Introduction This proposal introduces a platform condition to differentiate device and simulator builds. This condition subsumes a common pattern of conditional compilation for Metal, Keychain, and AVFoundation Camera code. Swift-evolution threads: Expanding Build Configuration Tests for Simulator and Device targets Target environment platform condition Motivation A common developer requirement is to conditionally compile code based on whether the current compilation target is a simulator or a real device. The current technique for accomplishing this involves testing for particular combinations of presumed mismatch between architecture and operating system. This is fragile and non-obvious, and requires reasoning about complex nested conditions that obscure the user’s purpose. For example, code often looks like this: // Test for a simulator destination #if (arch(i386) || arch(x86_64)) &amp;&amp; (!os(macOS)) print(&quot;Simulator&quot;) #else print(&quot;Device&quot;) #endif // More restrictive test for iOS simulator // Adjust the os test for watchOS, tvOS #if (arch(i386) || arch(x86_64)) &amp;&amp; os(iOS) // iOS simulator code #endif Proposed Solution This proposal adds a new platform condition targetEnvironment with a single valid argument: simulator. In other words, the proposal is to enable conditional compilation of the form #if targetEnvironment(simulator). Detailed Design When the compiler is targeting simulator environments, the targetEnvironment(simulator) condition will evaluate to true. Otherwise it will evaluate as false. In the future, other target environments may be indicated using different arguments to the targetEnvironment condition. It is a general extension point for disambiguating otherwise-similar target environments. The name of the condition is motivated by the fact that an unambiguous indication of target environment can be made using the 4th (seldom used, but valid) environment field of the target triple provided to the compiler. In other words, if the compiler’s target triple is specified with an environment field such as arm64-apple-tvos-simulator, the targetEnvironment(simulator) condition will be set. As a transitionary measure: until users have migrated to consistent use of target triples with an explicit simulator value in the environment field, the Swift compiler will infer it from the remaining components of the target triple, without requiring the user to approximate the condition through combinations of os and arch platform conditions. In other words, while a given target triple may be missing the environment field, the targetEnvironment(simulator) condition may still be true, if it is inferred that the current target triple denotes a simulator environment. Source compatibility This is an additive proposal, existing code will continue to work. A warning and fixit may be provided for migrating recognizable cases in existing code, but this will necessarily be best-effort, as existing conditions may be arbitrarily complex. Effect on ABI stability None Effect on API resilience None Current Art Swift currently supports the following platform conditions: The os() function that tests for macOS, iOS, watchOS, tvOS, Linux, Windows, FreeBSD, Android, PS4, Cygwin and Haiku The arch() function that tests for x86_64, arm, arm64, i386, powerpc64, powerpc64le and s390x The swift() function that tests for specific Swift language releases, e.g. swift(&gt;=2.2) Comparison with other languages Rust’s conditional compilation system includes the target_env configuration option, which similarly presents the environment field of the target triple. In Clang, several environment-based preprocessor symbols can be used to achieve similar effects (__CYGWIN__, __ANDROID__, etc.) though the mapping is quite ad-hoc and the 4th field of the target triple is officially documented as representing the target ABI. In the implementation, however, the 4th field is treated as environment (subsuming ABI) and a 5th field for object format is supported. Clang also supports various flags such as -mtvos-simulator-version-min which define a simulator-specific preprocessor symbol __APPLE_EMBEDDED_SIMULATOR__. Alternatives Considered Some possible alternatives were considered: As in the first round of this proposal, target(simulator). This has the advantage of brevity, but the disadvantage of using a relatively overloaded term, and contradicts the existing design of using a separate condition per-component of the target triple (os() and arch()). A similarly brief environment(simulator) condition, which has the disadvantage that users may mistake it for a means of accessing environment variables of the compiler process. An additional state for the os or arch conditions, such as os(simulator). This would complicate both the definition and implementation of platform conditions, while blurring the notion of an operating system. Avoidance of the target triple altogether, and use of a dedicated simulator() platform condition. This is the simplest option, but is less-similar to existing conditions and may introduce more meaningless combinations of flags as the set of target environments grows (rather than mutually exclusive arguments to targetEnvironment).",
    "url": "http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html",
    "relUrl": "/docs/2019-08-26-0190-target-environment-platform-condition.html"
  },
  "190": {
    "id": "190",
    "title": "SE-0191 Eliminate `IndexDistance` from `Collection`",
    "content": "Eliminate IndexDistance from Collection Proposal: SE-0191 Author: Ben Cohen Review Manager: Doug Gregor Status: Implemented (Swift 4.1) Implementation: apple/swift#12641 Decision Notes: Rationale Introduction Eliminate the associated type IndexDistance from Collection, and modify all uses to the concrete type Int instead. Motivation Collection allows for the distance between two indices to be any SignedInteger type via the IndexDistance associated type. While in practice the distance between indices is almost always an Int, generic algorithms on Collection need to either constrain IndexDistance == Int or write their algorithm to be generic over any SignedInteger. Swift 4.0 introduced the ability to constrain associated types with where clauses (SE-142) and will soon allow protocol constraints to be recursive (SE-157). With these features, writing generic algorithms against Collection is finally a realistic tool for intermediate Swift programmers. You no longer need to know to constrain SubSequence.Element == Element or SubSequence: Collection, missing constraints that previously led to inexplicable error messages. At this point, the presence of IndexDistance is of of the biggest hurdles that new users trying to write generic algorithms face. If you want to write code that will compile against any distance type, you need to constantly juggle with explicit type annotations (i.e. you need to write let i: IndexDistance = 0 instead of just let i = 0), and perform numericCast to convert from one distance type to another. But these numericCasts are hard to use correctly. Given two collections with different index distances, it’s very hard to reason about whether your numericCast is casting from the smaller to larger type correctly. This turns any problem of writing a generic collection algorithm into both a collection and numeric problem. And chances are you are going to need to interoperate with a method that takes or provides a concrete Int anyway (like Array.reserveCapacity inside Collection.map). Much of the generic code in the standard library would trap if ever presented with a collection with a distance greater than Int.max. Additionally, this generalization makes specialization less likely and increases compile-time work. For these reasons, it’s common to see algorithms constrained to IndexDistance == Int. In fact, the inconvenience of having to deal with generic index distances probably encourages more algorithms to be constrained to Index == Int, such as this code in the Swift Package Manager. Converting this function to work with any index type would be straightforward. Converting it to work with any index distance as well would be much trickier. The general advice from The Swift Programming Language when writing Swift code is to encourage users to stick to using Int unless they have a special reason not to: Unless you need to work with a specific size of integer, always use Int for integer values in your code. […] Int is preferred, even when the values to be stored are known to be nonnegative. A consistent use of Int for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference[.] There are two main use cases for keeping IndexDistance as an associated type rather than concretizing it to be Int: tiny collections that might benefit from tiny distances, and huge collections that need to address greater than Int.max elements. For example, it may seem wasteful to force a type that presents the bits in a UInt as a collection to need to use a whole Int for its distance type. Or you may want to create a gigantic collection, such as one backed by a memory mapped file, with a size great than Int.max. The most likely scenario for this is on 32-bit processors where a collection would be constrained to 2 billion elements. These use cases are very niche, and do not seem to justify the considerable impedance to generic programming that IndexDistance causes. Therefore, this proposal recommends removing the associated type and replacing all references to it with Int. Proposed solution Scrap the IndexDistance associated type. Switch all references to it in the standard library to the concrete Int type: protocol Collection { var count: Int { get } func index(_ i: Index, offsetBy n: Int) -&gt; Index func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -&gt; Index? func distance(from start: Index, to end: Index) -&gt; Int } // and in numerous extensions in the standard library The one instance where a concrete type uses an IndexDistance other than Int in the standard library is AnyCollection, which uses Int64. This would be changed to Int. Source compatibility This can be split into 2 parts: Algorithms that currently constrain IndexDistance to Int in their where clause, and algorithms that use IndexDistance within the body of a method, can be catered for by a deprecated typealias for IndexDistance inside an extension on Collection. This is the common case. Collections that truly take advantage of the ability to define non-Int distances would be source-broken, with no practical way of making this compatible in a 4.0 mode. It’s worth noting that there are no such types in the Swift source compatibility suite. Effect on ABI stability This removes an associated type and changes function signatures, so must be done before declaring ABI stability Alternatives considered None other than status quo.",
    "url": "http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html",
    "relUrl": "/docs/2019-08-26-0191-eliminate-indexdistance.html"
  },
  "191": {
    "id": "191",
    "title": "SE-0192 Handling Future Enum Cases",
    "content": "Handling Future Enum Cases Proposal: SE-0192 Author: Jordan Rose Review Manager: Ted Kremenek Status: Implemented (Swift 5) Implementation: apple/swift#14945 Previous revision: 1, 2 (informal), 3 Pre-review discussion: Enums and Source Compatibility, with additional orphaned thread Review discussion: Review author summarizes some feedback from review discussion and proposes alternatives, full discussion thread, plus Handling unknown cases in enums Decision Notes: Rationale Introduction Currently, adding a new case to an enum is a source-breaking change, something that’s at odds with Apple’s established process for evolving APIs. This proposal aims to distinguish between enums that are frozen (meaning they will never get any new cases) and those that are non-frozen, and to ensure that clients handle any future cases when dealing with the latter. A key note: in this version of the proposal, nothing changes for user-defined Swift enums. This only affects C enums and enums in the standard library and overlays today. (This refers to libraries that Apple could hypothetically ship with its OSs, as it does with Foundation.framework and the Objective-C runtime.) The features described here may be used by third-party libraries in the future. Post-acceptance revision Since the proposal was accepted months after it was written, the rollout plan turned out to be a little too aggressive. Therefore, in Swift 5 the diagnostic for omitting @unknown default: or @unknown case _: will only be a warning, and in Swift 4 mode there will be no diagnostic at all. (The previous version of the proposal used an error and a warning, respectively.) Developers are still free to use @unknown in Swift 4 mode, in which case the compiler will still produce a warning if all known cases are not handled. Revision at acceptance The “new case” unknown: was changed to the unknown attribute, which can only be applied to default: and case _:. Differences from the first revision This now only affects C enums and enums defined in the standard library and overlays The unknown case has been added, to preserve exhaustivity checking The term used to describe enums that will not change is now “frozen” rather than “exhaustive” The proposal now describes what will happen if you “break the contract” in a new library version Much more discussion of future directions and alternatives considered Thanks to everyone who offered feedback! Motivation It’s well-established that many enums need to grow new cases in new versions of a library. For example, in last year’s release of iOS 10, Foundation’s DateComponentsFormatter.UnitsStyle gained a brief case and UIKit’s UIKeyboardType gained an asciiCapableNumberPad case. Large error enums also often grow new cases to go with new operations supported by the library. This all implies that library authors must have a way to add new cases to enums without breaking binary compatibility. At the same time, we really like that you can exhaustively switch over enums. This feature helps prevent bugs and makes it possible to enforce definitive initialization without having default cases in every switch. So we don’t want to get rid of enums where every case is known, either. This calls for a distinction between enums where every case can be known statically and enums that might grow new cases in the future. To see how this distinction will play out in practice, I investigated the public headers of Foundation in the macOS SDK. Out of all 60 or so NS_ENUMs in Foundation, only 6 of them are clearly intended to be switched exhaustively: ComparisonResult NSKeyValueChange / NSKeyValueSetMutationKind NSRectEdge FileManager.URLRelationship maybe Decimal.CalculationError …with a handful more that could go either way, such as Stream.Status. This demonstrates that there is a clear default for public enums, at least in Objective-C. Proposed solution In Swift 4.2, enums imported from C and enums defined in the standard library and overlays are either frozen or non-frozen. (Grammatical note: they are not “unfrozen” because that implies that they were frozen at one point.) When a client tries to switch over a non-frozen enum, they should include a “catch-all” case of some kind (default, case _, etc). In Swift 5 mode, omitting this case will result in a warning. All enums written in Swift outside of the standard library and overlays will implicitly be considered frozen in Swift 4.2. Enums imported from C will be non-frozen by default, with a new C-side annotation to treat them as frozen. Detailed design When switching over a non-frozen enum, the switch statement that matches against it must include a catch-all case (usually default or an “ignore” _ pattern). switch excuse { case .eatenByPet: // … case .thoughtItWasDueNextWeek: // … } Failure to do so will produce a warning in Swift 5. A program will trap at run time if an unknown enum case is actually encountered. All other uses of enums (if case, creation, accessing members, etc) do not change. Only the exhaustiveness checking of switches is affected by the frozen/non-frozen distinction. Non-exhaustive switches over frozen enums (and boolean values) will continue to be invalid in all language modes. Here’s a more complicated example: switch (excuse, notifiedTeacherBeforeDeadline) { case (.eatenByPet, true): // … case (.thoughtItWasDueNextWeek, true): // … case (_, false): // … } This switch handles all known patterns, but still doesn’t account for the possibility of a new enum case when the second tuple element is true. This should result in a warning in Swift 5, like the first example. @unknown The downside of using a default case is that the compiler can no longer alert a developer that a particular enum has elements that aren’t explicitly handled in the switch. To remedy this, switch cases will gain a new attribute, @unknown. switch excuse { case .eatenByPet: // … case .thoughtItWasDueNextWeek: // … @unknown default: // … } Like the regular default, @unknown default matches any value; it is a “catch-all” case. However, the compiler will produce a warning if all known elements of the enum have not already been matched. This is a warning rather than an error so that adding new elements to the enum remains a source-compatible change. (This is also why @unknown default matches any value rather than just those not seen at compile-time.) @unknown may only be applied to default or a case consisting of the single pattern _. Even in the latter case, @unknown must be used with the last case in a switch. This restriction is discussed further in the “unknown patterns” section under “Future directions”. The compiler will warn if all enums in the pattern being matched by @unknown are explicitly annotated as frozen, or if there are no enums in the pattern at all. This is a warning rather than an error so that annotating an enum as frozen remains a source-compatible change. If the pattern contains any enums that are implicitly frozen (i.e. because it is a user-defined Swift enum), @unknown is permitted, in order to make it easier to adapt to newly-added cases. @unknown has a downside that it is not testable, since there is no way to create an enum value that does not match any known cases, and there wouldn’t be a safe way to use it if there was one. However, combining @unknown with other cases using fallthrough can get the effect of following another case’s behavior while still getting compiler warnings for new cases. switch excuse { case .eatenByPet: showCutePicturesOfPet() case .thoughtItWasDueNextWeek: fallthrough @unknown default: askForDueDateExtension() } C enums Enums imported from C are tricky, because it’s difficult to tell whether they’re part of the current project or not. An NS_ENUM in Apple’s SDK should probably be treated as non-frozen, but one in your own framework might be frozen. Even there, though, it’s possible that there’s a “private case” defined in a .m file: // MyAppPaperSupport.h typedef NS_ENUM(NSInteger, PaperSize) { PaperSizeUSLetter = 0, PaperSizeA4 = 1, PaperSizePhoto4x6 = 2 }; // MyAppPaperSupport.m static const PaperSize PaperSizeStickyNote = 255; (While this pattern may be unfamiliar, it is used in Apple’s SDKs, though not often.) Therefore, enums imported from C will be treated conservatively: an otherwise-unannotated NS_ENUM will be imported as non-frozen and treated as such in all contexts. The newly-added C attribute enum_extensibility can be used to override this behavior: typedef NS_ENUM(NSInteger, GregorianMonth) { GregorianMonthJanuary = 1, GregorianMonthFebruary, GregorianMonthMarch, GregorianMonthApril, GregorianMonthMay, GregorianMonthJune, GregorianMonthJuly, GregorianMonthAugust, GregorianMonthSeptember, GregorianMonthOctober, GregorianMonthNovember, GregorianMonthDecember, } __attribute__((enum_extensibility(closed))); Apple doesn’t speak about future plans for its SDKs, so having an alternate form of NS_ENUM that includes this attribute is out of scope for this proposal. Apart from the effect on switches, a frozen C enum’s init(rawValue:) will also enforce that the case is one of those known at compile time. Imported non-frozen enums will continue to perform no checking on the raw value. This section only applies to enums that Swift considers “true enums”, rather than option sets or funny integer values. In the past, the only way to get this behavior was to use the NS_ENUM or CF_ENUM macros, but the presence of enum_extensibility(closed) or enum_extensibility(open) will instruct Swift to treat the enum as a “true enum”. Similarly, the newly-added flag_enum C attribute can be used to signify an option set like NS_OPTIONS. Effect on the standard library and overlays The majority of enums defined in the standard library do not need the flexibility afforded by being non-frozen, and so will be marked as frozen. This includes the following enums: ❄️ ClosedRange.Index ❄️ FloatingPointSign ❄️ FloatingPointClassification ❄️ Never ❄️ Optional ❄️ UnicodeDecodingResult ❄️ Unicode.ParseResult The following public enums in the standard library will not be marked as frozen: DecodingError EncodingError FloatingPointRoundingRule Mirror.AncestorRepresentation Mirror.DisplayStyle PlaygroundQuickLook (deprecated anyway) And while the overlays are not strictly part of the Swift Open Source project (since they are owned by framework teams at Apple), the tentative plan would be to mark these two enums as frozen: ❄️ ARCamera.TrackingState (a tri-state of “on”, “off”, and “limited(Reason)”) ❄️ DispatchTimeoutResult (“success” and “timed out”) And the other public enums in the overlays would be non-frozen: ARCamera.TrackingState.Reason Calendar.Component Calendar.Identifier Calendar.MatchingPolicy Calendar.RepeatedTimePolicy Calendar.SearchDirection CGPathFillRule Data.Deallocator DispatchData.Deallocator DispatchIO.StreamType DispatchPredicate DispatchQoS.QoSClass DispatchQueue.AutoreleaseFrequency DispatchQueue.GlobalQueuePriority (deprecated anyway) DispatchTimeInterval JSONDecoder.DataDecodingStrategy JSONDecoder.DateDecodingStrategy JSONDecoder.KeyDecodingStrategy JSONDecoder.NonConformingFloatDecodingStrategy JSONEncoder.DataEncodingStrategy JSONEncoder.DateEncodingStrategy JSONEncoder.KeyEncodingStrategy JSONEncoder.NonConformingFloatEncodingStrategy MachErrorCode POSIXErrorCode Comparison with other languages “Enums”, “unions”, “variant types”, “sum types”, or “algebraic data types” are present in a number of other modern languages, most of which don’t seem to treat this as an important problem. Languages without non-frozen enums Haskell and OCaml make heavy use of enums (“algebraic data types”, or just “types”) without any feature like this; adding a new “case” is always a source-breaking change. (Neither of these languages seems to care much about binary compatibility.) This is definitely a sign that you can have a successful language without a form of non-frozen enum other than “protocols”. Kotlin also falls in this bucket, although it uses enums (“enum classes”) less frequently. The C# docs have a nice section on how the language isn’t very helpful for distinguishing frozen and non-frozen enums. Objective-C, of course, is in the same bucket, though Apple could start doing things with the enum_extensibility Clang attribute that was recently added. Languages with alternate designs F# enums (“unions”) either expose all of their “cases” or none of them. The Swift equivalent of this would be not allowing you to switch on such an enum at all, as if it were a struct with private fields. Enums in D are like enums in C, but D distinguishes switch from final switch, and only the latter is exhaustive. That is, it’s a client-side decision at the use site, rather than a decision by the definer of the enum. Scala has enums, but the pattern most people seem to use is “sealed traits”, which in Swift terms would be “protocols where all conforming types are known, usually singletons”. A non-frozen enum would then just be a normal protocol. Some downsides of applying this to Swift are discussed below under “Use protocols instead”. Languages with designs similar to this proposal Rust has an accepted proposal to add non-frozen enums that looks a lot like this one, but where “frozen” is still the default to not break existing Rust programs. (There are some interesting differences that come up in Rust but not Swift; in particular they need a notion of non-frozen structs because their structs can be decomposed in pattern-matching as well.) Source compatibility It is now a source-compatible change to add a case to a non-frozen enum (whether imported from C or defined in the standard library). It is not a source-compatible change to add a case to a frozen enum. It is still not a source-compatible change to remove a case from a public enum (frozen or non-frozen). It is a source-compatible change to change a non-frozen enum into a frozen enum, but not vice versa. Breaking the contract If a library author adds a case to a frozen enum, any existing switches will likely not handle this new case. The compiler will produce an error for any such switch (i.e. those without a default case or _ pattern to match the enum value), noting that the case is unhandled; this is the same error that is produced for a non-exhaustive switch in Swift 4. If a library author changes an enum previously marked frozen to make it non-frozen, the compiler will produce a warning for any switch that does not have a catch-all case. Effect on ABI stability The layout of a non-frozen Swift enum must not be exposed to clients, since the library may choose to add a new case that does not fit in that layout in its next release. This results in extra indirection when that enum appears in public API. The layout of a frozen enum will continue to be made available to clients for optimization purposes. This change does not affect the layout of @objc enums, whether imported from C or defined in Swift. (Note that the representation of a non-@objc enum’s case may differ from its raw value; this improves the efficiency of switch statements when all cases are known at compile time.) Effect on Library Evolution It is now a binary-compatible change to add a case to a non-frozen enum. It is still not a binary-compatible change to remove a case from a public enum (frozen or non-frozen). It is not a binary-compatible change to add @objc to an enum, nor to remove it. Taking an existing non-frozen enum and making it frozen is something we’d like to support without breaking binary compatibility, but there is no design for that yet. The reverse will not be allowed. Breaking the contract Because the compiler uses the set of cases in a frozen enum to determine its in-memory representation and calling convention, adding a new case or marking such an enum as non-frozen will result in “undefined behavior” from any client apps that have not been recompiled. This means a loss of memory-safety and type-safety on par with a misuse of “unsafe” types, which would most likely lead to crashes but could lead to code unexpectedly being executed or skipped. In short, things would be very bad. Some ideas for how to prevent library authors from breaking the rules accidentally are discussed in “Compatibility checking” under “Future directions”. As a special case, switching over an unexpected value in an @objc enum (whether imported or defined in Swift) will always result in a trap rather than “undefined behavior”, even if the enum is frozen. Future directions Non-frozen Swift enums outside the standard library Earlier versions of this proposal included syntax that allowed all public Swift enums to have a frozen/non-frozen distinction, rather than just those in the standard library and overlays. This is still something we want to support, but the core team has made it clear that such a distinction is only worth it for libraries that have binary compatibility concerns (such as those installed into a standard location and used by multiple clients), at least without a more developed notion of versioning and version-locking. Exactly what it means to be a “library with binary compatibility concerns” is a large topic that deserves its own proposal. unknown patterns As described, @unknown cases can only be used to match the entire switched value; it does not work when trying to match a tuple element, or another enum’s associated type. In theory, we could make a new pattern kind that allows matching unknown cases anywhere within a larger pattern: switch (excuse, notifiedTeacherBeforeDeadline) { case (.eatenByPet, true): // … case (.thoughtItWasDueNextWeek, true): // … case (#unknown, true): // … case (_, false): // … } (The #unknown spelling is chosen by analogy with #selector to not conflict with existing syntax; it is not intended to be a final proposal.) However, this produces potentially surprising results when followed by a case that could also match a particular input. Because @unknown is only supported on catch-all cases, the input (.thoughtItWasDueNextWeek, true) would result in case 2 being chosen rather than case 3. switch (excuse, notifiedTeacherBeforeDeadline) { case (.eatenByPet, true): // 1 // … case (#unknown, true): // 2 // … case (.thoughtItWasDueNextWeek, _): // 3 // … case (_, false): // 4 // … } The compiler would warn about this, at least, since there is a known value that can reach the unknown pattern. @unknown must appear only on the last case in a switch to avoid this issue. However, it’s not possible to enforce the same thing for arbitrary patterns because there may be multiple enums in the pattern whose unknown cases need to be treated differently. A key point of this discussion is that as proposed @unknown merely produces a warning when the compiler can see that some enum cases are unhandled, rather than an error. If the compiler produced an error instead, it would make more sense to use a pattern-like syntax for unknown (see the naming discussions under “Alternatives considered”). However, if the compiler produced an error, then adding a new case would not be a source-compatible change. For these reasons, generalized unknown patterns are not being included in this proposal. Using @unknown with other catch-all cases At the moment, @unknown is only supported on cases that are written as default: or as case _:. However, there are other ways to form catch-all cases, such as case let value:, or case (_, let b): for a tuple input. Supporting @unknown with these cases was considered outside the scope of this proposal, which had already gone on for quite a while, but there are no known technical issues with lifting this restriction. Non-public cases The work required for non-frozen enums also allows for the existence of non-public cases in a public enum. This already shows up in practice in Apple’s SDKs, as described briefly in the section on “C enums” above. Like “enum inheritance”, this kind of behavior can mostly be emulated by using a second enum inside the library, but that’s not sufficient if the non-public values need to be vended opaquely to clients. Were such a proposal to be written, I advise that a frozen enum not be permitted to have non-public cases. An enum in a user-defined library would then be implicitly considered frozen if and only if it had no non-public cases. Compatibility checking Of course, the compiler can’t stop a library author from adding a new case to a frozen enum, even though that will break source and binary compatibility. We already have two ideas on how we could catch mistakes of this nature: A checker that can compare APIs across library versions, using swiftmodule files or similar. Encoding the layout of a type in a symbol name. Clients could link against this symbol so that they’d fail to launch if it changes, but even without that an automated system could check the list of exported symbols to make sure nothing was removed. Frozen enums remain useful even without any automated checking, and such checking should account for more than just enums, so it’s not being included in this proposal. Efficient representation of enums with raw types For enums with raw types, a 32-bit integer can be used as the representation rather than a fully opaque value, on the grounds that 4 billion is a reasonable upper limit for the number of distinct cases in an enum without payloads. However, this would make it an ABI-breaking change to add or remove a raw type from an enum, and would make the following definitions not equivalent: /* non-frozen */ public enum HTTPMethod: String { case get = &quot;GET&quot; case put = &quot;PUT&quot; case post = &quot;POST&quot; case delete = &quot;DELETE&quot; } /* non-frozen */ public enum HTTPMethod: RawRepresentable { case get case put case post case delete public init?(rawValue: String) { switch rawValue { case &quot;GET&quot;: return .get case &quot;PUT&quot;: return .put case &quot;POST&quot;: return .post case &quot;DELETE&quot;: return .delete default: return nil } } public var rawValue: String { switch self { case .get: return &quot;GET&quot; case .put: return &quot;PUT&quot; case .post: return &quot;POST&quot; case .delete: return &quot;DELETE&quot; } } } As such, this representation change is out of scope for this proposal. Alternatives considered Terminology and syntax Terminology: “closed” and “open” The original description of the problem used “closed” and “open” to describe frozen and non-frozen enums, respectively. However, this conflicts with the use of open in classes and their members. In this usage, open is clearly a greater level of access than public, in that clients of an open class can do everything they can with a public class and more; it is source-compatible to turn a public class into an open one. For enums, however, it is frozen enums that are “greater”: you can do everything you can with a non-frozen enum and more, and it would be source-compatible for a standard library contributor to turn a non-frozen enum into a frozen one (at the cost of a warning). Terminology: other options Several more options were suggested during initial discussions: complete / incomplete covered exhaustive / non-exhaustive non-extensible final / non-final finite / non-finite (not “infinite”) fixed locked sealed / non-sealed total / partial I didn’t have a strong preference for any particular choice as long as it isn’t “closed” / “open”, for the reasons described above. In the first revision of this proposal I picked “exhaustive” because it matches the name proposed in Rust. (Unfortunately, Clang’s enum_extensibility attribute, recently added by us at Apple, uses open and closed.) Note that “nonextensible” does have one problem: Apple already uses NS_TYPED_EXTENSIBLE_ENUM to refer to enum-like sets of constants (usually strings) that clients can add “cases” to. That’s not the same meaning as the exhaustiveness discussed in this proposal. During the first review for this proposal, Brent Royal-Gordon suggested “frozen”, which was met with general approval or at least no major objections. unknown naming The first version of this proposal did not include unknown, but did discuss it as a “considered alternative” under the name future. Previous discussions have also used unexpected or undeclared to describe this feature as well. It was pointed out that neither future nor unexpected really described the feature being provided. unknown does not just handle cases added in the future; it also handles private cases and invalid values for C enums. Nor are such cases entirely unexpected, since the compiler is telling the developer to expect them. undeclared has fewer issues, but certainly private cases can be declared somewhere; the declarations just aren’t visible. The “intermediate” revision of this proposal where unknown was first added used the spelling unknown case, but restricted the new case to only match values that were enums rather than values containing enums. When that restriction was loosened, the reading of unknown case as “(enum) cases that I don’t know about” no longer made as much sense. During discussion, the name unknown default (or @unknown default) was suggested as an alternative to unknown case, since the semantics behave very much like default. However, it isn’t the “default” that’s “unknown”. Other proposed spellings included default unknown (a simple attempt to avoid reading “unknown” as an adjective modifying “default”) and default(unknown) (by analogy with private(set)). Nevertheless, this attribute syntax won out in the end by not tying it to default; the alternate spelling @unknown case _ is also accepted. Moving away from “unknown”, @unused default was also suggested, but the case is not unused. A more accurate @runtimeReachableOnly (or even @runtimeOnly) was proposed instead, but that’s starting to get overly verbose for something that will appear reasonably often. For standalone names, fallback was also suggested, but semantically that seems a little too close to “default”, and in terms of actual keywords it was pointed out that this was very similar to fallthrough despite having no relation. invisible was suggested as well (though in the context of patterns rather than cases), but that doesn’t exactly apply to future cases. To summarize, the following spellings were considered for unknown: future: unexpected: undeclared: unknown case: unknown default: @unknown default: @unused default: @runtimeReachableOnly default: default unknown: default(unknown): fallback: invisible: For the review of the proposal, I picked unknown: as the best option, admittedly as much for not having unwanted connotations as for having good connotations. The core team ultimately went with @unknown default: / @unknown case _: instead. A bigger change would be to make a custom pattern instead of a custom case, even if it were subject to the same restrictions in implementation (see “unknown patterns” above). This usually meant using a symbol of some kind to distinguish the “unknown” from a normal label or pattern, leading to case #unknown or similar. This makes the new feature less special, since it’s “just another pattern”. However, it would be surprising to have such a pattern but keep the restrictions described in this proposal; thus, it would only make sense to do this if we were going to implement fully general pattern-matching for this feature. See “unknown patterns” above for more discussion. Finally, there was the option to put an annotation on a switch instead of customizing the catch-all case, e.g. @warnUnknownCases switch x {. This is implementable but feels easier for a developer to forget to write, and the compiler can only help if the developer actually has implemented all of the current cases alongside their default case. switch! switch! was an alternative to @unknown that would not support any action other than trapping when the enum is not one of the known cases. This avoids some of the problems with @unknown (such as making it much less important to test), but isn’t exactly in the spirit of non-frozen enums, where you know there will be more cases in the future. The following two examples would be equivalent (except perhaps in the form of the diagnostic produced). switch! excuse { case .eatenByPet: // … case .thoughtItWasDueNextWeek: // … } switch excuse { case .eatenByPet: // … case .thoughtItWasDueNextWeek: // … unknown: fatalError(&quot;unknown case in switch: (excuse)&quot;) } Testing invalid cases Another issue with non-frozen enums is that clients cannot properly test what happens when a new case is introduced, almost by definition. Brent Royal-Gordon came up with the idea to have a new type annotation that would allow the creation of an invalid enum value. Since this is only something to use for testing, the initial version of the idea used @testable as the spelling for the annotation. The tests could then use a special expression, #invalid, to pass this invalid value to a function with a @testable enum parameter. However, this would only work in cases where the action to be taken does not actually depend on the enum value. If it needs to be passed to the original library that owns the enum, or used with an API that is not does not have this annotation, the code still cannot be tested properly. override func process(_ transaction: @testable Transaction) { switch transaction { case .deposit(let amount): // … case .withdrawal(let amount): // … default: super.process(transaction) // hmm… } } This is an additive feature, so we can come back and consider it in more detail even if we leave it out of the language for now. Meanwhile, the effect can be imitated using an Optional or ImplicitlyUnwrappedOptional parameter. Allow enums defined in source packages to be considered non-frozen The first version of this proposal applied the frozen/non-frozen distinction to all public enums, even those in user-defined libraries. The motivation for this was to allow package authors to add cases to their enums without it being a source-breaking change, meaning it can be done in a minor version release of a library (i.e. one intended to be backwards-compatible). Like deprecations, this can produce new warnings, but not new errors, and it should not (if done carefully) break existing code. The core team decided that this feature was not worth the disruption and long-term inconvenience it would cause for users who did not care about this capability. Leave out @unknown The initial version of this proposal did not include @unknown, and required people to use a normal default to handle cases added in the future instead. However, many people were unhappy with the loss of exhaustivity checking for switch statements, both for enums in libraries distributed as source and enums imported from Apple’s SDKs. While this is an additive feature that does not affect ABI, it seems to be one that the community considers a necessary part of a language model that provides non-frozen enums. Mixing @unknown with other catch-all cases The proposal as written forbids having two catch-all cases in the same switch where only one is marked @unknown. Most people would expect this to have the following behavior: switch excuse { case .eatenByPet: // Specific known case @unknown case _: // Any cases not recognized by the compiler case _: // Any other cases the compiler *does* know about, // such as .thoughtItWasDueNextWeek } However, I can’t think of an actual use case for this; it’s not clear what action one would take in the @unknown case that they wouldn’t take in the later default case. Furthermore, this becomes a situation where the same code behaves differently before and after recompilation: A new case is added to the HomeworkExcuse enum, say, droppedInMud. When using the new version of the library with an existing built client app, the droppedInMud case will end up in the @unknown part of the switch. When the client app is recompiled, the droppedInMud case will end up in the case _ case. The compiler will not (and cannot) provide any indication that the behavior has changed. Without a resolution to these concerns, this feature does not seem worth including in the proposal. It’s also additive and has no ABI impact, so if we do find use cases for it in the future we can always add it then. Introduce a new declaration kind instead There have been a few suggestions to distinguish enum from some other kind of declaration that acts similarly but allows adding cases: choices HomeworkExcuse { case eatenByPet case thoughtItWasDueNextWeek } My biggest concern with this is that if we ever do expand this beyond the standard library and overlays, it increases the possibility of a library author accidentally publishing a (frozen) enum when they meant to publish a (non-frozen) choices. As described above, the opposite mistake is one that can be corrected without breaking source compatibility, but this one cannot. A smaller concern is that both enum and choices would behave the same when they aren’t public. Stepping back, increasing the surface area of the language in this way does not seem desirable. Exhaustive switching has been a key part of how Swift enums work, but it is not their only feature. Given how people already struggle with the decision of “struct vs. class” when defining a new type, introducing another pair of “similar but different” declaration kinds would have to come with strong benefits. My conclusion is that it is better to think of frozen and non-frozen enums as two variants of the same declaration kind, rather than as two different declaration kinds. Use protocols instead Everything you can do with non-frozen enums, you can do with protocols as well, except for: exhaustivity checking with @unknown forbidding others from adding their own “cases” protocol HomeworkExcuse {} struct EatenByPet: HomeworkExcuse {} struct ThoughtItWasDueNextWeek: HomeworkExcuse {} switch excuse { case is EatenByPet: // … case is ThoughtItWasDueNextWeek: // … default: // … } (Associated values are a little harder to get out of the cases, but let’s assume we could come up for syntax as well.) This is a valid model; it’s close to what Scala does (as mentioned above), and is independently useful in Swift. However, using this as the only way to get non-frozen enum semantics would lead to a world where enum is dangerous for library authors, because public enum is now a promise that no new cases will be added. Nothing else in Swift works that way. More practically, getting around this restriction would mean rewriting existing code to use the more verbose syntax of separate types conforming to a common protocol. (If Swift were younger, perhaps we would consider using protocols for all non-imported enums, not just non-frozen ones. But at this point that would be way too big a change to the language.) Import non-frozen C enums as RawRepresentable structs The Swift compiler already makes a distinction between plain C enums, enums marked with the flag_enum Clang attribute (NS_OPTIONS), and enums marked with the enum_extensibility Clang attribute (NS_ENUM). The first two categories were deemed to not be sufficiently similar to Swift enums and are imported instead as structs. Given that we’re most immediately concerned about C enums growing new cases (specifically, those in Apple’s existing Objective-C SDKs), we could sidestep the problem by importing all C enums as structs except for those marked enum_extensibility(closed). However, this doesn’t solve the problem for future Swift libraries, while still requiring changes to existing switch statements across many many projects, and it doesn’t support the exhaustivity checking provided by unknown. Furthermore, it would probably be harder to implement high-quality migration support from Swift 4 to Swift 5, since the structs-formerly-enums will look like any other structs imported from C. Get Apple to stop adding new cases to C enums This isn’t going to happen, but I thought I’d mention it since it was brought up during discussion. While some may consider this a distasteful use of the C language, it’s an established pattern for Apple frameworks and is not going to change. “Can there be a kind of open enum where you can add new cases in extensions?” There is no push to allow adding new cases to an enum from outside a library. This use case (no pun intended) is more appropriate for a RawRepresentable struct, where the library defines some initial values as static properties. (You can already switch over struct values in Swift as long as they are Equatable.)",
    "url": "http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html",
    "relUrl": "/docs/2019-08-26-0192-non-exhaustive-enums.html"
  },
  "192": {
    "id": "192",
    "title": "SE-0193 Cross-module inlining and specialization",
    "content": "Cross-module inlining and specialization Proposal: SE-0193 Author: Slava Pestov Review Manager: Ted Kremenek Status: Implemented (Swift 4.2) Evolution review thread: https://forums.swift.org/t/se-0193-cross-module-inlining-and-specialization/7310 Implementation: apple/swift#15787 Introduction We propose introducing a pair of new attributes, @inlinable and @usableFromInline. The @inlinable attribute exports the body of a function as part of a module’s interface, making it available to the optimizer when referenced from other modules. The @usableFromInline attribute marks an internal declaration as being part of the binary interface of a module, allowing it to be used from @inlinable code without exposing it as part of the module’s source interface. Motivation One of the top priorities of the Swift 5 release is a design and implementation of the Swift ABI. This effort consists of three major tasks: Finalizing the low-level function calling convention, layout of data types, and various runtime data structures. The goal here is to maintain compatibility across compiler versions, ensuring that we can continue to make improvements to the Swift compiler without breaking binaries built with an older version of the compiler. Implementing support for library evolution, or the ability to make certain source-compatible changes, without breaking binary compatibility. Examples of source-compatible changes we are considering include adding new stored properties to structs and classes, removing private stored properties from structs and classes, adding new public methods to a class, or adding new protocol requirements that have a default implementation. The goal here is to maintain compatibility across framework versions, ensuring that framework authors can evolve their API without breaking binaries built against an older version of the framework. For more information about the resilience model, see the library evolution document in the Swift repository. Stabilizing the API of the standard library. The goal here is to ensure that the standard library can be deployed separately from client binaries and frameworks, without forcing recompilation of existing code. All existing language features of Swift were designed with these goals in mind. In particular, the implementation of generic types and functions relies on runtime reified types to allow separate compilation and type checking of generic code. Within the scope of a single module, the Swift compiler performs very aggressive optimization, including full and partial specialization of generic functions, inlining, and various forms of interprocedural analysis. On the other hand, across module boundaries, runtime generics introduce unavoidable overhead, as reified type metadata must be passed between functions, and various indirect access patterns must be used to manipulate values of generic type. We believe that for most applications, this overhead is negligible compared to the actual work performed by the code itself. However, for some advanced use cases, and in particular for the standard library, the overhead of runtime generics can dominate any useful work performed by the library. Examples include the various algorithms defined in protocol extensions of Sequence and Collection, for instance the map method of the Sequence protocol. Here the algorithm is very simple and spends most of its time manipulating generic values and calling to a user-supplied closure; specialization and inlining can completely eliminate the algorithm of the higher-order function call and generate equivalent code to a hand-written loop manipulating concrete types. The library author can annotate such published APIs with the @inlinable attribute. This will make their bodies available to the optimizer when building client code in other modules that call those APIs. The optimizer may or may not make use of the function body; it might be inlined, specialized, or ignored, in which case the compiler will continue to reference the public entry point in the framework. If the framework were to change the definition of such a function, only binaries built against the newer version of library might continue using the old, inlined definition, they may use the new definition, or even a mix depending if certain call sites inlined the function or not. Proposed solution The @inlinable attribute causes the body of a function to be emitted as part of the module interface. For example, a framework can define a rather impractical implementation of an algorithm which returns true if all elements of a sequence are equal or if the sequence is empty, and false otherwise: @inlinable public func allEqual&lt;T&gt;(_ seq: T) -&gt; Bool where T : Sequence, T.Element : Equatable { var iter = seq.makeIterator() guard let first = iter.next() else { return true } func rec(_ iter: inout T.Iterator) -&gt; Bool { guard let next = iter.next() else { return true } return next == first &amp;&amp; rec(&amp;iter) } return rec(&amp;iter) } A client binary built against this framework can call allEqual() and enjoy a possible performance improvement when built with optimizations enabled, due to the elimination of abstraction overhead. On the other hand, once the framework author comes to their senses and implements an iterative solution to replace the recursive algorithm defined above, the client binary might not be able to make use of the more efficient implementation until recompiled. Detailed design The @inlinable attribute The @inlinable attribute can be applied to the following kinds of declarations: Functions and methods Subscripts Computed properties Initializers Deinitializers The attribute can only be applied to declarations with public or internal visibility. The attribute cannot be applied to local declarations, that is, declarations nested inside functions or statements. However, local functions and closure expressions defined inside public @inlinable functions are always implicitly @inlinable. When applied to a subscript or computed property, the attribute applies to both the getter and setter. Note that only delegating initializers (those that assign to self or call another initializer via self.init) can be inlinable. Root initializers which initialize the stored properties of a struct or class directly cannot be inlinable. For motivation, see SE-0189 Restrict Cross-module Struct Initializers. Inlinable contexts The body of an inlinable declaration is an example of an inlinable context. The compiler enforces certain restrictions within inlinable contexts: Inlinable declarations cannot define local types. This is because all types have a unique identity in the Swift runtime, visible to the language in the form of the == operator on metatype values. It is not clear what it would mean if two different libraries inline the same local type from a third library, with all three libraries linked together into the same binary. This becomes even worse if two different versions of the same inlinable function appear inside the same binary. Inlinable declarations can only reference ABI-public declarations. This is because they can be emitted into the client binary, and are therefore limited to referencing symbols that the client binary can reference. Note: Future evolution proposals may add new kinds of inlinable contexts. The @usableFromInline attribute This attribute allows us to introduce a notion of an ABI-public declaration. A declaration is ABI-public if both of the following conditions hold: The declaration is a top-level declaration, or it is nested inside an ABI-public type. The declaration is public, or is internal and annotated with either the @usableFromInline attribute or @inlinable attribute. In the following example, the method C.f is ABI-public: public class C { public func f() {} } Two more examples of ABI-public declarations are the methods C.D.f and C.D.g below: public class C { @usableFromInline internal class D { @usableFromInline internal func f() {} @inlinable internal func g() {} } } In the following, the method C.f is not ABI-public, because it is nested inside a type that is not @usableFromInline or public: internal class C { public func f() {} } The @usableFromInline attribute can be applied to all declarations which support access control modifiers. This includes almost all kinds of declarations, except for the following, which always have the same effective visibility as their containing declaration: Protocol requirements Enum cases Class destructors When applied to a subscript or computed property, the attribute applies to both the getter and setter, if present. The @usableFromInline attribute can only be applied to internal declarations. It does not make sense on public declarations, which are already ABI-public. It also cannot be applied to private and fileprivate declarations. and not private, fileprivate or public declarations. The @usableFromInline attribute does not affect source-level visibility of a declaration; it only results in the entry point being exported at the ABI level, allowing it to be referenced from @inlinable functions. Note: On an internal declaration, @inlinable implies @usableFromInline. The compiler will emit a warning if a declaration has both attributes. Future directions We would also like to add the ability to specify versioning information. This capability is not part of this proposal, but will be explored in the future, possibly using syntax like @inlinable(2.0) or @available(inlinable, 2.0). This is needed when a function introduced in the original release of a framework becomes inlinable in a later release of the framework. The function body might use ABI-public functions that are only part of the later release, and therefore the function is only available for inlining if the client is deploying against the newer version of the framework. This versioning capability will also be required for non-exhaustive enums and fixed-contents structs, since enums can become exhaustive, and structs can become fixed-contents, after the fact, and the compiler can only make use of this information of deploying against a sufficiently-recent version of the framework. Source compatibility The introduction of the @inlinable and @usableFromInline attributes is an additive change to the language and has no impact on source compatibility. Effect on ABI stability The following changes are ABI compatible: Adding @inlinable to a public or internal declaration Removing @inlinable from a public declaration Replacing @inlinable with @usableFromInline on an internal declaration Adding @usableFromInline to an existing declaration Effect on API resilience Any changes to the body of an @inlinable declaration should be considered very carefully. As a general guideline, we feel that @inlinable makes the most sense with “obviously correct” algorithms which manipulate other data types abstractly through protocols, so that any future changes to an @inlinable declaration are optimizations that do not change observed behavior. An @inlinable function implementation must be prepared to interact with multiple versions of the same function linked into a single binary. For example, if a hashing function is @inlinable, the hash algorithm must not be changed to avoid introducing inconsistency. Comparison with other languages The closest language feature to the @inlinable attribute is found in C and C++. In C and C++, the concept of a header file is similar to Swift’s binary swiftmodule files, except they are written by hand and not generated by the compiler. Swift’s public declarations are roughly analogous to declarations whose prototypes appear in a header file. Header files mostly contain declarations without bodies, but can also declare inline functions with bodies. Such functions are not part of the binary interface of the library, and are instead emitted into client code when referenced. As with @inlinable declarations, inline functions can only reference other “public” declarations, that is, those that are defined in other header files. Note that while static inline is the most commonly-used incarnation of this feature in C, our proposed @inlinable attribute is most similar to extern inline, were that easier to use. The closest analogue in C to @usableFromInline is a non-static function that is not declared in a framework’s header file. External clients cannot see it directly, but they can call it if they provide a local extern declaration. Alternatives considered One possible alterative would be to add a new compiler mode where all declarations become implicitly @inlinable, and all private and internal declarations become @usableFromInline. However, such a compilation mode would not solve the problem of delivering a stable ABI and standard library which can be deployed separately from user code. We don’t want all declaration bodies in the standard library to be available to the optimizer when building user code. While such a feature might be useful for users who build private frameworks that are always shipped together their application without resilience concerns, we do not feel it aligns with our goals for ABI stability, and at best it should be a separate discussion. For similar reasons, we do not feel that an “opt-out” attribute that can be applied to declarations to mark them non-inlinable makes sense. We have also considered generalizing @inlinable to allow it to be applied to entire blocks of declarations, for example at the level of an extension. As we gain more experience with using this attribute in the standard library we might decide this would be a useful addition, but we feel that for now, it makes sense to focus on the case of a single inlinable declaration instead. Any future generalizations can be introduced as additive language features. We originally used the spelling @inlineable for the attribute. However, we settled on @inlinable for consistency with the Decodable and Encodable protocols, which are named as they are and not Decodeable and Encodeable. Finally, we have considered some alternate spellings for this attribute. The name @inlinable is somewhat of a misnomer, because nothing about it actually forces the compiler to inline the declaration; it might simply generate a concrete specialization of it, or look at the body as part of an interprocedural analysis, or completely ignore the body. However, nothing seemed to read as well as @inlinable.",
    "url": "http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html",
    "relUrl": "/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html"
  },
  "193": {
    "id": "193",
    "title": "SE-0194 Derived Collection of Enum Cases",
    "content": "Derived Collection of Enum Cases Proposal: SE-0194 Authors: Jacob Bandes-Storch, Brent Royal-Gordon, Robert Widmann Review Manager: Doug Gregor Review Thread: SE-0194 review Status: Implemented (Swift 4.2) Implementation: apple/swift#13655 Bugs: SR-7151, SR-7152 Introduction It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them. Enumeration types without associated values (henceforth referred to as “simple enums”) have a finite, fixed number of cases, yet working with them programmatically is challenging. It would be natural to enumerate all the cases, count them, determine the highest rawValue, or produce a Collection of them. However, despite the fact that both the Swift compiler and the Swift runtime are aware of this information, there is no safe and sanctioned way for users to retrieve it. Users must resort to various workarounds in order to iterate over all cases of a simple enum. This topic was brought up three different times in just the first two months of swift-evolution’s existence. It was the very first language feature request on the Swift bug tracker. It’s a frequent question on Stack Overflow (between them, these two questions have over 400 upvotes and 60 answers). It’s a popular topic on blogs. It is one of just eight examples shipped with Sourcery. We propose the introduction of a protocol, CaseIterable, to indicate that a type has a finite, enumerable set of values. Moreover, we propose an opt-in derived implementation of CaseIterable for the common case of a simple enum. Prior discussion on Swift-Evolution List of all Enum values (for simple enums) (December 8, 2015) Proposal: Enum ‘count’ functionality (December 21, 2015) Draft Proposal: count property for enum types (January 17, 2016) † Pre-proposal: CaseEnumerable protocol (derived collection of enum cases) (January 17, 2016) † ValueEnumerable protocol with derived implementation for enums (April 15, 2016) …more than a year passes… [Pitch] Synthesized static enum property to iterate over cases (September 8, 2017) † Re-pitch: Deriving collections of enum cases (November 6, 2017) Official Review: SE-0194: Derived Collection of Enum Cases (January 6, 2018) † = a precursor to this proposal Motivation Use cases Examples online typically pose the question “How do I get all the enum cases?”, or even “How do I get the count of enum cases?”, without fully explaining what the code will do with that information. To guide our design, we focus on two categories of use cases: The code must greedily iterate over all possible cases, carrying out some action for each case. For example, imagine enumerating all combinations of suit and rank to build a deck of playing cards: let deck = Suit.magicListOfAllCases.flatMap { suit in (1...13).map { rank in PlayingCard(suit: suit, rank: rank) } } The code must access information about all possible cases on demand. For example, imagine displaying all the cases through a lazy rendering mechanism like UITableViewDataSource: class SuitTableViewDataSource: NSObject, UITableViewDataSource { func tableView(_: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return Suit.magicListOfAllCases.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let suit = Suit.magicListOfAllCases[indexPath.row] cell.titleView!.text = suit.localizedName return cell } } To limit our scope, we are primarily interested in simple enums—those without any associated values—although we would also like to allow more complicated enums and structs to manually participate in this mechanism. The second use case suggests that access by contiguous, zero-based integer index is important for at least some uses. At minimum, it should be easy to construct an Array from the list of cases, but ideally the list could be used like an array directly, at least for simple enums. Workarounds The most basic approach to producing a collection of all cases is by manual construction: enum Attribute { case date, name, author } protocol Entity { func value(for attribute: Attribute) -&gt; Value } // Cases must be listed explicitly: [Attribute.date, .name, .author].map{ entity.value(for: $0) }.joined(separator: &quot; n&quot;) For RawRepresentable enums, users have often relied on iterating over the known (or assumed) allowable raw values: Excerpt from Nate Cook’s post, Loopy, Random Ideas for Extending “enum” (October 2014): enum Reindeer: Int { case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph } extension Reindeer { static var allCases: [Reindeer] { var cur = 0 return Array( GeneratorOf&lt;Reindeer&gt; { return Reindeer(rawValue: cur++) } ) } static var caseCount: Int { var max: Int = 0 while let _ = self(rawValue: ++max) {} return max } static func randomCase() -&gt; Reindeer { // everybody do the Int/UInt32 shuffle! let randomValue = Int(arc4random_uniform(UInt32(caseCount))) return self(rawValue: randomValue)! } } Or creating the enums by unsafeBitCast from their hashValue, which is assumed to expose their memory representation: Excerpt from Erica Sadun’s post, Swift: Enumerations or how to annoy Tom, with full implementation in this gist (July 12, 2015): static func fromHash(hashValue index: Int) -&gt; Self { let member = unsafeBitCast(UInt8(index), Self.self) return member } public init?(hashValue hash: Int) { if hash &gt;= Self.countMembers() {return nil} self = Self.fromHash(hashValue: hash) } Or using a switch statement, making it a compilation error to forget to add a case, as with Dave Sweeris’s Enum Enhancer (which includes some extra functionality to avoid the boilerplate required for .cases and .labels): enum RawValueEnum : Int, EnumeratesCasesAndLabels { static let enhancer:EnumEnhancer&lt;RawValueEnum&gt; = EnhancedGenerator { // `$0` is a RawValueEnum? switch $0 { case .none: $0 = .zero case .some(let theCase): switch theCase { case .zero: $0 = .one case .one: $0 = nil } } } case zero = 0 case one = 1 } There are many problems with these existing techniques: They are ad-hoc and can’t benefit every enum type without duplicated code. They are not standardized across codebases, nor provided automatically by libraries such as Foundation and {App,UI}Kit. They are dangerous at worst, bug-prone in most cases (such as when enum cases are added, but the user forgets to update a hard-coded static collection), and awkward at best. Resilience implications This last point is especially important as we begin to concern ourselves with library resilience. Future versions of Swift should allow library authors to add and deprecate public enum cases without breaking binary compatibility. But if clients are manually constructing arrays of “all cases”, those arrays will not correspond to the version of the library they are running against. At the same time, the principle that libraries ought to control the promises they make should apply to any case-listing feature. Participation in a “list all cases” mechanism should be optional and opt-in. Precedent in other languages Rust does not seem to have a solution for this problem. C#’s Enum has several methods available for reflection, including GetValues() and GetNames(). Java implicitly declares a static values() function, returning an array of enum values, and valueOf(String name) which takes a String and returns the enum value with the corresponding name (or throws an exception). More examples here. The Template Haskell extension to Haskell provides a function reify which extracts info about types, including their constructors. Proposed solution We propose introducing a CaseIterable protocol to the Swift Standard Library. The compiler will derive an implementation automatically for simple enums when the conformance is specified. enum Ma: CaseIterable { case 马, 吗, 妈, 码, 骂, 麻, 🐎, 🐴 } Ma.allCases // returns some Collection whose Iterator.Element is Ma Ma.allCases.count // returns 8 Array(Ma.allCases) // returns [Ma.马, .吗, .妈, .码, .骂, .麻, .🐎, .🐴] Detailed design The CaseIterable protocol will have the following declaration: public protocol CaseIterable { associatedtype AllCases: Collection where AllCases.Element == Self static var allCases: AllCases { get } } The compiler will synthesize an implementation of CaseIterable for an enum type if and only if: the enum contains only cases without associated values; the enum declaration has an explicit CaseIterable conformance (and does not fulfill the protocol’s requirements). Enums imported from C/Obj-C headers will not participate in the derived CaseIterable conformance. Cases marked unavailable will not be included in allCases. The implementation will not be synthesized if the conformance is on an extension — it must be on the original enum declaration. Source compatibility This proposal only adds functionality, so existing code will not be affected. (The identifier CaseIterable doesn’t make very many appearances in Google and GitHub searches.) Effect on ABI stability The proposed implementation adds a derived conformance that makes use of no special ABI or runtime features. Effect on API resilience User programs will come to rely on the CaseIterable protocol and its allCases and AllCases requirements. Due to the use of an associated type for the property’s type, the derived implementation is free to change the concrete Collection it returns without breaking the API. Alternatives considered The functionality could also be provided entirely through the Mirror/reflection APIs. This would likely result in much more obscure and confusing usage patterns. Provide a default collection Declaring this in the Standard Library reduces the amount of compiler magic required to implement the protocol. However, it also exposes a public unsafe entrypoint to the reflection API that we consider unacceptable. extension CaseIterable where AllCases == DefaultCaseCollection&lt;Self&gt; { public static var allCases: DefaultCaseCollection&lt;Self&gt; { return DefaultCaseCollection(unsafeForEnum: Self.self) } } public struct DefaultCaseCollection&lt;Enum&gt;: RandomAccessCollection { public var startIndex: Int { return 0 } public let endIndex: Int public init(unsafeForEnum _: Enum.Type) { endIndex = _countCaseValues(Enum.self) } public subscript(i: Int) -&gt; Enum { precondition(indices.contains(i), &quot;Case index out of range&quot;) return Builtin.reinterpretCast(i) as Enum } } Metatype conformance to Collection A type inherently represents a set of its possible values, and as such, for val in MyEnum.self { } could be a natural way to express iteration over all cases of a type. Specifically, if the metatype MyEnum.Type could conform to Collection or Sequence (with Element == MyEnum), this would allow for-loop enumeration, Array(MyEnum.self), and other use cases. In a generic context, the constraint T: CaseIterable could be expressed instead as T.Type: Collection. Absent the ability for a metatype to actually conform to a protocol, the compiler could be taught to treat the special case of enum types as if they conformed to Collection, enabling this syntax before metatype conformance became a fully functional feature.",
    "url": "http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html",
    "relUrl": "/docs/2019-08-26-0194-derived-collection-of-enum-cases.html"
  },
  "194": {
    "id": "194",
    "title": "SE-0195 Introduce User-defined "Dynamic Member Lookup" Types",
    "content": "Introduce User-defined “Dynamic Member Lookup” Types Proposal: SE-0195 Author: Chris Lattner Review Manager: Ted Kremenek Implementation: apple/swift#14546 Previous Revision #1 Status: Implemented (Swift 4.2) Decision Notes: Review extended, Rationale Introduction This proposal introduces a new @dynamicMemberLookup attribute. Types that use it provide “dot” syntax for arbitrary names which are resolved at runtime - in a completely type safe way. This provides syntactic sugar that allows the user to write: a = someValue.someMember someValue.someMember = a mutateParameter(&amp;someValue.someMember) and have it be interpreted by the compiler as: a = someValue[dynamicMember: &quot;someMember&quot;] someValue[dynamicMember: &quot;someMember&quot;] = a mutateParameter(&amp;someValue[dynamicMember: &quot;someMember&quot;]) This allows the static type of someValue to decide how to implement these dynamic member references. Many other languages have analogous features e.g., the dynamic feature in C#, the Dynamic trait in Scala, the composition of Objective-C’s explicit properties and underlying messaging infrastructure. This sort of functionality is great for implementing dynamic language interoperability, dynamic proxy APIs, and other APIs (e.g. for JSON processing). The driving motivation for this feature is to improve interoperability with inherently dynamic languages like Python, Javascript, Ruby and others. That said, this feature is designed such that it can be applied to other inherently dynamic domains in a modular way. NOTE: if you are generally supportive of interoperability with dynamic languages but are concerned about the potential for abuse of this feature, please see the Reducing Potential Abuse section in the Alternatives Considered section and voice your support for one of those directions that limit the feature. Motivation and Context Swift is well known for being exceptional at interworking with existing C and Objective-C APIs, but its support for calling APIs written in scripting languages like Python, Perl, and Ruby is quite lacking. C and Objective-C are integrated into Swift by expending a heroic amount of effort into integrating Clang ASTs, remapping existing APIs in an attempt to feel “Swifty”, and by providing a large number of attributes and customization points for changing the behavior of this integration when writing an Objective-C header. The end result of this massive investment of effort is that Swift tries to provide an (arguably) better experience when programming against these legacy APIs than Objective-C itself does. When considering the space of dynamic languages, four things are clear: 1) there are several different languages of interest, and they each have significant communities in different areas: for example, Python is big in data science and machine learning, Ruby is popular for building server side apps, a few people apparently use Javascript, and even Perl is still widely used. 2) These languages have decades of library building behind them, sometimes with significant communities and 3) there are one or two orders of magnitude more users of these libraries than there are people currently using Swift. 4) APIs written in these languages will never feel “Swifty”, both because of serious differences between the type systems of Swift and these languages, and because of runtime issues like the Python GIL. In the extensive discussion and development of this feature (including hundreds of emails to swift-evolution) we considered many different implementation approaches. These include things like Objective-C style bridging support, F# type providers, generated wrappers, foreign class support, and others described in the Alternative Python Interoperability Approaches section. The conclusion of these many discussions was that it is better to embrace the fact that these languages are inherently dynamic and meet them where they are: F# type providers and generated wrappers require this proposal to work in the first place (because, for example, Javascript does not have classes and Python doesn’t have stored property declarations) and providing a good code completion experience for dynamic languages requires incorporation of flow-sensitive analysis into SourceKit (something that is fully compatible with this proposal). Given that Swift already has an intentionally incredibly syntax-extensible design, we only need two minor enhancements to the language to support these dynamic languages in an ergonomic way: this proposal (which introduces the @dynamicMemberLookup attribute) and a related @dynamicCallable proposal. To show the impact of these proposals, consider this Python code: class Dog: def __init__(self, name): self.name = name self.tricks = [] # creates a new empty list for each dog def add_trick(self, trick): self.tricks.append(trick) return self we would like to be able to use this from Swift like this (the comments show the corresponding syntax you would use in Python): // import DogModule // import DogModule.Dog as Dog // an alternate let Dog = Python.import(&quot;DogModule.Dog&quot;) // dog = Dog(&quot;Brianna&quot;) let dog = Dog(&quot;Brianna&quot;) // dog.add_trick(&quot;Roll over&quot;) dog.add_trick(&quot;Roll over&quot;) // cuteDog = Dog(&quot;Kaylee&quot;).add_trick(&quot;snore&quot;) let cuteDog = Dog(&quot;Kaylee&quot;).add_trick(&quot;snore&quot;) Of course, this would also apply to standard Python APIs as well. Here is an example working with the Python pickle API and the builtin Python function open: // import pickle let pickle = Python.import(&quot;pickle&quot;) // file = open(filename) let file = Python.open(filename) // blob = file.read() let blob = file.read() // result = pickle.loads(blob) let result = pickle.loads(blob) This can all be expressed today as library functionality written in Swift, but without this proposal, the code required is unnecessarily verbose and gross. Without it (but with the related @dynamicCallable proposal) the code would have explicit member lookups all over the place: // import pickle let pickle = Python.get(member: &quot;import&quot;)(&quot;pickle&quot;) // file = open(filename) let file = Python.get(member: &quot;open&quot;)(filename) // blob = file.read() let blob = file.get(member: &quot;read&quot;)() // result = pickle.loads(blob) let result = pickle.get(member: &quot;loads&quot;)(blob) // dog2 = Dog(&quot;Kaylee&quot;).add_trick(&quot;snore&quot;) let dog2 = Dog(&quot;Kaylee&quot;).get(member: &quot;add_trick&quot;)(&quot;snore&quot;) If you’d like to explore what Python interoperability looks like with plain Swift 4 (i.e. without either of these proposals) then check out the Xcode 9 playground demonstrating Python interoperability that has been periodically posted to swift-evolution over the last few months. While this is a syntactic sugar proposal, we believe that this expands Swift to be usable in important new domains. In addition to dynamic language interoperability, this sort of functionality is useful for other APIs, e.g. when working with dynamically typed unstructured data like JSON, which could provide an API like jsonValue?.jsonField1?.jsonField2 where each field is dynamically looked up. An example of this is shown below in the “Example Usage” section. Proposed solution We propose introducing a new attribute to the Swift language, @dynamicMemberLookup. Types with this attribute on their primary type declaration have the behavior that member lookup - accessing someval.member will always succeed. Failures to find normally declared members of member will be turned into subscript references using the someval[dynamicMember: member] member. It is an error to put the @dynamicMemberLookup attribute on a type but not have this subscript declared. This attribute extends the language such that member lookup syntax (x.y) - when it otherwise fails (because there is no member y defined on the type of x) and when applied to a value with the @dynamicMemberLookup attribute - is accepted and transformed into a subscript on x. The produced value is a mutable L-value if the type implements a mutable subscript, or immutable otherwise. This allows the type to perform arbitrary runtime processing to calculate the value to return. The dynamically computed property can be used the same way as an explicitly declared computed property, including being passed inout if mutable. The attribute is intentionally designed to be flexible: the implementation can take the member name through any ExpressibleByStringLiteral type, including StaticString and of course String. The result type may also be any type the implementation desires, including an Optional, ImplicitlyUnwrappedOptional or some other type, which allows the implementation to reflect dynamic failures in a way the user can be expected to process (e.g., see the JSON example below). Example Usage While there are many potential uses of this sort of API, one motivating example comes from a prototype Python interoperability layer. There are many ways to implement this, and the details are not particularly important, but it is perhaps useful to know that this is directly useful to address the motivation section described above. Given a currency type of PyVal, an implementation may look like: @dynamicMemberLookup struct PyVal { ... subscript(dynamicMember member: String) -&gt; PyVal { get { let result = PyObject_GetAttrString(borrowedPyObject, member)! return PyVal(owned: result) } set { PyObject_SetAttrString(borrowedPyObject, member, newValue.borrowedPyObject) } } } Another example use are JSON libraries which represent JSON blobs as a Swift enum, e.g.: enum JSON { case IntValue(Int) case StringValue(String) case ArrayValue(Array&lt;JSON&gt;) case DictionaryValue(Dictionary&lt;String, JSON&gt;) } Today, it is not unusual for them to implement members like this to allow drilling down into the JSON value: extension JSON { var stringValue : String? { if case .StringValue(let str) = self { return str } return nil } subscript(index: Int) -&gt; JSON? { if case .ArrayValue(let arr) = self { return index &lt; arr.count ? arr[index] : nil } return nil } subscript(key: String) -&gt; JSON? { if case .DictionaryValue(let dict) = self { return dict[key] } return nil } } This allows someone to drill into a JSON value with code like: json[0]?[&quot;name&quot;]?[&quot;first&quot;]?.stringValue. On the other hand, if we add the @dynamicMemberLookup attribute and an implementation like this: @dynamicMemberLookup enum JSON { ... subscript(dynamicMember member: String) -&gt; JSON? { if case .DictionaryValue(let dict) = self { return dict[member] } return nil } } Now clients are able to write more natural code like: json[0]?.name?.first?.stringValue which is close to the expressivity of Javascript… while being fully type safe! It is important to note that this proposal does not include introducing or changing an existing JSON type to use this mechanic, we only point out that this proposal allows subsequent work to turn this on if sagacious API authors approve of it. Future Directions: Python Code Completion In the extensive discussion of alternative implementation approaches, one concern raised was whether or not we could ever get a good code completion experience with this design. It would be nice to get at least something along the lines of what Swift provides for AnyObject lookup, where you can get a “big list” and filter down quickly as you type. After extensive discussion at the Core Team, we concluded that the best way to get a good code completion for Python APIs in Swift (if and when that becomes a priority) is to build such functionality into SourceKit, and model it directly after the way that existing Python IDEs provide their code completion. The observation is that a state of the art Python code completion experience requires incorporating simple control flow analysis and unsound heuristics into the the model in order to take local hints into account, pre-filtering the lists. These heuristics would be inappropriate to include in the static type system of the Swift language (in any form), and thus we believe it is better to build this as special support in SourceKit (e.g. special casing code completion on Python.PyVal (or whatever the currency type ends up being called) to incorporate these techniques. In any case, while we would like to see such future developments, but they are beyond the scope of this proposal, and are a tooling discussion for “swift-dev”, not a language evolution discussion. Source compatibility This is a strictly additive proposal with no source breaking changes. Effect on ABI stability This is a strictly additive proposal with no ABI breaking changes. Effect on API resilience Types with this attribute will always succeed at member lookup (x.foo will always be accepted by the compiler): members that are explicitly declared in the type or in a visible extension will be found and referenced, and anything else will be handled by the dynamic lookup feature. That behavior could lead to a surprising behavior change if the API evolves over time: adding a new statically declared member to the type or an extension will cause clients to resolve that name to the static declaration instead of being dynamically dispatched. This is inherent to this sort of feature, and means it should not be used on types that have a large amount of API, API that is likely to change over time, or API with names that are likely to conflict. Alternatives considered A few alternatives were considered: Spelling: Attribute vs Declaration Modifier This proposal argues for spelling this as a @dynamicMemberLookup attribute that is applied to a type, but there are many other ways this can be spelled. There could be other ]attribute names that are worth considering (suggestions welcome!), and it is also possible to spell this as a declaration modifier like dynamicMemberLookup. Make this a marker protocol We started with the approach of making this be a protocol that types conform to to get this behavior. It turns out that this behavior is very non-protocol like: it is not useful to define generic algorithms over, and existential values are only useful if they define a specific subscript that implements the requirements implicit in this attribute. For these and other reasons, defining this as a protocol doesn’t really fit into the design of Swift. Model this with methods, instead of a labeled subscript It may be surprising to some that this functionality is modeled as a subscript instead of a get/set method pair. This is intentional though: subscripts are the way that Swift supports parameterized l-values like we’re are trying to expose here. Exposing this as two methods doesn’t fit into the language as cleanly, and would make the compiler implementation more invasive. It is better to use the existing model for l-values directly. Reducing Potential Abuse In the discussion cycle, there was significant concern about abuse of this feature, particularly when this was spelled as a protocol that would allow someone to retroactively conform a type to the DynamicMemberLookupProtocol protocol. For this and other reasons, this proposal has been revised to be an attribute that can be applied to a primary type declaration, not to be a protocol. On the other hand, the potential for abuse has never been a strong guiding principle for Swift features (and many existing features could theoretically be abused (including operator overloading, emoji identifiers, AnyObject lookup, ImplicitlyUnwrappedOptional, and many more). If we look to other language communities, we find that Objective-C has many inherently dynamic features. Furthermore, directly analogous “dynamic” features were added to C# and Scala late in their evolution cycle, and no one has produced evidence that they led to abuse. Finally, despite extensive discussion on the mailing list and lots of concern about how this feature could be abused, no one has been able to produce (even one) non-malicious example where someone would use this feature inappropriately and lead to harm for users (and of course, if you’re consuming an API produced by a malicious entity, you are already doomed. :-)). Fortunately (if and only if a compelling example of harm were demonstrated) there are different ways to assuage concerns of “abuse” of this feature, for example we could have the compiler specifically bless individual well-known types, e.g. Python.PyVal (or whatever it is eventually named) by baking in awareness of these types into the compiler. Such an approach would require a Swift evolution proposal to add a new type that conforms to this. Despite such possibilities, this doesn’t seem like a likely future direction. Increasing Visibility of Dynamic Member Lookups People have suggested that we add some explicit syntax to accesses to make the dynamic lookup visible, e.g.: foo.^bar or foo-&gt;bar or some other punctuation character we haven’t already used. In my opinion, this is the wrong thing to do for several reasons: 1) Swift’s type system already includes features (optionals, IUOs, runtime failure) for handling failability. Keeping that orthogonal to this proposal is good because that allows API authors to make the right decision for expressing the needs of their use-case. 2) Swift already has a dynamic member lookup feature, “AnyObject dispatch” which does not use additional punctuation, so this would break precedent. The syntax and behavior of AnyObject dispatch was carefully considered in a situation that was directly analogous to this - Swift 1 days - where nullability audited headers were rare. 3) Adding punctuation to the lookup itself reduces the likelihood that an API author would make the lookups return strong optionals, because of increased syntactic noise. 4) The point of this proposal is to make use of dynamic language APIs more elegant than what is already possible: making use of them ugly (this punctuation character would be pervasive through use of the APIs and just add visual noise, not clarity) undermines the entire purpose of this proposal. 5) There are already other features (including operator overloading, subscripts, forthcoming @dynamicCallable, etc) that are just as dynamic as property lookup when implemented on a type like PyVal. Requiring additional syntax for “a.b” but not “a + b” (which can be just as dynamic) would be inconsistent. 6) Language syntax is not the only way to handle this. IDEs like Xcode could color code dynamic member lookups differently, making their semantics visible without adversely affecting the code that is written. It is true that not all developers use Xcode, but since many other major pieces of Swift assume a rich editor experience, it is consistent for this one to expect it too. It probably helps to consider an example. Assume we used the ^ sigil to represent a dynamic operation (member lookup, call, dynamic operator, etc). This would give us syntax like foo.^bar for member lookup, baz^(42) for calls. The API author isn’t forced to pick an operator that follows this scheme, but has the option to do so. Such a design would change reasonable code like this: let np = Python.import(&quot;numpy&quot;) let x = np.array([6, 7, 8]) let y = np.arange(24).reshape(2, 3, 4) let a = np.ones(3, dtype: np.int32) let b = np.linspace(0, pi, 3) let c = a+b let d = np.exp(c) print(d) into: let np = Python.import(&quot;numpy&quot;) let b = np^.array^([6, 7, 8]) let y = np^.arange^(24)^.reshape^(2, 3, 4) let a = np^.ones^(3, dtype: np^.int32) let b = np^.linspace^(0, pi, 3) let c = a+^b let d = np^.exp^(c) This does not improve clarity of code, it merely serves to obfuscate logic. It is immediately apparent from the APIs being used, the API style, and the static types (in Xcode or through static declarations) that this is all Python stuff. When you start mixing in use of native Swift types like dictionaries (something we want to encourage because they are typed!) you end up with an inconsistent mishmash where people would just try adding syntax or applying fixits continuously until the code builds. The example gets ever worse if the implementation chooses to return a strong optional value, because you’d end up with something like this (just showing a couple lines): let y = np^.arange?^(24)?^.reshape?^(2, 3, 4)! let a = np^.ones?^(3, dtype: np^.int32!)! This is so bad that no one would actually do this. Making the Python operators return optionals would be even worse, since binary operators break optional chaining. Alternative Python Interoperability Approaches In addition to the alternatives above (which provide different approaches to refine a proposal along the lines of this one), there have also been extensive discussion of different approaches to the problem of dynamic language interoperability on the whole. Before we explore those alternatives, we need to understand the common sources of concern. The biggest objection to this proposal is that it is “completely dynamic”, and some people have claimed that Swift intentionally pushes people towards static types. Others claim that dynamic features like this are unsafe (what if a member doesn’t exist?), and claim that Swift does not provide unsafe features. While the aims are largely correct for pure Swift code, the only examples of language interoperability we have so far is with C and Objective-C, and Swift’s interop with those is indeed already memory unsafe, unsound, and far more invasive than what we propose. Observe: 1) Swift does have completely dynamic features, even ones that can be used unsafely or unwisely. There was a recent talk at Swift Summit 2017 that explored some of these. 2) Bridging to dynamic languages inherently requires “fully dynamic” facilities, because the imported language has fully dynamic capabilities, and programmers use them. This is pervasive in Python code, and is also reasonable common in Objective-C “the id type”. 3) The Objective-C interoperability approach to handling the “inherently dynamic” parts of Objective-C is a feature called “AnyObject dispatch”. If you aren’t familiar, it returns members lookup as ImplicitlyUnwrappedOptional types (aka, T! types), which are extremely dangerous to work with - though not “unsafe” in the Swift sense. 4) Beyond the problems with IUOs, Anyobject lookup is also completely non-type safe when the lookup is successful: it is entirely possible to access a property or method as “String” even if it were declared as an integer in Objective-C: the bridging logic doesn’t even return such a lookup as nil in general. 5) The implementation of “AnyObject lookup” is incredibly invasive across the compiler and has been the source of a large number of bugs. 6) Beyond AnyObject lookup, the Clang importer itself is ~25 thousand lines of code, and while it is the source of great power, it is also a continuous source of bugs and problems. Beyond the code in the Clang importer library itself, it also has tendrils in almost every part of the compiler and runtime. in contrast, the combination of the @dynamicMemberLookup and @dynamicCallable proposals are both minimally invasive in the compiler, and fully type safe. Implementations of these proposals may choose to provide one of three styles of fully type safe implementation: 1) Return optional types, forcing clients to deal with dynamic failures. We show an example of this in the JSON example above. 2) Return IUO types, providing the ability for clients to deal with dynamic failures, but allow them to ignore them otherwise. This approach is similar to AnyObject dispatch, but is more type safe. 3) Return non-optional types, and enforce type safety at runtime with traps. This is the approach followed in the Python interop example above, but that bridge is under development and may switch to another approach if it provides a better experience. The actual prototype already has a more holistic approach for handling failability that isn’t describe here. The style of design depends on the exact bridging problem being solved, e.g. the customs of the language being interoperated with. Also, yes, it is possible to use these APIs to provide an unsafe API, but that is true of literally every feature in Swift - Swift provides support for unsafe features as part of its goals to be pragmatic. With this as background, let’s explore the proposed alternatives approaches to dynamic language interoperability: Direct language support for Python (and all the other languages) We considered implementing something analogous to the Clang importer for Python, which would add a first class Python specific type(s) to Swift language and/or standard library. We rejected this option because: 1) Such integration would require that we do something like this proposal anyway, because Python (like Objective-C) is a fundamentally dynamic language, and we need a way to express that fundamental dynamism: either this proposal or something like “AnyObject for Python”. 2) Python is actually far less “inherently typed” than Objective-C is, because everything is typed with the equivalent of id, whereas the Objective-C community has used concrete types for many things (and with the introduction of Objective-C Generics and other features, this has become even more common). 3) it would be significantly more invasive in the compiler than this proposal. While it is unlikely to be as large a scope of impact as the Clang importer in terms of bulk of code, it would require just as many tendrils spread throughout the compiler. 4) Taking this approach would set the precedent for all other dynamic languages to get first class language support baked into the Swift compiler, leading to an even greater complexity spiral down the road. 5) The proposed “first class support” doesn’t substantially improve the experience of working with Python over this proposal, so it is all pain and no gain. Several people have suggested that a “Clang-importer” style Python interoperability approach could use the “Type Hints” introduced in PEP 484, which would invalidate that last point above. This approach to progressive typing for Python was prototyped in mypy and first shipped in Python 3.5 in September 2015. Unfortunately, it isn’t reasonable to expect Type Hints to significantly improve the experience working with Python in Swift for several reasons, including: 1) PEP 484 states: “It should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.” (the emphasis is by the authors of PEP 484). This means we need this proposal or something like AnyObject lookup … forever. 2) These annotations are only currently supported on a provisional basis, which means that they are “deliberately excluded from .. backwards compatibility guarantees… up to and including removal of the interface”. Because they are subject to change and potentially removal, they haven’t gotten wide adoption. 3) Unlike Objective-C type annotations, these type hints are inherently unsound by design. Further, Python APIs often creep to accepting many more types than a Swift programmer would expect, which means that a type annotation is often “so broad as to be unhelpful” or “too narrow to be correct”. 4) These annotations are not dynamically enforced, and they are specifically designed to “influence” static analysis tools, which means that they are also frequently wrong. In the context of a narrowly used static analysis tool, a wrong type annotation is merely annoying. In the context of bridging into Swift, being incorrect is a real problem. 5) The fact that they have only been available in Python 3 (which has a smaller community than Python 2) and have only been shipping for 2 years, means that they haven’t been used by many people, and which contributes to their low adoption. 6) It is a goal to work with other dynamic language communities beyond Python, and not all have progressive typing facilities like this one. 7) Type annotations help the most in situations when you are “mixing and matching” Swift code with an existing body of some other code that you are able to modify. While it is possible that some people will want to mix and match Swift and Python, by far the most common reason for wanting to interoperate with a dynamic language is to leverage the existing APIs that the community provides in a black box manner. Being black box means that you want to reuse the code, but you don’t want to touch and own it yourself. 8) Finally, the idea of Swift providing a “better Python than Python itself does” under-appreciates the effort that the Python community has spent trying to achieve the same goals. Its community includes a lot of people in it that understand the benefits of static and progressive typing (e.g. the mypy community) and they have spent a lot of time on this problem. Despite their efforts, the ideas have low adoption: Swift bridging doesn’t change the fundamental reasons for this. Finally, it is important to realize that Swift and Clang have a special relationship because they were designed by many of the same people - so their implementations are similar in many respects. Further, the design of both Clang and the Objective-C language shifted in major ways to support interoperability with Swift - including the introduction of ARC, Modules, Objective-C generics, pervasive lazy decl resolution, and many more minor features). It is extremely unlikely that another established language/compiler community would accept the scope of changes necessary to provide great importer support for them, and it is also extremely unlikely that one would just magically work out of the box for what we need it to do. That said, our goals aren’t to provide a better Python than Python, only to embrace Python (and other dynamic languages) for what they are, without polluting the Swift compiler and runtime with a ton of complexity that we’ll have to carry around forever. Introduce F# style “Type Providers” into Swift Type providers are a cool feature of the F# language. They are an expansive (and quite complex) metaprogramming system which permits a “metaprogrammed library” to synthesize types and other language features into the program based on statically knowable type databases. This leads to significantly improved type safety in the case where schemas for dynamic APIs are available (e.g. a JSON schema) but which are not apparent in the source code. While type providers are extremely interesting and might be considered for inclusion into a future macro system in Swift, it is important to understand that they just provide a way for library developers to extend the compiler along the lines of the Clang importer in Swift. As such, they aren’t actually helpful for this proposal for all of the reasons described in the section above, but the most important point is that: Type providers can only “provide” a type that is expressible in the language, and dynamic languages do have completely dynamic features, so something that provides the semantics of DynamicMemberLookup will be required with that approach anyway. We’d have to take this proposal (or something substantially similar) before type providers would be useful for Python in the first place. Because of this, we believe that type providers and other optional typing facilities are a potentially interesting follow-on to this proposal which should be measured according to their own merits. The author of this proposal is also personally skeptical that type providers could ever be done in a way that is acceptable within the goals of Swift (e.g. to someday have fast compile times). Introduce a language independent “foreign class” feature to Swift One suggestion was to introduce a general “foreign class” feature to Swift. The core team met to discuss this and concluded that it was the wrong direction to go. Among opinions held by core team members, several believed that forcing other languages models into the Swift model would violate their fundamental principles (e.g. Go and Javascript don’t have classes), some felt it would be too invasive into the compiler, and others believed that such an approach ends up requiring a DynamicMemberLookup related feature anyway - because e.g. Python doesn’t require property declarations. Use “automatically generated wrappers” to interface with Python This approach has numerous problems. Beyond that, wrappers also fundamentally require that we take (something like) this proposal to work in the first place. The primary issue is that Python (and other dynamic languages) require no property declarations. If you have no property declaration, there is nothing for the wrapper generator to [w]rap or generate.",
    "url": "http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html",
    "relUrl": "/docs/2019-08-26-0195-dynamic-member-lookup.html"
  },
  "195": {
    "id": "195",
    "title": "SE-0196 Compiler Diagnostic Directives",
    "content": "Compiler Diagnostic Directives Proposal: SE-0196 Author: Harlan Haskins Review Manager: Ted Kremenek Implementation: apple/swift#14048 Previous Revision: 1 Status: Implemented (Swift 4.2) Introduction This proposal introduces #warning and #error directives that will cause the Swift compiler to emit a custom warning or an error during compilation. Motivation During the development lifecycle, it’s common to leave bits of code unfinished while focusing on other parts. Frequently, developers leave TODO or FIXME comments around unfinished or suboptimal portions of their code to signal to themselves and their teammates that the code needs work. Many editors pick up on these comments and present them in code navigators, but these don’t materialize in command-line builds or continuous integration. Allowing #warning gives a predictable, universal way to ensure a message will be displayed during compilation. Additionally, it’s possible for two build configurations to be mutually exclusive, and there isn’t a canonical way to ensure those configurations don’t happen. #error solves this problem: #if MYLIB_VERSION &lt; 3 &amp;&amp; os(macOS) #error(&quot;MyLib versions &lt; 3 are not supported on macOS&quot;) #endif #warning can be used for code templates where the user is meant to fill in the values of global constants or implement missing routines: enum APICredentials { #warning(&quot;fill in your API key below&quot;) static let key = &quot;&quot; #warning(&quot;fill in your API secret below&quot;) static let secret = &quot;&quot; } Proposed solution Add #warning and #error as compiler directives that emit an appropriate diagnostic with the contents, pointing to the start of the message. func configPath() -&gt; String { #warning(&quot;this should be made more safe&quot;) return Bundle.main().path(forResource: &quot;Config&quot;, ofType: &quot;plist&quot;)! } Detailed design This will add four new productions to the Swift grammar: compiler-control-statement → warning-directive compiler-control-statement → error-directive warning-directive → #warning &#39;(&#39; static-string-literal &#39;)&#39; error-directive → #error &#39;(&#39; static-string-literal &#39;)&#39; Upon parsing a #error directive, the Swift compiler will emit the provided string literal as an error, pointing to the beginning of the string, and ignore the directive. Upon parsing a #warning directive, the Swift compiler will emit the provided string literal as a warning, pointing to the beginning of the string, and ignore the directive. If a #warning or #error exists inside a branch of a #if directive that is not taken, then no diagnostic is emitted. #if false #warning(&quot;this will not trigger a warning&quot;) #error(&quot;this will not trigger an error&quot;) #endif #if true #warning(&quot;this will trigger a warning&quot;) #error(&quot;this will trigger an error&quot;) #endif Impact on existing code This change is purely additive; no migration will be required. Alternatives considered We could do some kind of comment-parsing based approach to surface TODOs and FIXMEs, but #warning serves as a general-purpose facility for reporting at compile time. It is also likely that there are TODO and FIXME comments that are not urgent, but that should be revisited. Alexander Momchilov brought up the idea of using TODO and warning as functions in the standard library with special compiler magic that will warn on their uses. func TODO(_ message: StaticString? = nil) { if let s = message { print(&quot;TODO: (s)&quot;) } } @discardableResult func TODO&lt;T&gt;(_ message: StaticString? = nil, _ temporaryValue: T) -&gt; T { if let s = message { print(&quot;TODO: (s)&quot;) } return temporaryValue } While these could be useful, I think #warning and #error have uses beyond just marking unfinished code that would be unwieldy or impossible with just an expression-oriented approach. Erik Little refined that to instead use special directives #warning and #error in expression position, like: let somethingSuspect = #warning(&quot;This is really the wrong function to call, but I&#39;m being lazy&quot;, suspectFunction()) However, I think there’s not much of a benefit to this syntax vs. just adding a #warning above the line: #warning &quot;This is really the wrong function to call, but I&#39;m being lazy&quot; let somethingSuspect = suspectFunction() A few people have requested #message or #info, as an analogue for Clang’s #pragma message. This may be something we want, but I didn’t include it in this proposal because as of this writing, Clang treats #pragma message as a warning and flags it as -W#pragma-message. Future directions Both #message and an expression-based #warning are additive with respect to this proposal, and both could be addressed in future proposals. Rationale On February 1, 2018 the Core Team decided to accept this proposal with slight revision over the original proposal. The only revision over the original proposal is to change the syntax to use #warning(&lt;Message&gt;) instead of #warning &lt;Messsage&gt;. This fits well with most of Swift’s existing compiler directives, and was strongly supported in the review discussion. The review discussion also covered a variety of possible extensions or variants to this proposal, including support for using #warning as an expression instead of a line directive and support for runtime issues. The Core Team decided that while these directions are interesting and worth exploring, they are complementary to the core functionality serviced by this proposal. Further, keeping #warning as a line directive allows it to be used in a wide variety of contexts, and serves a different need than using it as a placeholder expression.",
    "url": "http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html",
    "relUrl": "/docs/2019-08-26-0196-diagnostic-directives.html"
  },
  "196": {
    "id": "196",
    "title": "SE-0197 Adding in-place `removeAll(where:)` to the Standard Library",
    "content": "Adding in-place removeAll(where:) to the Standard Library Proposal: SE-0197 Author: Ben Cohen Review Manager: John McCall Status: Implemented (Swift 4.2) Implementation: apple/swift#11576 Review: Thread Previous Revision: 1 Introduction It is common to want to remove all occurrences of a certain element from a collection. This proposal is to add a removeAll algorithm to the standard library, which will remove all entries in a collection in-place matching a given predicate. Motivation Removing all elements matching some criteria is a very common operation. However, it can be tricky to implement correctly and efficiently. The easiest way to achieve this effect in Swift 3 is to use filter and assign back, negating the thing you want to remove (because filter takes a closure of items to “keep”): var nums = [1,2,3,4,5] // remove odd elements nums = nums.filter { !isOdd($0) } In addition to readability concerns, this has two performance problems: fresh memory allocation, and a copy of all the elements in full even if none need to be removed. The alternative is to open-code a for loop. The simplest performant solution is the “shuffle-down” approach. While not especially complex, it is certainly non-trivial: if var i = nums.index(where: isOdd) { var j = i + 1 while j != nums.endIndex { let e = nums[j] if !isOdd(nums[j]) { nums[i] = nums[j] i += 1 } j += 1 } nums.removeSubrange(i...) } Possibilities for logic and performance errors abound. There are probably some in the above code. Additionally, this approach does not work for range-replaceable collections that are not mutable i.e. collections that can replace subranges, but can’t guarantee replacing a single element in constant time. String is the most important example of this, because its elements (graphemes) are variable width. Proposed solution Add the following method to RangeReplaceableCollection: nums.removeAll(where: isOdd) The default implementation will use the protocol’s init() and append(_:) operations to implement a copy-based version. Collections which also conform to MutableCollection will get the more efficient “shuffle-down” implementation, but still require RangeReplaceableCollection as well because of the need to trim at the end. Other types may choose Collections which are range replaceable but not mutable (like String) will be able to implement their own version which makes use of their internal layout. Collections like Array may also implement more efficient versions using memory copying operations. Since Dictionary and Set would benefit from this functionality as well, but are not range-replaceable, they should be given concrete implementations for consistency. Detailed design Add the following to RangeReplaceableCollection: protocol RangeReplaceableCollection { /// Removes every element satisfying the given predicate from the collection. mutating func removeAll(where: (Iterator.Element) throws -&gt; Bool) rethrows } extension RangeReplaceableCollection { mutating func removeAll(where: (Iterator.Element) throws -&gt; Bool) rethrows { // default implementation similar to self = self.filter } } Other protocols or types may also have custom implementations for a faster equivalent. For example RangeReplaceableCollection where Self: MutableCollection can provide a more efficient non-allocating default implementation. String is also likely to benefit from a custom implementation. Source compatibility This change is purely additive so has no source compatibility consequences. Effect on ABI stability This change is purely additive so has no ABI stability consequences. Effect on API resilience This change is purely additive so has no API resilience consequences. Alternatives considered removeAll(where:) takes a closure with true for elements to remove. filter takes a closure with elements to keep. In both cases, true is the “active” case, so likely to be what the user wants without having to apply a negation. The naming of filter is unfortunately ambiguous as to whether it’s a removing or keeping operation, but re-considering that is outside the scope of this proposal. Several collection methods in the standard library (such as index(where:)) have an equivalent for collections of Equatable elements. A similar addition could be made that removes every element equal to a given value. This could easily be done as a further additive proposal later. The initial proposal of this feature named it remove(where:). During review, it was agreed that this was unnecessarily ambiguous about whether all the matching elements should be removed or just the first, and so the method was renamed to removeAll(where:).",
    "url": "http://localhost:4000/docs/2019-08-26-0197-remove-where.html",
    "relUrl": "/docs/2019-08-26-0197-remove-where.html"
  },
  "197": {
    "id": "197",
    "title": "SE-0198 Playground QuickLook API Revamp #",
    "content": "Playground QuickLook API Revamp Proposal: SE-0198 Author: Connor Wakamo Implementation: Swift 4.1 deprecation (apple/swift#13911], introduction of new protocol (apple/swift-xcode-playground-support#21), Swift 5 removal + shim library (apple/swift#14252, apple/swift-corelibs-foundation#1415, apple/swift-xcode-playground-support#20) Review Manager: Ben Cohen Review thread: SE-0198 review Status: Implemented (Swift 4.1) Introduction The standard library currently includes API which allows a type to customize its description in Xcode playgrounds and Swift Playgrounds. This API takes the form of the PlaygroundQuickLook enum which enumerates types which are supported for quick looks, and the CustomPlaygroundQuickLookable protocol which allows a type to return a custom PlaygroundQuickLook value for an instance. This is brittle, and to avoid dependency inversions, many of the cases are typed as taking Any instead of a more appropriate type. This proposal suggests that we deprecate PlaygroundQuickLook and CustomPlaygroundQuickLookable in Swift 4.1 so they can be removed entirely in Swift 5, preventing them from being included in the standard library’s stable ABI. To maintain compatibility with older playgrounds, the deprecated symbols will be present in a temporary compatibility shim library which will be automatically imported in playground contexts. (This will represent an intentional source break for projects, packages, and other non-playground Swift code which use PlaygroundQuickLook or CustomPlaygroundQuickLookable when they switch to the Swift 5.0 compiler, even in the compatibility modes.) Since it is still useful to allow types to provide alternate descriptions for playgrounds, we propose to add a new protocol to the PlaygroundSupport framework which allows types to do just that. (PlaygroundSupport is a framework delivered by the swift-xcode-playground-support project which provides API specific to working in the playgrounds environment). The new CustomPlaygroundDisplayConvertible protocol would allow instances to return an alternate object or value (as an Any) which would serve as their description. The PlaygroundLogger framework, also part of swift-xcode-playground-support, will be updated to understand this protocol. Swift-evolution thread: Discussion thread topic for that proposal Motivation The PlaygroundQuickLook enum which currently exists in the standard library is substandard: public enum PlaygroundQuickLook { case text(String) case int(Int64) case uInt(UInt64) case float(Float32) case double(Float64) case image(Any) case sound(Any) case color(Any) case bezierPath(Any) case attributedString(Any) case rectangle(Float64, Float64, Float64, Float64) case point(Float64, Float64) case size(Float64, Float64) case bool(Bool) case range(Int64, Int64) case view(Any) case sprite(Any) case url(String) case _raw([UInt8], String) } The names of these enum cases do not necessarily match current Swift naming conventions (e.g. uInt), and many cases are typed as Any to avoid dependency inversions between the standard library and higher-level frameworks like Foundation and AppKit or UIKit. It also contains cases which the PlaygroundLogger framework does not understand (e.g. sound), and this listing of cases introduces revlock between PlaygroundLogger and the standard library that makes it challenging to introduce support for new types of quick looks. Values of this enum are provided to the PlaygroundLogger framework by types via conformances to the CustomPlaygroundQuickLookable protocol: public protocol CustomPlaygroundQuickLookable { var customPlaygroundQuickLook: PlaygroundQuickLook { get } } This protocol itself is not problematic, but if PlaygroundQuickLook is being removed, then it needs to be removed as well. Additionally, there is a companion underscored protocol which should be removed as well: public protocol _DefaultCustomPlaygroundQuickLookable { var _defaultCustomPlaygroundQuickLook: PlaygroundQuickLook { get } } Proposed solution To solve this issue, we propose the following changes: Introduce a new CustomPlaygroundDisplayConvertible protocol in PlaygroundSupport in Swift 4.1 to allow types to provide an alternate description for playground logging Deprecate PlaygroundQuickLook and CustomPlaygroundQuickLookable in Swift 4.1, suggesting users use CustomPlaygroundDisplayConvertible instead Remove PlaygroundQuickLook and CustomPlaygroundQuickLookable from the standard library in Swift 5.0 Provide an automatically-imported shim library for the playgrounds context to provide the deprecated instances of PlaygroundQuickLook and CustomPlaygroundQuickLookable for pre-Swift 5 playgrounds Detailed design To provide a more flexible API, we propose deprecating and ultimately removing the PlaygroundQuickLook enum and CustomPlaygroundQuickLookable protocol in favor of a simpler design. Instead, we propose introducing a protocol which just provides the ability to return an Any that serves as a stand-in for the instance being logged: /// A type that supplies a custom description for playground logging. /// /// All types have a default description for playgrounds. This protocol /// allows types to provide custom descriptions which are then logged in /// place of the original instance. /// /// Playground logging can generate, at a minimum, a structured description /// of any type. Playground logging is also capable of generating a richer, /// more specialized description of core types -- for instance, the contents /// of a `String` are logged, as are the components of an `NSColor` or /// `UIColor`. /// /// The current playground logging implementation logs specialized /// descriptions of at least the following types: /// /// - `String` and `NSString` /// - `Int` and `UInt` (including the sized variants) /// - `Float` and `Double` /// - `Bool` /// - `Date` and `NSDate` /// - `NSAttributedString` /// - `NSNumber` /// - `NSRange` /// - `URL` and `NSURL` /// - `CGPoint`, `CGSize`, and `CGRect` /// - `NSColor`, `UIColor`, `CGColor`, and `CIColor` /// - `NSImage`, `UIImage`, `CGImage`, and `CIImage` /// - `NSBezierPath` and `UIBezierPath` /// - `NSView` and `UIView` /// /// Playground logging may also be able to support specialized descriptions /// of other types. /// /// Implementors of `CustomPlaygroundDisplayConvertible` may return a value of /// one of the above types to also receive a specialized log description. /// Implementors may also return any other type, and playground logging will /// generated structured logging for the returned value. public protocol CustomPlaygroundDisplayConvertible { /// Returns the custom playground description for this instance. /// /// If this type has value semantics, the instance returned should be /// unaffected by subsequent mutations if possible. var playgroundDescription: Any { get } } Additionally, instead of placing this protocol in the standard library, we propose placing this protocol in the PlaygroundSupport framework, as it is only of interest in the playgrounds environment. Should demand warrant it, a future proposal could suggest lowering this protocol into the standard library. If this proposal is accepted, then code like the following: extension MyStruct: CustomPlaygroundQuickLookable { var customPlaygroundQuickLook: PlaygroundQuickLook { return .text(&quot;A description of this MyStruct instance&quot;) } } would be replaced with something like the following: extension MyStruct: CustomPlaygroundDisplayConvertible { var playgroundDescription: Any { return &quot;A description of this MyStruct instance&quot; } } This proposal also allows types which wish to be represented structurally (like an array or dictionary) to return a type which is logged structurally instead of requiring an implementation of the CustomReflectable protocol: extension MyStruct: CustomPlaygroundDisplayConvertible { var playgroundDescription: Any { return [1, 2, 3] } } This is an enhancement over the existing CustomPlaygroundQuickLookable protocol, which only supported returning opaque, quick lookable values for playground logging. Implementations of CustomPlaygroundDisplayConvertible may potentially chain from one to another. For instance, with: extension MyStruct: CustomPlaygroundDisplayConvertible { var playgroundDescription: Any { return &quot;MyStruct description for playgrounds&quot; } } extension MyOtherStruct: CustomPlaygroundDisplayConvertible { var playgroundDescription: Any { return MyStruct() } } Playground logging for MyOtherStruct would generate the string “MyStruct description for playgrounds” rather than the structural view of MyStruct. It is legal, however, for playground logging implementations to cap chaining to a reasonable limit to guard against infinite recursion. Source compatibility This proposal is explicitly suggesting that we make a source-breaking change in Swift 5 to remove PlaygroundQuickLook, CustomPlaygroundQuickLookable, and _DefaultCustomPlaygroundQuickLookable. Looking at a GitHub search, there are fewer than 900 references to CustomPlaygroundQuickLookable in Swift source code; from a cursory glance, many of these are duplicates, from forks of the Swift repo itself (i.e. the definition of CustomPlaygroundQuickLookable in the standard library), or are clearly implemented using pre-Swift 3 names of the enum cases in PlaygroundQuickLook. (As a point of comparison, there are over 185,000 references to CustomStringConvertible in Swift code on GitHub, and over 145,000 references to CustomDebugStringConvertible, so CustomPlaygroundQuickLookable is clearly used many orders of magnitude less than those protocols.) Furthermore, it does not appear that any projects currently in the source compatibility suite use these types. However, to mitigate the impact of this change, we propose to provide a limited source compatibility shim for the playgrounds context. This will be delivered as part of the swift-xcode-playground-support project as a library containing the deprecated PlaygroundQuickLook and CustomPlaygroundQuickLookable protocols. This library would be imported automatically in playgrounds. This source compatibility shim would not be available outside of playgrounds, so any projects, packages, or other Swift code would be intentionally broken by this change when upgrading to the Swift 5.0 compiler, even when compiling in a compatibility mode. Due to the limited usage of these protocols, and the potential challenge in migration, this proposal does not include any proposed migrator changes to support the replacement of CustomPlaygroundQuickLookable with CustomPlaygroundDisplayConvertible. Instead, we intend for Swift 4.1 to be a deprecation period for these APIs, allowing any code bases which implement CustomPlaygroundQuickLookable to manually switch to the new protocol. While this migration may not be trivial programatically, it should – in most cases – be fairly trivial for someone to hand-migrate to CustomPlaygroundDisplayConvertible. During the deprecation period, the PlaygroundLogger framework will continue to honor implementations of CustomPlaygroundQuickLookable, though it will prefer implementations of CustomPlaygroundDisplayConvertible if both are present on a given type. Effect on ABI stability This proposal affects ABI stability as it removes an enum and a pair of protocols from the standard library. Since this proposal proposes adding CustomPlaygroundDisplayConvertible to PlaygroundSupport instead of the standard library, there is no impact of ABI stability from the new protocol, as PlaygroundSupport does not need to maintain a stable ABI, as its clients – playgrounds – are always recompiled from source. Since playgrounds are always compiled from source, the temporary shim library does not represent a new ABI guarantee, and it may be removed if the compiler drops support for the Swift 3 and 4 compatibility modes in a future Swift release. Removing PlaygroundQuickLook from the standard library also potentially allows us to remove a handful of runtime entry points which were included to support the PlaygroundQuickLook(reflecting:) API. Effect on API resilience This proposal does not impact API resilience. Alternatives considered Do nothing One valid alternative to this proposal is to do nothing: we could continue to live with the existing enum and protocol. As noted above, these are fairly poor, and do not serve the needs of playgrounds particularly well. Since this is our last chance to remove them prior to ABI stability, we believe that doing nothing is not an acceptable alternative. Provide type-specific protocols Another alternative we considered was to provide type-specific protocols for providing playground descriptions. We would introduce new protocols like CustomNSColorConvertible, CustomNSAttributedStringConvertible, etc. which would allow types to provide descriptions as each of the opaquely-loggable types supported by PlaygroundLogger. This alternative was rejected as it would balloon the API surface for playgrounds, and it also would not provide a good way to select a preferred description. (That is, what would PlaygroundLogger select as the description of an instance if it implemented both CustomNSColorConvertible and CustomNSAttributedStringConvertible?) Implement CustomPlaygroundDisplayConvertible in the standard library As an alternative to implementing CustomPlaygroundDisplayConvertible in PlaygroundSupport, we could implement it in the standard library. This would make it available in all contexts (i.e. in projects and packages, not just in playgrounds), but this protocol is not particularly useful outside of the playground context, so this proposal elects not to place CustomPlaygroundDisplayConvertible in the standard library. Additionally, it should be a source-compatible change to move this protocol to the standard library in a future Swift version should that be desirable. Since playgrounds are always compiled from source, the fact that this would be an ABI change for PlaygroundSupport does not matter, and a compatibility typealias could be provided in PlaygroundSupport to maintain compatibility with code which explicitly qualified the name of the CustomPlaygroundDisplayConvertible protocol. Have CustomPlaygroundDisplayConvertible return something other than Any One minor alternative considered was to have CustomPlaygroundDisplayConvertible return a value with a more specific type than Any. For example: protocol CustomPlaygroundDisplayConvertible { var playgroundDescription: CustomPlaygroundDisplayConvertible { get } } or: protocol PlaygroundDescription {} protocol CustomPlaygroundDisplayConvertible { var playgroundDescription: PlaygroundDescription { get } } In both cases, core types which the playground logger supports would conform to the appropriate protocol such that they could be returned from implementations of playgroundDescription. The benefit to this approach is that it is more self-documenting than the approach proposed in this document, as a user can look up all of the types which conform to a particular protocol to know what the playground logger understands. However, this approach has a number of pitfalls, largely because it’s intentional that the proposal uses Any instead of a more-constrained protocol. It should be possible to return anything as the stand-in for an instance, including values without opaque playground quick look views, so that it’s easier to construct an alternate structured view of a type (without having to override the more complex CustomReflectable protocol). Furthermore, by making the API in the library use a general type like Any, this proposal prevents revlock from occurring between IDEs and the libraries, as the IDE’s playground logger can implement support for opaque logging of new types without requiring library changes. (And IDEs can opt to support a subset of types if they prefer, whereas if the libraries promised support an IDE would effectively be compelled to provide it.) Have CustomPlaygroundDisplayConvertible return an Any? instead of an Any One alternative considered was to have CustomPlaygroundDisplayConvertible return an Any? instead of an Any. This would permit individual instances to opt-out of a custom playground description by returning nil instead of a concrete value or object. Although that capability is no longer present, in most cases implementors of CustomPlaygroundDisplayConvertible may return a custom description which closely mirrors their default description. One big exception to this are classes which are considered core types, such as NSView and UIView, as one level of subclass may wish to customize its description while deeper level may wish to use the default description (which is currently a rendered image of the view). This proposal does not permit that; the second-level subclass must return a custom description one way or another, and due to the chaining nature of CustomPlaygroundDisplayConvertible implementations, it cannot return self and have that reliably indicate to the playground logger implementation that that means “don’t use a custom description”. This issue seems to be limited enough that it should not tarnish the API design as a whole. Returning Any and not Any? is easier to understand, so this proposal opts to do that. Should this be a larger issue than anticipated, a future proposal could introduce a struct like DefaultPlaygroundDescription&lt;T&gt; which the playground logger would understand to mean “don’t check for a CustomPlaygroundDisplayConvertible conformance on the wrapped value”. Alternate Names for CustomPlaygroundDisplayConvertible Finally, as this introduces a new protocol, there are other possible names: CustomPlaygroundRepresentable CustomPlaygroundConvertible CustomPlaygroundPreviewConvertible CustomPlaygroundQuickLookConvertible CustomPlaygroundValuePresentationConvertible CustomPlaygroundPresentationConvertible CustomPlaygroundRepresentable was rejected as it does not match the naming convention established by CustomStringConvertible/CustomDebugStringConvertible. CustomPlaygroundConvertible was rejected as not being specific enough – types conforming to this protocol are not themselves convertible to playgrounds, but are instead custom convertible for playground display. CustomPlaygroundPreviewConvertible is very similar to CustomPlaygroundDisplayConvertible, but implies more about the presentation than is appropriate as a playground environment is free to display it any way it wants, not just as a “preview”. CustomPlaygroundQuickLookConvertible was rejected as it potentially invokes the to-be-removed PlaygroundQuickLook enum. CustomPlaygroundValuePresentationConvertible and CustomPlaygroundPresentationConvertible were rejected as too long of names for the protocol.",
    "url": "http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html",
    "relUrl": "/docs/2019-08-26-0198-playground-quicklook-api-revamp.html"
  },
  "198": {
    "id": "198",
    "title": "SE-0199 Adding `toggle` to `Bool`",
    "content": "Adding toggle to Bool Proposal: SE-0199 Author: Chris Eidhof Review Manager: Ben Cohen Status: Implemented (Swift 4.2) Decision notes: Rationale Implementation: apple/swift#14586 Review thread: Swift evolution forum Introduction I propose adding a mutating func toggle to Bool. It toggles the Bool. Swift-evolution thread: Discussion thread topic for that proposal Swift forums thread: pitch: adding toggle to Bool Motivation For Bool variables, it is common to want to toggle the state of the variable. In larger (nested) structs, the duplication involved can become especially annoying: myVar.prop1.prop2.enabled = !myVar.prop1.prop2.enabled It’s also easy to make a mistake in the code above if there are multiple Bool vars. Proposed solution Add a method toggle on Bool: extension Bool { /// Equivalent to `someBool = !someBool` /// /// Useful when operating on long chains: ///  /// myVar.prop1.prop2.enabled.toggle()  mutating func toggle() { self = !self } } This allows us to write the example above without duplication: myVar.prop1.prop2.enabled.toggle() ! and toggle() mirror the API design for - and negate(). (Thanks to Xiaodi Wu for pointing this out). Detailed design N/A Source compatibility This is strictly additive. Effect on ABI stability N/A Effect on API resilience N/A Alternatives considered Other names could be: invert negate flip From the brief discussion on SE, it seems like toggle is the clear winner. Some people also suggested adding a non-mutating variant (in other words, a method with the same semantics as the prefix ! operator), but that’s out of scope for this proposal, and in line with commonly rejected proposals.",
    "url": "http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html",
    "relUrl": "/docs/2019-08-26-0199-bool-toggle.html"
  },
  "199": {
    "id": "199",
    "title": "SE-0200 Enhancing String Literals Delimiters to Support Raw Text",
    "content": "Enhancing String Literals Delimiters to Support Raw Text Proposal: SE-0200 Authors: John Holdsworth, Brent Royal-Gordon, Erica Sadun Review Manager: Doug Gregor Previous Revision: 1 Status: Implemented (Swift 5) Implementation: apple/swift#17668 Bugs: SR-6362 Review: Discussion thread, Announcement thread Introduction Like many computer languages, Swift uses an escape character ( ) to create a special interpretation of subsequent characters within a string literal. Escape character sequences represent a set of predefined, non-printing characters as well as string delimiters (the double quote), the escape character (the backslash itself), and (uniquely in Swift) to allow in-string expression interpolation. Escape characters provide useful and necessary capabilities but strings containing many escape sequences are difficult to read. Other languages have solved this problem by providing an alternate “raw” string literal syntax which does not process escape sequences. As the name suggests, raw string literals allow you to use “raw” text, incorporating backslashes and double quotes without escaping. We propose to alter Swift’s string literal design to do the same, using a new design which we believe fits Swift’s simple and clean syntax. This design supports both single-line and multi-line string literals, and can contain any content whatsoever. This proposal has been extensively revised based on the Core Team feedback for SE-0200. It was discussed on the Swift online forums. Discussion Raw strings and their design have been discussed in the following Evolution forum threads: [Pitch] Raw mode string literals SE-0200: “Raw” mode string literals (Review thread) [Returned for revision] SE-0200: “Raw” mode string literals Pure Bikeshedding: Raw Strings (why yes, again!) Background Modern programming languages use two approaches to represent string literals. A conventional string literal is exactly what you use in Swift today. It allows you to use escape sequences like and &quot; and u{n} to express backslashes, quotes, and unicode scalars, among other special character sequences. A raw string literal ignores escape sequences. It allows you to paste raw code. In a raw string literal the sequence n represents three backslashes followed by the letter “n”, not a backslash followed by a line feed. This proposal uses the following terms. String literals represent a sequence of characters in source. String delimiters establish the boundaries at the start and end of a character sequence. Swift’s string delimiter is &quot;, the double quote (U+0022). Escape characters create a special interpretation of one or more subsequent characters within a string literal. Swift’s escape character is , the backslash (U+005C). Escape character sequences (shortened to escape sequence) represent special characters. In the current version of Swift, the backslash escape character tells the compiler that a sequence should combine to produce one of these special characters. Motivation Raw strings support non-trivial content which belongs directly in source code – not in an external file – but cannot be satisfactorily maintained or read in escaped form. Hand-escaped strings require time and effort to transform source material to an escaped form. It is difficult to validate the process to ensure the escaped form properly represents the original text. This task is also hard to automate as it may not pick up intended nuances, such as recognizing embedded dialog quotes. Escaping actively interferes with inspection. Developers should be able to inspect and modify raw strings in-place without removing that text from source code. This is especially important when working with precise content such as code sources and regular expressions. Backslash escapes are common in other languages and formats, from JSON to LaTeX to Javascript to regular expressions. Embedding these in a string literal currently requires doubling-up escapes, or even quadrupling if the source is pre-escaped. Pre-escaped source should be maintained exactly as presented so it can be used, for example, when contacting web-based services. Importantly, raw strings are transportable. They allow developers to cut and paste content both from and to the literal string. This allows testing, reconfiguration, and adaption of raw content without the hurdles escaping and unescaping that limit development. In short, a good raw string feature should let users embed any valid Unicode text snippet in a Swift string literal merely by surrounding it with appropriate delimiters, without altering the content itself. Examples Raw string literals may include characters normally used for escaping (such as the backslash character) and characters normally requiring escaping (such as a double quote &quot;). For example, consider the following multiline string. It represents code to be output at some point in the program execution: let separators = &quot;&quot;&quot; public static var newlineSeparators: Set&lt;Character&gt; = [ // [Zl]: &#39;Separator, Line&#39; &quot; u{2028}&quot;, // LINE SEPARATOR // [Zp]: &#39;Separator, Paragraph&#39; &quot; u{2029}&quot;, // PARAGRAPH SEPARATOR ] &quot;&quot;&quot; Unescaped backslash literals cause the unicode escape sequences to be evaluated and replaced in-string. This produces the following result: public static var newlineSeparators: Set&lt;Character&gt; = [ // [Zl]: &#39;Separator, Line&#39; &quot; &quot;, // LINE SEPARATOR // [Zp]: &#39;Separator, Paragraph&#39; &quot; &quot;, // PARAGRAPH SEPARATOR ] To preserve the intended text, each backslash must be escaped, for example u{2029}. This is a relatively minor edit but if the code is being copied in and out of the source to permit testing and modification, then each hand-escaped cycle introduces the potential for error. Single-line string literals may similarly be peppered with backslashes to preserve their original intent, as in the following examples. // Quoted Text let quote = &quot;Alice: &quot;How long is forever?&quot; White Rabbit: &quot;Sometimes, just one second.&quot;&quot; let quote = &quot;Alice: &quot;How long is forever? &quot; White Rabbit: &quot;Sometimes, just one second. &quot;&quot; // and // Regular Expression let ucCaseCheck = &quot;enum s+.+ {.*case s+[:upper:]&quot; let ucCaseCheck = &quot;enum s+.+ {.*case s+[:upper:]&quot; Escaping hinders readability and interferes with inspection, especially in the latter example, where the content contains secondary escape sequences. Using a raw form ensures the expression can be read and updated as needed in the form that will be passed by the literal string. Candidates A good candidate for using raw strings is non-trivial and is burdened by escaping because it: Is obscured by escaping. Escaping actively harms code review and validation. Is already escaped. Escaped material should not be pre-interpreted by the compiler. Requires easy transport between source and code in both directions, whether for testing or just updating source. The following example is a poor case for using a raw string: let path = &quot;C: AUTOEXEC.BAT&quot; The example is trivial and the escaping is not burdensome. It’s unlikely that the string contents will require any further modification or reuse in a raw form. Utility Raw strings are most valuable for the following scenarios. Metaprogramming: Use cases include code-producing-code. This incorporates utility programming and building test cases. Apps may generate color scheme type extensions (in Swift, ObjC, for SpriteKit/SceneKit, literals, etc) or date formatters, perform language-specific escaping, create markup, and more. Escaping complicates copying and pasting from working code into your source and back. When you’re talking about code, and using code, having that code be formatted as an easily updated raw string is especially valuable. Examples of popular apps that perform these tasks include Kite Compositor and PaintCode. Any utility app that outputs code would benefit in some form. Regular expressions: While we have bigger plans for regular expressions in the future, we think they will be a primary use case for raw strings in the short term, and will continue to have an important place in regex usage in the long term. Even if we introduce native regular expressions in a future version of Swift, users will still sometimes have to write regular expressions intended for use in other systems. For instance, if you need to send a regex to a server, or embed it in Javascript, or put it in a SQL query, or construct an NSRegularExpression and pass it to an existing API which uses that type, you’ll still express that regular expression as a string literal, not a native regex. And when you do, raw strings will make that much easier. A raw string feature would thus help with all regular expressions now and some regular expressions in the future. And if the native regular expression feature involves some form of quoting and escaping, it can follow the by-then-established precedent of this proposal to support “raw regexes”. Pedagogy: Not all Swift learning takes place in the playground and not all code described in Swift source files use the Swift programming language. Code snippets extend beyond playground-only solutions for many applications. Students may be presented with source code, which may be explained in-context within an application or used to populate text edit areas as a starting point for learning. Removing escaped snippets to external files makes code review harder. Escaping (or re-escaping) code is a tedious process, which is hard to inspect and validate. Data Formats and Domain Specific Languages: It’s useful to incorporate short sections of unescaped or pre-escaped JSON and XML. It may be impractical to use external files and databases for each inclusion. Doing so impacts inspection, maintenance, and updating. Windows paths: Windows uses backslashes to delineate descent through a directory tree: e.g., C: Windows All Users Application Data. The more complex the path, the more intrusive the escapes. Initial Proposal “Raw-mode” strings were first discussed during the SE-0168 Multi-Line String literals review and postponed for later consideration. This proposal focuses on raw strings to allow the entry of single and multi-line string literals. The first iteration of SE-0200 proposed adopting Python’s model, using r&quot;...raw string...&quot;. The proposal was returned for revision with the following feedback: During the review discussion, a few issues surfaced with the proposal, including: The proposed r”…” syntax didn’t fit well with the rest of the language. The most-often-discussed replacement was #raw(“…”), but the Core Team felt more discussion (as a pitch) is necessary. The proposal itself leans heavily on regular expressions as a use case for raw string literals. Several reviewers remarked that the motivation wasn’t strong enough to justify the introduction of new syntax in the language, so a revised proposal will need additional motivating examples in other domains. To move forward, the new raw string design must provide a suitable Swift-appropriate syntax that works within the language’s culture and conventions. Prior Art The following links explore the existing art in other languages. We were inspired by the Rust raw string RFC discussion when researching these features. Syntax Language(s) Possible in Swift? Swifty? &#39;Hello, world!&#39; Bourne shell, Perl, PHP, Ruby, Windows PowerShell Yes Yes if Rust-style multiplicity allows incorporating &#39; into raw strings. May be too narrow a use-case to burn &#39;. q(Hello, world!) Perl (alternate) Maybe (depends on delimiter) No %q(Hello, world!) Ruby (alternate) No (% is a valid prefix operator) No @&quot;Hello, world!&quot; C#, F# Yes (but would be awful for Obj-C switchers) No R&quot;(Hello, world!)&quot; C++11 Yes No r&quot;Hello, world!&quot; D, Python Yes No r#&quot;Hello, world!&quot;# Rust Yes Would need to drop the opening r and maybe change the delimiter from #. &quot;&quot;&quot;hello &#39; world&quot;&quot;&quot; and raw&quot;Hello, world!&quot; Scala No/Yes No `Hello, world!` D, Go, `…` No (conflicts with escaped identifiers) No, needs Rust multiplicity ``...`` Java, any number of ` No (conflicts with escaped identifiers) Yes Design We determined that Rust’s approach to raw string literals is the best starting point, offering the greatest flexibility in the smallest syntactic footprint. In Rust, raw string literals are written as r&quot;...&quot;. To embed double-quotes in a Rust raw string literal, you add one or more pound signs before the opening quote, and put a matching number of pound signs after the closing quote: r#&quot;...&quot;...&quot;#, r##&quot;...#&quot;...&quot;##, etc. Rust developers assured us that even one pound sign was unusual and more than one almost never needed but it’s nice to have the flexibility in the rare cases where you need it. Swiftifying Rust’s Design Rust’s design distinguishes between conventional and raw string literals. It also includes an asymmetric r off its leading edge. We found these distinctions unnecessary and the r aesthetically displeasing. Instead, our design powers up a conventional Swift String literal and in doing so, allows you to access features normally associated with raw literals. In this design, there is no separate “raw” syntax; rather, there is a small extension of the conventional string literal syntax. A conventional string literal is either: a sequence of characters surrounded by double quotation marks (“), or a string that spans several lines surrounded by three double quotation marks. These are examples of conventional Swift string literals: &quot;This is a single line Swift string literal&quot; &quot;&quot;&quot; This is a multi line Swift string literal &quot;&quot;&quot; In this form, the revised string design acts exactly like any other string. You use escape character sequences including string interpolation exactly as you would today. A backslash escape character tells the compiler that a sequence should be interpolated, interpreted as an escaped character, or represent a unicode scalar. Swift’s escape sequences include: The special characters 0 (null character), (backslash), t (horizontal tab), n (line feed), r (carriage return), &quot; (double quotation mark) and &#39; (single quotation mark) Arbitrary Unicode scalars, written as u{n}, where n is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point Interpolated expressions, introduced by ( and terminated by ) Expanding Delimiters Our design adds customizable string delimiters. You may pad a string literal with one or more # (pound, Number Sign, U+0023) characters: &quot;This is a Swift string literal&quot; #&quot;This is also a Swift string literal&quot;# ####&quot;So is this&quot;#### The number of pound signs at the start of the string (in these examples, zero, one, and four) must match the number of pound signs at the end of the string. &quot;This&quot;, #&quot;This&quot;#, and ##&quot;This&quot;## represent identical string values: static-string-literal -&gt; &quot; quoted-text &quot; | &quot;&quot;&quot; multiline-quoted-text &quot;&quot;&quot; | # static-string-literal # Any instance of the delimiter which is not followed by the appropriate number of pound signs is treated as literal string contents, rather than as the end of the string literal. That is, the leading pound signs change the string’s delimiter from &quot; to &quot;# (or &quot;##’, etc.). A plain &quot; without pound signs after it is just a double-quote character inside the string. #&quot;She said, &quot;This is dialog!&quot;&quot;# // Equivalent to &quot;She said, &quot;This is dialog! &quot;&quot; If you do add a backslash, it is interpreted as an extra character. This string literal includes the backslash and both double quote marks inside the string delimiters (#&quot; and &quot;#): #&quot;A &quot;quote&quot;.&quot;# When you need to include #&quot; (pound-quote) or &quot;# (quote-pound) in your character sequence, adjust the number of delimiting pound signs. This need should be rare. Customized Escape Delimiters This design uses an escape delimiter, that is a sequence of one or more characters to indicate the beginning of an escape character sequence, rather than a single escape character. Like Swift today, the escape delimiter begins with a backslash (Reverse Solidus, U+005C), but it is now followed by zero or more pound signs (Number Sign, U+0023). An escape delimiter in a string literal must match the number of pound signs used to delimit either end of the string. Here is the degenerate case. It is a normal string with no pound signs. The escape delimiter therefore needs no pound signs and a single backslash is sufficient to establish the escape character sequence: &quot;This string has an (interpolated) item&quot; Strings using custom boundary delimiters mirror their pound sign(s) after the leading backslash, as in these examples which produce identical results to the preceding string literal: #&quot;This string has an #(interpolated) item&quot;# ####&quot;This string has an ####(interpolated) item&quot;#### The escape delimiter customization matches the string. Any backslash that is not followed by the correct number of pound signs is treated as raw text. It is not an escape: #&quot;This is not (interpolated)&quot;# String Start Delimiter Escape Delimiter String End Delimiter &quot; &quot; #&quot; # &quot;# ##&quot; ## &quot;## ######&quot; ###### &quot;###### Inside the string, any backslash that is followed by too few pound signs (like # in a ##&quot;&quot;## string) is not an escape delimiter. It is just that exact string. Any backslash followed by too many pound signs (like ## in a #&quot;&quot;# string) creates an invalid escape sequence because it is an escape delimiter followed by one or more pound signs. This escaping rule supports several important features: it provides for raw string support, and string interpolation. We feel this is a huge win, especially for code generation applications. We believe this conceptual leap of elegance simplifies all our previous design workarounds and collapses them into one general solution. This design retains Rust-inspired custom delimiters, offers all the features of “raw” strings, introduces raw string interpolation, and does this all without adding a new special-purpose string type to Swift. Yes, this approach requires work: You must use pound signs for any raw string. You must use a more cumbersome interpolation sequence for raw strings than conventional strings. Hopefully the tradeoffs are worth it in terms of added expressibility and the resulting design is sufficiently elegant to pass muster. Updated Escape Character Sequences Reference Swift string literals may include the following special character sequences. Swift’s escape delimiter begins with a backslash (Reverse Solidus, U+005C), and is followed by zero or more pound signs (Number Sign, U+0023). An escape delimiter in a string literal must match the number of pound signs used to delimit either end of the string. Sequence Escape Characters Result Escape Delimiter + 0 Digit Zero (U+0030) Boundary Neutral / Null character U+0000 Escape Delimiter + Reverse Solidus (U+005C) Punctuation / Backslash U+005C Escape Delimiter + t Latin Small Letter T (U+0074) Character Tabulation / Horizontal Tab U+0009 Escape Delimiter + n Latin Small Letter N (U+006E) Paragraph Separator / Line Feed U+000A Escape Delimiter + r Latin Small Letter R (U+0072) Paragraph Separator / Carriage Return U+000D Escape Delimiter + &quot; Quotation Mark (U+0022) Punctuation / Quotation Mark U+0022 Escape Delimiter + &#39; Apostrophe (U+0027) Punctuation / Apostrophe (Single Quote) U+0027 Escape Delimiter + u{n} Latin Small Letter U (U+0055), Left Curly Bracket (U+007B), Right Curly Bracket (U+007D) An arbitrary Unicode scalar, where n is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point Escape Delimiter + (...) Left Parenthesis (U+0028), Right Parenthesis (U+0029) An interpolated expression Examples Consider the text #1: // What you type today &quot; #1&quot; // escape delimiter + backslash + # + 1 // What you type using the new system &quot; #1&quot; // the same // What you type with a single pound string delimiter #&quot; # #1&quot;# // escape delimiter + backslash + # + 1 // Or you can adjust the string delimiter for a raw string: ##&quot; #1&quot;## // backslash + # + 1, no escape sequence Adjusting string delimiters allows you to eliminate escape sequences to present text as intended for use: #&quot;c: windows system32&quot;# // vs. &quot;c: windows system32&quot; #&quot; d{3) d{3} d{4}&quot;# // vs &quot; d{3) d{3} d{4}&quot; #&quot;a string with &quot;double quotes&quot; in it&quot;# ##&quot;a string that needs &quot;# in it&quot;## #&quot;&quot;&quot; a string with &quot;&quot;&quot; in it &quot;&quot;&quot;# The following example terminates with backslash-r-backslash-n, not a carriage return and line feed: #&quot;a raw string containing r n&quot;# // vs &quot;a raw string containing r n&quot; The same behavior is extended to multi-line strings: #&quot;&quot;&quot; a raw string containing r n &quot;&quot;&quot;# New line escaping works as per SE-182: #&quot;&quot;&quot; this backslash and newline will be present in the string this newline will take it&#39;s escaped value in this case # and the line continues here with only a space joining. &quot;&quot;&quot;# Custom-delimited strings allow you to incorporate already-escaped text. For example, you can paste static data without having to worry about re-escaping a JSON message #&quot;&quot;&quot; [ { &quot;id&quot;: &quot;12345&quot;, &quot;title&quot;: &quot;A title that &quot;contains &quot; &quot;&quot; } ] &quot;&quot;&quot;# Without custom delimiters, Swift would silently unescape this content, yielding an invalid JSON message. Even if you did remember to escape, this process would be error-prone and difficult to maintain. However, if you wanted to interpolate the value of the “id” field, you could still do that without having to double-escape the other backslashes: #&quot;&quot;&quot; [ { &quot;id&quot;: &quot; #(idNumber)&quot;, &quot;title&quot;: &quot;A title that &quot;contains &quot; &quot;&quot; } ] &quot;&quot;&quot;# It is anticipated raw strings will also work in attributes: @available(swift, deprecated: 4.2, message: #&quot;Note: &quot; r n&quot; (CR-LF) is normalized to &quot; n&quot; (LF)&quot;#) Errors The compiler errors when an escape delimiter is followed by an unrecognized value to complete an escape sequence. For example, using one-#-delimited strings: #&quot;printf(&quot;%s n&quot;, value_string)&quot;# // no error, no escape sequence #&quot;printf(&quot;%s #n&quot;, value_string)&quot;# // newline escape sequence #&quot;printf(&quot;%s #x #n&quot;, value_string)&quot;# // error: escape delimiter + x. The last example can introduce a fixit by adding another # to either side of the string so # is no longer the escape delimiter. However, this eliminates the subsequent line feed (a valid escape sequence) that follows unless that, too, is appropriately updated. There are also wrong ways to add interpolated text. These examples are both errors. The escape delimiter in each case (respectively and #) is followed by #, forming an invalid escape sequence: &quot;This is not #(correct)&quot; #&quot;This is not ##(correct)&quot;# An escape with too many pounds should be an error with a special message and fix-it. The fixit should suggest that escape-delimiter + # instances remove the extra pound or add further #-signs to each end of the string. Discoverability and Recognition There are two questions of developer approach: discoverability (“how do I use raws string in Swift”) and recognition (“Why do some strings in Swift start with #?” and “Why are there # signs after backslashes?”). When presented to developers unfamiliar with the new string syntax, we feel that it isn’t overly burdensome to search the web for: “What do #/pound/number/etc signs mean in Swift strings?” “How do I use raw strings in Swift?” “How do I add quote marks to strings without escaping in Swift?” “How do I interpolate in raw Swift strings?” Implementation Changes are largely confined to the file lib/Parse/Lexer.cpp. They involve a slight modification to the main lexer loop Lexer::lexImpl() to detect strings that have a custom delimiter/are surrounded by 1 or more # characters. When the start of a custom-delimited string is detected Lexer::lexStringLiteral() is called with the delimiter’s length. Targeted changes to Lexer::lexCharacter() and Lexer::getEncodedStringSegment() bypass processing of the escape character if the delimiter length is not equal to the number of # characters after the , the degenerate case being delimiter length of 0 which is normal string processing. A new field StringDelimiterLength in Token.h carries the string escaping mode from the parsing to code generation phases of compilation. Source compatibility This is a purely additive change. The syntax proposed is not currently valid Swift. Effect on ABI stability None. Effect on API resilience None. Alternatives considered We evaluated many, many designs from other languages and worked through a long thread full of bikeshedding. We will list the most notable rejected designs here, but these are just the tip of the iceberg. Excluding single quotes and backticks Single quotes are a common syntax for raw strings in other languages. However, they’re also commonly used for character literals (i.e. integer literals containing the value of a Unicode scalar) in other languages. If we use single quotes for raw strings, we cannot use them for character literals or any other future proposal. We see no need to burn single quotes on this feature. Similarly, while backticks preserve the meaning of “code voice” and “literal”, as you are used to in Markdown, they would conflict with escaped identifiers. Using “raw” and “rawString” The original design r&quot;...&quot; was rejected in part for not being Swifty, that is, not taking on the look and feel and characteristics of existing parts of the language. Similar approaches like raw&quot;...&quot; and #raw&quot;...&quot; carry the same issues. Leading text is distracting and competes for attention with the content of the string that follows. And function-like constructs like #raw(&quot;...&quot;) harmonize better with the language syntax, but are even worse for readability. Using user-specified delimiter characters We felt user-specified delimiters overly complicated the design space, were harder to discover and use, and were generally un-Swifty. The pound sign is rarely used and a minor burden on the syntax. @rawString(delimiter: @) @&quot;Hello&quot;@ // no We considered a Perl/Ruby-like approach to arbitrary delimiters, but quickly rejected it. The arbitrary delimiter rules in these languages are complex and have many corner cases; we don’t need or want that complexity. We also rejected a standalone raw string attribute for being wordy and heavy, especially for short literals.",
    "url": "http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html",
    "relUrl": "/docs/2019-08-26-0200-raw-string-escaping.html"
  },
  "200": {
    "id": "200",
    "title": "SE-0201 Package Manager Local Dependencies",
    "content": "Package Manager Local Dependencies Proposal: SE-0201 Author: Ankit Aggarwal Review Manager: Boris Bügling Status: Implemented (Swift 4.2) Implementation: apple/swift-package-manager#1583 Bug: SR-7433 Introduction This proposal adds a new API in PackageDescription to support declaring dependency on a package using its path on disk instead of the git URL. Motivation There are two primary motivations for this proposal: Reduce friction in bringing up a set of packages. Currently, there is a lot of friction in setting up a new set of interconnected packages. The packages must be in a git repository and the package author needs to run the swift package edit command for each dependency to develop them in tandem. Some package authors prefer to keep their packages in a single repository. This could be because of several reasons, for e.g.: The packages are in very early design phase and are not ready to be published in their own repository yet. The author has a set of loosely related packages which they may or may not want to publish as a separate repository in future. Proposed solution We propose to add the following API in the PackageDescription module: extension Package.Dependency { public static func package(path: String) -&gt; Package.Dependency } This API will only be available if the tools version of the manifest is greater than or equal to the Swift version this proposal is implemented in. The value of path must be a valid absolute or relative path string. The package at path must be a valid Swift package. The local package will be used as-is and the package manager will not try to perform any git operation on the package. The local package must be declared in the root package or in other local dependencies. This means, it is not possible to depend on a regular versioned dependency that declares a local package dependency. A local package dependency will override any regular dependency in the package graph that has the same package name. A local dependency will not be recorded in the Package.resolved file and if it overrides a dependency in the package graph, any existing entry will be removed. This is similar to the edit mode behaviour. The package manager will not allow using the edit feature on local dependencies. Impact on existing packages None. Alternatives considered We considered piggybacking this on the multi-package repository feature, which would also allow authors to publish subpackages from a repository. However, we think local dependencies is a much simpler feature that stands on its own.",
    "url": "http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html",
    "relUrl": "/docs/2019-08-26-0201-package-manager-local-dependencies.html"
  },
  "201": {
    "id": "201",
    "title": "SE-0202 Random Unification",
    "content": "Random Unification Proposal: SE-0202 Author: Alejandro Alonso Review Manager: Ben Cohen Status: Implemented (Swift 4.2) Implementation: apple/swift#12772 Decision Notes: Rationale Introduction This proposal’s main focus is to create a unified random API, and a secure random API for all platforms. This idea has been floating around swift-evolution for a while now, but this is the thread that started this proposal: https://forums.swift.org/t/proposal-random-unification/6626 Motivation The current random functionality that Swift provides is through imported C APIs. This of course is dependent on what system is running the code. This means that a different random implementation is provided on a per system basis. Swift relies on Darwin to provide developers the arc4random(3) approach. While on Linux, many developers tend to use random(3), from the POSIX standard, or rand(3), from the C standard library, for a quick and dirty solution for Linux systems. A very common implementation that developers tend to use for quick random functionality is here: // This is confusing because some may look at this and think Foundation provides these functions, // when in reality Foundation imports Darwin and Glibc from which these are defined and implemented. // You get the same behavior when you import UIKit, or AppKit. import Foundation // We can&#39;t forget to seed the Linux implementation. // This is unsecure as time is a very predictable seed. // This raises more questions to whether or not Foundation, UIKit, or AppKit provided these functions. #if os(Linux) srandom(UInt32(time(nil))) #endif // We name this randomNumber because random() interferes with Glibc&#39;s random()&#39;s namespace func randomNumber() -&gt; Int { #if !os(Linux) return Int(arc4random()) // This is inefficient as it doesn&#39;t utilize all of Int&#39;s range #else return random() // or Int(rand()) #endif } // Many tend to opt in for ranges here, but for this example I opt for a start and end argument func random(from start: Int, to end: Int) -&gt; Int { #if !os(Linux) var random = Int(arc4random_uniform(UInt32(end - start))) #else // Not recommended as it introduces modulo bias var random = random() % (end - start) #endif random += start return random } // Alternatively, an easier solution would be: /* func random(from start: Int, to end: Int) -&gt; Int { var random = randomNumber() % (end - start) random += start return random } */ // However this approach introduces modulo bias for all systems rather than just Linux. While although this does work, it just provides a quick workaround to a much larger outstanding problem. Below is a list outlining the problems the example contains, and the problems the example introduces. In order to define these workarounds, developers must utilize a few platform checks. Developers should not be forced to define platform checks for such trivial requests like this one. Unexperienced developers who rely on workarounds like these, may be pushing unsecure code that is used by tens of hundreds or thousands of users. Starting with Darwin’s arc4random(3), pre macOS 10.12 (Sierra) and iOS 10, the implementation of arc4random(3) utilized the RC4 algorithm. This algorithm is now considered non-cryptographically secure due to RC4 weakness. Post macOS 10.12 (Sierra) and iOS 10, “…it was replaced with the NIST-approved AES cipher”, as stated from the man pages in terminal (man arc4random). Moving on to Linux we see that using random() or rand() to generate numbers make it completely predictable as these weren’t designed to be at a crypto level. In the example, it uses modulo to generate the number within the upper bound. Many developers may not realize it, but for a quick workaround, it introduces modulo bias in which modulo does not correctly distribute the probability in dividing the upper bound equally within the range. Highly inefficient as creating a new Int from a UInt32 doesn’t utilize the full extent of Int’s range. Could confuse some users as Foundation, AppKit, or UIKit don’t provide these random functionalities. Considering all of this, I believe it is very important that Swift provides developers a simple, easy to use, and powerful random API. Although this is out of focus for Swift 5, this proposal solves a huge pain point for many Swift developers. Proposed Solution Random Number Generator To kick this off, the standard library will provide a default RNG. Each platform vendor will have the freedom to decide the specific implementation for this RNG for their platform. The standard library should document what specific RNG implementation is used on a specific platform. The aspiration is that this RNG should be cryptographically secure, provide reasonable performance, and should be thread safe. If a vendor is unable to provide these goals, they should document it clearly. It is also worth mentioning, that if an RNG on a platform has the possibility of failing, then it must fail when it is unable to complete its operation. An example of this is reading from /dev/urandom. If an error is to occur during reading, then it should produce a fatal error and abort the application. Reasons why I went with this approach in Alternatives Considered at the bottom of this proposal. Random API For the core API, introduce a new protocol named RandomNumberGenerator. This type is used to define RNGs that can be used within the stdlib. Developers can conform to this type and use their own custom RNG throughout their whole application. Then for the stdlib’s default RNG implementation, introduce a new struct named SystemRandomNumberGenerator. Next, we will make extension methods for FixedWidthInteger, BinaryFloatingPoint and Bool. For numeric types, this allows developers to select a value within a range and swap out the RNG used to select a value within the range. FixedWidthInteger example: // Utilizes the standard library&#39;s default random // Alias to: // var rng = SystemRandomNumberGenerator() // Int.random(in: 0 ..&lt; 10, using: &amp;rng) let randomIntFrom0To10 = Int.random(in: 0 ..&lt; 10) let randomUIntFrom10Through100 = UInt.random(in: 10 ... 100, using: &amp;myCustomRandomNumberGenerator) // The following are examples on how to get full width integers let randomInt = Int.random(in: .min ... .max) let randomUInt = UInt.random(in: .min ... .max, using: &amp;myCustomRandomNumberGenerator) BinaryFloatingPoint example: // Utilizes the standard library&#39;s default random // Alias to: // var rng = SystemRandomNumberGenerator() // Float.random(in: 0 ..&lt; 1, using: &amp;rng) let randomFloat = Float.random(in: 0 ..&lt; 1) let randomDouble = Double.random(in: 0 ... .pi, using: &amp;myCustomRandomNumberGenerator) Bool example: // Utilizes the standard library&#39;s default random // Alias to: // var rng = SystemRandomNumberGenerator() // Bool.random(using: &amp;rng) let randomBool1 = Bool.random() let randomBool2 = Bool.random(using: &amp;myCustomRandomNumberGenerator) Collection Additions Random Element For Collection we add an extension method for collections to get a random element. Collection example: let greetings = [&quot;hey&quot;, &quot;hi&quot;, &quot;hello&quot;, &quot;hola&quot;] // Utilizes the standard library&#39;s default random // Alias to: // var rng = SystemRandomNumberGenerator() // greetings.randomElement(using: &amp;rng)! print(greetings.randomElement()!) // This returns an Optional print(greetings.randomElement(using: &amp;myCustomRandomNumberGenerator)!) // This returns an Optional Note that some types make it easy to form collections with more elements than can be represented as an Int, such as the range Int.min...Int.max, and randomElement will likely trap on such collections. However, such ranges are likely to trap when used with almost any collection API, and the random(in:) method on FixedWidthInteger can be used for this purpose instead. Shuffle API As a result of adding the random API, it only makes sense to utilize that power to fuel the shuffle methods. We extend MutableCollection to add a method to shuffle the collection itself, and extend Sequence to add a method to return a shuffled version of itself in a new array. Example: var greetings = [&quot;hey&quot;, &quot;hi&quot;, &quot;hello&quot;, &quot;hola&quot;] // Utilizes the standard library&#39;s default random // Alias to: // var rng = SystemRandomNumberGenerator() // greetings.shuffle(using: &amp;rng) greetings.shuffle() print(greetings) // A possible output could be [&quot;hola&quot;, &quot;hello&quot;, &quot;hey&quot;, &quot;hi&quot;] let numbers = 0 ..&lt; 5 print(numbers.shuffled(using: &amp;myCustomRandomNumberGenerator)) // A possible output could be [1, 3, 0, 4, 2] Detailed Design The actual implementation can be found here: apple/swift#12772 public protocol RandomNumberGenerator { // This determines the functionality for producing a random number. // Required to implement by all RNGs. mutating func next() -&gt; UInt64 } // These sets of functions are not required and are provided by the stdlib by default extension RandomNumberGenerator { // This function provides generators a way of generating other unsigned integer types public mutating func next&lt;T : FixedWidthInteger &amp; UnsignedInteger&gt;() -&gt; T // This function provides generators a mechanism for uniformly generating a number from 0 to upperBound // Developers can extend this function themselves and create different behaviors for different distributions public mutating func next&lt;T : FixedWidthInteger &amp; UnsignedInteger&gt;(upperBound: T) -&gt; T } // The stdlib RNG. public struct SystemRandomNumberGenerator : RandomNumberGenerator { public init() {} // Conformance for `RandomNumberGenerator`, calls one of the crypto functions. public mutating func next() -&gt; UInt64 // We override the protocol defined one to prevent unnecessary work in generating an // unsigned integer that isn&#39;t a UInt64 public mutating func next&lt;T: FixedWidthInteger &amp; UnsignedInteger&gt;() -&gt; T } extension Collection { // Returns a random element from the collection // Can return nil if isEmpty is true public func randomElement&lt;T: RandomNumberGenerator&gt;( using generator: inout T ) -&gt; Element? /// Uses the standard library&#39;s default RNG public func randomElement() -&gt; Element? { var g = SystemRandomNumberGenerator() return randomElement(using: &amp;g) } } // Enables developers to use things like Int.random(in: 5 ..&lt; 12) which does not use modulo bias. // It is worth noting that any empty range entered here will abort the program. // We do this to preserve a general use case design that the core team expressed. // For those that are that unsure whether or not their range is empty or not, // they can if/guard check whether or not the range is empty beforehand, then // use these functions. extension FixedWidthInteger { public static func random&lt;T: RandomNumberGenerator&gt;( in range: Range&lt;Self&gt;, using generator: inout T ) -&gt; Self /// Uses the standard library&#39;s default RNG public static func random(in range: Range&lt;Self&gt;) -&gt; Self { var g = SystemRandomNumberGenerator() return Self.random(in: range, using: &amp;g) } public static func random&lt;T: RandomNumberGenerator&gt;( in range: ClosedRange&lt;Self&gt;, using generator: inout T ) -&gt; Self /// Uses the standard library&#39;s default RNG public static func random(in range: ClosedRange&lt;Self&gt;) -&gt; Self { var g = SystemRandomNumberGenerator() return Self.random(in: range, using: &amp;g) } } // Enables developers to use things like Double.random(in: 5 ..&lt; 12) which does not use modulo bias. // It is worth noting that any empty range entered here will abort the program. // We do this to preserve a general use case design that the core team expressed. // For those that are that unsure whether or not their range is empty or not, // they can simply if/guard check the bounds to make sure they can correctly form // ranges which a random number can be formed from. extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger { public static func random&lt;T: RandomNumberGenerator&gt;( in range: Range&lt;Self&gt;, using generator: inout T ) -&gt; Self /// Uses the standard library&#39;s default RNG public static func random(in range: Range&lt;Self&gt;) -&gt; Self { var g = SystemRandomNumberGenerator() return Self.random(in: range, using: &amp;g) } public static func random&lt;T: RandomNumberGenerator&gt;( in range: ClosedRange&lt;Self&gt;, using generator: inout T ) -&gt; Self /// Uses the standard library&#39;s default RNG public static func random(in range: ClosedRange&lt;Self&gt;) -&gt; Self { var g = SystemRandomNumberGenerator() return Self.random(in: range, using: &amp;g) } } // We add this as a convenience to something like: // Int.random(in: 0 ... 1) == 1 // To the unexperienced developer they might have to look at this a few times to // understand what is going on. This extension methods helps bring clarity to // operations like these. extension Bool { public static func random&lt;T: RandomNumberGenerator&gt;( using generator: inout T ) -&gt; Bool /// Uses the standard library&#39;s default RNG public static func random() -&gt; Bool { var g = SystemRandomNumberGenerator() return Bool.random(using: &amp;g) } } // Shuffle API // The shuffle API will utilize the Fisher Yates algorithm extension Sequence { public func shuffled&lt;T: RandomNumberGenerator&gt;( using generator: inout T ) -&gt; [Element] /// Uses the standard library&#39;s default RNG public func shuffled() -&gt; [Element] { var g = SystemRandomNumberGenerator() return shuffled(using: &amp;g) } } extension MutableCollection { public mutating func shuffle&lt;T: RandomNumberGenerator&gt;( using generator: inout T ) /// Uses the standard library&#39;s default RNG public mutating func shuffle() { var g = SystemRandomNumberGenerator() shuffle(using: &amp;g) } } Source compatibility This change is purely additive, thus source compatibility is not affected. Effect on ABI stability This change is purely additive, thus ABI stability is not affected. Effect on API resilience This change is purely additive, thus API resilience is not affected. Alternatives considered There were very many alternatives to be considered in this proposal. Why would the program abort if it failed to generate a random number? I spent a lot of time deciding what to do if it failed. Ultimately it came down to the fact that many RNGs for platforms will almost never fail. In the cases where this can fail is where an RNG like /dev/urandom doesn’t exist, or there were too many file descriptors open at once. In the case where /dev/urandom doesn’t exist, either the kernel is too old to generate that file by itself on a fresh install, or a privileged user deleted it. Both of which are way out of scope for Swift in my opinion. In the case where there are too many file descriptors, with modern technology this should almost never happen. If the process has opened too many descriptors then it should be up to the developer to optimize opening and closing descriptors. In a world where this did return an error to Swift, it would require types like Int to return an optional on its static function. This would defeat the purpose of those static functions as it creates a double spelling for the same operation. let randomDice = Int.random(in: 1 ... 6)! “I just want a random dice roll, what is this ! the compiler is telling me to add?” This syntax wouldn’t make sense for a custom RNG that deterministically generates numbers with no fail. This also goes against the “general use” design that the core team and much of the community expressed. Looking at Rust, we can observe that they also abort when an unexpected error occurs with any of the forms of randomness. source It would be silly to account for these edge cases that would only happen to those who need to update their os, optimize their file descriptors, or deleted their /dev/urandom. Accounting for these edge cases for specific platforms sacrifices the clean API for everyone else. Shouldn’t this fallback on something more secure at times of low entropy? Thomas Hühn explains it very well here. There is also a deeper discussion here talking about python’s implementation. Both articles discuss that even though /dev/urandom may not have enough entropy at a fresh install, “It doesn’t matter. The underlying cryptographic building blocks are designed such that an attacker cannot predict the outcome.” Using getrandom(2) on linux systems where the kernel version is &gt;= 3.17, will block if it decides that the entropy pool is too small. In python’s implementation, they fallback to reading /dev/urandom if getrandom(2) decides there is not enough entropy. Why not make the default RNG non-secure? Swift is a safe language which means that it shouldn’t be encouraging non-experienced developers to be pushing unsecure code. Making the default secure removes this issue and gives developers a feeling of comfort knowing their code is ready to go out of the box. Rename RandomNumberGenerator It has been discussed to give this a name such as RNG. I went with RandomNumberGenerator because it is clear, whereas RNG has a level of obscurity to those who don’t know the acronym. Add static .random() to numerical types There were a bit of discussion for and against this. Initially I was on board with adding this as it provided a rather simple approach to getting full width integers/floating points within the range of [0, 1). However, discussion came up that Int.random() encourages the misuse of modulo to get a number within x and y. This is bad because of modulo bias as I discussed in Motivation. For unexperienced developers, they might not know what values are going to be produced from those functions. It would require documentation reading to understand the range at which those functions pick from. They would also have inconsistent ranges that they choose from ([.min, .max] for FixedWidthIntegers and [0, 1) for BinaryFloatingPoints). I thought about this for a very long time and I came to the conclusion that I would rather have a few extra characters than to have the potential for abuse with modulo bias and confusion around the ranges that these functions use. Choose range.random() over static .random(in:) This was a very heavily discussed topic that we can’t skip over. I think we came into agreement that range.randomElement() should be possible, however the discussion was around whether or not this is the primary spelling for getting random numbers. Having a range as the primary spelling makes it fairly simple to get a random number from. Ranges are also very desirable because it doesn’t encourage modulo bias. Also, since we decided pretty early on that we’re going to trap if for whatever reason we can’t get a random number, this gave range.randomElement() the excuse to return a non optional. On the other end of the spectrum, we came into early agreement that Collection.randomElement() needs to return an optional in the case of an empty collection. If ranges were the primary spelling, then we would need to create exceptions for them to return non optionals. This would satisfy the general use design, but as we agreed that .randomElement() behaves more like .first, .last, .min(), and .max(). Because of this, .randomElement() has to return an optional to keep the consistent semantics. This justifies the static functions on the numeric types as the primary spelling as they can be the ones to return non optionals. These static functions are also the spelling for how developers think about going about random numbers. “Ok, I need a random integer from x and y.” This helps give these functions the upper hand in terms of discoverability.",
    "url": "http://localhost:4000/docs/2019-08-26-0202-random-unification.html",
    "relUrl": "/docs/2019-08-26-0202-random-unification.html"
  },
  "202": {
    "id": "202",
    "title": "SE-0203 Rename Sequence.elementsEqual",
    "content": "Rename Sequence.elementsEqual Proposal: SE-0203 Author: Xiaodi Wu Review Manager: Ted Kremenek Status: Rejected Implementation: apple/swift#12884 Bugs: SR-6102 Review thread: Swift evolution forum Introduction The behavior of Sequence.elementsEqual is confusing to users given its name. Having surveyed alternative solutions to this problem, it is proposed that the method be renamed to Sequence.elementsEqualInIterationOrder. Swift-evolution thread: Rename Sequence.elementsEqual Motivation As Ole Begemann describes, use of Sequence.elementsEqual(_:) can lead to surprising results for two instances of Set: var set1: Set&lt;Int&gt; = Set(1...5) var set2: Set&lt;Int&gt; = Set((1...5).reversed()) set1 == set2 // true set1.elementsEqual(set2) // false In almost all circumstances where a set is compared to another set or a dictionary is compared to another dictionary, users should use ==, which is order-insensitive, instead of elementsEqual(_:), which is order-sensitive. As Michael Ilseman explains: We have two forms of equality we’re talking about: equality of Sequence and equality of the elements of Sequences in their respective ordering. == covers the former, and I’ll use the existing (harmful) name of elementsEqual for the latter. == conveys substitutability of the two Sequences. This does not necessarily entail anything about their elements, how those elements are ordered, etc., it just means two Sequences are substitutable. elementsEqual means that the two Sequences produce substitutable elements. These are different concepts and both are independently useful. Cases: Two Sequences are substitutable and produce substitutable elements when iterated. == and elementsEqual both return true. Example: Two arrays with the same elements in the same order. Two Sequences are substitutable, but do not produce substitutable elements when iterated. == returns true, while elementsEqual returns false. Example: Two Sets that contain the same elements but in a different order. Contrived Example: Two Lorem Ipsum generators are the same generator (referentially equal, substitutable for the purposes of my library), but they sample the user’s current battery level (global state) each time they produce text to decide how fancy to make the faux Latin. They’re substitutable, but don’t generate the same sequence. Two Sequences are not substitutable, but produce substitutable elements when iterated. == returns false, while elementsEqual returns true. Example: Consider two sequences that have differing identity. == operates on an identity level, elementsEqual operates at an element level. Contrived Example: InfiniteMonkeys and Shakespeare both produce the same sonnet, but they’re not substitutable for my library’s purposes. Two Sequences are not substitutable and don’t produce substitutable elements when iterated. == and elementsEqual both return false. Example: [1,2,3] compared to [4,5,6] It is true that situations #2 and #3 are a little harder to grok, but they are what illustrate the subtle difference at hand. I think situation #2 is the most confusing, and has been the primary focus of this thread as Set exists and exhibits it. Proposed solution The method elementsEqual(_:) is listed as an “order-dependent operation” in Apple documentation. However, its name does not suggest that it performs an order-sensitive comparison. (Other “order-dependent operations” incorporate words that clearly suggest order dependence in the name, such as “first,” “last,” “prefix,” “suffix,” and so on.) These “order-dependent operations” are available for use because Set and Dictionary conform to Sequence. Major changes to the protocol hierarchy for Swift standard library collection types are out of the scope of this proposal, if not out of scope for Swift 5 entirely. The proposed solution is the result of an iterative process of reasoning, presented here: The first and most obvious solution is to remove the elementsEqual(_:) method altogether in favor of ==. This prevents its misuse. However, because elementsEqual(_:) is a generic method on Sequence, we can use it to compare an instance of UnsafeBufferPointer&lt;Int&gt; to an instance of [Int]. This is a potentially useful and non-redundant feature which would be eliminated if the method is removed altogether. A second solution is to create overloads that forbid the use of elementsEqual(_:) method specifically in non-generic code that uses sets or dictionaries. This would certainly prevent misuse in non-generic code. However, it would also forbid legitimate mixed-type comparisons in non-generic code, and it would not prevent misuse in generic code. This solution also creates a difference in the behavior of generic and non-generic code that calls the same method, which is confusing, without solving the problem completely. A third solution is proposed here. It is predicated on the following observation: Another method similar to elementsEqual(_:) exists on Sequence named lexicographicallyPrecedes(_:). Like prefix(_:) and others, it is an order-dependent operation not completely suitable for an unordered collection. However, like prefix(_:) and unlike elementsEqual(_:), this fact is called out in the name of the method. Unsurprisingly, like prefix(_:) and unlike elementsEqual(_:), there is no evidence that lexicographicallyPrecedes(_:) has been a pitfall for users. This observation suggests that a major reason for confusion over elementsEqual(_:) stems from its name. So, it is proposed that elementsEqual(_:) should be renamed. Initially, the suggested name for this method was lexicographicallyMatches, to parallel lexicographicallyPrecedes. This was opposed on two grounds: The term matches suggests a connection to pattern matching which does not exist. The term lexicographically is unfamiliar to users, is inaccurate in the absence of a total ordering (i.e., where Sequence.Element does not conform to Comparable), and could erroneously suggest that the receiver and argument could themselves be re-ordered for comparison. Alternative suggestions used terms such as pairwise, iterative, ordered, or sequential. A revised name that aims for call-site clarity while incorporating these suggestions would be equalsInIterationOrder. However, the name should reflect the distinction, explained above, between equality of sequences and equality of their elements. It remains important for the renamed method to clarify that it is performing a comparison operation based on Sequence.Element.== and not Sequence.==. Therefore, incorporating this insight, the proposed name for the method is elementsEqualInIterationOrder. Detailed design extension Sequence where Element : Equatable { @available(swift, deprecated: 5, renamed: &quot;elementsEqualInIterationOrder(_:)&quot;) public func elementsEqual&lt;Other : Sequence&gt;( _ other: Other ) -&gt; Bool where Other.Element == Element { return elementsEqualInIterationOrder(other) } public func elementsEqualInIterationOrder&lt;Other : Sequence&gt;( _ other: Other ) -&gt; Bool where Other.Element == Element { // The body of this method is unchanged. var iter1 = self.makeIterator() var iter2 = other.makeIterator() while true { switch (iter1.next(), iter2.next()) { case let (e1?, e2?): if e1 != e2 { return false } case (_?, nil), (nil, _?): return false case (nil, nil): return true } } } } A parallel change will be made with respect to elementsEqual(_:by:); that is, it will be renamed to elementsEqualInIterationOrder(_:by:). Source compatibility Existing code that uses elementsEqual will gain a deprecation warning. Effect on ABI stability None. Effect on API resilience This proposal adds new methods to the public API of Sequence and conforming types. Alternatives considered It is to be noted that lexicographicallyPrecedes(_:by:) and elementsEqual(_:by:) are very closely related methods. However, they cannot be unified because they handle sequences of dissimilar count differently. Along those same lines, the manner in which lexicographicallyPrecedes(_:) and lexicographicallyPrecedes(_:by:) compare sequences of dissimilar count is described by the term lexicographical (“a” &lt; “aa” &lt; “aaa” &lt; “ab”), in contradistinction to length-lexicographical (shortlex) ordering (“a” &lt; “aa” &lt; “ab” &lt; “aaa”) or Kleene–Brouwer ordering (“aaa” &lt; “aa” &lt; “ab” &lt; “a”). Though strictly redundant, the name could be modestly clarified by expanding it to lexicographicallyPrecedesInIterationOrder; however, the name cannot be shortened to precedesInIterationOrder without losing information as to the comparison performed. In the absence of evidence that users are using this method incorrectly, the additional consistency gained by adding “in iteration order” to the name is outweighed by the source-breaking nature of the change and the unwieldy end result. An entirely different solution to the motivating problem is to have sets internally reorder themselves prior to any order-dependent operations so that iteration order is guaranteed to be the same for sets which compare equal. As a result, == and elementsEqual would become equivalent when comparing two sets. Few (if any) other order-dependent operations would benefit from such a change, however, as the result of first remains arbitrary with or without it. There could potentially be a performance cost imposed on all users of sets, and the resulting benefit would be two functionally equivalent methods, which does not make possible any additional uses for the type.",
    "url": "http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html",
    "relUrl": "/docs/2019-08-26-0203-rename-sequence-elements-equal.html"
  },
  "203": {
    "id": "203",
    "title": "SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods",
    "content": "Add last(where:) and lastIndex(where:) Methods Proposal: SE-0204 Author: Nate Cook Review manager: John McCall Status: Implemented (Swift 4.2) Decision Notes: Rationale Implementation: apple/swift#13337 Bug: SR-1504 Introduction The standard library should include methods for finding the last element in a sequence, and the index of the last element in a collection, that match a given predicate. Swift-evolution thread: [swift-evolution] (Draft) Add last(where:) and lastIndex(where:) methods Motivation The standard library currently has methods that perform a linear search to find an element or the index of an element that matches a predicate: let a = [20, 30, 10, 40, 20, 30, 10, 40, 20] a.first(where: { $0 &gt; 25 }) // 30 a.index(where: { $0 &gt; 25 }) // 1 a.index(of: 10) // 2 Unfortunately, there are no such methods that search from the end. Finding the last of a particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string. You can work around this limitation by using the methods above on a reversed view of a collection, but the resulting code is frankly appalling. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), something like this unholy incantation is required: (a.reversed().index(where: { $0 &gt; 25 })?.base).map({ a.index(before: $0) }) Proposed solution The Sequence protocol should add a last(where:) method, and the Collection protocol should add lastIndex(where:) and lastIndex(of:) methods. These new methods create symmetry with the existing forward-searching APIs that are already part of Sequence and Collection. These additions remove the need for searching in a reversed collection and allow code like this: a.last(where: { $0 &gt; 25 }) // 40 a.lastIndex(where: { $0 &gt; 25 }) // 7 a.lastIndex(of: 10) // 6 Much better! Detailed design last(where:) and lastIndex(where:) will be added to the standard library as Sequence and Collection protocol requirements, respectively. These methods will have default implementations in their respective protocols and in BidirectionalCollection, which can provide a more efficient implementation. lastIndex(of:) will be provided in Collection and BidirectionalCollection extensions constrained to Equatable elements. In addition, the index(of:) and index(where:) methods will be renamed to firstIndex(of:) and firstIndex(where:), respectively. This change is beneficial for two reasons. First, it groups the first... and last... methods into two symmetric analogous groups, and second, it leaves the index... methods as solely responsible for index manipulation. The new APIs are shown here: protocol Sequence { // Existing declarations... /// Returns the last element of the collection that satisfies the given /// predicate, or `nil` if no element does. The sequence must be finite. func last(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? } protocol Collection { // Existing declarations... // Renamed from index(where:) func firstIndex(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Index? /// Returns the index of the last element of the collection that satisfies /// the given predicate, or `nil` if no element does. func lastIndex(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Index? } extension BidirectionalCollection { func last(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? { ... } func lastIndex(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Index? { ... } } extension Collection where Element: Equatable { // Renamed from index(of:) func firstIndex(of element: Element) -&gt; Index? { ... } /// Returns the index of the last element equal to the given element, or /// no matching element is found. func lastIndex(of element: Element) -&gt; Index? { ... } } extension BidirectionalCollection where Element: Equatable { func lastIndex(of element: Element) -&gt; Index? { ... } } You can try out the usage (but not really the performance) of the last... methods by copying this gist into a playground. Source compatibility The addition of the last(where:), lastIndex(where:), and lastIndex(of:) methods is strictly additive and should have no impact on existing code. The name changes to index(of:) and index(where:) are easily migratable, and will be deprecated in Swift 4.2 before being removed in Swift 5. Effect on ABI stability &amp; API resilience This change does not affect ABI stability or API resilience beyond the addition of the new methods. Alternatives considered A previous proposal limited the new methods to the BidirectionalCollection protocol. This isn’t a necessary limitation, as the standard library already has methods on sequences and forward collections with the same performance characteristics. Another previous proposal included renaming index(of:) and index(where:) to firstIndex(of:) and firstIndex(where:), respectively. A proposal after that one removed that source-breaking change. This version of the proposal adds the source-breaking change back in again. An alternative approach is to add a defaulted options parameter to the existing searching methods, like so: let a = [20, 30, 10, 40, 20, 30, 10, 40, 20] a.index(of: 10) // 2 a.index(of: 10, options: .backwards) // 6 This alternative approach matches the convention used in Foundation, such as NSString.range(of:options:) and NSArray.indexOfObject(options:passingTest:), but in the opinion of this author, separate functions better suit the structure of the Swift standard library.",
    "url": "http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html",
    "relUrl": "/docs/2019-08-26-0204-add-last-methods.html"
  },
  "204": {
    "id": "204",
    "title": "SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values",
    "content": "withUnsafePointer(to:_:) and withUnsafeBytes(of:_:) for immutable values Proposal: SE-0205 Authors: Joe Groff Review Manager: Ben Cohen Status: Implemented (Swift 4.2) Implementation: apple/swift#15608 Introduction We propose to extend the toplevel withUnsafePointer(to:_:) and withUnsafeBytes(of:_:) functions to work with read-only values. Swift-evolution thread: withUnsafePointer and withUnsafeBytes for immutable arguments Motivation withUnsafePointer and withUnsafeBytes provide temporary scoped access to the in-memory representation of variables and properties via pointers. They currently only accept inout arguments, which makes working with the in-memory representation of immutable values more awkward and inefficient than it ought to be, requiring a copy: let x = 1 + 2 var x2 = x withUnsafeBytes(of: &amp;x2) { ... } Even for inout arguments, the semantics of withUnsafeBytes and withUnsafePointer are extremely narrow: the pointer cannot be used after the closure returns, cannot be mutably aliased, and is not guaranteed to have a stable identity across withUnsafe* applications to the same property. There’s therefore no fundamental reason these operations couldn’t also be offered on arbitrary read-only variables or temporary values, since memory does not need to be persisted for longer than a call. It is a frequent request to extend these APIs to work with read-only values. Proposed solution We add overloads of withUnsafeBytes and withUnsafePointer that accept their to/of argument by value (by shared borrow, when we get moveonly types). Detailed design The following top-level functions are added to the standard library: public func withUnsafePointer&lt;T, Result&gt;( to value: /*borrowed*/ T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result ) rethrows -&gt; Result public func withUnsafeBytes&lt;T, Result&gt;( of value: /*borrowed*/ T, _ body: (UnsafeRawBufferPointer) throws -&gt; Result ) rethrows -&gt; Result Like their inout-taking siblings, each method produces a pointer to the in-memory representation of its value argument and invokes the body closure with the pointer. The pointer is only valid for the duration of body. It is undefined behavior to write through the pointer or access it after body returns. It is unspecified whether taking a pointer to the same variable or property produces a consistent pointer value across different withUnsafePointer/Bytes calls. We do not propose removing the inout-taking forms of withUnsafePointer and withUnsafeBytes, both for source compatibility, and because in Swift today, using inout is still the only reliably way to assert exclusive access to storage and suppress implicit copying. Optimized Swift code ought to in principle avoid copying when withUnsafePointer(to: x) is passed a stored let property x that is known to be immutable, and with moveonly types it would be possible to statically guarantee this, but in Swift today this cannot be guaranteed. Source compatibility Existing code can continue to use the inout-taking forms without modification. Effect on ABI stability/API resilience This is a purely additive change to the standard library. In anticipation of a future version of Swift adding moveonly types, we should ensure that the implementations of withUnsafePointer and withUnsafeBytes takes their arguments +0 so that they will be ABI-compatible with shared borrows of moveonly types in the future.",
    "url": "http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html",
    "relUrl": "/docs/2019-08-26-0205-withUnsafePointer-for-lets.html"
  },
  "205": {
    "id": "205",
    "title": "SE-0206 Hashable Enhancements",
    "content": "Hashable Enhancements Proposal: SE-0206 Authors: Karoy Lorentey, Vincent Esche Review Manager: Joe Groff Status: Implemented (Swift 4.2) Decision Notes: Rationale Implementation: apple/swift#14913 (standard library, underscored), apple/swift#16009 (Hasher interface), apple/swift#16073 (automatic synthesis, de-underscoring) Previous Revision: 1 Introduction Motivation The status quo Universal hash functions Proposed solution The Hasher struct The hash(into:) requirement Detailed design Hasher Hashable Source compatibility Effect on ABI stability Effect on API resilience Alternatives considered Leaving Hashable as is Defining a new protocol Making hash(into:) generic over a Hasher protocol Change hash(into:) to take a closure instead of a new type Introduction This proposal introduces a new Hasher type representing the standard library’s universal hash function, and it extends the Hashable protocol with a new hash(into:) requirement that expresses hashing in terms of Hasher. This new requirement is intended to replace the old hashValue property, which is deprecated. Switching to hash(into:) moves the choice of a hash function out of Hashable implementations, and into the standard library. This makes it considerably easier to manually conform types to Hashable – the task of writing a custom implementation reduces to identifying the parts of a type that should contribute to the hash value. Standardizing on a single, high-quality hash function greatly improves the reliability of Set and Dictionary. The hash function can be specially selected and tuned to work well with the hash tables used by these collections, preventing hash collision patterns that would break the expected performance of common operations. Hasher is a resilient struct, enabling future versions of the standard library to improve the hash function without the need to change (or even recompile) existing code that implements Hashable. Not baking any particular hash function into Hashable types is especially important in case a weakness is found in the current algorithm. Swift-evolution thread: Combining Hashes Motivation The Swift Standard Library includes two general-purpose hashing collections, Set and Dictionary. These collections are built around hash tables, whose performance is critically dependent on the expected distribution of the elements stored in them, along with the quality of the hash function that is used to derive bucket indices for individual elements. With a good hash function, simple lookups, insertions and removals take constant time on average. However, when the hash function isn’t carefully chosen to suit the data, the expected time of such operations can become proportional to the number of elements stored in the table. If the table is large enough, such a regression can easily lead to unacceptable performance. When they’re overwhelmed with hash collisions, applications and network services may stop processing new events for prolonged periods of time; this can easily be enough to make the app unresponsive or to bring down the service. The status quo Since Swift version 1.0, Hashable has had a single requirement on top of Equatable: the hashValue property. hashValue looks deceptively simple, but implementing it is unreasonably hard: Not only do we need to decide which components of our type should be involved in hashing, but we also have to come up with a way to somehow distill these components down into a single integer value. The API is essentially asking us to implement a new hash function, from scratch, every single time we conform to Hashable. Given adequate documentation, it is reasonable to expect that an experienced programmer implementing a custom type would be able to identify what parts need to be hashed. On the other hand, implementing a good hash function requires careful consideration and specialist knowledge. It is unreasonable to expect Swift programmers to invest time and effort to get this right for every Hashable type out there. For example, consider the code below, extracted directly from the documentation of Swift 4.1’s Hashable. Is this a good implementation of hashValue? struct GridPoint { var x: Int var y: Int } extension GridPoint: Hashable { var hashValue: Int { return x.hashValue ^ y.hashValue &amp;* 16777619 } static func == (lhs: GridPoint, rhs: GridPoint) -&gt; Bool { return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y } } The answer is that it depends; while the hash values it produces are perfectly fine if x and y are expected to be small integers coming from trusted sources, this hash function does have some undesirable properties: The clever bit manipulations make it hard to understand what the code does, or how it works. For example, can you tell what makes 16777619 a better choice for the multiplier than, say, 16777618? What are the precedence rules for ^ and &amp;* again? What’s with the ampersand, anyway? We just wanted to use GridPoint values as keys in a Dictionary, but first, we need to spend a couple of hours learning about bitwise operations, integer overflows and the exciting properties of coprime numbers. (For what it’s worth, the magic constant used in the example above is the same as the one used for the 32-bit version of the FNV-1a hashing algorithm, which uses a similar (if a little more complicated) method to distill arbitrary byte sequences down into a single integer.) It is trivially easy to construct an arbitrarily large set of GridPoint values that aren’t equal, but have the same hash value. If the values come from an untrusted source, they may sometimes be deliberately chosen to induce collisions. The hash function doesn’t do a particularly great job at mixing up the input data; the hash values it produces tend to form long chains of sequential integer clusters. While these aren’t as bad as hash collisions, some hash table operations can slow down drasticaly when such clusters are present. (In Swift 4.1, Set and Dictionary use open addressing with linear probing, and they have to do some clever postprocessing of hash values to get rid of such patterns.) It seems desirable for the standard library to provide better guidance for people implementing hashValue. Universal hash functions With SE-0185, Swift 4.1 introduced compiler support for automatic synthesis of Hashable conformance for certain types. For example, the GridPoint struct above can be made to conform to Hashable without explicitly defining hashValue (or ==): struct GridPoint: Hashable { var x: Int var y: Int // hashValue and == are automatically synthesized by the compiler } SE-0185 did not specify a hash function to be used for such conformances, leaving it as an implementation detail of the compiler and the standard library. Doing this well requires the use of a hash function that works equally well on any number of components, regardless of their expected distributions. Luckily, this problem has occured in other contexts before, and there is an extensive list of hash functions that have been designed for exactly such cases: Foller-Noll-Vo, MurmurHash, CityHash, SipHash, and HighwayHash are just a small selection of these. The last two algorithms include some light cryptographic elements so that they provide a level of protection against deliberate hash collision attacks. This makes them a better choice for general-purpose hashed collections like Set and Dictionary. Since SE-0185 required the standard library to implement a high-quality universal hash function, it seems like a good idea to expose it as public API, so that manual Hashable implementations can take advantage of it, too. Universal hash functions work by maintaining some internal state – this can be as simple as a single 32/64-bit integer value (for e.g. FNV-1a), but it is usually much wider than that. For example, SipHash maintains a state of 256 bits, while HighwayHash uses 1024 bits. Proposed solution We solve Hashable’s implementation problems in two parts. First, we make the standard library’s hash function public. Second, we replace hashValue with a requirement that is designed specifically to eliminate the guesswork from manual Hashable implementations. The Hasher struct We propose to expose the standard library’s standard hash function as a new, public struct type, called Hasher. This new struct captures the state of the hash function, and provides the following operations: An initializer to create an empty state. To make hash values less predictable, the standard hash function uses a per-execution random seed, so that generated hash values will be different in each execution of a Swift program. public struct Hasher { public init() // Uses a per-execution random seed value } Operations to feed new bytes to the hash function, mixing them into its state: extension Hasher { public mutating func combine(bytes buffer: UnsafeRawBufferPointer) public mutating func combine&lt;H: Hashable&gt;(_ value: H) } combine(bytes:) is the most general operation, suitable for use when the bytes to be hashed are available as a single contiguous region in memory. combine(_:) is a convenience operation that can take any Hashable value; we expect this will be more frequently useful. (We’ll see how this is implemented in the next section.) An operation to finalize the state, extracting the hash value from it. extension Hasher { public __consuming func finalize() -&gt; Int } Finalizing the hasher state consumes it; it is illegal to call combine or finalize on a hasher you don’t own, or on one that’s already been finalized. For example, here is how one may use Hasher as a standalone type: var hasher = Hasher() // Initialize state, usually by random seeding hasher.combine(23) // Mix in several integer&#39;s worth of bytes hasher.combine(42) print(hasher.finalize()) // Finalize the state and return the hash Within the same execution of a Swift program, Hashers are guaranteed to return the same hash value in finalize(), as long as they are fed the exact same sequence of bytes. (Note that the order of combine operations matters; swapping the two integers above will produce a completely different hash.) However, Hasher may generate entirely different hash values in other executions, even if it is fed the exact same byte sequence. This randomization is a critical feature, as it makes it much harder for potential attackers to predict hash values. Hashable has always been documented to explicitly allow such nondeterminism: Important: Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use in a future execution. – Hashable documentation (Random seeding can be disabled by setting a special environment variable; see Effect on ABI stability for details.) The choice of which hash function Hasher implements is an implementation detail of the standard library, and may change in any new release. This includes the size and internal layout of Hasher itself. (The current implementation uses SipHash-1-3 with 320 bits of state.) The hash(into:) requirement Introducing Hasher is a big improvement, but it’s only half of the story: Hashable itself needs to be updated to make better use of it. We propose to change the Hashable protocol by adding a new hash(into:) requirement: public protocol Hashable: Equatable { var hashValue: Int { get } func hash(into hasher: inout Hasher) } At the same time, we deprecate custom implementations of the hashValue property. (Please see the section on Source compatibility on how we’ll do this without breaking code written for previous versions of Swift.) In some future language version, we intend to convert hashValue to an extension method. To make it easier to express hash(into:) in terms of Hashable components, Hasher provides a variant of combine that simply calls hash(into:) on the supplied value: extension Hasher { @inlinable public mutating func combine&lt;H: Hashable&gt;(_ value: H) { value.hash(into: &amp;self) } } This is purely for convenience; hasher.combine(foo) is slightly easier to type than foo.hash(into: &amp;hasher). At first glance, it may not be obvious why we need to replace hashValue. After all, Hasher can be used to take the guesswork out of its implementation: extension GridPoint: Hashable { var hashValue: Int { var hasher = Hasher() hasher.combine(x) hasher.combine(y) return hasher.finalize() } } What’s wrong with this? What makes hash(into:) so much better that’s worth the cost of a change to a basic protocol? Better Discoverability – With hashValue, you need to know about Hasher to make use of it: the API does not direct you to do the right thing. Worse, you have to do extra busywork by manually initializing and finalizing a Hasher instance directly in your hashValue implementation. Compare the code above to the hash(into:) implementation below: extension GridPoint: Hashable { func hash(into hasher: inout Hasher) { hasher.combine(x) hasher.combine(y) } } This is nice and easy, with minimal boilerplate. Hasher is part of the function signature; people who need to implement hash(into:) are naturally guided to learn about it. Guaranteed Dispersion Quality – Keeping the existing hashValue interface would mean that there was no way for Set and Dictionary to guarantee that Hashable types produce hash values with good enough dispersion. Therefore, these collections would need to keep postprocessing hash values. We’d like to eliminate postprocessing overhead for types that upgrade to Hasher. Hasher Customizability – hash(into:) moves the initialization of Hasher out of Hashable types, and into hashing collections. This allows us to customize Hasher to the needs of each hashing data structure. For example, the stdlib could start using a different seed value for every new Set and Dictionary instance; this somewhat improves reliability by making hash values even less predictable, but (probably more importantly), it drastically improves the performance of some relatively common operations involving copying data between Set/Dictionary instances. Better Performance – Similarly, hash(into:) moves the finalization step out of Hashable. Finalization is a relatively expensive operation; for example, in SipHash-1-3, it costs three times as much as a single 64-bit combine. Repeating it for every single component of a composite type would make hashing unreasonably slow. For example, consider the GridRectangle type below: struct GridRectangle { let topLeft: GridPoint let bottomRight: GridPoint } With hashValue, its Hashable implementation would look like this: extension GridRectangle: Hashable { var hashValue: Int { // SLOW, DO NOT USE var hasher = Hasher() hasher.combine(bits: topLeft.hashValue) hasher.combine(bits: bottomRight.hashValue) return hasher.finalize() } } Both of the hashValue invocations above create and finalize separate hashers. Assuming finalization takes three times as much time as a single combine call (and generously assuming that initialization is free) this takes 15 combines’ worth of time: 1 hasher.combine(topLeft.hashValue) 1 hasher.combine(topLeft.x) (in topLeft.hashValue) 1 hasher.combine(topLeft.y) 3 hasher.finalize() 1 hasher.combine(bottomRight.hashValue) 1 hasher.combine(bottomRight.x) (in bottomRight.hashValue) 1 hasher.combine(bottomRight.y) 3 hasher.finalize() 3 hasher.finalize() 15 Switching to hash(into:) gets us the following code: extension GridRegion: Hashable { func hash(into hasher: inout Hasher) { hasher.combine(topLeft) hasher.combine(bottomRight) } } This reduces the cost of hashing to just four combines and a single finalization, which takes less than half the time of our original approach: 1 hasher.combine(topLeft.x) (in topLeft.hash(into:)) 1 hasher.combine(topLeft.y) 1 hasher.combine(bottomRight.x) (in bottomRight.hash(into:)) 1 hasher.combine(bottomRight.y) 3 hasher.finalize() (outside of GridRectangle.hash(into:)) 7 Switching to hash(into:) gets us more robust hash values faster, and with cleaner, simpler code. Detailed design Hasher Add the following type to the standard library: /// Represents the universal hash function used by `Set` and `Dictionary`. /// /// The hash function is a mapping from a 128-bit seed value and an /// arbitrary sequence of bytes to an integer hash value. The seed value /// is specified during `Hasher` initialization, while the byte sequence /// is fed to the hasher using a series of calls to mutating `combine` /// methods. When all bytes have been fed to the hasher, the hash value /// can be retrieved by calling `finalize()`: /// /// var hasher = Hasher() /// hasher.combine(23) /// hasher.combine(&quot;Hello&quot;) /// let hashValue = hasher.finalize() /// /// The underlying hash algorithm is designed to exhibit avalanche /// effects: slight changes to the seed or the input byte sequence /// will produce drastic changes in the generated hash value. /// /// - Note: `Hasher` is usually randomly seeded, which means it will return /// different values on every new execution of your program. The hash /// algorithm implemented by `Hasher` may itself change between /// any two versions of the standard library. Do not save or otherwise /// reuse hash values across executions of your program. public struct Hasher { /// Initialize a new hasher using a per-execution seed value. /// The seed is set during process startup, usually from a high-quality /// random source. public init() /// Feed `value` to this hasher, mixing its essential parts into /// the hasher state. @inlinable public mutating func combine&lt;H: Hashable&gt;(_ value: H) { value.hash(into: &amp;self) } /// Feed the raw bytes in `buffer` into this hasher, mixing its bits into /// the hasher state. public mutating func combine(bytes buffer: UnsafeRawBufferPointer) /// Finalize the hasher state and return the hash value. /// /// Finalizing consumes the hasher: it is illegal to finalize a hasher you /// don&#39;t own, or to perform operations on a finalized hasher. (These may /// become compile-time errors in the future.) public __consuming func finalize() -&gt; Int } Hashable Change the Hashable protocol as follows. /// A type that can be hashed into a `Hasher`. /// /// You can use any type that conforms to the `Hashable` protocol in a set or as /// a dictionary key. Many types in the standard library conform to `Hashable`: /// Strings, integers, floating-point and Boolean values, and even sets are /// hashable by default. Some other types, such as optionals, arrays and ranges /// automatically become hashable when their type arguments implement the same. /// /// Your own custom types can be hashable as well. When you define an /// enumeration without associated values, it gains `Hashable` conformance /// automatically, and you can add `Hashable` conformance to your other custom /// types by implementing the `hash(into:)` function. For structs whose stored /// properties are all `Hashable`, and for enum types that have all-`Hashable` /// associated values, the compiler is able to provide an implementation of /// `hash(into:)` automatically. /// /// Hashing a value means feeding its essential components into a hash function, /// represented by the `Hasher` type. Essential components are those that /// contribute to the type&#39;s implementation of `Equatable`. Two instances that /// are equal must feed the same values to `Hasher` in `hash(into:)`, in the /// same order. /// /// Conforming to the Hashable Protocol /// =================================== /// /// To use your own custom type in a set or as the key type of a dictionary, /// add `Hashable` conformance to your type. The `Hashable` protocol inherits /// from the `Equatable` protocol, so you must also satisfy that protocol&#39;s /// requirements. /// /// A custom type&#39;s `Hashable` and `Equatable` requirements are automatically /// synthesized by the compiler when you declare `Hashable` conformance in the /// type&#39;s original declaration and your type meets these criteria: /// /// - For a `struct`, all its stored properties must conform to `Hashable`. /// - For an `enum`, all its associated values must conform to `Hashable`. (An /// `enum` without associated values has `Hashable` conformance even without /// the declaration.) /// /// To customize your type&#39;s `Hashable` conformance, to adopt `Hashable` in a /// type that doesn&#39;t meet the criteria listed above, or to extend an existing /// type to conform to `Hashable`, implement the `hash(into:)` function in your /// custom type. To ensure that your type meets the semantic requirements of the /// `Hashable` and `Equatable` protocols, it&#39;s a good idea to also customize /// your type&#39;s `Equatable` conformance to match the `hash(into:)` definition. /// /// As an example, consider a `GridPoint` type that describes a location in a /// grid of buttons. Here&#39;s the initial declaration of the `GridPoint` type: /// /// /// A point in an x-y coordinate system. /// struct GridPoint { /// var x: Int /// var y: Int /// } /// /// You&#39;d like to create a set of the grid points where a user has already /// tapped. Because the `GridPoint` type is not hashable yet, it can&#39;t be used /// as the `Element` type for a set. To add `Hashable` conformance, provide an /// `==` operator function and a `hash(into:)` function. /// /// extension GridPoint: Hashable { /// func hash(into hasher: inout Hasher) { /// hasher.combine(x) /// hasher.combine(y) /// } /// /// static func == (lhs: GridPoint, rhs: GridPoint) -&gt; Bool { /// return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y /// } /// } /// /// The `hash(into:)` property in this example feeds the properties `x` and `y` /// to the supplied hasher; these are the same properties compared by the /// implementation of the `==` operator function. /// /// Now that `GridPoint` conforms to the `Hashable` protocol, you can create a /// set of previously tapped grid points. /// /// var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)] /// let nextTap = GridPoint(x: 0, y: 1) /// if tappedPoints.contains(nextTap) { /// print(&quot;Already tapped at ( (nextTap.x), (nextTap.y)).&quot;) /// } else { /// tappedPoints.insert(nextTap) /// print(&quot;New tap detected at ( (nextTap.x), (nextTap.y)).&quot;) /// } /// // Prints &quot;New tap detected at (0, 1).&quot;) public protocol Hashable: Equatable { /// The hash value. /// /// Hash values are not guaranteed to be equal across different executions of /// your program. Do not save hash values to use during a future execution. var hashValue: Int { get } /// Hash the essential components of this value into the hash function /// represented by `hasher`, by feeding them into it using its `combine` /// methods. /// /// Essential components are precisely those that are compared in the type&#39;s /// implementation of `Equatable`. func hash(into hasher: inout Hasher) } Source compatibility The introduction of the new Hasher type is a purely additive change. However, adding the hash(into:) requirement is potentially source breaking. To ensure we keep compatibility with code written for previous versions of Swift, while also allowing new code to only implement hash(into:), we extend SE-0185’s automatic Hashable synthesis to automatically derive either of these requirements when the other has been manually implemented. Code written for Swift 4.1 or earlier will continue to compile (in the corresponding language mode) after this proposal is implemented. The compiler will synthesize the missing hash(into:) requirement automatically: struct GridPoint41: Hashable { // Written for Swift 4.1 or below let x: Int let y: Int var hashValue: Int { return x.hashValue ^ y.hashValue &amp;* 16777619 } // Supplied automatically by the compiler: func hash(into hasher: inout Hasher) { hasher.combine(self.hashValue) } } The compiler will emit a deprecation warning when it needs to do this in 4.2 mode. (However, note that code that merely uses hashValue will continue to compile without warnings.) Code written for Swift 4.2 or later should conform to Hashable by implementing hash(into:). The compiler will then complete the conformance with a suitable hashValue definition: struct GridPoint42: Hashable { // Written for Swift 4.2 let x: Int let y: Int func hash(into hasher: inout Hasher) { hasher.combine(x) hasher.combine(y) } // Supplied automatically by the compiler: var hashValue: Int { var hasher = Hasher() self.hash(into: &amp;hasher) return hasher.finalize() } } When upgrading to Swift 4.2, Hashable types written for earlier versions of Swift should be migrated to implement hash(into:) instead of hashValue. For types that satisfy SE-0185’s requirements for Hashable synthesis, this can be as easy as removing the explicit hashValue implementation. Note that Swift 4.2 implements conditional Hashable conformances for many standard library types that didn’t have it before; this enables automatic Hashable synthesis for types that use these as components. For types that still need to manually implement Hashable, the migrator can be updated to help with this process. For example, the GridPoint41.hashValue implementation above can be mechanically rewritten as follows: struct GridPoint41: Hashable { // Migrated from Swift 4.1 let x: Int let y: Int // Migrated from hashValue: func hash(into hasher: inout Hasher) { hash.combine(x.hashValue ^ y.hashValue &amp;* 16777619) } } This will not provide the same hash quality as combining both members one by one, but it may be useful as a starting point. Effect on ABI stability Hasher and hash(into:) are additive changes that extend the ABI of the standard library. Hasher is a fully resilient struct, with opaque size/layout and mostly opaque members. (The only exception is the generic function combine(_:), which is provided as a syntactic convenience.) While this proposal deprecates the hashValue requirement, it doesn’t remove it. Types implementing Hashable will continue to provide an implementation for it, although the implementation may be provided automatically by compiler synthesis. To implement nondeterminism, Hasher uses an internal seed value initialized by the runtime during process startup. The seed is usually produced by a random number generator, but this may be disabled by defining the SWIFT_DETERMINISTIC_HASHING environment variable with a value of 1 prior to starting a Swift process. Effect on API resilience Replacing hashValue with hash(into:) moves the responsibility of choosing a suitable hash function out of Hashable implementations and into the standard library, behind a resiliency boundary. Hasher is explicitly designed so that future versions of the standard library will be able to replace the hash function. Hashable implementations compiled for previous versions will automatically pick up the improved algorithm when linked with the new release. This includes changing the size or internal layout of the Hasher state itself. (We foresee several reasons why we may want to replace the hash function. For example, we may need to do so if a weakness is discovered in the current function, to restore the reliability of Set and Dictionary. We may also want to tweak the hash function to adapt it to the special requirements of certain environments (such as network services), or to generally improve hashing performance.) Alternatives considered Leaving Hashable as is One option that we considered is to expose Hasher, but to leave the Hashable protocol as is. Individual Hashable types would be able to choose whether or not to use it or to roll their own hash functions. We felt this was an unsatisfying approach; the rationale behind this is explained in the section on The hash(into:) requirement. Defining a new protocol There have been several attempts to fix Hashable by creating a new protocol to replace it. For example, there’s a prototype implementation of a NewHashable protocol in the Swift test suite. The authors of this proposal have done their share of this, too: Karoy has previously published an open-source hashing package providing an opt-in replacement for Hashable, while Vincent wrote a detailed pitch for adding a HashVisitable protocol to the standard library – these efforts were direct precursors to this proposal. In these approaches, the new protocol could either be a refinement of Hashable, or it could be unrelated to it. Here is what a refinement would look like: protocol Hashable: Equatable { var hashValue: Int { get } } protocol Hashable2: Hashable { func hash(into hasher: inout Hasher) } extension Hashable2 { var hashValue: Int { var hasher = Hasher() hash(into: &amp;hasher) return hasher.finalize() } } While this is a great approach for external hashing packages, we believe it to be unsuitable for the standard library. Adding a new protocol would add a significant new source of user confusion about hashing, and it would needlessly expand the standard library’s API surface area. The new protocol would need to have a new name, but Hashable already has the perfect name for a protocol representing hashable things – so we’d need to choose an imperfect name for the “better” protocol. While deprecating a protocol requirement is a significant change, we believe it to be less harmful overall than leaving Hashable unchanged, or trying to have two parallel protocols for the same thing. Additionally, adding a second protocol would lead to complications with Hashable synthesis. It’s also unclear how Set and Dictionary would be able to consistently use Hasher for their primary hashing API. (These problems are not unsolvable, but they may involve adding special one-off compiler support for the new protocol. For example, we may want to automatically derive Hashable2 conformance for all types that implement Hashable.) Making hash(into:) generic over a Hasher protocol It would be nice to allow Swift programmers to define their own hash functions, and to plug them into any Hashable type: protocol Hasher { func combine(bytes: UnsafeRawBufferPointer) } protocol Hashable { func hash&lt;H: Hasher&gt;(into hasher: inout H) } However, we believe this would add a degree of generality whose costs are unjustifiable relative to their potential gain. We expect the ability to create custom hashers would rarely be exercised. For example, we do not foresee a need for adding support for custom hashers in Set and Dictionary. On the other hand, there are distinct advantages to standardizing on a single, high-quality hash function: Adding a generic type parameter to hash(into:) would complicate the Hashable API. By supporting only a single Hasher, we can concentrate our efforts on making sure it runs fast. For example, we know that the standard hasher’s opaque mutating functions won’t ever perform any retain/release operations, or otherwise mutate any of the reference types we may encounter during hashing; describing this fact to the compiler enables optimizations that would not otherwise be possible. Generics in Swift aren’t zero-cost abstractions. We may be tempted to think that we could gain some performance by plugging in a less sophisticated hash function. This is not necessarily the case – support for custom hashers comes with significant overhead that can easily overshadow the (slight, if any) algorithmic disadvantage of the standard Hasher. Note that the proposed non-generic Hasher still has full support for Bloom filters and other data structures that require multiple hash functions. (To select a different hash function, we just need to supply a new seed value.) Change hash(into:) to take a closure instead of a new type A variant of the previous idea is to represent the hasher by a simple closure taking an integer argument: protocol Hashable { func hash(into hasher: (Int) -&gt; Void) } extension GridPoint: Hashable { func hash(into hasher: (Int) -&gt; Void) { hasher(x) hasher(y) } } While this is an attractively minimal API, it has problems with granularity – it doesn’t allow adding anything less than an Int’s worth of bits to the hash state. Additionally, like generics, the performance of such a closure-based interface would compare unfavorably to Hasher, since the compiler wouldn’t be able to guarantee anything about the potential side-effects of the closure.",
    "url": "http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html",
    "relUrl": "/docs/2019-08-26-0206-hashable-enhancements.html"
  },
  "206": {
    "id": "206",
    "title": "SE-0207 Add an `allSatisfy` algorithm to `Sequence`",
    "content": "Add an allSatisfy algorithm to Sequence Proposal: SE-0207 Authors: Ben Cohen Review Manager: Dave Abrahams Implementation: apple/swift#15120 Status: Implemented (Swift 4.2) Decision Notes: Rationale Introduction It is common to want to confirm that every element of a sequence equals a value, or matches certain criteria. Many implementations of this can be found in use on GitHub. This proposal adds such a method to Sequence. Motivation You can achieve this in Swift 3 with contains by negating both the criteria and the result: // every element is 9 !nums.contains { $0 != 9 } // every element is odd !nums.contains { !isOdd($0) } but these are a readability nightmare. Additionally, developers may not make the leap to realize contains can be used this way, so may hand-roll their own for loop, which could be buggy, or compose other inefficient alternatives: // misses opportunity to bail early nums.reduce(true) { $0.0 &amp;&amp; $0.1 == 9 } // the most straw-man travesty I could think of... Set(nums).count == 1 &amp;&amp; Set(nums).first == 9 Proposed solution Introduce an algorithm on Sequence which tests every element and returns true if they all match a given predicate: nums.allSatisfy(isOdd) on the basis that it aids readability and avoids performance pitfalls from the composed alternatives. Detailed design Add the following extensions to Sequence: extension Sequence { /// Returns a Boolean value indicating whether every element of the sequence /// satisfies the given predicate. func allSatisfy(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool } Source compatibility This change is purely additive so has no source compatibility consequences. Effect on ABI stability This change is purely additive so has no ABI stability consequences. Effect on API resilience This change is purely additive so has no API resilience consequences. Alternatives considered Not adding it, since it can be trivially (if confusingly) composed. Much name bikeshedding has ensued. Names considered included containsOnly and all. all has strong precedent in other languages, but was considered unclear at the call site (adding an argument label does not help here given trailing closures omit them). Naming it all suggests a renaming of contains to any would be appropriate – but this is already a fairly heavily-used term elsewhere in Swift, and is less explicit. containsOnly is more explicit, and echoes the existing contains, but is too easily misread at the use-site as “contains one instance equal to,” especially when considering empty collections. contains(only:) was discounted due to trailing closures dropping the argument label, rendering it indistiguishable from contains(where:).",
    "url": "http://localhost:4000/docs/2019-08-26-0207-containsOnly.html",
    "relUrl": "/docs/2019-08-26-0207-containsOnly.html"
  },
  "207": {
    "id": "207",
    "title": "SE-0208 Package Manager System Library Targets",
    "content": "Package Manager System Library Targets Proposal: SE-0208 Author: Ankit Aggarwal, Daniel Dunbar Review Manager: Boris Bügling Status: Implemented (Swift 4.2) Implementation: apple/swift-package-manager#1586 Bug: SR-7434 Introduction This proposal introduces a new type of target “system library target”, which moves the current system-module packages feature from package to target level. Motivation The package manager currently supports “system-module packages” which are intended to adapt a system installed dependency to work with the package manager. However, this feature is only supported on package declarations, which mean libraries that need it often need to create a separate repository containing the system package and refer to it as a dependency. Our original motivation in forcing system packages to be declared as standalone packages was to encourage the ecosystem to standardize on them, their names, their repository locations, and their owners. In practice, this effort did not work out and it only made the package manager harder to use. Terminology Swift N: The tools version this proposal is implemented in. Proposed solution We propose adding a new “system library target”, which would supply the same metadata needed to adapt system libraries to work with the package manager, but as a target. This would allow packages to embed these targets with the libraries that need them. We propose to deprecate the legacy system-module package declaration for packages that are only compatible with Swift N or later. Detailed design We will add a new factory method for system library target: extension Target { public static func systemLibrary( name: String, path: String? = nil, pkgConfig: String? = nil, providers: [SystemPackageProvider]? = nil ) -&gt; Target } This target factory function will only be available if the tools version of the manifest is greater than or equal to Swift N. During dependency resolution, the package manager will emit a deprecation warning if there is a legacy system-module package in the package graph and the tools version of the root package is greater than or equal to Swift N. Currently, the package manage implicitly assumes a dependency on system-module packages when they are included as a dependency. In the new model, for consistency with the existing target/product model, clients of a system package must also specify explicit dependencies from the targets which use the system library. System library targets may be exported from a package as products. To do so, they must be exported via a library product with exactly one member target i.e. the system library target. Examples For example, an existing package which defines only a system library adaptor would be described: // swift-tools-version:N import PackageDescription let package = Package( name: &quot;CZLib&quot;, products: [ .library(name: &quot;CZLib&quot;, targets: [&quot;CZLib&quot;]), ], targets: [ .systemLibrary( name: &quot;CZLib&quot;, pkgConfig: &quot;zlib&quot;, providers: [ .brew([&quot;zlib&quot;]), .apt([&quot;zlib&quot;]), ] ) ] ) A similar package which exported a Swift interface for zlib might look like the following example, which is not expressible today without using a separate repository. // swift-tools-version:N import PackageDescription let package = Package( name: &quot;ZLib&quot;, products: [ .library(name: &quot;ZLib&quot;, targets: [&quot;ZLib&quot;]), ], targets: [ .target( name: &quot;ZLib&quot;, dependencies: [&quot;CZLib&quot;]), .systemLibrary( name: &quot;CZLib&quot;) ] ) In this case, the system library is not an exported product, and would not be available to other packages. Impact on existing packages None. Alternatives considered None.",
    "url": "http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html",
    "relUrl": "/docs/2019-08-26-0208-package-manager-system-library-targets.html"
  },
  "208": {
    "id": "208",
    "title": "SE-0209 Package Manager Swift Language Version API Update",
    "content": "Package Manager Swift Language Version API Update Proposal: SE-0209 Author: Ankit Aggarwal Review Manager: Boris Bügling Status: Implemented (Swift 4.2) Implementation: apple/swift-package-manager#1563 Bug: SR-7464 Introduction This proposal changes the current Package.swift manifest API for declaring for Swift language versions from freeform Integer array to a new SwiftVersion enum array. Motivation The Swift compiler now allows 4.2 as an accepted value of Swift version flag (-swift-version). The swiftLanguageVersions API in Package.swift currently accepts an interger array and we need to update this API in order for packages to declare this language version if required. Proposed solution We propose to change the type of swiftLanguageVersions property from [Int] to [SwiftVersion] in the manifest API used for Swift tools version 4.2. The SwiftVersion will be an enum that contains all known Swift language version values and will provide an option to declare custom version values: /// Represents the version of the Swift language that should be used for /// compiling Swift sources in the package. public enum SwiftVersion { case v3 case v4 case v4_2 /// User-defined value of Swift version. /// /// The value is passed as-is to Swift compiler&#39;s `-swift-version` flag. case version(String) } The existing package manifests that use swiftLanguageVersions will need to migrate to the new enum when their tools version is updated to 4.2. Detailed design The custom version string will be passed as-is to the value of -swift-version flag. The custom version string allows a package to support and make use of new language versions which are not known to the manifest API of the current tools version. This is important for packages which want to add support for a newer Swift language version but also want to retain compatibility with an older language and tools version, where the new language version isn’t known in the manifest API. The package manager will use standard version numbering rules to determine precedence of language versions. For e.g. 5 &gt; 4.2.1 &gt; 4.2 &gt; 4. We will ship a new PackageDescription runtime in the Swift 4.2 toolchain. This runtime will be selected if tools version of a package greater than or equal to version 4.2. When building a package, we will always select the Swift language version that is most close to (but not exceeding) a valid language version of the Swift compiler in use. If a package does not specify a Swift language version, the tools version of the manifest will be used to derive the value. The swift package init command in Swift 4.2 will create packages with // swift-tools-version:4.2. This is orthogonal to this proposal but is probably worth mentioning. Examples Here are some concrete examples: Example 1: // swift-tools-version:4.0 import PackageDescription let package = Package( name: &quot;HTTPClient&quot;, ... swiftLanguageVersions: [4] ) The sources will be compiled with -swift-version 4. Example 2: // swift-tools-version:4.2 import PackageDescription let package = Package( name: &quot;HTTPClient&quot;, ... swiftLanguageVersions: [.v4, .v4_2] ) The sources will be compiled with -swift-version 4.2. Example 3: // swift-tools-version:4.0 import PackageDescription let package = Package( name: &quot;HTTPClient&quot;, ... swiftLanguageVersions: [.v4_2, .version(&quot;5&quot;)] ) The package manager will emit an error because this is not possible in PackageDescription 4 runtime. Example 4: // swift-tools-version:4.2 import PackageDescription let package = Package( name: &quot;HTTPClient&quot;, ... swiftLanguageVersions: [.v4, .version(&quot;5&quot;)] ) The sources will be compiled with -swift-version 4. Impact on existing code Existing packages will not be impacted but they will not be able to use Swift language version 4.2 unless they update their manifest to tools version 4.2. Once they do update their tools version to 4.2, they will need to migrate to the new enum if they use swiftLanguageVersions property. Alternatives considered We considered adding a new property to existing PackageDescription runtime so we don’t need to ship additional runtime. However that approach is not very scalable as it requires us to come up with another name for the APIs that are breaking. We considered making SwiftVersion a struct which conforms to ExpressibleByIntegerLiteral and ExpressibleByStringLiteral. However, we think the enum approach is better for several reasons: It is consistent with the C/C++ language version settings. The package authors can easily tell which versions are available. The package authors don’t need to concern themselves with how to spell a valid version.",
    "url": "http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html",
    "relUrl": "/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html"
  },
  "209": {
    "id": "209",
    "title": "SE-0210 Add an `offset(of:)` method to `MemoryLayout`",
    "content": "Add an offset(of:) method to MemoryLayout Proposal: SE-0210 Authors: Joe Groff Review Manager: Doug Gregor Status: Implemented (Swift 4.2) Implementation: apple/swift#15519 Introduction This proposal introduces the ability for Swift code to query the in-memory layout of stored properties in aggregates using key paths. Like the offsetof macro in C, MemoryLayout&lt;T&gt;.offset(of:) returns the distance in bytes between a pointer to a value and a pointer to one of its fields. Swift-evolution thread: Pitch: “offsetof”-like functionality for stored property key paths Motivation Many graphics and math libraries accept input data in arbitrary input formats, which the user has to describe to the API when setting up their input buffers. For example, OpenGL lets you describe the layout of vertex buffers using series of calls to the glVertexAttribPointer API. In C, you can use the standard offsetof macro to get the offset of fields within a struct, allowing you to use the compiler’s knowledge of a type’s layout to fill out these function calls: // Layout of one of our vertex entries struct MyVertex { float position[4]; float normal[4]; uint16_t texcoord[2]; }; enum MyVertexAttribute { Position, Normal, TexCoord }; glVertexAttribPointer(Position, 4, GL_FLOAT, GL_FALSE, sizeof(MyVertex), (void*)offsetof(MyVertex, position)); glVertexAttribPointer(Normal, 4, GL_FLOAT, GL_FALSE, sizeof(MyVertex), (void*)offsetof(MyVertex, normal)); glVertexAttribPointer(TexCoord, 2, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(MyVertex), (void*)offsetof(MyVertex, texcoord)); There’s currently no equivalent to offsetof in Swift, so users of these kinds of APIs must either write those parts of their code in C or else do Swift memory layout in their heads, which is error-prone if they ever change their data layout or the Swift compiler implementation changes its layout algorithm (which it reserves the right to do). Proposed solution Key paths now provide a natural way to refer to fields in Swift. We can add an API to the MemoryLayout type to ask for the offset of the field represented by a key path. Detailed design A new API is added to MemoryLayout: extension MemoryLayout { func offset(of key: PartialKeyPath&lt;T&gt;) -&gt; Int? } If the given key refers to inline storage within the in-memory representation of T, and the storage is directly addressable (meaning that accessing it does not need to trigger any didSet or willSet accessors, perform any representation changes such as bridging or closure reabstraction, or mask the value out of overlapping storage as for packed bitfields), then the return value is a distance in bytes that can be added to a pointer of type T to get a pointer to the storage accessed by key. In other words, if the return value is non-nil, then these formulations are equivalent: var root: T, value: U var key: WritableKeyPath&lt;T, U&gt; // Mutation through the key path... root[keyPath: .key] = value // ...is exactly equivalent to mutation through the offset pointer... withUnsafePointer(to: &amp;root) { (UnsafeMutableRawPointer($0) + MemoryLayout&lt;T&gt;.offset(of: .key)) // ...which can be assumed to be bound to the target type .assumingMemoryBound(to: U.self).pointee = value } One possible set of answers for a Swift struct might look like this: struct Point { var x, y: Double } struct Size { var w, h: Double var area: Double { return w*h } } struct Rect { var origin: Point var size: Size } MemoryLayout&lt;Rect&gt;.offset(of: .origin.x) // =&gt; 0 MemoryLayout&lt;Rect&gt;.offset(of: .origin.y) // =&gt; 8 MemoryLayout&lt;Rect&gt;.offset(of: .size.w) // =&gt; 16 MemoryLayout&lt;Rect&gt;.offset(of: .size.h) // =&gt; 24 MemoryLayout&lt;Rect&gt;.offset(of: .size.area) // =&gt; nil In Swift today, only key paths that refer to struct fields would support taking their offset, though if support for tuple elements in key paths were added in the future, tuple elements could as well. Class properties are always stored out-of-line, and require runtime exclusivity checking to access, so their offsets would not be available by this mechanism. Source compatibility This is an additive change to the API of MemoryLayout. Effect on ABI stability KeyPath objects already encode the offset information for stored properties necessary to implement this, so this has no additional demands from the ABI. Effect on API resilience Clients of an API could potentially use this functionality to dynamically observe whether a public property is implemented as a stored property from outside of the module. If a client assumes that a property will always be stored by force-unwrapping the optional result of offset(of:), that could lead to compatibility problems if the library author changes the property to computed in a future library version. Client code using offsets should be careful not to rely on the stored-ness of properties in types they don’t control. Alternatives considered Instead of a new static method on MemoryLayout, this functionality could also be expressed as an offset property on KeyPath. All of the information necessary to answer the offset question is in the KeyPath value itself. Nonetheless, MemoryLayout seems like the natural place to put this API. A related API that might be useful to build on top of this functionality would be to add methods to UnsafePointer and UnsafeMutablePointer for projecting a pointer to a field from a pointer to a base value, for example: extension UnsafePointer { subscript&lt;Field&gt;(field: KeyPath&lt;Pointee, Field&gt;) -&gt; UnsafePointer&lt;Field&gt; { return (UnsafeRawPointer(self) + MemoryLayout&lt;Pointee&gt;.offset(of: field)) .assumingMemoryBound(to: Field.self) } } extension UnsafeMutablePointer { subscript&lt;Field&gt;(field: KeyPath&lt;Pointee, Field&gt;) -&gt; UnsafePointer&lt;Field&gt; { return (UnsafeRawPointer(self) + MemoryLayout&lt;Pointee&gt;.offset(of: field)) .assumingMemoryBound(to: Field.self) } subscript&lt;Field&gt;(field: WritableKeyPath&lt;Pointee, Field&gt;) -&gt; UnsafeMutablePointer&lt;Field&gt; { return (UnsafeMutableRawPointer(self) + MemoryLayout&lt;Pointee&gt;.offset(of: field)) .assumingMemoryBound(to: Field.self) } }",
    "url": "http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html",
    "relUrl": "/docs/2019-08-26-0210-key-path-offset.html"
  },
  "210": {
    "id": "210",
    "title": "SE-0211 Add Unicode Properties to `Unicode.Scalar`",
    "content": "Add Unicode Properties to Unicode.Scalar Proposal: SE-0211 Author: Tony Allevato Review Manager: Ben Cohen Status: Implemented (Swift 5) Implementation: apple/swift#15593 Decision Notes: Rationale Previous Revision: 1 Introduction We propose adding a number of properties to the Unicode.Scalar type to support both common and advanced text processing use cases, filling in a number of gaps in Swift’s text support compared to other programming languages. Swift-evolution thread: Adding Unicode properties to UnicodeScalar/Character Motivation The Swift String type, and related types like Character and Unicode.Scalar, provide very rich support for Unicode-correct operations. String comparisons are normalized, grapheme cluster boundaries are automatically detected, and string contents can be easily accessed in terms of grapheme clusters, code points, and UTF-8 and -16 code units. However, when drilling down to lower levels, like individual code points (i.e., Unicode.Scalar elements), the current APIs are missing a number of fundamental features available in other programming languages. Unicode.Scalar lacks the ability to ask whether a scalar is upper/lowercase or what its upper/lowercase mapping is, if it is a whitespace character, and so forth. Without pulling in third-party code, users can currently import the Darwin/Glibc module and access C functions like isspace, but these only work with ASCII characters. Issues Linking with ICU The Swift standard library uses the system’s ICU libraries to implement its Unicode support. A third-party developer may expect that they could also link their application directly to the system ICU to access the functionality that they need, but this proves problematic on both Apple and Linux platforms. On Apple operating systems, libicucore.dylib is built with function renaming disabled (function names lack the _NN version number suffix). This makes it fairly straightforward to import the C APIs and call them from Swift without worrying about which version the operating system is using. Unfortunately, libicucore.dylib is considered to be private API for submissions to the App Store, so applications doing this will be rejected. Instead, users must built their own copy of ICU from source and link that into their applications. This is significant overhead. On Linux, system ICU libraries are built with function renaming enabled (the default), so function names have the _NN version number suffix. Function renaming makes it more difficult to use these APIs from Swift; even though the C header files contain #defines that map function names like u_foo_59 to u_foo, these #defines are not imported into Swift—only the suffixed function names are available. This means that Swift bindings would be fixed to a specific version of the library without some other intermediary layer. Again, this is significant overhead. Therefore, this proposal not only fills in important gaps in the standard library’s capabilities, but removes a significant pain point for users who may try to access that functionality through other means. Proposed solution We propose adding a nested struct, Unicode.Scalar.Properties, which will encapsulate many of the properties that the Unicode specification defines on scalars. Supporting types, such as enums representing the values of certain properties, will also be added to the Unicode enum “namespace.” Scope of This Proposal This proposal is restricted, by design, to add functionality to Unicode.Scalar only. While we believe that some of the properties described here (and others) would be valuable on Character as well, we have intentionally saved those for a future proposal in order to keep this one small and focused. Such a future proposal would likely depend on the design and implementation herein. Detailed design The code snippets below reflect an elided sketch of the proposed public API only. Full details can be found in the implementation pull request. In general, the names of the properties inside the Properties struct are derived directly from the names of the properties as they are defined in the Unicode Standard. extension Unicode.Scalar { // NOT @_fixed_layout public struct Properties { // Remaining API is defined in the subsections below. } /// The value that encapsulates the properties exposed. public var properties: Properties { get } } Boolean Properties Each of the Boolean properties in the first block below would be implemented by calling ICU’s u_hasBinaryProperty function. The official Unicode name of each property is indicated by the comment next to the computed properties below. We propose supporting all of the Boolean properties that are currently available using ICU’s u_hasBinaryProperty that correspond to properties in the Unicode Standard (but not ICU-specific properties), with the following exceptions: Grapheme_Link is omitted because it is deprecated and equivalent to canonical combining class 9. Hyphen is omitted because is deprecated in favor of the Line_Break property. extension Unicode.Scalar.Properties { public var isAlphabetic: Bool { get } // Alphabetic public var isASCIIHexDigit: Bool { get } // ASCII_Hex_Digit public var isBidiControl: Bool { get } // Bidi_Control public var isBidiMirrored: Bool { get } // Bidi_Mirrored public var isDash: Bool { get } // Dash public var isDefaultIgnorableCodePoint: Bool { get } // Default_Ignorable_Code_Point public var isDeprecated: Bool { get } // Deprecated public var isDiacritic: Bool { get } // Diacritic public var isExtender: Bool { get } // Extender public var isFullCompositionExclusion: Bool { get } // Full_Composition_Exclusion public var isGraphemeBase: Bool { get } // Grapheme_Base public var isGraphemeExtend: Bool { get } // Grapheme_Extend public var isHexDigit: Bool { get } // Hex_Digit public var isIDContinue: Bool { get } // ID_Continue public var isIDStart: Bool { get } // ID_Start public var isIdeographic: Bool { get } // Ideographic public var isIDSBinaryOperator: Bool { get } // IDS_Binary_Operator public var isIDSTrinaryOperator: Bool { get } // IDS_Trinary_Operator public var isJoinControl: Bool { get } // Join_Control public var isLogicalOrderException: Bool { get } // Logical_Order_Exception public var isLowercase: Bool { get } // Lowercase public var isMath: Bool { get } // Math public var isNoncharacterCodePoint: Bool { get } // Noncharacter_Code_Point public var isQuotationMark: Bool { get } // Quotation_Mark public var isRadical: Bool { get } // Radical public var isSoftDotted: Bool { get } // Soft_Dotted public var isTerminalPunctuation: Bool { get } // Terminal_Punctuation public var isUnifiedIdeograph: Bool { get } // Unified_Ideograph public var isUppercase: Bool { get } // Uppercase public var isWhitespace: Bool { get } // Whitespace public var isXIDContinue: Bool { get } // XID_Continue public var isXIDStart: Bool { get } // XID_Start public var isCaseSensitive: Bool { get } // Case_Sensitive public var isSentenceTerminal: Bool { get } // Sentence_Terminal (S_Term) public var isVariationSelector: Bool { get } // Variation_Selector public var isNFDInert: Bool { get } // NFD_Inert public var isNFKDInert: Bool { get } // NFKD_Inert public var isNFCInert: Bool { get } // NFC_Inert public var isNFKCInert: Bool { get } // NFKC_Inert public var isSegmentStarter: Bool { get } // Segment_Starter public var isPatternSyntax: Bool { get } // Pattern_Syntax public var isPatternWhitespace: Bool { get } // Pattern_White_Space public var isCased: Bool { get } // Cased public var isCaseIgnorable: Bool { get } // Case_Ignorable public var changesWhenLowercased: Bool { get } // Changes_When_Lowercased public var changesWhenUppercased: Bool { get } // Changes_When_Uppercased public var changesWhenTitlecased: Bool { get } // Changes_When_Titlecased public var changesWhenCaseFolded: Bool { get } // Changes_When_Casefolded public var changesWhenCaseMapped: Bool { get } // Changes_When_Casemapped public var changesWhenNFKCCaseFolded: Bool { get } // Changes_When_NFKC_Casefolded public var isEmoji: Bool { get } // Emoji public var isEmojiPresentation: Bool { get } // Emoji_Presentation public var isEmojiModifier: Bool { get } // Emoji_Modifier public var isEmojiModifierBase: Bool { get } // Emoji_Modifier_Base } We also propose the following Boolean computed property that is generally useful, though it does not correspond to a named Unicode property: extension Unicode.Scalar.Properties { // Implemented in terms of ICU&#39;s `u_isdefined`. public var isDefined: Bool { get } } Case Mappings The properties below provide full case mappings for scalars. Since a handful of mappings result in multiple scalars (e.g., “ß” uppercases to “SS”), these properties are String-valued, not Unicode.Scalar. These properties are also common enough that they could be reasonably hoisted out of Unicode.Scalar.Properties and made into instance properties directly on Unicode.Scalar. extension Unicode.Scalar.Properties { public var lowercaseMapping: String { get } // u_strToLower public var titlecaseMapping: String { get } // u_strToTitle public var uppercaseMapping: String { get } // u_strToUpper } Identification and Classification We add the following properties for the purposes of identifying and categorizing scalars. The Canonical_Combining_Class property is somewhat unique in that the Unicode standard provides names for some, but not all, of the 255 valid values. We choose to represent this in Swift as a RawRepresentable struct that wraps the raw integer value, while still being Comparable for the purposes of implementing manual decomposition logic if necessary, and still providing the named values through static let constants. extension Unicode.Scalar.Properties { /// Corresponds to the `Age` Unicode property, when a code point was first /// defined. public var age: Unicode.Version? { get } /// Corresponds to the `Name` Unicode property. public var name: String? { get } /// Corresponds to the `Name_Alias` Unicode property. public var nameAlias: String? { get } /// Corresponds to the `General_Category` Unicode property. public var generalCategory: Unicode.GeneralCategory { get } /// Corresponds to the `Canonical_Combining_Class` Unicode property. public var canonicalCombiningClass: Unicode.CanonicalCombiningClass { get } } extension Unicode { /// Represents the version of Unicode in which a scalar was introduced. public typealias Version = (major: Int, minor: Int) /// General categories returned by /// `Unicode.Scalar.Properties.generalCategory`. Listed along with their /// two-letter code. public enum GeneralCategory { case uppercaseLetter // Lu case lowercaseLetter // Ll case titlecaseLetter // Lt case modifierLetter // Lm case otherLetter // Lo case nonspacingMark // Mn case spacingMark // Mc case enclosingMark // Me case decimalNumber // Nd case letterlikeNumber // Nl case otherNumber // No case connectorPunctuation //Pc case dashPunctuation // Pd case openPunctuation // Ps case closePunctuation // Pe case initialPunctuation // Pi case finalPunctuation // Pf case otherPunctuation // Po case mathSymbol // Sm case currencySymbol // Sc case modifierSymbol // Sk case otherSymbol // So case spaceSeparator // Zs case lineSeparator // Zl case paragraphSeparator // Zp case control // Cc case format // Cf case surrogate // Cs case privateUse // Co case unassigned // Cn } public struct CanonicalCombiningClass: Comparable, Hashable, RawRepresentable { public static let notReordered = CanonicalCombiningClass(rawValue: 0) public static let overlay = CanonicalCombiningClass(rawValue: 1) public static let nukta = CanonicalCombiningClass(rawValue: 7) public static let kanaVoicing = CanonicalCombiningClass(rawValue: 8) public static let virama = CanonicalCombiningClass(rawValue: 9) public static let attachedBelowLeft = CanonicalCombiningClass(rawValue: 200) public static let attachedBelow = CanonicalCombiningClass(rawValue: 202) public static let attachedAbove = CanonicalCombiningClass(rawValue: 214) public static let attachedAboveRight = CanonicalCombiningClass(rawValue: 216) public static let belowLeft = CanonicalCombiningClass(rawValue: 218) public static let below = CanonicalCombiningClass(rawValue: 220) public static let belowRight = CanonicalCombiningClass(rawValue: 222) public static let left = CanonicalCombiningClass(rawValue: 224) public static let right = CanonicalCombiningClass(rawValue: 226) public static let aboveLeft = CanonicalCombiningClass(rawValue: 228) public static let above = CanonicalCombiningClass(rawValue: 230) public static let aboveRight = CanonicalCombiningClass(rawValue: 232) public static let doubleBelow = CanonicalCombiningClass(rawValue: 233) public static let doubleAbove = CanonicalCombiningClass(rawValue: 234) public static let iotaSubscript = CanonicalCombiningClass(rawValue: 240) public let rawValue: UInt8 public init(rawValue: UInt8) } } Numerics Many Unicode scalars have associated numeric values. These are not only the common digits zero through nine, but also vulgar fractions and various other linguistic characters and ideographs that have an innate numeric value. These properties are exposed below. They can be useful for determining whether segments of text contain numbers or non-numeric data, and can also help in the design of algorithms to determine the values of such numbers. extension Unicode.Scalar.Properties { /// Corresponds to the `Numeric_Type` Unicode property. public var numericType: Unicode.NumericType? /// Corresponds to the `Numeric_Value` Unicode property. public var numericValue: Double? } extension Unicode { public enum NumericType { case decimal case digit case numeric } } Source compatibility These changes are strictly additive. This proposal does not affect source compatibility. Effect on ABI stability These changes are strictly additive. This proposal does not affect the ABI of existing language features. Effect on API resilience The Unicode.Scalar.Properties struct is currently defined as a resilient (non-@_fixed_layout) struct whose only stored property in the initial implementation is the integer value of the scalar whose properties are being retrieved. All other properties are computed properties, and new properties can be added without breaking the ABI. In the future, we may choose to cache certain properties if data show that they are more frequently accessed than others and that there would be a meaningful performance improvement by computing them early. It is too soon to make such a determination now, however. Alternatives considered API Designs We considered other representations for the Boolean properties of a scalar: A BooleanProperty enum with a case for each property, and a Unicode.Scalar.hasProperty method used to query it. This is very close to the underlying ICU C APIs and does not bloat the Unicode.Scalar API, but makes the kinds of queries users would commonly make less discoverable. A Unicode.Scalar.properties property whose type conforms to OptionSet. This would allow us to use the underlying property enum constants as the bit-shifts for the option set values, but there are already 64 Boolean properties defined by ICU. Since the underlying integral type is part of the public API/ABI of the option set, we would not be able to change it in the future without breaking compatibility. A Unicode.Scalar.properties property whose type is a Set&lt;BooleanProperty&gt;, but we would not be able to form this collection without querying all Boolean properties upon any access (the OptionSet solution above suffers the same problem). This would be needlessly inefficient in almost all usage. We feel that by putting the properties into a separate Unicode.Scalar.Properties struct, the large number of advanced properties does not contribute to bloat of the main Unicode.Scalar API, and allows us to cleanly represent not only Boolean properties but other types of properties with ease. Naming The names of the Boolean properties are all of the form is&lt;Unicode Property Name&gt;, with the exception of a small number of properties whose names already start with indicative verb forms and read as assertions (e.g., changesWhenUppercased). This leads to some technical and/or awkward property names, like isXIDContinue. We considered modifying these names to make them read more naturally like other Swift APIs; for example, extendsPrecedingScalar instead of isExtender. However, since these properties are intended for advanced users who are likely already somewhat familiar with the Unicode Standard and its definitions, we decided to keep the names directly derived from the Standard, which makes them more discoverable to the intended audience.",
    "url": "http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html",
    "relUrl": "/docs/2019-08-26-0211-unicode-scalar-properties.html"
  },
  "211": {
    "id": "211",
    "title": "SE-0212 Compiler Version Directive",
    "content": "Compiler Version Directive Proposal: SE-0212 Author: David Hart Review Manager: Ted Kremenek Implementation: apple/swift#15977 Status: Implemented (Swift 4.2) Introduction This proposal introduces a compiler directive that is syntactically equivalent to the #if swift version check but checks against the version of the compiler, regardless of which compatibility mode it’s currently running in. Motivation The #if swift check allows conditionally compiling code depending on the version of the language. Prior to Swift 4, the version of the compiler and the language were one and the same. But since Swift 4, the compiler can run in a compatibility mode for previous Swift versions, introducing an new version dimension. To support code across multiple compiler versions and compatibility modes, extra language versions are regularly introduced to represent old language versions running under compatibility mode. For example, the release of Swift 4 introduced a Swift 3.2 language version representing the Swift 4 compiler in version 3 compatibility mode. Here is the current language matrix, as well as guesses as to what those versions will be for Swift 5.0 and 5.1. Swift –swift-version 3 –swift-version 4 –swift-version 4.2 –swift-version 5 3.0 N/A N/A N/A N/A 3.1 N/A N/A N/A N/A 4.0 3.2 4.0 N/A N/A 4.1 3.3 4.1 N/A N/A 4.2 3.4 4.1.50 4.2 N/A 5.0 3.5 4.1.51 4.3 5.0 5.1 3.6 4.1.52 4.4 5.1 This solution is problematic for several reasons: It creates a quadratic growth in the number of Swift versions for each new compatibility version. Conditionally compiling for a version of the compiler, regardless of the compatibility mode, is difficult and error prone: #if swift(&gt;=4.1) || (swift(&gt;=3.3) &amp;&amp; !swift(&gt;=4.0)) // Code targeting the Swift 4.1 compiler and above. #endif #if swift(&gt;=4.1.50) || (swift(&gt;=3.4) &amp;&amp; !swift(&gt;=4.0)) // Code targeting the Swift 4.2 compiler and above. #endif #if swift(&gt;=5.0) || (swift(&gt;=4.1.50) &amp;&amp; !swift(&gt;=4.2)) || (swift(&gt;=3.5) &amp;&amp; !swift(&gt;=4.0)) // Code targeting the Swift 5.0 compiler and above. #endif Proposed solution This proposal suggests: introducing a new compiler directive that is syntactically equivalent to the swift directive but checks against the version of the compiler, stop bumping old Swift versions when new versions are introduced. This will simplify future Swift versions by stopping the artificial growth of old language versions: Invocation Compiler Version Language Version 3.0 N/A 3.0 3.1 N/A 3.1 4.0 N/A 4.0 4.0 (–swift-version 3) N/A 3.2 4.1 N/A 4.1 4.1 (–swift-version 3) N/A 3.3 4.2 4.2 4.2 4.2 (–swift-version 3) 4.2 3.3 4.2 (–swift-version 4) 4.2 4.1 5.0 5.0 5.0 5.0 (–swift-version 3) 5.0 3.3 5.0 (–swift-version 4) 5.0 4.1 5.0 (–swift-version 4.2) 5.0 4.2 5.1 5.1 5.1 5.1 (–swift-version 3) 5.1 3.3 5.1 (–swift-version 4) 5.1 4.1 5.1 (–swift-version 4.2) 5.1 4.2 This change is possible because it retains the ability to conditionally compile code targeting a compiler in compatibility mode: #if swift(&gt;=4.1) &amp;&amp; compiler(&gt;=5.0) // Code targeting the Swift 5.0 compiler and above in --swift-version 4 mode and above. #endif It will also greatly simplify conditional compilation based on compiler version alone: #if swift(&gt;=4.1) || (swift(&gt;=3.3) &amp;&amp; !swift(&gt;=4.0)) // Code targeting the Swift 4.1 compiler and above. // This can&#39;t change because it needs to continue working with older compilers. #endif #if compiler(&gt;=4.2) // Code targeting the Swift 4.2 compiler and above. #endif #if compiler(&gt;=5.0) // Code targeting the Swift 5.0 compiler and above. #endif Impact on existing code This is a purely additive change and will have no impact on existing code. Alternatives considered No other alternative naming was considered for this new directive.",
    "url": "http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html",
    "relUrl": "/docs/2019-08-26-0212-compiler-version-directive.html"
  },
  "212": {
    "id": "212",
    "title": "SE-0213 Literal initialization via coercion",
    "content": "Literal initialization via coercion Proposal: SE-0213 Authors: Pavel Yaskevich Review Manager: John McCall Status: Implemented (Swift 5) Implementation: apple/swift#17860 Introduction T(literal) should construct T using the appropriate literal protocol if possible. Swift-evolution thread: Literal initialization via coercion Motivation Currently types conforming to literal protocols are type-checked using regular initializer rules, which means that for expressions like UInt32(42) the type-checker is going to look up a set of available initializer choices and attempt them one-by-one trying to deduce the best solution. This is not always a desired behavior when it comes to numeric and other literals, because it means that argument is going to be type-checked separately (most likely to some default literal type like Int) and passed to an initializer call. At the same time coercion behavior would treat the expression above as 42 as UInt32 where 42 is ascribed to be UInt32 and constructed without an intermediate type. Proposed solution The proposed change makes all initializer expressions involving literal types behave like coercion of literal to specified type if such type conforms to the expected literal protocol. As a result expressions like UInt64(0xffff_ffff_ffff_ffff), which result in compile-time overflow under current rules, become valid. It also simplifies type-checker logic and leads to speed-up in some complex expressions. This change also makes some of the errors which currently only happen at runtime become compile-time instead e.g. Character(&quot;ab&quot;). Detailed design Based on the previous discussion on this topic here is the formal typing rule: Given a function call expression of the form `A(B)` (that is, an expr-call with a single, unlabelled argument) where B is a literal expression, if `A` has type `T.Type` for some type `T` and there is a declared conformance of `T` to an appropriate literal protocol for `B`, then `A` is directly constructed using `init` witness to literal protocol (as if the expression were written &quot;B as A&quot;). This behavior could be avoided by spelling initializer call verbosely e.g. UInt32.init(42). Implementation is going to transform CallExpr with TypeExpr as a applicator into implicit CoerceExpr if the aforementioned typing rule holds before forming constraint system. Source compatibility This is a source breaking change because it’s possible to declare a conformance to a literal protocol and also have a failable initializer with the same parameter type: struct Q: ExpressibleByStringLiteral { typealias StringLiteralType = String var question: String init?(_ possibleQuestion: StringLiteralType) { return nil } init(stringLiteral str: StringLiteralType) { self.question = str } } _ = Q(&quot;ultimate question&quot;) // &#39;nil&#39; _ = &quot;ultimate question&quot; as Q // Q(question: &#39;ultimate question&#39;) Although such situations are possible, we consider them to be quite rare in practice. FWIW, none were found in the compatibility test suite. Effect on ABI stability Does not affect ABI stability Effect on API resilience Does not affect API resilience Alternatives considered Not to make this change.",
    "url": "http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html",
    "relUrl": "/docs/2019-08-26-0213-literal-init-via-coercion.html"
  },
  "213": {
    "id": "213",
    "title": "SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`",
    "content": "Renaming the DictionaryLiteral type to KeyValuePairs Proposal: SE-0214 Authors: Erica Sadun, Chéyo Jiménez Review Manager: Chris Lattner Status: Implemented (Swift 5) Implementation: apple/swift#16577 Decision Notes: Rationale Previous Revision: 1 Introduction This proposal renames the confusing and misnamed DictionaryLiteral type to KeyValuePairs. This type is neither a dictionary nor a literal. It is a list of key-value pairs. There is no strong motivation to deprecate. The type does not produce active harm. Instead, it adds measurable (if small) utility and will be part of the ABI. A sensible renaming mitigates the most problematic issue with the type. This proposal was discussed in the Swift Forums on the 100% bikeshed topic: DictionaryLiteral thread. Motivation This proposal renames the standard library’s DictionaryLiteral before the Swift Language declares ABI stability. The type is confusingly misnamed. A DictionaryLiteral is neither a dictionary nor a literal. It offers no key-based value lookup. It does not represent a fixed value in source code. It seems reasonable to give the type to a better name that fits its role and purpose. Current Use: DictionaryLiteral establishes the Mirror API’s children: public init&lt;Subject&gt;( _ subject: Subject, children: DictionaryLiteral&lt;String, Any&gt;, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default ) This implementation depends on DictionaryLiteral’s continued existence. The @dynamicCallable proposal will provide another use case for this type. Even when narrowly used, a type’s reach is no longer a sufficient reason to deprecate it or remove it from the language. Absent active harm, source stability takes precedence. In this case, the DictionaryLiteral type causes no measurable harm beyond API sprawl and the issues with its name. The latter is easily fixed. Current Limits: The type’s doc comments note an inefficient lookup implementation. This issue can be resolved in future Swift releases if needed: /// Some operations that are efficient on a dictionary are slower when using /// `DictionaryLiteral`. In particular, to find the value matching a key, you /// must search through every element of the collection. The call to /// `index(where:)` in the following example must traverse the whole /// collection to find the element that matches the predicate Utility: The type’s support of duplicate keys could become be a feature for scanning key-value pairs: /// You initialize a `DictionaryLiteral` instance using a Swift dictionary /// literal. Besides maintaining the order of the original dictionary literal, /// `DictionaryLiteral` also allows duplicates keys. This key-value pair processing might support custom initializers. It allows duplicate keys and preserves declaration order, which are both reasonably useful features. Detailed Design DictionaryLiteral is renamed to KeyValuePairs. A typealias preserves the old name for compatibility but can be deprecated as of Swift 5.0. This name was extensively bikeshedded on the Swift Forum thread before proposal. The runner up name was KeyValueArray. Source compatibility The old name can live on indefinitely via a typealias (which has no ABI consequences, so could be retired at a later date once everyone has had plenty of time to address the deprecation warnings). Removing it as not carrying its weight (and instead using [(Key,Value)], which is basically what it’s a wrapper for) is probably off the table for reasons of source stability. Effect on ABI stability Should be decided before ABI Stability is declared. Effect on API resilience None. Alternatives and Future Directions This proposal does not change syntax. It processes an ordered immutable list of pairs declared using [:] syntax. This syntax offers better visual aesthetics than [(,)]. Swift cannot yet replace DictionaryLiteral with conditional conformance using Array: ExpressibleByDictionaryLiteral where Element = (Key,Value) because parameterized extensions are not yet available. Further, creating an array from a dictionary literal may be unnecessarily confusing. This proposal does not deprecate and remove the type, as Mirror relies on its existence. This proposal does not recommend the removal of the Mirror type as third party custom debugging features rely on this feature. A forum discussion considered a one-time split of the standard library, creating a “SwiftDeprecated” module that could eventually be phased out. That idea lies outside the scope of this proposal and involves a tradeoff between sunsetting APIs in the future for a slight reduction in size of today’s standard library. Most applications will not use these APIs, whether such an approach is taken or not. Acknowledgments Thanks, Ben Cohen, for pointing out this problem and starting the forum thread to arrive at a better name. Thanks Chris Lattner and Ted Kremenek for design direction.",
    "url": "http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html",
    "relUrl": "/docs/2019-08-26-0214-DictionaryLiteral.html"
  },
  "214": {
    "id": "214",
    "title": "SE-0215 Conform `Never` to `Equatable` and `Hashable`",
    "content": "Conform Never to Equatable and Hashable Proposal: SE-0215 Author: Matt Diephouse Review Manager: Ted Kremenek Status: Implemented (Swift 5) Decision Notes: Rationale Implementation: apple/swift#16857 Introduction Extend Never so it conforms to Equatable and Hashable. Swift-evolution thread: Conform Never to Equatable and Hashable Motivation Never is very useful for representing impossible code. Most people are familiar with it as the return type of functions like fatalError, but Never is also useful when working with generic classes. For example, a Result type might use Never for its Value to represent something that always errors or use Never for its Error to represent something that never errors. Conditional conformances to Equatable and Hashable are also very useful when working with enums so you can test easily or work with collections. But those don’t play well together. Without conformance to Equatable and Hashable, Never disqualifies your generic type from being Equatable and Hashable. Proposed solution The standard library should add Equatable and Hashable implementations for Never: extension Never: Equatable { public static func == (lhs: Never, rhs: Never) -&gt; Bool { switch (lhs, rhs) { } } } extension Never: Hashable { public func hash(into hasher: inout Hasher) { } } Detailed design The question that most often comes up is how Never should implement Equatable. How do you compare to Never values? But there are no Never values; it’s an uninhabitable type. Thankfully Swift makes this easy. By switching over the left- and right-hand sides, Swift correctly notices that there are no missing cases. Since there are no missing cases and every case returns a Bool, the function compiles. The new Hashable design makes its implementation even easier: the function does nothing. Source compatibility Existing applications may have their own versions of these conformances. In this case, Swift will give a redundant conformance error. Effect on ABI stability None. Effect on API resilience None. Alternatives considered Make Never conform to all protocols As a bottom type, Never could conceivably conform to every protocol automatically. This would have some advantages and might be ideal, but would require a lot more work to determine the design and implement the behavior. Don’t include this functionality in the standard library This creates a significant headache—particularly for library authors. Since redundant conformance would be an error, the community would need to settle on a de facto library to add this conformance. Require generic types to add conditional conformances with Never An example Result type could manually add Equatable and Hashable implementations for Nevers: extension Result: Equatable where Value == Never, Error: Equatable { … } extension Result: Equatable where Value: Hashable, Error == Never { … } extension Result: Equatable where Value == Never, Error == Never { … } Adding so many extra conditional conformances is an unreasonable amount of work. Amendment from Core Team As part of the review decision from the Core Team when accepting this proposal, in addition to Equatable and Hashable conformances being added to Never this proposal now also includes adding conformances to the Comparable and Error protocols as well.",
    "url": "http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html",
    "relUrl": "/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html"
  },
  "215": {
    "id": "215",
    "title": "SE-0216 Introduce user-defined dynamically "callable" types",
    "content": "Introduce user-defined dynamically “callable” types Proposal: SE-0216 Authors: Chris Lattner, Dan Zheng Review Manager: John McCall Implementation: apple/swift#20305 Decision Notes: Rationale Status: Implemented (Swift 5) Introduction This proposal is a follow-up to SE-0195 - Introduce User-defined “Dynamic Member Lookup” Types, which shipped in Swift 4.2. It introduces a new @dynamicCallable attribute, which marks a type as being “callable” with normal syntax. It is simple syntactic sugar which allows the user to write: a = someValue(keyword1: 42, &quot;foo&quot;, keyword2: 19) and have it be rewritten by the compiler as: a = someValue.dynamicallyCall(withKeywordArguments: [ &quot;keyword1&quot;: 42, &quot;&quot;: &quot;foo&quot;, &quot;keyword2&quot;: 19 ]) Many other languages have analogous features (e.g. Python “callables”, C++ operator(), and functors in many other languages), but the primary motivation of this proposal is to allow elegant and natural interoperation with dynamic languages in Swift. Swift-evolution threads: Pitch: Introduce user-defined dynamically “callable” types. Pitch #2: Introduce user-defined dynamically “callable” types. Current pitch thread: Pitch #3: Introduce user-defined dynamically “callable” types Motivation and context Swift is exceptional at interworking with existing C and Objective-C APIs and we would like to extend this interoperability to dynamic languages like Python, JavaScript, Perl, and Ruby. We explored this overall goal in a long design process wherein the Swift evolution community evaluated multiple different implementation approaches. The conclusion was that the best approach was to put most of the complexity into dynamic language specific bindings written as pure-Swift libraries, but add small hooks in Swift to allow these bindings to provide a natural experience to their clients. SE-0195 was the first step in this process, which introduced a binding to naturally express member lookup rules in dynamic languages. What does interoperability with Python mean? Let’s explain this by looking at an example. Here’s some simple Python code: class Dog: def __init__(self, name): self.name = name self.tricks = [] # creates a new empty list for each `Dog` def add_trick(self, trick): self.tricks.append(trick) With the SE-0195 @dynamicMemberLookup feature introduced in Swift 4.2, it is possible to implement a Python interoperability layer written in Swift. It interoperates with the Python runtime, and project all Python values into a single PythonObject type. It allows us to call into the Dog class like this: // import DogModule.Dog as Dog let Dog = Python.import.call(with: &quot;DogModule.Dog&quot;) // dog = Dog(&quot;Brianna&quot;) let dog = Dog.call(with: &quot;Brianna&quot;) // dog.add_trick(&quot;Roll over&quot;) dog.add_trick.call(with: &quot;Roll over&quot;) // dog2 = Dog(&quot;Kaylee&quot;).add_trick(&quot;snore&quot;) let dog2 = Dog.call(with: &quot;Kaylee&quot;).add_trick.call(with: &quot;snore&quot;) This also works with arbitrary other APIs as well. Here is an example working with the Python pickle API and the builtin Python function open. Note that we choose to put builtin Python functions like import and open into a Python namespace to avoid polluting the global namespace, but other designs are possible: // import pickle let pickle = Python.import.call(with: &quot;pickle&quot;) // file = open(filename) let file = Python.open.call(with: filename) // blob = file.read() let blob = file.read.call() // result = pickle.loads(blob) let result = pickle.loads.call(with: blob) This capability works well, but the syntactic burden of having to use foo.call(with: bar, baz) instead of foo(bar, baz) is significant. Beyond the syntactic weight, it directly harms code clarity by making code hard to read and understand, cutting against a core value of Swift. The proposed @dynamicCallable attribute directly solves this problem. With it, these examples become more natural and clear, effectively matching the original Python code in expressiveness: // import DogModule.Dog as Dog let Dog = Python.import(&quot;DogModule.Dog&quot;) // dog = Dog(&quot;Brianna&quot;) let dog = Dog(&quot;Brianna&quot;) // dog.add_trick(&quot;Roll over&quot;) dog.add_trick(&quot;Roll over&quot;) // dog2 = Dog(&quot;Kaylee&quot;).add_trick(&quot;snore&quot;) let dog2 = Dog(&quot;Kaylee&quot;).add_trick(&quot;snore&quot;) Python builtins: // import pickle let pickle = Python.import(&quot;pickle&quot;) // file = open(filename) let file = Python.open(filename) // blob = file.read() let blob = file.read() // result = pickle.loads(blob) let result = pickle.loads(blob) This proposal merely introduces a syntactic sugar - it does not add any new semantic model to Swift. We believe that interoperability with scripting languages is an important and rising need in the Swift community, particularly as Swift makes inroads into the server development and machine learning communities. This feature is also precedented in other languages (e.g. Scala’s Dynamic trait), and can be used for other purposes besides language interoperability (e.g. implementing dynamic proxy objects). Proposed solution We propose introducing a new @dynamicCallable attribute to the Swift language which may be applied to structs, classes, enums, and protocols. This follows the precedent of SE-0195. Before this proposal, values of these types are not valid in a call expression: the only existing callable values in Swift are those with function types (functions, methods, closures, etc) and metatypes (which are initializer expressions like String(42)). Thus, it is always an error to “call” an instance of a nominal type (like a struct, for instance). With this proposal, types with the @dynamicCallable attribute on their primary type declaration become “callable”. They are required to implement at least one of the following two methods for handling the call behavior: func dynamicallyCall(withArguments: &lt;#Arguments#&gt;) -&gt; &lt;#R1#&gt; // `&lt;#Arguments#&gt;` can be any type that conforms to `ExpressibleByArrayLiteral`. // `&lt;#Arguments#&gt;.ArrayLiteralElement` and the result type `&lt;#R1#&gt;` can be arbitrary. func dynamicallyCall(withKeywordArguments: &lt;#KeywordArguments#&gt;) -&gt; &lt;#R2#&gt; // `&lt;#KeywordArguments#&gt;` can be any type that conforms to `ExpressibleByDictionaryLiteral`. // `&lt;#KeywordArguments#&gt;.Key` must be a type that conforms to `ExpressibleByStringLiteral`. // `&lt;#KeywordArguments#&gt;.Value` and the result type `&lt;#R2#&gt;` can be arbitrary. // Note: in these type signatures, bracketed types like &lt;#Arguments#&gt; and &lt;#KeywordArguments#&gt; // are not actual types, but rather any actual type that meets the specified conditions. As stated above, &lt;#Arguments#&gt; and &lt;#KeywordArguments#&gt; can be any types that conform to the ExpressibleByArrayLiteral and ExpressibleByDictionaryLiteral protocols, respectively. The latter is inclusive of KeyValuePairs, which supports duplicate keys, unlike Dictionary. Thus, using KeyValuePairs is recommended to support duplicate keywords and positional arguments (because positional arguments are desugared as keyword arguments with the empty string &quot;&quot; as the key). If a type implements the withKeywordArguments: method, it may be dynamically called with both positional and keyword arguments: positional arguments have the empty string &quot;&quot; as the key. If a type only implements the withArguments: method but is called with keyword arguments, a compile-time error is emitted. Since dynamic calls are syntactic sugar for direct calls to dynamicallyCall methods, additional behavior of the dynamicallyCall methods is directly forwarded. For example, if a dynamicallyCall method is marked with throws or @discardableResult, then the corresponding sugared dynamic call will forward that behavior. Ambiguity resolution: most specific match Since there are two @dynamicCallable methods, there may be multiple ways to handle some dynamic calls. What happens if a type specifies both the withArguments: and withKeywordArguments: methods? We propose that the type checker resolve this ambiguity towards the tightest match based on syntactic form of the expression. The exact rules are: If a @dynamicCallable type implements the withArguments: method and it is called with no keyword arguments, use the withArguments: method. In all other cases, attempt to use the withKeywordArguments: method. This includes the case where a @dynamicCallable type implements the withKeywordArguments: method and it is called with at least one keyword argument. This also includes the case where a @dynamicCallable type implements only the withKeywordArguments: method (not the withArguments: method) and it is called with no keyword arguments. If @dynamicCallable type does not implement the withKeywordArguments: method but the call site has keyword arguments, an error is emitted. Here are some toy illustrative examples: @dynamicCallable struct Callable { func dynamicallyCall(withArguments args: [Int]) -&gt; Int { return args.count } } let c1 = Callable() c1() // desugars to `c1.dynamicallyCall(withArguments: [])` c1(1, 2) // desugars to `c1.dynamicallyCall(withArguments: [1, 2])` c1(a: 1, 2) // error: `Callable` does not define the &#39;withKeywordArguments:&#39; method @dynamicCallable struct KeywordCallable { func dynamicallyCall(withKeywordArguments args: KeyValuePairs&lt;String, Int&gt;) -&gt; Int { return args.count } } let c2 = KeywordCallable() c2() // desugars to `c2.dynamicallyCall(withKeywordArguments: [:])` c2(1, 2) // desugars to `c2.dynamicallyCall(withKeywordArguments: [&quot;&quot;: 1, &quot;&quot;: 2])` c2(a: 1, 2) // desugars to `c2.dynamicallyCall(withKeywordArguments: [&quot;a&quot;: 1, &quot;&quot;: 2])` @dynamicCallable struct BothCallable { func dynamicallyCall(withArguments args: [Int]) -&gt; Int { return args.count } func dynamicallyCall(withKeywordArguments args: KeyValuePairs&lt;String, Int&gt;) -&gt; Int { return args.count } } let c3 = BothCallable() c3() // desugars to `c3.dynamicallyCall(withArguments: [])` c3(1, 2) // desugars to `c3.dynamicallyCall(withArguments: [1, 2])` c3(a: 1, 2) // desugars to `c3.dynamicallyCall(withKeywordArguments: [&quot;a&quot;: 1, &quot;&quot;: 2])` This ambiguity resolution rule works out naturally given the behavior of the Swift type checker, because it only resolves call expressions when the type of the base expression is known. At that point, it knows whether the base is a function type, metatype, or a valid @dynamicCallable type, and it knows the syntactic form of the call. This proposal does not require massive or invasive changes to the constraint solver. Please look at the implementation for more details. Example usage Here, we sketch some example bindings to show how this could be used in practice. Note that there are lots of design decisions that are orthogonal to this proposal (e.g. how to handle exceptions) that we aren’t going into here. This is just to show how this feature provides an underlying facility that language bindings authors can use to achieve their desired result. These examples also show @dynamicMemberLookup to illustrate how they work together, but elides other implementation details. JavaScript supports callable objects but does not have keyword arguments. Here is a sample JavaScript binding: @dynamicCallable @dynamicMemberLookup struct JSValue { // JavaScript doesn&#39;t have keyword arguments. @discardableResult func dynamicallyCall(withArguments: [JSValue]) -&gt; JSValue { ... } // This is a `@dynamicMemberLookup` requirement. subscript(dynamicMember member: JSValue) -&gt; JSValue {...} // ... other stuff ... } On the other hand, a common JavaScript pattern is to take a dictionary of values as a stand-in for argument labels (called like example({first: 1, second: 2, third: 3}) in JavaScript). A JavaScript bridge in Swift could choose to implement keyword argument support to allow this to be called as example(first: 1, second: 2, third: 3) from Swift code (kudos to Ben Rimmington for this observation). Python does support keyword arguments. While a Python binding could implement only the withKeywordArguments: method, it is be better to implement both the non-keyword and keyword forms to make the non-keyword case slightly more efficient (avoid allocating temporary storage) and to make direct calls with positional arguments nicer (x.dynamicallyCall(withArguments: 1, 2) instead of x.dynamicallyCall(withKeywordArguments: [&quot;&quot;: 1, &quot;&quot;: 2])). Here is a sample Python binding: @dynamicCallable @dynamicMemberLookup struct PythonObject { // Python supports arbitrary mixes of keyword arguments and non-keyword // arguments. @discardableResult func dynamicallyCall( withKeywordArguments: KeyValuePairs&lt;String, PythonObject&gt; ) -&gt; PythonObject { ... } // An implementation of a Python binding could choose to implement this // method as well, avoiding allocation of a temporary array. @discardableResult func dynamicallyCall(withArguments: [PythonObject]) -&gt; PythonObject { ... } // This is a `@dynamicMemberLookup` requirement. subscript(dynamicMember member: String) -&gt; PythonObject {...} // ... other stuff ... } Limitations Following the precedent of SE-0195, this attribute must be placed on the primary definition of a type, not on an extension. This proposal does not introduce the ability to provide dynamically callable static/class members. We don’t believe this is important given the goal of supporting dynamic languages like Python, but it could be explored if a use case is discovered in the future. Such future work should keep in mind that call syntax on metatypes is already meaningful, and that ambiguity would have to be resolved somehow (e.g. through the most specific rule). This proposal supports direct calls of values and methods, but subsets out support for currying methods in Smalltalk family languages. This is just an implementation limitation given the current state of currying in the Swift compiler. Support can be added in the future if there is a specific need. Source compatibility This is a strictly additive proposal with no source breaking changes. Effect on ABI stability This is a strictly additive proposal with no ABI breaking changes. Effect on API resilience This has no impact on API resilience which is not already captured by other language features. Future directions Dynamic member calling (for Smalltalk family languages) In addition to supporting languages like Python and JavaScript, we would also like to grow to support Smalltalk derived languages like Ruby and Squeak. These languages resolve method calls using both the base name as well as the keyword arguments at the same time. For example, consider this Ruby code: time = Time.zone.parse(user_time) The Time.zone reference is a member lookup, but zone.parse(user_time) is a method call, and needs to be handled differently than a lookup of zone.parse followed by a direct function call. This can be handled by adding a new @dynamicMemberCallable attribute, which acts similarly to @dynamicCallable but enables dynamic member calls (instead of dynamic calls of self). @dynamicMemberCallable would have the following requirements: func dynamicallyCallMethod(named: S1, withArguments: [T5]) -&gt; T6 func dynamicallyCallMethod(named: S2, withKeywordArguments: [S3 : T7]) -&gt; T8 Here is a sample Ruby binding: @dynamicMemberCallable @dynamicMemberLookup struct RubyObject { @discardableResult func dynamicallyCallMethod( named: String, withKeywordArguments: KeyValuePairs&lt;String, RubyObject&gt; ) -&gt; RubyObject { ... } // This is a `@dynamicMemberLookup` requirement. subscript(dynamicMember member: String) -&gt; RubyObject {...} // ... other stuff ... } General callable behavior This proposal is mainly directed at dynamic language interoperability. For this use case, it makes sense for the dynamicallyCall method to take a variable-sized list of arguments where each argument has the same type. However, it may be useful to support general callable behavior (akin to operator() in C++) where the desugared “callable” method can have a fixed number of arguments and arguments of different types. For example, consider something like: struct BinaryFunction&lt;T1, T2, U&gt; { func call(_ argument1: T1, _ argument1: T2) -&gt; U { ... } } It is not unreasonable to look ahead to a day where sugaring such things is supported, particularly when/if Swift gets variadic generics. This could allow typesafe n-ary smart function pointer types. We feel that the approach outlined in this proposal supports this direction. When/if a motivating use case for general callable behavior comes up, we can simply add a new form to represent it and enhance the type checker to prefer that during ambiguity resolution. If this is a likely direction, then it may be better to name the attribute @callable instead of @dynamicCallable in anticipation of that future growth. We believe that general callable behavior and @dynamicCallable are orthogonal features and should be evaluated separately. Alternatives considered Many alternatives were considered and discussed. Most of them are captured in the “Alternatives Considered” section of SE-0195. Here are a few points raised in the discussion: It was suggested that we use subscripts to represent the call implementations instead of a function call, aligning with @dynamicMemberLookup. We think that functions are a better fit here: the reason @dynamicMemberLookup uses subscripts is to allow the members to be l-values, but call results are not l-values. It was requested that we design and implement the ‘static callable’ version of this proposal in conjunction with the dynamic version proposed here. In the author’s opinion, it is important to consider static callable support as a likely future direction to make sure that the two features sit well next to each other and have a consistent design (something we believe this proposal has done) but it doesn’t make sense to join the two proposals. So far, there have been no strong motivating use case presented for the static callable version, and Swift lacks certain generics features (e.g. variadics) that would be necessary to make static callables general. We feel that static callable should stand alone on its own merits.",
    "url": "http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html",
    "relUrl": "/docs/2019-08-26-0216-dynamic-callable.html"
  },
  "216": {
    "id": "216",
    "title": "SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library",
    "content": "Introducing the !! “Unwrap or Die” operator to the Swift Standard Library Proposal: SE-0217 Authors: Ben Cohen, Dave DeLong, Paul Cantrell, Erica Sadun, and several other folk Review Manager: Joe Groff Status: Rejected Decision Notes: Rationale Introduction This proposal introduces an annotating forced-unwrapping operator to the Swift standard library. It augments the ?, ??, and ! family, adding !!. This “unwrap or die” operator provides code-sourced rationales for failed unwraps, supporting self-documentation and safer development. The !! operator is commonly implemented in the wider Swift Community and should be considered for official adoption. The new operator benefits both experienced and new Swift users. It takes this form: let value = wrappedValue !! &lt;# &quot;Explanation why lhs cannot be nil.&quot; #&gt; It provides a sugared and succinct equivalent of the following guard, unwrapping its left hand value and branching to a fatal error on nil values: guard let value = wrappedValue else { fatalError(&lt;# &quot;Explanation why lhs cannot be nil.&quot; #&gt;) } This approach replaces commented versions that do not emit explanations when an unwrap fails: let value = wrappedValue! // Explanation why lhs cannot be nil Adopting this operator: Encourages a thoughtful approach to unwrapping, Promotes reasons for trapping during unwraps, which are visible at run time, and Provides a succinct and easily-taught form for new Swift learners. This proposal was first discussed on the Swift Evolution list in the [Pitch] Introducing the “Unwrap or Die” operator to the standard library thread. It has been further discussed in the Swift Forums on the Resolved: Insert “!” is a bad fixit” thread. Motivation “Unwrap or Die” has been widely adopted in the Swift community. This approach provides a best practices approach that establishes informative run-time diagnostics with compiler-checked rationales (the rhs is mandatory). Relying solely on comments only conveys in the source code itself the reason why the developer thinks the value cannot be nil. Requiring a string on the rhs of !! provides useful information all the way from source to the console should the underlying guarantee fail at runtime. This produces “better” failures with explicit explanations. If you’re going to write a comment, why not make that comment useful for debugging at the same time? The Naive User / Fixit Problem Swift’s Insert &quot;!&quot; fixit is a dangerous enticement to new Swift language users. Force-unwrapping should be used sparingly and thoughtfully. Beginners have a strong tendency to throw code at the compiler until it runs. Consider the following line of code and its fixit. Mashing the “Fix” button inserts an unwrap after the url instance. let resourceData = try String(contentsOf: url, encoding: .utf8) // Error: Value of optional type &#39;URL?&#39; not unwrapped; did you mean to use &#39;!&#39; or &#39;?&#39;? // Fix: Insert &#39;!&#39; Experienced developers easily distinguish whether an optional value reflects an overlooked error condition, in which case they rearchitect to introduce a better pattern, or if the value in question is guaranteed to never contain nil and can safely support an unwrap. Inexperienced developers, unless they’re moving from a language with similar constructs, usually will not make such distinctions. They’re focused on getting past a compilation barrier, without realizing the hazard of nil values at the point of use. Quincey Morris writes with respect to the url example: The problem with the fixit (for inexperienced Swift programmers) is that this is almost certainly not the point at which things went wrong. Almost always (for the inexperienced) the problem is that url is optional by accident, and the correct fix is to add a ! to the RHS of the assignment from which url’s type was inferred — or, at least, to handle the optional there). The “fixit” solution adds an unwrap at the point of use: let resourceData = try String(contentsOf: url!, encoding: .utf8) A better solution tests and unwraps at the point of declaration using if-let or guard-let: let destination = &quot;http://swift.org&quot; guard let url = URL(string: destination) else { fatalError(&quot;Invalid URL string: (destination)&quot;) } let destination = &quot;☹️&quot; guard let url = URL(string: destination) else { fatalError(&quot;Invalid URL string: (destination)&quot;) } Swift’s “Add !” is a syntactic fix, not a semantic one. Swift cannot holistically evaluate user code intent. It cannot recommend or fixit a guard let or if let alternative at a disjoint location that leads to the point of error. Moral Hazards Fixits should not be used as bandaids to make things compile. Swift’s “Add !” fixit is a modest courtesy for experienced users and a moral hazard for the inexperienced. Stack Overflow and the developer forums are littered with questions regarding “unexpectedly found nil” errors at runtime: If you go through the Swift tab on Stack Overflow and take a drink every time you see a blatantly inappropriate use of ! in a questioner’s code due to them just mashing the fix-it, you will soon be dead of alcohol poisoning. – Charles Srstka Introducing !! allows Swift to offer a better, more educational fixit that guides new users to better solutions. If the expression cannot guarantee that the lhs is non-nil, coders are better served using if let/guard let constructions. Replacing the ! fixit with !! &lt;# &quot;Explanation why the left hand value cannot be nil.&quot; #&gt; offers a user-supporting hint that counters “Value of optional type not unwrapped” confusion. Runtime Diagnostics Forced unwraps are an essential part of the Swift programming language. In many cases, a ! forced unwrap is the correct way to unwrap an optional value. This proposal does not challenge this. The new operator promotes safety, maintainability, and readability as an alternative, not evolutionary, use. !!’s documentary “guided landing” explains why unwrapping is guaranteed to be non-nil. It takes its cue from existing Swift constructs (like precondition and assert) that incorporate meaningful output strings when the app traps: assert(!array.isEmpty, &quot;Array guaranteed to be non-empty because...&quot;) let lastItem = array.last! Guard statements, assertions, preconditions, and fatal errors allow developers to backtrack and correct assumptions that underlie their design. When an application traps from annotated assertions and preconditions, debug console output explains why straight away. You don’t have to hunt down the code, read the line that failed, then establish the context around the line to understand the reason. Embedded rationales are even more important when you didn’t write this code yourself. Incorporating messages explains the use of forced unwraps in code. This provides better self documentation of facts that are known to be true. These messages support better code reading, maintenance, and future modifications. When an optional can a priori be guaranteed to be non-nil, using guards, assertions, preconditions, etc, are relatively heavy-handed approaches to document these established truths. When you already know that an array is not-empty, you should be able to specify this in a single line using a simple operator: // Existing force-unwrap let lastItem = array.last! // Array guaranteed to be non-empty because... // Proposed unwrap operator with fallback explanation let lastItem = array.last !! &quot;Array guaranteed to be non-empty because...&quot; Consider the following scenario of a custom view controller subclass that only accepts children of a certain kind. It is known a priori that the cast will succeed: let existing = childViewControllers as? Array&lt;TableRowViewController&gt; !! &quot;TableViewController must only have TableRowViewControllers as children&quot; This pattern extends to any type-erased or superclass where a cast will always be valid. Examples of Real-World Use Here are a variety of examples that demonstrate the !! operator in real-world use: // In a right-click gesture recognizer action handler let event = NSApp.currentEvent !! &quot;Trying to get current event for right click, but there&#39;s no event&quot; // In a custom view controller subclass that only // accepts children of a certain kind: let existing = childViewControllers as? Array&lt;TableRowViewController&gt; !! &quot;TableViewController must only have TableRowViewControllers as children&quot; // Providing a value based on an initializer that returns an optional: lazy var sectionURL: URL = { return URL(string: &quot;myapp://section/ (identifier)&quot;) !! &quot;can&#39;t create URL for section (identifier)&quot; }() // Retrieving an image from an embedded framework: private static let addImage: NSImage = { let bundle = Bundle(for: FlagViewController.self) let image = bundle.image(forResource: &quot;add&quot;) !! &quot;Missing &#39;add&#39; image&quot; image.isTemplate = true return image }() // Asserting consistency of an internal model: let flag = command.flag(with: flagID) !! &quot;Unable to retrieve non-custom flag for id (flagID.string)&quot; // drawRect: override draw(_ rect: CGRect) { let context = UIGraphicsGetCurrentContext() !! &quot;`drawRect` context guarantee was breeched&quot; } The !! operator generally falls in two use scenarios: Asserting System Framework Correctness: The NSApp.currentEvent property returns an Optional&lt;NSEvent&gt; as there’s not always a current event going on. It is always safe to assert an actual event in the action handler of a right-click gesture recognizer. If this ever fails, !! provides an immediately and clear description of where the system framework has not worked according to expectations. Asserting Application Logic Correctness: The !! operator ensures that outlets are properly hooked up and that the internal data model is in a consistent state. The related error messages explicitly mention specific outlet and data details. These areas identify when resources haven’t been added to the right target, when a URL has been mis-entered, or when a model update has not propagated completely to its supporting use. Incorporating a diagnostic message, provides immediate feedback as to why the code is failing and where. The Black Swan Deployment In one real-world case, a developer’s deployed code crashed when querying Apple’s smart battery interface on a Hackintosh. Since the laptop in question wasn’t an actual Apple platform, it used a simulated AppleSmartBatteryManager interface. In this case, the simulated manager didn’t publish the full suite of values normally guaranteed by the manager’s API. The developer’s API-driven contract assumptions meant that forced unwraps broke his app: Since IOKit just gives you back dictionaries, a missing key, is well… not there, and nil. you know how well Swift likes nils… Applications normally can’t plan for, anticipate, or provide workarounds for code running on unofficial platforms. There are too many unforeseen factors that cannot be incorporated into realistic code that ships. Adopting a universal “unwrap or die” style with explanations enables you to “guide the landing” on these unforseen “Black Swan” failures: guard let value = dict[guaranteedKey] else { fatalError(&quot;Functionality compromised when unwrapping &quot; + &quot;Apple Smart Battery Dictionary value.&quot;) return } // or more succinctly let value = dict[guaranteedKey] !! &quot;Functionality compromised when unwrapping Apple Smart Battery Dictionary value.&quot; The !! operator reduces the overhead involved in debugging unexpected Black Swan deployments. This practice adds robustness and assumes that in reality bad execution can happen for the oddest of reasons. Providing diagnostic information even when your assumptions are “guaranteed” to be correct is a always positive coding style. Real World Deployment The !! operator is in reasonably wide use in the Swift community, including in the personal toolboxes of this proposal’s authors. For example, Constantino Tsarouhas explains how !! has affected his development, enhancing code reading and introducing mindful unwrapping practices: I’ve been happily using !! in my codebases for over a year. It significantly improved understanding what my code does, even after several months of not reading it. I almost never use ! now. The extra keystrokes also act as a deterrent to use this escape hatch too often. On Forced Unwraps This proposal does not eliminate or prejudge the !operator. Using !! should be a positive house standards choice, especially when the use of explanatory text becomes cumbersome. The following example using an unwrapping operator: // Constructed date values will always produce valid results return Date.sharedCalendar.date(byAdding: rhs, to: lhs)! is far simpler than an equivalent version using guard: guard let date = Date.sharedCalendar.date(byAdding: lhs, to: rhs) else { // This should never happen fatalError(&quot;Constructed date values will always produce valid results&quot;) } return date and slightly more succinct than: return Date.sharedCalendar.date(byAdding: lhs, to: rhs) !! &quot;Constructed date values will always produce valid results&quot; The major difference is that the first example lacks the runtime diagnostic output of the latter. This last example accrues all the benefits of !!. Those benefits are ultimately the choice of the adopter. An often-touted misconception exists that force unwraps are, in and of themselves, bad: that they were only created to accommodate legacy apps, and that you should never use force-unwrapping in your code. This isn’t true. There are many good reasons to use force unwraps, though if you’re often reaching for it, it’s a bad sign. Force-unwrapping can be a better choice than throwing in meaningless default values with nil-coalescing or applying optional chaining when the presence of nil would indicate a serious failure. Introducing the !! operator endorses and encourages the use of “mindful force-unwrapping”. It incorporates the reason why the forced unwrap should be safe (for example, why the array can’t be empty at this point, not just that it is unexpectedly empty). If you’re already going to write a comment, why not make that comment useful for debugging at the same time? Using !! provides syntactic sugar for the following common unwrap pattern: guard let y = x else { fatalError(&quot;reason&quot;) } // becomes let y = x !! &quot;reason&quot; // and avoids let y = x! // reason Although comments document in-code reasoning, these explanations are not emitted when the application traps on the forced unwrap: As the screener of a non-zero number of radars resulting from unwrapped nils, I would certainly appreciate more use of guard let x = x else { fatalError(&quot;explanation&quot;) } and hope that !! would encourage it. – Ben Cohen Sometimes it’s not necessary to explain your use of a forced unwrap. In those cases the normal ! operator will remain, even after the introduction of !!. You can continue using !, as before, just as you can leave off the string from a precondition. Similarly, updating Swift’s recommended fixit from Insert ! to Insert &lt;# &quot;Explanation why lhs cannot be nil.&quot; #&gt; does not prevent the use of ! for the experienced user and requires no more keystrokes or actions on the part of the experienced user. On Adding a New Operator to Swift Although burning a new operator is a serious choice, !! is a good candidate for adoption: It matches and parallels the existing ?? operator. It fosters better understanding of optionals and the legitimate use of force-unwrapping in a way that encourages safe coding and good documentation, both in source and at run-time. !! sends the right semantic message. It communicates that “unwrap or die” is an unsafe operation and that failures should be both extraordinary and explained. The new operator is consciously based on !, the unsafe forced unwrap operator, and not on ??, the safe fallback nil-coalescing operator. Its symbology therefore follows ! and not ?. Detailed Design infix operator !!: NilCoalescingPrecedence extension Optional { /// Performs an unsafe forced-unwrap operation, returning /// the wrapped value of an `Optional` instance or /// executing `fatalError` using the message on the rhs /// of the operator. /// /// The result of a successful operation will be the same type /// as the wrapped value of the left-hand side argument. /// /// The `optional` lhs is checked first, and a `fatalError` /// is called only if the left hand side is nil. /// /// Use this operator when the lhs is guaranteed to be non-nil, /// for example: /// /// /// // This URL is well formed /// let normalURL = URL(string: &quot;http://swift.org&quot;) /// !! &quot;URL is not well formed&quot; /// /// // An emoji character cannot be used to construct a URL /// let badURL = URL(string: &quot;😱&quot;) /// !! &quot;URL is not well formed&quot; /// /// /// - Parameters: /// - optional: An optional value. /// - message: A message to emit via `fatalError` upon /// failing to unwrap the optional. public static func !!( optional: Optional, errorMessage: @autoclosure () -&gt; String ) -&gt; Wrapped { guard let wrapped = optional else { fatalError(errorMessage()) } return wrapped } } Updating Fixits A well-designed error message explains why an error occurred and offer user-supporting directions for remedying the situation. The current error/fixit works like this: ERROR(missing_unwrap_optional,none, &quot;value of optional type %0 not unwrapped; did you mean to use &#39;!&#39; &quot; &quot;or &#39;?&#39;?&quot;, (Type)) diag.fixItInsertAfter(affected-&gt;getEndLoc(), &quot;!&quot;); Adopting !! allows Swift to refresh the error message in question and provide multiple fixits: Found unexpected value of optional type %0; did you mean to unwrap this optional or provide a default fallback value? Use if-let and if-guard statements to unwrap optionals before use in statements and expressions. Insert ‘!!’ to unwrap values that cannot be nil: !! &lt;# &quot;statement why lhs cannot be nil.&quot; #&gt; Insert ‘??’ to provide a default fallback value: ?? &lt;# default value #&gt; Optimized Builds and Runtime Errors With one notable exception, the !! operator should follow the same semantics as Optional.unsafelyUnwrapped, which establishes a precedent for this approach: “The unsafelyUnwrapped property provides the same value as the forced unwrap operator (postfix !). However, in optimized builds (-O), no check is performed to ensure that the current instance actually has a value. Accessing this property in the case of a nil value is a serious programming error and could lead to undefined behavior or a runtime error.” By following Optional.unsafelyUnwrapped, this approach is consistent with Swift’s error handling system: “Logic failures are intended to be handled by fixing the code. It means checks of logic failures can be removed if the code is tested enough. Actually checks of logic failures for various operations, !, array[i], &amp;+ and so on, are designed and implemented to be removed when we use -Ounchecked. It is useful for heavy computation like image processing and machine learning in which overhead of those checks is not permissible.” Like assert, unsafelyUnwrapped does not perform a check in optimized builds. The forced unwrap ! operator does as does precondition. The new “unwrap or die” operator, !!, should behave like precondition and not assert to preserve trapping information in optimized builds. Unfortunately, there is no direct way at this time to emit the #file name and #line number with the above code. We hope the dev team can somehow work around this limitation to produce that information at the !! site. The !!-alternative design that uses a () -&gt; Never closure in the “Alternative Designs” section provides that information today. Future Directions Calling Context Right now, fatalError reports the line and file of the !! operator implementation rather than the code where the operator is used. At some point Swift may allow operator implementations with more than two parameters. At such time, the !! operator should incorporate the source line and file of the forced unwrap call: public static func !!(optional: Optional, errorMessage: @autoclosure () -&gt; String, file: StaticString = #file, line: UInt = #line) -&gt; Wrapped This could be a minimal modification to lib/AST/Decl.cpp:4919, to the FuncDecl::isBinaryOperator() implementation, enabling size() &gt; 2 if get(2+)-&gt;isDefaultArgument(): bool FuncDecl::isBinaryOperator() const { if (!isOperator()) return false; auto *params = getParameterList(getDeclContext()-&gt;isTypeContext()); return params-&gt;size() == 2 &amp;&amp; !params-&gt;get(0)-&gt;isVariadic() &amp;&amp; !params-&gt;get(1)-&gt;isVariadic(); } Having a line and file reference for the associated failure point would be a major advantage in adopting this proposal, even if some under-the-covers “Swift Magic™” must be applied to the !! implementation. Never as a Bottom Type If Never ever becomes a true bottom type as in SE-0102, Swift will be able to use fatalError() on the right hand side of nil-coalescing. If [Never as a bottom type] were supported by the compiler, it would enable some potentially useful things, for instance using a nonreturning function directly as a parameter to a higher-order function that expects a result…or allowing a subclass to override a method and covariantly return Never. – SE-0102 // Legal if a (desirable) `Never` bottom type is adopted let x = y ?? fatalError(&quot;reason&quot;) This proposal supports using a String (or more properly a string autoclosure) on the rhs of a !! operator in preference to a Never bottom type or a () -&gt; Never closure with ?? for the reasons that are enumerated here: A string provides the cleanest user experience, and allows the greatest degree of in-place self-documentation. A string respects DRY, and avoids using both the operator and the call to fatalError or preconditionFailure to signal an unsafe condition: let last = array.last !! &quot;Array guaranteed non-empty because...&quot; // readable versus: let last = array.last !! fatalError(&quot;Array guaranteed non-empty because...&quot;) // redundant A string allows the operator itself to unsafely fail, just as the unary version of ! does now. It does this with additional feedback to the developer during testing, code reading, and code maintenance. The string provides a self-auditing in-line annotation of the reason why the forced unwrap has been well considered, using a language construct to support this. A string disallows a potentially unsafe Never call that does not reflect a serious programming error, for example: let last = array.last !! f() // where func f() -&gt; Never { while true {} } Using foo ?? Never requires a significant foundational understanding of the language, which includes a lot of heavy lifting to understand how and why it works. Using !! is a simpler approach that is more easily taught to new developers: “This variation of forced unwrap emits this message if the lhs is nil.” Although a Never closure solution can be cobbled together in today’s Swift, !! operator solution can be as well. Neither one requires a fundamental change to the language. Pushing forward on this proposal does not in any way reflect on adopting the still-desirable Never bottom type. Alternatives Considered We present two alternative designs that cover a similar space and an extension of !! that adds throwing and Never closures. Error-throwing operaters was previously discussed in an early proposal by Pyry Jahkola and Erica Sadun: Introducing an error-throwing nil-coalescing operator. Reasons why these alternatives may not be ideal are covered in the future directions section, such as why extending the ?? operator to fail or throw creates a foundational re-architecting of its semantics. Introducing fail(_:) Fail allows you to supply a string or error on the right hand side of the coalescing operator. It infers the Wrapped type from context: // This URL is well formed let normalURL = URL(string: &quot;http://swift.org&quot;) ?? fail(&quot;URL is not well formed&quot;) // This URL is not well formed and should raise a fatal error let emojiURL = URL(string: &quot;😱&quot;) ?? fail(&quot;URL is not well formed&quot;) // A custom error let illformedURL = ErrorMessage(&quot;URL is not well formed&quot;) do { This URL is fine let normalURL = try URL(string: &quot;http:swift.org&quot;) ?? fail(illformedURL) This URL is not well formed and will throw let emojiURL = try URL(string: &quot;😱&quot;) ?? fail(illformedURL) } catch { print(error) } Here is the basic implementation. It avoids using Wrapped as its generic variable as fail can be used to replace any contextual type. // Inspired by Maz Jaleel, https://github.com/Mazyod /// Unconditionally prints a given message and stops execution, /// allowing placement at any point where a contextual type /// is required. /// /// - Parameters: /// - message: The string to print. The default is an empty string. /// - file: The file name to print with `message`. The default is the file /// where `fail(_:file:line:)` is called. /// - line: The line number to print along with `message`. The default is the /// line number where `fail(_:file:line:)` is called. public func fail&lt;T&gt;( _ message: String = &quot;&quot;, file: StaticString = #file, line: UInt = #line ) -&gt; T { fatalError(message, file: file, line: line) } /// Unconditionally throw an error, allowing placement at /// any point where a contextual type is required. /// /// - Parameters: /// - error: The error to throw. public func fail&lt;T, E: Error&gt;(_ error: E) throws -&gt; T { throw error } Extending ?? for throwing and Never A second alternate design overloads ??, as was discussed several years ago in this preliminary proposal, adopting Dave DeLong’s suggestion of overriding ??: // where illFormedURL is an error let normalURL = try URL(string: &quot;http://swift.org&quot;) ?? illFormedURL let badURL = try URL(string: &quot;😱&quot;) ?? illFormedURL // Using a `Never` call let normalURL = URL(string: &quot;http://swift.org&quot;) ?? fatalError(&quot;URL is not well formed&quot;) let badURL = URL(string: &quot;😱&quot;) ?? fatalError(&quot;URL is not well formed&quot;) Here is the design: extension Optional { /// Performs an unwrapping operation, returning the wrapped value of an /// `Optional` instance or throwing an error corresponding to /// the rhs of the operation. For example: /// /// /// let normalURL = try URL(string: &quot;http://swift.org&quot;) ?? illFormedURL /// let badURL = try URL(string: &quot;😱&quot;) ?? illFormedURL /// /// - Parameters: /// - optionalValue: An optional value. /// - error: an error to throw should the optional be nil. public static func ??&lt;E: Error&gt; ( optionalValue: Wrapped?, error: E ) throws -&gt; Wrapped { guard let value = optionalValue else { throw error } return value } /// Performs an unwrapping operation, returning the wrapped value of an /// `Optional` instance or executing a closure that is guaranteed /// to never return, such as fatalError(). Use this operator /// when the rhs should never execute, for example: /// /// /// let normalURL = URL(string: &quot;http://swift.org&quot;) /// ?? fatalError(&quot;URL is not well formed&quot;) /// let badURL = URL(string: &quot;😱&quot;) ?? fatalError(&quot;URL is not well formed&quot;) /// /// /// - Parameters: /// - optionalValue: An optional value. /// - never: a `Never` closure to execute should the optional be nil. public static func ?? ( optionalValue: Wrapped?, never: @autoclosure () -&gt; Never ) -&gt; Wrapped { guard let value = optionalValue else { never() } return value } } Extending !! beyond strings Both throwing and Never behaviors can be added to !!. These offer the same community sourced features used in the nil-coalescing design. The Never variation provides line and file information at the point of use. extension Optional { /// Performs an unsafe forced-unwrap operation, returning /// the wrapped value of an `Optional` instance or /// throwing an error corresponding to the rhs of the operator. /// /// The result of a successful operation will be the same type /// as the wrapped value of the left-hand side argument. /// /// The `optional` lhs is checked first, and an error is thrown /// only if the left hand side is nil. /// /// Use this operator when the lhs is guaranteed to be non-nil, /// for example: /// /// /// // `illFormedURL` is an `Error`-conforming instance. /// /// // This URL is well formed /// let normalURL = try URL(string: &quot;http://swift.org&quot;) !! illFormedURL /// /// // An emoji character cannot be used to construct a URL /// let badURL = try URL(string: &quot;😱&quot;) !! illFormedURL /// /// /// - Parameters: /// - optional: An optional value. /// - error: an error to throw should the optional be nil. public static func !!&lt;E: Error&gt;( optional: Optional, error: E ) throws -&gt; Wrapped { guard let wrapped = optional else { throw error } return value } /// Performs an unsafe forced-unwrap operation, returning /// the wrapped value of an `Optional` instance or /// executing a closure that is guaranteed to never return, /// such as fatalError(). /// /// The result of a successful operation will be the same type /// as the wrapped value of the left-hand side argument. /// /// The `optional` lhs is checked first, and an error is thrown /// only if the left hand side is nil. /// /// Use this operator when the rhs should never execute, /// for example: /// /// /// // This URL is well formed /// let normalURL = URL(string: &quot;http://swift.org&quot;) /// !! fatalError(&quot;URL is not well formed&quot;) /// /// // An emoji character cannot be used to construct a URL /// let badURL = URL(string: &quot;😱&quot;) /// !! fatalError(&quot;URL is not well formed&quot;) /// /// /// - Parameters: /// - optional: An optional value. /// - error: an error to throw should the optional be nil. public static func !!&lt;E: Error&gt;( optional: Optional, never: @autoclosure () -&gt; Never ) throws -&gt; Wrapped { guard let wrapped = optionalValue else { never() } return wrapped } Additional Operators Considered The throwing variation of !! could be named ?!, taking an Error on the rhs. This extension introduces a non-fatal operator that creates variation of try specifically for optionals. Adding ?! produces the following operator family: Operator Use ! Force unwrap ? Optional chaining !! Unwrap or die ?? Nil coalescing ?! Unwrap or throw try Throw on error try! Die on error try? Nil on error as! Die on failed cast as? Nil on failed cast Source compatibility This proposal is strictly additive. Effect on ABI stability This proposal does not affect ABI stability. Effect on API resilience This proposal does not affect ABI resilience.",
    "url": "http://localhost:4000/docs/2019-08-26-0217-bangbang.html",
    "relUrl": "/docs/2019-08-26-0217-bangbang.html"
  },
  "217": {
    "id": "217",
    "title": "SE-0218 Introduce `compactMapValues` to Dictionary",
    "content": "Introduce compactMapValues to Dictionary Proposal: SE-0218 Author: Daiki Matsudate Review Manager: Ben Cohen Status: Implemented (Swift 5) Implementation: apple/swift#15017 Decision Notes: Rationale Introduction This proposal adds a combined filter/map operation to Dictionary, as a companion to the mapValues and filter methods introduced by SE-0165. The new compactMapValues operation corresponds to compactMap on Sequence. Swift forums pitch: Add compactMapValues to Dictionary Motivation Swift 4 introduced two new Dictionary operations: the new method mapValues and a new version of filter. They correspond to the Sequence methods map and filter, respectively, but they operate on Dictionary values and return dictionaries rather than arrays. However, SE-0165 left a gap in the API: it did not introduce a Dictionary-specific version of compactMap. We sometimes need to transform and filter values of a Dictionary at the same time, and Dictionary does not currently provide an operation that directly supports this. For example, consider the task of filtering out nil values from a Dictionary of optionals: let d: [String: String?] = [&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: nil, &quot;c&quot;: &quot;3&quot;] let r1 = d.filter { $0.value != nil }.mapValues { $0! } let r2 = d.reduce(into: [String: String]()) { (result, item) in result[item.key] = item.value } // r1 == r2 == [&quot;a&quot;: &quot;1&quot;, &quot;c&quot;: &quot;3&quot;] Or try running a failable conversion on dictionary values: let d: [String: String] = [&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;2&quot;, &quot;c&quot;: &quot;three&quot;] let r1 = d.mapValues(Int.init).filter { $0.value != nil }.mapValues { $0! } let r2 = d.reduce(into: [String: Int]()) { (result, item) in result[item.key] = Int(item.value) } // r == [&quot;a&quot;: 1, &quot;b&quot;: 2] While mapValues and filter can be combined to solve this tasks, the solution needs multiple passes on the input dictionary, which is not particularly efficient. reduce(into:) provides a more efficient solution, but it is rather tricky to get right, and it obscures the intended meaning of the code with implementation details. It seems worth adding an extra extension method to Dictionary for this operation; its obvious name is compactMapValues(_:), combining the precedents set by compactMap and mapValues. let r3 = d.compactMapValues(Int.init) Proposed solution Add the following to Dictionary: let d: [String: String?] = [&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: nil, &quot;c&quot;: &quot;3&quot;] let r4 = d.compactMapValues({$0}) // r4 == [&quot;a&quot;: &quot;1&quot;, &quot;c&quot;: &quot;3&quot;] Or, let d: [String: String] = [&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;2&quot;, &quot;c&quot;: &quot;three&quot;] let r5 = d.compactMapValues(Int.init) // r5 == [&quot;a&quot;: 1, &quot;b&quot;: 2] Detailed design Add the following to Dictionary: extension Dictionary { public func compactMapValues&lt;T&gt;(_ transform: (Value) throws -&gt; T?) rethrows -&gt; [Key: T] { return try self.reduce(into: [Key: T](), { (result, x) in if let value = try transform(x.value) { result[x.key] = value } }) } } Source compatibility This change is purely additive so has no source compatibility consequences. Effect on ABI stability This change is purely additive so has no ABI stability consequences. Effect on API resilience This change is purely additive so has no API resilience consequences. Alternatives considered We can simply omit this method from the standard library – however, we already have mapValues and filter, and it seems reasonable to fill the API hole left between them with a standard extension.",
    "url": "http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html",
    "relUrl": "/docs/2019-08-26-0218-introduce-compact-map-values.html"
  },
  "218": {
    "id": "218",
    "title": "SE-0219 Package Manager Dependency Mirroring",
    "content": "Package Manager Dependency Mirroring Proposal: SE-0219 Authors: Ankit Aggarwal Review Manager: Boris Bügling Status: Implemented (Swift 5) Implementation: apple/swift-package-manager#1776 Bug: SR-8328 Introduction A dependency mirror refers to an alternate source location which exactly replicates the contents of the original source. This is a proposal for adding support for dependency mirroring in SwiftPM. Motivation Dependency mirroring is useful for several reasons: Availability: Mirrors can ensure that a dependency can be always fetched, in case the original source is unavailable or even deleted. Cache: Access to the original source location could be slow or forbidden in the current environment. Validation: Mirrors can help with screening the upstream updates before making them available internally within a company. Proposed solution We propose to introduce a “package configuration” file to store per-dependency mirroring information that SwiftPM can use as additional input. We propose to allow registering a mirror using the following command: $ swift package config set-mirror --package-url &lt;original URL&gt; --mirror-url &lt;mirror URL&gt; # Example: $ swift package config set-mirror --package-url https://github.com/Core/libCore.git --mirror-url https://mygithub.com/myOrg/libCore.git A dependency’s mirror URL will be used instead of its original URL to perform all relevant git operations, such as fetching and updating the dependency. It will be possible to mirror both direct and transitive dependencies of a package. Detailed design Package Configuration File The package configuration file will be expected at this location: &lt;package-root&gt;/.swiftpm/config Similar to the Package.resolved file, the configuration file of a dependency will not affect a top-level package. This file will be managed through SwiftPM commands and users are not expected to edit it by hand. The format of this file is an implementation detail but it will be JSON in practice. The configuration file can be expanded to add other information if it makes sense to add it there. Other tools and IDEs written on top of SwiftPM, can also use the .swiftpm directory to store their auxiliary files. Dependency Mirroring In addition to the set-mirror command described above, SwiftPM will provide a command to unset mirror URLs: $ swift package config unset-mirror (--mirror-url | --package-url | --all) &lt;url&gt; # Examples: $ swift package config unset-mirror --package-url https://github.com/Core/libCore.git $ swift package config unset-mirror --mirror-url https://mygithub.com/myOrg/libCore.git $ swift package config unset-mirror --all A dependency can have only one mirror URL at a time; set-mirror command will replace any previous mirror URL for that dependency. SwiftPM will allow overriding the path of the configuration file using the environment variable SWIFTPM_MIRROR_CONFIG. This allows using mirrors on arbitrary packages that don’t have a config file or require different configurations in different environments. Note that the file at this variable will override only the mirror configuration, if in future we have other configuration stored in the configuration file. The Package.resolved file will contain the mirror URLs that were used during dependency resolution. Security There is no security impact since mirrors only work for the top-level package, and dependencies can’t add mirrors on downstream packages. There is a potential privacy concern in case someone accidentally commits their private mirror configuration file in a public package. Impact on existing packages This is an additive feature and doesn’t impact existing packages. Alternatives considered We considered using a dedicated file for storing mirror information. However, there is no good reason to have a new file specifically for mirrors. A generic file gives us flexibility if we discover the need to store more configuration. We considered adding a global configuration file for storing the mirror information. A global file could be convenient for some users, but it can also cause “gotcha” moments if the file is used when it shouldn’t be used and vice versa. Users who understand this risk can export the SWIFTPM_MIRROR_CONFIG in their shell to achieve a similar effect. We considered storing the mirroring information in the Package.swift manifest file but that doesn’t fit well with several of the use-cases of mirrors. The manifest file is also fundamentally different from the configuration file. The manifest file defines how a package is configured and built, whereas the mirror configuration provides overrides for fetching the package dependencies. For e.g., different users would want to use different mirror files depending on their environment, or a user may want to use a mirror on a package they don’t have permission to edit.",
    "url": "http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html",
    "relUrl": "/docs/2019-08-26-0219-package-manager-dependency-mirroring.html"
  },
  "219": {
    "id": "219",
    "title": "SE-0220 `count(where:)`",
    "content": "count(where:) Proposal: SE-0220 Author: Soroush Khanlou Review Manager: Chris Lattner Status: Accepted Implementation: apple/swift#16099 Introduction While Swift’s Sequence models brings a lot of niceties that we didn’t have access to in Objective-C, like map and filter, there are other useful operations on sequences that the standard library doesn’t support yet. One current missing operation is count(where:), which counts the number of elements in a Sequence that pass some test. Swift-evolution thread: count(where:) on Sequence Motivation Counting the number of objects that pass a test has a wide range of uses in many domains. However, Swift currently doesn’t give its users a simple way to perform this operation. While the behavior can currently be approximated with a filter and a count, this approach creates an intermediate array which it immediately discards. This is a bit wasteful. [1, 2, 3, -1, -2].filter({ $0 &gt; 0 }).count // =&gt; 3 To correctly avoid a potentially expensive intermediate array, you can use the Swift’s lazy subsystem: [1, 2, 3, -1, -2].lazy.filter({ $0 &gt; 0 }).count // =&gt; 3 However, using lazy comes with the downside of being forced to use an @escaping block. Lastly, you could rely on an eminently unreadable reduce: [1, 2, 3, -1, -2].reduce(0) { $1 &gt; 0 ? $0 + 1 : $0 } These three solutions lie on a spectrum between “easy to write, but include performance traps” to “performant, but require Swift arcana to write”. Proposed solution The proposed solution would avoid a performance trap and provide a simple interface for users to both read and write. Autocomplete should present it to them handily as well. [1, 2, 3, -1, -2].count(where: { $0 &gt; 0 }) // =&gt; 3 I use it as an extension in my code regularly, and I think it’d make a nice addition to the standard library. Detailed design A reference implementation for the function is included here: extension Sequence { func count(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Int { var count = 0 for element in self { if try predicate(element) { count += 1 } } return count } } The recommended implementation can be found in a pull request to apple/swift. Source compatibility This change is additive only. Effect on ABI stability This change is additive only. Effect on API resilience This change is additive only. Alternatives considered One alternative worth discussing is the addition of count(of:), which can be implemented on sequences where Element: Equatable. This function returns the count of all objects that are equal to the parameter. I’m open to amending this proposal to include this function, but in practice I’ve never used or needed this function, so I’ve omitted it here.",
    "url": "http://localhost:4000/docs/2019-08-26-0220-count-where.html",
    "relUrl": "/docs/2019-08-26-0220-count-where.html"
  },
  "220": {
    "id": "220",
    "title": "SE-0221 Character Properties",
    "content": "Character Properties Proposal: SE-0221 Authors: Michael Ilseman, Tony Allevato Review Manager: Ben Cohen Status: Implemented (Swift 5) Implementation: apple/swift#20520 Review: Discussion thread, Announcement thread Previous Revision: 1 Introduction @allevato (a co-author here) proposed Add Unicode Properties to Unicode.Scalar, which exposes Unicode properties from the Unicode Character Database. These are Unicode expert/enthusiast oriented properties that give a finer granularity of control and answer highly-technical and specific Unicody enquiries. However, they are not ergonomic and Swift makes no attempt to clarify their interpretation or usage: meaning and proper interpretation is directly tied to the Unicode Standard and the version of Unicode available at run time. There’s some low-hanging ergo-fruit ripe for picking by exposing properties directly on Character. Pitch thread: Character and String properties Motivation String is a collection whose element is Character, which represents an extended grapheme cluster (commonly just called “grapheme”). This makes Character one of the first types encountered both by newcomers to Swift as well as by experienced Swift developers playing around in new domains (e.g. scripting). Yet Character exposes little functionality other than the ability to order it with respect to other characters, and a way to access the raw Unicode scalar values that comprise it. This proposal adds several queries to increase the usefulness of Character and approachability of programming in Swift. It tries to walk the fuzzy line between what Swift can give reasonably good answers to, and what would require the user to adopt more elaborate linguistic analysis frameworks or techniques. Proposed Solution (Note that Unicode does not define properties on graphemes in general. Swift is defining its own semantics in terms of Unicode semantics derived from scalar properties, semantics on strings, or both) Character Properties extension Character { /// Whether this Character is ASCII. @inlinable public var isASCII: Bool { ... } /// Returns the ASCII encoding value of this Character, if ASCII. /// /// Note: &quot; r n&quot; (CR-LF) is normalized to &quot; n&quot; (LF), which will return 0x0A @inlinable public var asciiValue: UInt8? { ... } /// Whether this Character represents whitespace, including newlines. /// /// Examples: /// * &quot; t&quot; (U+0009 CHARACTER TABULATION) /// * &quot; &quot; (U+0020 SPACE) /// * U+2029 PARAGRAPH SEPARATOR /// * U+3000 IDEOGRAPHIC SPACE /// public var isWhitespace: Bool { ... } /// Whether this Character represents a newline. /// /// Examples: /// * &quot; n&quot; (U+000A): LINE FEED (LF) /// * &quot; r&quot; (U+000D): CARRIAGE RETURN (CR) /// * &quot; r n&quot; (U+000A U+000D): CR-LF /// * U+0085: NEXT LINE (NEL) /// * U+2028: LINE SEPARATOR /// * U+2029: PARAGRAPH SEPARATOR /// public var isNewline: Bool { ... } /// Whether this Character represents a number. /// /// Examples: /// * &quot;7&quot; (U+0037 DIGIT SEVEN) /// * &quot;⅚&quot; (U+215A VULGAR FRACTION FIVE SIXTHS) /// * &quot;㊈&quot; (U+3288 CIRCLED IDEOGRAPH NINE) /// * &quot;𝟠&quot; (U+1D7E0 MATHEMATICAL DOUBLE-STRUCK DIGIT EIGHT) /// * &quot;๒&quot; (U+0E52 THAI DIGIT TWO) /// public var isNumber: Bool { ... } /// Whether this Character represents a whole number. See /// `Character.wholeNumberValue` @inlinable public var isWholeNumber: Bool { ... } /// If this Character is a whole number, return the value it represents, else /// nil. /// /// Examples: /// * &quot;1&quot; (U+0031 DIGIT ONE) =&gt; 1 /// * &quot;५&quot; (U+096B DEVANAGARI DIGIT FIVE) =&gt; 5 /// * &quot;๙&quot; (U+0E59 THAI DIGIT NINE) =&gt; 9 /// * &quot;万&quot; (U+4E07 CJK UNIFIED IDEOGRAPH-4E07) =&gt; 10_000 /// public var wholeNumberValue: Int? { ... } /// Whether this Character represents a hexadecimal digit. /// /// Hexadecimal digits include 0-9, Latin letters a-f and A-F, and their /// fullwidth compatibility forms. To get their value, see /// `Character.hexadecimalDigitValue` @inlinable public var isHexadecimalDigit: Bool { ... } /// If this Character is a hexadecimal digit, returns the value it represents, /// else nil. /// /// Hexadecimal digits include 0-9, Latin letters a-f and A-F, and their /// fullwidth compatibility forms. public var hexadecimalDigitValue: Int? { ... } /// Whether this Character is a letter. /// /// Examples: /// * &quot;A&quot; (U+0041 LATIN CAPITAL LETTER A) /// * &quot;é&quot; (U+0065 LATIN SMALL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// * &quot;ϴ&quot; (U+03F4 GREEK CAPITAL THETA SYMBOL) /// * &quot;ڈ&quot; (U+0688 ARABIC LETTER DDAL) /// * &quot;日&quot; (U+65E5 CJK UNIFIED IDEOGRAPH-65E5) /// * &quot;ᚨ&quot; (U+16A8 RUNIC LETTER ANSUZ A) /// public var isLetter: Bool { ... } /// Perform case conversion to uppercase /// /// Examples: /// * &quot;é&quot; (U+0065 LATIN SMALL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// =&gt; &quot;É&quot; (U+0045 LATIN CAPITAL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// * &quot;и&quot; (U+0438 CYRILLIC SMALL LETTER I) /// =&gt; &quot;И&quot; (U+0418 CYRILLIC CAPITAL LETTER I) /// * &quot;π&quot; (U+03C0 GREEK SMALL LETTER PI) /// =&gt; &quot;Π&quot; (U+03A0 GREEK CAPITAL LETTER PI) /// * &quot;ß&quot; (U+00DF LATIN SMALL LETTER SHARP S) /// =&gt; &quot;SS&quot; (U+0053 LATIN CAPITAL LETTER S, U+0053 LATIN CAPITAL LETTER S) /// /// Note: Returns a String as case conversion can result in multiple /// Characters. public func uppercased() -&gt; String { ... } /// Perform case conversion to lowercase /// /// Examples: /// * &quot;É&quot; (U+0045 LATIN CAPITAL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// =&gt; &quot;é&quot; (U+0065 LATIN SMALL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// * &quot;И&quot; (U+0418 CYRILLIC CAPITAL LETTER I) /// =&gt; &quot;и&quot; (U+0438 CYRILLIC SMALL LETTER I) /// * &quot;Π&quot; (U+03A0 GREEK CAPITAL LETTER PI) /// =&gt; &quot;π&quot; (U+03C0 GREEK SMALL LETTER PI) /// /// Note: Returns a String as case conversion can result in multiple /// Characters. public func lowercased() -&gt; String { ... } /// Whether this Character is considered uppercase. /// /// Uppercase Characters vary under case-conversion to lowercase, but not when /// converted to uppercase. /// /// Examples: /// * &quot;É&quot; (U+0045 LATIN CAPITAL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// * &quot;И&quot; (U+0418 CYRILLIC CAPITAL LETTER I) /// * &quot;Π&quot; (U+03A0 GREEK CAPITAL LETTER PI) /// @inlinable public var isUppercase: Bool { ... } /// Whether this Character is considered lowercase. /// /// Lowercase Characters vary under case-conversion to uppercase, but not when /// converted to lowercase. /// /// Examples: /// * &quot;é&quot; (U+0065 LATIN SMALL LETTER E, U+0301 COMBINING ACUTE ACCENT) /// * &quot;и&quot; (U+0438 CYRILLIC SMALL LETTER I) /// * &quot;π&quot; (U+03C0 GREEK SMALL LETTER PI) /// @inlinable public var isLowercase: Bool { ... } /// Whether this Character changes under any form of case conversion. @inlinable public var isCased: Bool { ... } /// Whether this Character represents a symbol /// /// Examples: /// * &quot;®&quot; (U+00AE REGISTERED SIGN) /// * &quot;⌹&quot; (U+2339 APL FUNCTIONAL SYMBOL QUAD DIVIDE) /// * &quot;⡆&quot; (U+2846 BRAILLE PATTERN DOTS-237) /// public var isSymbol: Bool { ... } /// Whether this Character represents a symbol used in mathematical formulas /// /// Examples: /// * &quot;+&quot; (U+002B PLUS SIGN) /// * &quot;∫&quot; (U+222B INTEGRAL) /// * &quot;ϰ&quot; (U+03F0 GREEK KAPPA SYMBOL) /// /// Note: This is not a strict subset of isSymbol. This includes characters /// used both as letters and commonly in mathematical formulas. For example, /// &quot;ϰ&quot; (U+03F0 GREEK KAPPA SYMBOL) is considered a both mathematical symbol /// and a letter. /// public var isMathSymbol: Bool { ... } /// Whether this Character represents a currency symbol /// /// Examples: /// * &quot;$&quot; (U+0024 DOLLAR SIGN) /// * &quot;¥&quot; (U+00A5 YEN SIGN) /// * &quot;€&quot; (U+20AC EURO SIGN) public var isCurrencySymbol: Bool { ... } /// Whether this Character represents punctuation /// /// Examples: /// * &quot;!&quot; (U+0021 EXCLAMATION MARK) // * &quot;؟&quot; (U+061F ARABIC QUESTION MARK) /// * &quot;…&quot; (U+2026 HORIZONTAL ELLIPSIS) /// * &quot;—&quot; (U+2014 EM DASH) /// * &quot;“&quot; (U+201C LEFT DOUBLE QUOTATION MARK) /// public var isPunctuation: Bool { ... } } Detailed Semantics and Rationale Some fuzziness is inherent in modeling human writing systems and the rules of grapheme breaking allow for semantically meaningless, yet technically valid, graphemes. In light of all this, we make a best effort and try to discover some principle to follow. Principles are useful for evaluating tradeoffs, but are not hard rules that always lead to a single clear answer. The closest applicable principle might be something similar to W3C’s Principle of Tolerance, paraphrased as “Be liberal in what you accept, conservative in what you produce”. Character properties can be roughly grouped into those that “produce” specific values or behaviors, and those that “accept” graphemes under a fuzzy classification. Restrictive Properties Properties that provide a clear interpretation or which the stdlib produces a specific value for should be restrictive. One example is wholeNumberValue. wholeNumberValue produces an Int from a Character, which means it needs to be restrictive, permitting only the graphemes with unambiguous whole number values. It only returns a value for single-scalar graphemes whose sole scalar has an integral numeric value. Thus, wholeNumberValue returns nil for “7̅” (7 followed by U+0305 COMBINING OVERLINE) as there is no clear interpretation of the value. Any attempt to produce a specific integer from “7̅” would be suspect. Restrictive properties typically accept/reject based on an analysis of the entire grapheme. Values: isASCII / asciiValue, isWholeNumber / wholeNumberValue, isHexDigit / hexDigitValue Casing: isUppercase / uppercased(), isLowercase / lowercased(), isCased Permissive Properties Where there is no clear interpretation or specific value to produce, we try to be as permissive as reasonable. For example, isLetter just queries the first scalar to see if it is “letter-like”, and thus handles unforeseeable combinations of a base letter-like scalar with subsequent combining, modifying, or extending scalars. isLetter merely answers a general (fuzzy) question, but doesn’t prescribe further interpretation. Permissive APIs should in general be non-inlinable and their documentation may be less precise regarding details and corner cases. This allows for a greater degree of library evolution. Permissive properties typically accept/reject based on an analysis of part of the grapheme. Fuzzy queries: isNumber, isLetter, isSymbol / isMathSymbol / isCurrencySymbol, isPunctuation Newlines and Whitespace Newlines encompass more than hard line-breaks in traditional written language; they are common terminators for programmer strings. Whether a Character such as &quot; n u{301}&quot; (a newline with a combining accent over it) is a newline is debatable. Either interpretation can lead to inconsistencies. If true, then a program might skip the first scalar in a new entry (whatever such a combining scalar at the start could mean). If false, then a String with newline terminators inside of it would return false for myStr.contains { $0.isNewline }, which is counter-intuitive. The same is true of whitespace. We recommend that the precise semantics of isWhitespace and isNewline be unspecified regarding graphemes consisting of leading whitespace/newlines followed by combining scalars. Source Compatibility The properties on Character are strictly additive. Effect on ABI Stability These changes are ABI-additive: they introduce new ABI surface area to keep stable. The proposed solution includes recommended @inlinable annotations on properties which derive their value from other properties (thus benefitting from optimizations), or which are well-defined and stable under future Unicode versions (e.g. ASCII-related properties). Additions and Alternatives Considered Titlecase Titlecase can be useful for some legacy scalars (ligatures) as well as for Strings when combined with word-breaking logic. However, it seems pretty obscure to surface on Character directly. String.Lines, String.Words These have been deferred from this pitch to keep focus and await a more generalized lazy split collection. Rename Permissive isFoo to hasFoo This was mentioned above in discussion of isNewline semantics and could also apply to isWhitespace. However, it would be awkward for isNumber or isLetter. What the behavior should be for exotic whitespace and newlines is heavily debatable. We’re sticking to isNewline/isWhitespace for now, but are open to argument. Design as Character.has(OptionSet&lt;…&gt;, exclusively: …) There could be something valuable to glean from this, but we reject this approach as somewhat un-Swifty with a poor discovery experience, especially for new or casual users. It does, however, make the semantic distinctions above very explicit at the call site. Add Failable FixedWidthInteger/FloatingPoint Initializers Taking Character In addition to (or perhaps instead of) properties like wholeNumberValue, add Character-based FixedWidthInteger.init?(_:Character). Similarly FloatingPoint.init?(_:Character) which includes vulgar fractions and the like (if single-scalar, perhaps). However, these do not have direct counterparts in this pitch as named, at least without an explicit argument label clarifying their semantics. We could consider adding something like FixedWidthInteger.init?(hexDigit: Character) and FixedWithInteger.init?(wholeNumber: Character) which correspond to hexDigitValue and wholeNumberValue, and similarly a counterpart for String. But, we don’t feel this carries its weight as surfaced directly at the top level of e.g. Int. We prefer to keep this avenue open for future directions involving more general number parsing and grapheme evaluation logic. Drop isASCII/HexDigit/WholeNumber: Check for nil Instead This alternative is to drop isASCII, isHexDigit, and isWholeNumber and instead use if let or compare explicitly to nil. We decided to provide these convenience properties both for discoverability as well as use in more complex expressions: c.isHexDigit &amp;&amp; c.isLetter, c.isASCII &amp;&amp; c.isWhitespace, etc. We don’t think they add significant weight or undue API surface area. Add numericValue: Double? in addition to, or instead of, wholeNumberValue: Int?. Alternatively, add a rationalValue: (numerator: Int, denominator: Int)?. Unicode defines numeric values for whole numbers, hex digits, and rational numbers (vulgar fractions). As an implementation artifact (ICU only vends a double), Unicode.Scalar.Properties’s numericValue is a double rather than an enum of a rational or whole number. We could follow suit and add such a value to Character, restricted to single-scalar graphemes. We could also remove wholeNumberValue, letting users test if the double is integral. Alternatively or additionally, we could provide a rationalValue capable of handling non-whole-numbers. As far as adding a rationalValue is concerned, we do not feel that support for vulgar fractions and other obscure Unicode scalars (e.g. baseball score-keeping) warrants an addition to Character directly. wholeNumberValue producing an Int is a more fluid solution than a Double which happens to be integral, so we’re hesitant to replace wholeNumberValue entirely with a numericValue. Since numericValue would only add utility for these obscure characters, we’re not sure if it’s worth adding. Suggestions for alternative names for wholeNumberValuewould be appreciated.",
    "url": "http://localhost:4000/docs/2019-08-26-0221-character-properties.html",
    "relUrl": "/docs/2019-08-26-0221-character-properties.html"
  },
  "221": {
    "id": "221",
    "title": "SE-0222 Lazy CompactMap Sequence",
    "content": "Lazy CompactMap Sequence Proposal: SE-0222 Authors: TellowKrinkle, Johannes Weiß Review Manager: John McCall Status: Rejected Implementation: apple/swift#14841 Decision Notes: Rationale Introduction Chaining multiple .map()s and .filter()s on a lazy collection leads to suboptimal codegen, as well as large, painful type names. To improve this, we propose adding a LazyCompactMap{Sequence, Collection} type along with some overloads on the other lazy collection types’ .map(_:) and .filter(_:) functions which return this type to get better codegen and shorter type names. Swift-evolution thread: Discussion thread topic for the proposal Motivation The current lazy system is very good for easily defining transforms on collections, but certain constructs can lead to less-than-optimal codegen. For example, the code collection.map(map1).filter(filter1).map(map2).filter(filter2) will lead to code like this in the formIndex(after:) method: do { do { collection.formIndex(after: &amp;i) } while !filter1(map1(collection[i])) } while !filter2(map2(map1(collection[i]))) while it could be represented with this more efficient single loop: do { collection.formIndex(after: &amp;i) } while !filter1(map1(collection[i])) &amp;&amp; !filter2(map2(map1(collection[i]))) Currently, you can get a single loop by instead using this compactMap: collection.compactMap { let a = map1($0) guard filter1(a) else { return nil } let b = map2(a) guard filter2(b) else { return nil } return b } but this removes the nice composability of the chained map/filter combination. The standard library recently got an override on LazyMapCollection and LazyFilterCollection which combines multiple filters and maps in a row, however it does not work with alternating maps and filters. Proposed solution Define a LazyCompactMapCollection collection (and sequence) which represents a compactMap. Then, add overrides on LazyMapCollection.filter, LazyFilterCollection.map, Lazy*Collection.compactMap, and LazyCompactMapCollection.{filter, map} to return a LazyCompactMapCollection that combines all the maps and filters. As an added bonus, you’ll never see a giant chain of LazyMapCollection&lt;LazyFilterCollection&lt;...&gt;, ...&gt; again Detailed design A new LazyCompactMapCollection and equivalent Sequence should be defined like so: public struct LazyCompactMapCollection&lt;Base: Collection, Element&gt; { internal var _base: Base internal let _transform: (Base.Element) -&gt; Element? internal init(_base: Base, transform: @escaping (Base.Element) -&gt; Element?) { self._base = _base self._transform = transform } } with a very similar set of overrides to the current LazyFilterCollection Then, the following extensions should be added (with equivalent ones for Lazy Sequences): extension LazyMapCollection { public func compactMap&lt;U&gt;(_ transform: @escaping (Element) -&gt; U?) -&gt; LazyCompactMapCollection&lt;Base, U&gt; { let mytransform = self._transform return LazyCompactMapCollection&lt;Base, U&gt;( _base: self._base, transform: { transform(mytransform($0)) } ) } public func filter(_ isIncluded: @escaping (Element) -&gt; Bool) -&gt; LazyCompactMapCollection&lt;Base, Element&gt; { let mytransform = self._transform return LazyCompactMapCollection&lt;Base, Element&gt;( _base: self._base, transform: { let transformed = mytransform($0) return isIncluded(transformed) ? transformed : nil } ) } } extension LazyFilterCollection { public func compactMap&lt;U&gt;(_ transform: @escaping (Base.Element) -&gt; U?) -&gt; LazyCompactMapCollection&lt;Base, U&gt; { let mypredicate = self._predicate return LazyCompactMapCollection&lt;Base, U&gt;( _base: self._base, transform: { mypredicate($0) ? transform($0) : nil } ) } public func map&lt;U&gt;(_ transform: @escaping (Base.Element) -&gt; U) -&gt; LazyCompactMapCollection&lt;Base, U&gt; { let mypredicate = self._predicate return LazyCompactMapCollection&lt;Base, U&gt;( _base: self._base, transform: { mypredicate($0) ? transform($0) : nil } ) } } extension LazyCompactMapCollection { public func compactMap&lt;U&gt;(_ transform: @escaping (Element) -&gt; U?) -&gt; LazyCompactMapCollection&lt;Base, U&gt; { let mytransform = self._transform return LazyCompactMapCollection&lt;Base, U&gt;( _base: self._base, transform: { guard let halfTransformed = mytransform($0) else { return nil } return transform(halfTransformed) } ) } public func map&lt;U&gt;(_ transform: @escaping (Element) -&gt; U) -&gt; LazyCompactMapCollection&lt;Base, U&gt; { let mytransform = self._transform return LazyCompactMapCollection&lt;Base, U&gt;( _base: self._base, transform: { guard let halfTransformed = mytransform($0) else { return nil } return transform(halfTransformed) } ) } public func filter(_ isIncluded: @escaping (Element) -&gt; Bool) -&gt; LazyCompactMapCollection&lt;Base, Element&gt; { let mytransform = self._transform return LazyCompactMapCollection&lt;Base, Element&gt;( _base: self._base, transform: { guard let halfTransformed = mytransform($0), isIncluded(halfTransformed) else { return nil } return halfTransformed } ) } } Source compatibility In Swift 5, while most code will work with the new extensions, code that relies on the return type of LazyCollection.compactMap(_:) will break. In addition, code like following code will break: let array = [0, 1, 22] let tmp = array.lazy.map(String.init).filter { $0.count == 1 } let filtered: LazyFilterCollection&lt;LazyMapCollection&lt;[Int], String&gt;&gt; = tmp However, this type of code is probably rare and similar code will already be broken by the previously mentioned change that coalesces .filter(_:).filter(_:) and .map(_:).map(_:) Effect on ABI stability N/A Effect on API resilience N/A Alternatives considered The main alternative would be to not do this at all. This alternative isn’t great, as it can be many times slower when the map/filter functions do little work, as shown by this test",
    "url": "http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html",
    "relUrl": "/docs/2019-08-26-0222-lazy-compactmap-sequence.html"
  },
  "222": {
    "id": "222",
    "title": "SE-0223 Accessing an Array's Uninitialized Buffer",
    "content": "Accessing an Array’s Uninitialized Buffer Proposal: SE-0223 Author: Nate Cook Review Manager: Joe Groff Status: Returned for revision Decision Notes: Returned for revision Implementation: apple/swift#17389 Bug: SR-3087 Introduction This proposal suggests a new initializer and method for Array and ContiguousArray that provide access to an array’s uninitialized storage buffer. Swift-evolution thread: https://forums.swift.org/t/array-initializer-with-access-to-uninitialized-buffer/13689 Motivation Some collection operations require working on a fixed-size buffer of uninitialized memory. For example, one O(n) algorithm for performing a stable partition of an array is as follows: Create a new array the same size as the original array. Iterate over the original array, copying matching elements to the beginning of the new array and non-matching elements to the end. When finished iterating, reverse the slice of non-matching elements. Unfortunately, the standard library provides no way to create an array of a particular size without allocating every element, or to copy elements to the end of an array’s buffer without initializing every preceding element. Even if we avoid initialization by manually allocating the memory using an UnsafeMutableBufferPointer, there’s no way to convert that buffer into an array without copying the contents. There simply isn’t a way to implement this particular algorithm with maximum efficiency in Swift. We also see this limitation when working with C APIs that fill a buffer with an unknown number of elements and return the count. The workarounds are the same as above: either initialize an array before passing it or copy the elements from an unsafe mutable buffer into an array after calling. Proposed solution Adding a new Array initializer that lets a program work with an uninitialized buffer, and a method for accessing an existing array’s buffer of both initialized and uninitialized memory, would fill in this missing functionality. The new initializer takes a closure that operates on an UnsafeMutableBufferPointer and an inout count of initialized elements. This closure has access to the uninitialized contents of the newly created array’s storage, and must set the intialized count of the array before exiting. var myArray = Array&lt;Int&gt;(unsafeUninitializedCapacity: 10) { buffer, initializedCount in for x in 1..&lt;5 { buffer[x] = x } buffer[0] = 10 initializedCount = 5 } // myArray == [10, 1, 2, 3, 4] With this new initializer, it’s possible to implement the stable partition as an extension to the Collection protocol, without any unnecessary copies: func stablyPartitioned(by belongsInFirstPartition: (Element) throws -&gt; Bool) rethrows -&gt; [Element] { return try Array&lt;Element&gt;(unsafeUninitializedCapacity: count) { buffer, initializedCount in var low = buffer.baseAddress! var high = low + buffer.count do { for element in self { if try belongsInFirstPartition(element) { low.initialize(to: element) low += 1 } else { high -= 1 high.initialize(to: element) } } let highIndex = high - buffer.baseAddress! buffer[highIndex...].reverse() initializedCount = buffer.count } catch { let lowCount = low - buffer.baseAddress! let highCount = (buffer.baseAddress! + buffer.count) - high buffer.baseAddress!.deinitialize(count: lowCount) high.deinitialize(count: highCount) throw error } } } Detailed design The new initializer and method are added to both Array and ContiguousArray. /// Creates an array with the specified capacity, then calls the given closure /// with a buffer covering the array&#39;s uninitialized memory. /// /// The closure must set its second parameter to a number `c`, the number /// of elements that are initialized. The memory in the range `buffer[0..&lt;c]` /// must be initialized at the end of the closure&#39;s execution, and the memory /// in the range `buffer[c...]` must be uninitialized. /// /// - Note: While the resulting array may have a capacity larger than the /// requested amount, the buffer passed to the closure will cover exactly /// the requested number of elements. /// /// - Parameters: /// - unsafeUninitializedCapacity: The number of elements to allocate space /// for in the new array. /// - initializer: A closure that initializes elements and sets the count of /// the new array. /// - Parameters: /// - buffer: A buffer covering uninitialized memory with room /// for the specified number of of elements. /// - initializedCount: The count of the array&#39;s initialized elements. /// After initializing any elements inside `initializer`, update /// `initializedCount` with the new count for the array. public init( unsafeUninitializedCapacity: Int, initializingWith initializer: ( _ buffer: inout UnsafeMutableBufferPointer&lt;Element&gt;, _ initializedCount: inout Int ) throws -&gt; Void ) rethrows /// Calls the given closure with a buffer of the array&#39;s mutable contiguous /// storage, reserving the specified capacity if necessary. /// /// The closure must set its second parameter to a number `c`, the number /// of elements that are initialized. The memory in the range `buffer[0..&lt;c]` /// must be initialized at the end of the closure&#39;s execution, and the memory /// in the range `buffer[c...]` must be uninitialized. /// /// - Parameters: /// - capacity: The capacity to guarantee for the array. `capacity` must /// be greater than or equal to the array&#39;s current `count`. /// - body: A closure that can modify or deinitialize existing /// elements or initialize new elements. /// - Parameters: /// - buffer: An unsafe mutable buffer of the array&#39;s storage, covering /// memory for the number of elements specifed by the `capacity` /// parameter. The elements in `buffer[0..&lt;initializedCount]` are /// initialized, the memory in `buffer[initializedCount..&lt;capacity]` /// is uninitialized. /// - initializedCount: The count of the array&#39;s initialized elements. /// If you initialize or deinitialize any elements inside `body`, /// update `initializedCount` with the new count for the array. /// - Returns: The return value, if any, of the `body` closure parameter. public mutating func withUnsafeMutableBufferPointerToStorage&lt;Result&gt;( capacity: Int, _ body: ( _ buffer: inout UnsafeMutableBufferPointer&lt;Element&gt;, _ initializedCount: inout Int ) throws -&gt; Result ) rethrows -&gt; Result Specifying a capacity Both the initializer and the mutating method take the specific capacity that a user wants to work with as a parameter. In each case, the buffer passed to the closure has a count that is exactly the same as the specified capacity, even if the ultimate capacity of the new or existing array is larger. This helps avoid bugs where a user assumes that the capacity they observe before calling the mutating method would match the size of the buffer. The method requires that the capacity specified be at least the current count of the array to prevent nonsensical operations, like reducing the size of the array from the middle. That is, this will result in a runtime error: var a = Array(1...10) a.withUnsafeMutableBufferPointerToStorage(capacity: 5) { ... } Guarantees after throwing If the closure parameter to either the initializer or the mutating method throws, the initializedCount value at the time an error is thrown is assumed to be correct. This means that a user who needs to throw from inside the closure has one of two options. Before throwing, they must: deinitialize any newly initialized instances or re-initialize any deinitialized instances, or update initializedCount to the new count. In either case, the postconditions that buffer[0..&lt;initializedCount] are initialized and buffer[initializedCount...] are deinitialized still hold. Naming considerations The names of these new additions are definitely a little on the long side! Here are the considerations used when selecting these names. init(unsafeUninitializedCapacity:initializingWith:) There are two important details of this API that led to the proposed spelling. First, the initializer is unsafe, in that the user must be sure to properly manage the memory addressed by the closure’s buffer pointer parameter. Second, the initializer provides access to the array’s uninitialized storage, unlike the other Array.withUnsafe... methods that already exist. Because trailing closures are commonly used, it’s important to include those terms in the initial argument label, such that they’re always visible at the use site. withUnsafeMutableBufferPointerToStorage(capacity:_:) The mutating method is closely linked to the existing methods for accessing an array’s storage via mutable buffer pointer, but has the important distinction of including access to not just the elements of the array, but also the uninitialized portion of the array’s storage. Extending the name of the closest existing method (withUnsafeMutableBufferPointer) to mark the distinction makes the relationship (hopefully) clear. Suggested alternatives: withUnsafeMutableBufferPointerToReservedCapacity(_:_:) withUnsafeMutableBufferPointer(reservingCapacity:_:) withUnsafeMutableBufferPointerToFullCapacity(capacity:_:) Unused terminology This proposal leaves out wording that would reference two other relevant concepts: reserving capacity: Arrays currently have a reserveCapacity(_:) method, which is somewhat akin to the first step of the initializer. However, that method is used for the sake of optimizing performance when adding to an array, rather than providing direct access to the array’s capacity. In fact, as part of the RangeReplaceableCollection protocol, that method doesn’t even require any action to be taken by the targeted type. For those reasons, the idea of “reserving” capacity doesn’t seem as appropriate as providing a specific capacity that will be used. unmanaged: The proposed initializer is unusual in that it converts the lifetime management of manually initialized instances to be automatically managed, as elements of an Array instance. The only other type that performs this kind of conversion is Unmanaged, which is primarily used at the border of Swift and C interoperability, particularly with Core Foundation. Additionally, Unmanaged can be used to maintain and manage the lifetime of an instance over a long period of time, while this initializer performs the conversion as soon as the closure executes. As above, this term doesn’t seem appropriate for use with this new API. Source compatibility This is an additive change to the standard library, so there is no effect on source compatibility. Effect on ABI stability This addition has no effect on ABI stability. Effect on API resilience The additional APIs will be a permanent part of the standard library, and will need to remain public API. Alternatives considered Returning the new count from the initializer closure An earlier proposal had the initializer’s closure return the new count, instead of using an inout parameter. This proposal uses the parameter instead, so that the method and initializer use the same closure type. In addition, the throwing behavior described above requires that the initialized count be set as an inout parameter instead of as a return value. Not every Element type can be trivially initialized, so a user that deinitializes some elements and then needs to throw an error would be stuck. (This is only an issue with the mutating method.) Removing the throws capability from the closure would solve this problem and simplify the new APIs’ semantics, but would be inconsistent with the other APIs in this space and would make them more difficult to use as building blocks for higher-level operations like stablyPartitioned(by:). Creating an array from a buffer An Array initializer that simply converts an UnsafeMutableBufferPointer into an array’s backing storage seems like it would be another solution. However, an array’s storage includes information about the count and capacity at the beginning of its buffer, so an UnsafeMutableBufferPointer created from scratch isn’t usable. Addendum You can Try This At Home™ with this extension, which provides the semantics (but not the copy-avoiding performance benefits) of the proposed additions: extension Array { public init( unsafeUninitializedCapacity: Int, initializingWith initializer: ( _ buffer: inout UnsafeMutableBufferPointer&lt;Element&gt;, _ initializedCount: inout Int ) throws -&gt; Void ) rethrows { self = [] try self.withUnsafeMutableBufferPointerToStorage(capacity: unsafeUninitializedCapacity, initializer) } public mutating func withUnsafeMutableBufferPointerToStorage&lt;Result&gt;( capacity: Int, _ body: ( _ buffer: inout UnsafeMutableBufferPointer&lt;Element&gt;, _ initializedCount: inout Int ) throws -&gt; Result ) rethrows -&gt; Result { var buffer = UnsafeMutableBufferPointer&lt;Element&gt;.allocate(capacity: capacity) buffer.initialize(from: self) var initializedCount = self.count defer { buffer.baseAddress?.deinitialize(count: initializedCount) buffer.deallocate() } let result = try body(&amp;buffer, &amp;initializedCount) self = Array(buffer[..&lt;initializedCount]) self.reserveCapacity(capacity) return result } }",
    "url": "http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html",
    "relUrl": "/docs/2019-08-26-0223-array-uninitialized-initializer.html"
  },
  "223": {
    "id": "223",
    "title": "SE-0224 Support 'less than' operator in compilation conditions",
    "content": "Support ‘less than’ operator in compilation conditions Proposal: SE-0224 Authors: Daniel Martín Review Manager: Ted Kremenek Status: Implemented (Swift 5) Decision Notes: Rationale Bugs: SR-6852 Implementations: apple/swift#14503 (Stale?), apple/swift#17690 Introduction This proposal augments the functionality implemented for proposal SE-0020 with the introduction of a new valid operator in compilation condition: “&lt;”. The aim is that the syntax #if swift(&lt;4.2) is supported by the language. Swift-evolution thread: Discussion thread topic for that proposal Motivation The main motivation for introducing a new “&lt;” operator in compilation conditions is to be able to write Swift code that is easier to read. For example, if we want to only compile some piece of code if the Swift version is less than 4.2, right now we have to write the following code: #if !swift(&gt;=4.2) // This will only be executed if the Swift version is less than 4.2. #endif #if !compiler(&gt;=4.2) // This will only be executed if the Swift compiler version is less than 4.2. #endif With the introduction of support for the “&lt;” unary operator, the refactored code would be more clear and readable: #if swift(&lt;4.2) // This will only be executed if the Swift version is less than 4.2. #endif #if compiler(&lt;4.2) // This will only be executed if the Swift compiler version is less than 4.2. #endif In the former snippet, the ! can be easily missed in a code review. The latter snippet reads more like plain English. Support for other operators like “&lt;=” and “&gt;” is not desired, as they make a statement about future releases and they don’t account for patch releases. That means that client code will need to be updated if a patch release didn’t fix a particular issue with the compiler, for example. Proposed solution The solution is small change in the parser so that the operator “&lt;” is supported for both the #if swift and #if compiler conditions. Diagnostic messages about invalid unary operators must be updated as well. Detailed design The place in the parser where #if swift(...) is parsed is ParseIfConfig.cpp. There are two classes that will require modification: ValidateIfConfigCondition, to take into account the “&lt;” operator, and EvaluateIfConfigCondition, to actually evaluate the new operator semantics. A new ‘&lt;’ operator for Version will also need to be implemented. The diagnostic message when the operator is not valid also needs to change. I propose changing it from unexpected platform condition argument: expected a unary comparison, such as &#39;&gt;=2.2&#39; to unexpected platform condition argument: expected a unary comparison &#39;&gt;=&#39; or &#39;&lt;&#39;; for example, &#39;&gt;=2.2&#39; or &#39;&lt;2.2&#39; Source compatibility This has no effect in source compatibility. Effect on ABI stability This has no effect in ABI stability. Effect on API resilience This has no effect in API resilience.",
    "url": "http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html",
    "relUrl": "/docs/2019-08-26-0224-ifswift-lessthan-operator.html"
  },
  "224": {
    "id": "224",
    "title": "SE-0225 Adding `isMultiple` to `BinaryInteger`",
    "content": "Adding isMultiple to BinaryInteger Proposal: SE-0225 Authors: Robert MacEachern, Micah Hansonbrook Review Manager: John McCall Status: Implemented (Swift 5) (with modifications, see Implementation Notes) Implementation: apple/swift#18689 Review: Discussion thread, Announcement thread Note: the title of this proposal has been modified to reflect what was accepted. The original title was “Adding isEven, isOdd, and isMultiple to BinaryInteger”. Introduction This proposal adds var isEven: Bool, var isOdd: Bool, and func isMultiple(of other: Self) -&gt; Bool to the BinaryInteger protocol. isEven and isOdd are convenience properties for querying the parity of the integer and isMultiple is a more general function to determine whether an integer is a multiple of another integer. Swift-evolution thread: Even and Odd Integers Motivation It is sometimes necessary to know whether or not an integer is a multiple of another. The most common case is testing if a value is a multiple of 2 (even and oddness). Commonality: Testing if a value is a multiple of another shows up in a surprising number of contexts including UI code, algorithm implementations (often in the form of assertions), tests, benchmarks, documentation and tutorial/educational code. Currently, the most common way to test if a value is a multiple is by using the remainder operator (%) checking for a remainder of zero: 12 % 2 == 0 // returns true. 12 is a multiple of 2. Similarly, testing that a value is not a multiple of another is done by checking for a remainder other than zero: 13 % 2 != 0 // returns true. 13 is not a multiple of 2. Alternatively, it is also possible to use the bitwise AND operator (&amp;) to check the even/oddness of a value: 12 &amp; 1 == 0 // returns true. Some examples of testing multiples in code (see more in appendix): // UITableView alternating row colour cell.contentView.backgroundColor = indexPath.row % 2 == 0 ? .gray : .white // Codable.swift.gyb in apple/swift guard count % 2 == 0 else { throw DecodingError.dataCorrupted(...) } // Bool.swift in apple/swift public static func random&lt;T: RandomNumberGenerator&gt;(using generator: inout T) -&gt; Bool { return (generator.next() &gt;&gt; 17) &amp; 1 == 0 } // KeyPath.swift in apple/swift _sanityCheck(bytes &gt; 0 &amp;&amp; bytes % 4 == 0, &quot;capacity must be multiple of 4 bytes&quot;) // ReversedCollection Index.base documentation https://developer.apple.com/documentation/swift/reversedcollection/index/2965437-base guard let i = reversedNumbers.firstIndex(where: { $0 % 2 == 0 }) Determining whether a value is even or odd is a common question across programming languages, at least based on these Stack Overflow questions: c - How do I check if an integer is even or odd? 300,000+ views java - Check whether number is even or odd 350,000+ views Check if a number is odd or even in python 140,000+ views Convenience properties or functions equivalent to isEven and isOdd are available in the standard libraries of many other programming languages, including: Ruby, Haskell, Clojure, and according to RosettaCode: Julia, Racket, Scheme, Smalltalk, Common Lisp. Readability: This proposal significantly improves readability, as expressions read like straightforward English sentences. There is no need to mentally parse and understand non-obvious operator precedence rules (% has higher precedence than ==). The isEven and isOdd properties are also fewer characters wide than the remainder approach (maximum 7 characters for .isEven vs 9 for ` % 2 == 0`) which saves horizontal space while being clearer in intent. // UITableView alternating row colour cell.contentView.backgroundColor = indexPath.row.isEven ? .gray : .white // Codable.swift.gyb in apple/swift guard count.isEven else { throw DecodingError.dataCorrupted(...) } // Bool.swift in apple/swift public static func random&lt;T: RandomNumberGenerator&gt;(using generator: inout T) -&gt; Bool { return (generator.next() &gt;&gt; 17).isEven } // KeyPath.swift in apple/swift _sanityCheck(bytes &gt; 0 &amp;&amp; bytes.isMultiple(of: 4), &quot;capacity must be multiple of 4 bytes&quot;) Discoverability: IDEs will be able to suggest isEven, isOdd, and isMultiple as part of autocomplete on integer types which will aid discoverability. It will also be familiar to users coming from languages that also support functionality similar to isEven and isOdd. Trivially composable: It would be relatively easy to reproduce the proposed functionality in user code but there would be benefits to having a standard implementation. It may not be obvious to some users exactly which protocol these properties belong on (Int?, SignedInteger?, FixedWidthInteger?, BinaryInteger?). This inconsistency can be seen in a popular Swift utility library which defines isEven and isOdd on SignedInteger which results in the properties being inaccessible for unsigned integers. Testing the parity of integers is also relatively common in sample code and educational usage. In this context, it’s usually not appropriate for an author to introduce this functionality (unless they are teaching extensions!) in order to avoid distracting from the main task at hand (e.g. filter, map, etc). It may also be the same situation for authoring test code: it’d be used if it existed but it’s not worth the overhead of defining it manually. This functionality will also eliminate the need to use the remainder operator or bitwise AND when querying the divisibility of an integer. Correctness: It isn’t uncommon to see tests for oddness written as value % 2 == 1 in Swift, but this is incorrect for negative odd values. The semantics of the % operator vary between programming languages, such as Ruby and Python, which can be surprising. // Swift: 7 % 2 == 1 // true -7 % 2 == 1 // false. -7 % 2 evaluates to -1 // Ruby and Python 7 % 2 == 1 // true -7 % 2 == 1 // true The % operator will also trap when the righthand side is zero. The proposed solution does not. There is also a minor correctness risk in misinterpreting something like value % 2 == 0, particularly when used in a more complex statement, when compared to value.isEven, e.g. bytes &gt; 0 &amp;&amp; bytes % 4 == 0. Performance: It’s possible that isMultiple could be implemented in a more performant way than % divisor == 0 for more complex types, such as a BigInteger/BigNum type. The addition of isEven and isOdd likely won’t have a major positive impact on performance but it should not introduce any additional overhead thanks to @_transparent. Proposed solution Add two computed properties, isEven and isOdd, and a function isMultiple to the BinaryInteger protocol. // Integers.swift.gyb // On protocol BinaryInteger @_transparent public var isEven: Bool { return _lowWord % 2 == 0 } @_transparent public var isOdd: Bool { return !isEven } func isMultiple(of other: Self) -&gt; Bool Detailed design N/A Source compatibility This is strictly additive. Effect on ABI stability N/A Effect on API resilience N/A Alternatives considered isDivisible instead of isMultiple The original discussions during the pitch phase where related to an isDivisible(by:) alternative to isMultiple. Issues related to divisibility and division by zero were discussed and isMultiple was proposed as a solution that 1) avoids trapping on zero, and 2) avoids confusion where a value that is divisible by zero would not be dividable in Swift. e.g. let y = 0 if 10.isDivisible(by: y) { let val = 10 / y // traps } Only isEven/isOdd or only isMultiple. During the pitch phase there were discussions about including only one of isEven/isOdd or isMultiple in the proposal. On the one hand there were concerns that isEven/isOdd would not provide enough utility to justify inclusion into the standard library and that isMultiple was preferable as it was more general. isEven/isOdd are also trivial inverses of each other which Swift, as a rule, doesn’t include in the standard library. On the other hand there was some unscientific analysis that indicated that even/oddness accounted for 60-80% of the operations in which the result of the remainder operator was compared against zero. This lent some support to including isEven/isOdd over isMultiple. There is also more precedence in other languages for including isEven/isOdd over isMultiple. The authors decided that both were worthy of including in the proposal. Odd and even numbers have had special shorthand labels for thousands of years and are used frequently enough to justify the small additional weight isEven/isOdd would add to the standard library. isMultiple will greatly improve clarity and readability for arbitrary divisibility checks and also avoid potentially surprising % operator semantics with negative values. Implementation Notes Only isMultiple(of:) was approved during review, so the final implementation does not include isEven or isOdd. Two default implementations are provided in the standard library; one on BinaryInteger and one on FixedWidthInteger &amp; SignedInteger. For concrete signed and unsigned fixed-size integers, like the standard library types, these two implementations should be nearly optimal. For some user-defined types, especially bignum types, you may want to implement your own conformance for this function. Specifically, if your type does not have bounded min and max values, you should be able to do the divisibility check directly on the values rather than on the magnitudes, which may be more efficient. Appendix Other example uses in code (and beyond) % 2 == 0 appears 63 times in the Apple/Swift repository. Initializing a cryptographic cipher Colouring a checker/chess board and determining piece colour Multiple occurrences in cpp Boost library. Example: handleResizingVertex45 Alternating bar colours in a chart VoronoiFilter implementation and PoissonBlendFilter Image blurring library UPC check digit calculation (spec) (values in odd digit indices are multiplied by 3) Precondition check in sqlite function Alternating UITableView cell background style. NSTableView has built in support for this. Barcode reading CSS row and column styling with nth-child(even) and nth-child(odd) (h/t @brentdax) Various test code Some really real-world examples: Printing even or odd pages only New Hearthstone even/odd cards A variety of even-odd rationing rules: parking rules, water usage restrictions, driving restrictions",
    "url": "http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html",
    "relUrl": "/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html"
  },
  "225": {
    "id": "225",
    "title": "SE-0226 Package Manager Target Based Dependency Resolution",
    "content": "Package Manager Target Based Dependency Resolution Proposal: SE-0226 Authors: Ankit Aggarwal Review Manager: Boris Bügling Status: Accepted Bug: SR-8658 Introduction This is a proposal for enhancing the package resolution process to resolve the minimal set of dependencies that are used in a package graph. Motivation The current package resolution process resolves all declared dependencies in the package graph. Some of the declared dependencies may not be required by the products that are being used in the package graph. For e.g., a package may be using some additional dependencies for its test targets. The packages that depend on this package doesn’t need to resolve such additional dependencies. These dependencies increase the overall constraint in the dependency resolution process that can otherwise be avoided. It can cause more cases of dependency hell if two packages want to use incompatible versions of a dependency that they only use for their unexported products. Cloning unnecessary dependencies also impacts the performance of the resolution process. Another example of packages requiring additional dependencies is for sample code targets. A library package may want to create an executable target which demonstrates some functionality of the library. This executable may require other dependencies such as a command-line argument parser. Proposed solution We propose to enhance the dependency resolution process to resolve only the dependencies that are actually being used in the package graph. The resolution process can examine the target dependencies to figure out which package dependencies require resolution. Since we will only resolve what is required, it may reduce the odds of dependency hell situations. To achieve this, the package manager needs to associate the product dependencies with the packages which provide those products without cloning them. We propose to make the package name parameter in the product dependency declaration non-optional. This is necessary because if the package name is not specified, the package manager is forced to resolve all package dependencies just to figure out the packages for each of the product dependency. SwiftPM will retain support for the byName declaration for products that are named after the package name. This provides a shorthand for the common case of small packages that vend just one product. extension Target.Dependency { static func product(name: String, package: String) -&gt; Target.Dependency } SwiftPM will also need the package names of the declared dependencies without cloning them. The package name is declared inside the package’s manifest, and doesn’t always match the package URL. We propose to enhance the URL-based dependency declaration APIs to allow specifying the package name. In many cases, the package name and the last path component its URL are the same. Package name can be omitted for such dependencies. extension Package.Dependency { static func package( name: String? = nil, // Proposed url: String, from version: Version ) -&gt; Package.Dependency static func package( name: String? = nil, // Proposed url: String, _ requirement: Package.Dependency.Requirement ) -&gt; Package.Dependency static func package( name: String? = nil, // Proposed url: String, _ range: Range&lt;Version&gt; ) -&gt; Package.Dependency static func package( name: String? = nil, // Proposed url: String, _ range: ClosedRange&lt;Version&gt; ) -&gt; Package.Dependency } Detailed design The resolution process will start by examining the products used in the target dependencies and figure out the package dependencies that vend these products. For each dependency, the resolver will only clone what is necessary to build the products that are used in the dependees. The products declared in the target dependencies will need to provide their package name unless the package and product have the same name. SwiftPM will diagnose the invalid product declarations and emit an error. Similarly, SwiftPM will validate the dependency declarations. It will be required that the case used in the URL basename and the package name match in order to allow inferring the package name from the URL. It is recommended to keep consistent casing for the package name and the basename. Otherwise, the package name will be required to specified in the dependency declaration. Note that the basename will be computed by stripping the “.git” suffix from the URL (if present). As an example, consider the following package manifests: // IRC package let package = Package( name: &quot;irc&quot;, products: [ .library(name: &quot;irc&quot;, targets: [&quot;irc&quot;]), .executable(name: &quot;irc-sample&quot;, targets: [&quot;irc-sample&quot;]), ], dependencies: [ .package(name: &quot;NIO&quot;, url: &quot;https://github.com/apple/swift-nio.git&quot;, from: &quot;1.0.0&quot;), .package(url: &quot;https://github.com/swift/ArgParse.git&quot;, from: &quot;1.0.0&quot;), .package(url: &quot;https://github.com/swift/TestUtilities.git&quot;, from: &quot;1.0.0&quot;), ], targets: [ .target( name: &quot;irc&quot;, dependencies: [&quot;NIO&quot;] ), .target( name: &quot;irc-sample&quot;, dependencies: [&quot;irc&quot;, &quot;ArgParse&quot;] ), .testTarget( name: &quot;ircTests&quot;, dependencies: [ &quot;irc&quot;, .product(name: &quot;Nimble&quot;, package: &quot;TestUtilities&quot;), ] ) ] ) // IRC Client package let package = Package( name: &quot;irc-client&quot;, products: [ .executable(name: &quot;irc-client&quot;, targets: [&quot;irc-client&quot;]), ], dependencies: [ .package(url: &quot;https://github.com/swift/irc.git&quot;, from: &quot;1.0.0&quot;), ], targets: [ .target(name: &quot;irc-client&quot;, dependencies: [&quot;irc&quot;]), ] ) When the package “irc-client” is resolved, the package manager will only create checkouts for the packages “irc” and “swift-nio” as “ArgParse” is used by “irc-sample” but that product is not used in the “irc-client” package and “Nimble” is used by the test target of the “irc” package. Impact on existing packages There will be no impact on the existing packages. All changes, both behavioral and API, will be guarded against the tools version this proposal is implemented in. It is possible to form a package graph with mix-and-match of packages with different tools versions. Packages with the older tools version will resolve all package dependencies, while packages using the newer tools version will only resolve the package dependencies that are required to build the used products. As described in the proposal, the package manager will stop resolving the unused dependencies. There will be no Package.resolved entries and checkouts for such dependencies. Declaring target dependency on a product from an already resolved dependency could potentially trigger the dependency resolution process, which in turn could lead to cloning more repositories or even dependency hell. Note that such dependency hell situations will always happen in the current implementation. Alternatives considered We considered introducing a way to mark package dependencies as “development” or “test-only”. Adding these types of dependencies would have introduced new API and new concepts, increasing package manifest complexity. It could also require complicated rules, or new workflow options, dictating when these dependencies would be resolved. Instead, we rejected adding new APIs as the above proposal can handle these cases without any new API, and in a more intuitive manner.",
    "url": "http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html",
    "relUrl": "/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html"
  },
  "226": {
    "id": "226",
    "title": "SE-0227 Identity key path",
    "content": "Identity key path Proposal: SE-0227 Author: Joe Groff Review Manager: Ben Cohen Status: Implemented (Swift 5) Implementation: apple/swift#18804, apple/swift#19382 Review: Discussion thread, Announcement thread Introduction Add the ability to reference the identity key path, which refers to the entire input value it is applied to. Swift-evolution thread: Some small keypath extensions: identity and tuple components Motivation Key paths provide a means to refer to part of a value or a path through an object graph independent of any specific instance. In most places where this is useful, it is also useful to be able to refer to the entire value. For instance, one could have a coordinator object that owns a state value and notifies observers of changes to the state by allowing modification through key paths: class ValueController&lt;T&gt; { private var state: T private var observers: [(T) -&gt; ()] subscript&lt;U&gt;(key: WritableKeyPath&lt;T, U&gt;) { get { return state[keyPath: key] } set { state[keyPath: key] = newValue for observer in observers { observer(state) } } } } With such an interface, it’d be useful to be able to update the entire state object at once. Proposed solution We add a way to refer to the identity key path, which refers to the entire input value a key path applies to. Detailed design Every value in Swift has a special pseudo-property .self, which refers to the entire value: var x = 1 x.self = 2 print(x.self) // prints 2 By analogy, we could spell the identity key path .self, since it notionally refers to this self member: let id = Int.self x[keyPath: id] = 3 print(x[keyPath: id]) // prints 3 struct Employee { var name: String var position: String } func updateValue(of vc: ValueController&lt;Employee&gt;) { vc[ .self] = Employee(name: &quot;Cassius Green&quot;, position: &quot;Power Caller&quot;) } The identity key path is a WritableKeyPath&lt;T, T&gt;, since it can be used to mutate a mutable value, but cannot mutate immutable references. It also makes sense to give the identity key path special behavior with other key path APIs: Appending an identity key path produces a key path equal to the other operand: kp.appending(path: .self) // == kp ( .self).appending(path: kp) // == kp Asking for the offset(of:) the identity key path produces 0, since reading and writing a T at offset zero from an Unsafe(Mutable)Pointer&lt;T&gt; is of course equivalent to reading the entire value: MemoryLayout&lt;Int&gt;.offset(of: .self) // == 0 Also, for compatibility with Cocoa KVC, the identity key path maps to the @&quot;self&quot; KVC key path. Source compatibility This is an additive feature. Effect on ABI stability The Swift standard library required some modifications to correctly handle identity key paths. Alternatives considered The biggest design question here is the syntax. Some other alternatives include: The special syntax ., a key path with “no components”. A static property on KeyPath and/or WritableKeyPath.",
    "url": "http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html",
    "relUrl": "/docs/2019-08-26-0227-identity-keypath.html"
  },
  "227": {
    "id": "227",
    "title": "SE-0228 Fix `ExpressibleByStringInterpolation`",
    "content": "Fix ExpressibleByStringInterpolation Proposal: SE-0228 Authors: Brent Royal-Gordon, Michael Ilseman Review Manager: Doug Gregor Status: Implemented (Swift 5) Review: Discussion thread, Announcement thread Implementation: apple/swift#20214 Introduction String interpolation is a simple and powerful feature for expressing complex, runtime-created strings, but the current version of the ExpressibleByStringInterpolation protocol has been deprecated since Swift 3. We propose a new design that improves its performance, clarity, and efficiency. Swift-evolution thread: [Draft] Fix ExpressibleByStringInterpolation, String interpolation revamp, String interpolation revamp: design decisions Motivation Background An interpolated string literal contains one or more embedded expressions, delimited by ( and ). At runtime, these expressions are evaluated and concatenated with the string literal to produce a value. They are typically more readable than code that switches between string literals, concatenation operators, and arbitrary expressions. Like most literal features in Swift, interpolated string literals are implemented with a protocol, ExpressibleByStringInterpolation. However, this protocol has been known to have issues since Swift 3, so it is currently deprecated. Desired use cases We see three general classes of types that might want to conform to ExpressibleByStringInterpolation: Simple textual data: Types that represent simple, unconstrained text, like Swift.String itself. String types from foreign languages (like JavaScriptCore.JSValue) and alternative representations of strings (like a hypothetical ASCIIString type) might also want to participate in string interpolation. Structured textual data: Types that represent text but have some additional semantics. For example, a Foundation.AttributedString type might allow you to interpolate dictionaries to set or clear attributes. This gist’s LocalizableString type creates a format string, which can be looked up in a Foundation.Bundle’s localization tables. Machine-readable code fragments: Types that represent data in a format that will be understood by a machine, like SQLKit.SQLStatement or this blog post’s SanitizedHTML. These types often require data included in them to be escaped or passed out-of-band; a good ExpressibleByStringInterpolation design might allow this to be done automatically without the programmer having to do anything explicit. They may only support specific types, or may want to escape by default but also have a way to insert unescaped data. The current design handles simple textual data, but struggles to support structured textual data and machine-readable code fragments. Current design The compiler parses a string literal into a series of segments, each of which is either a literal segment containing characters and escapes, or an interpolated segment containing an expression to be interpolated. If there is more than one segment, it wraps each segment in a call to init(stringInterpolationSegment:), then wraps all of the segments together in a call to init(stringInterpolation:): // Semantic expression for: &quot;hello (name)!&quot; String(stringInterpolation: String(stringInterpolationSegment: &quot;hello &quot;), String(stringInterpolationSegment: name), String(stringInterpolationSegment: &quot;!&quot;)) The type checker considers all overloads of init(stringInterpolationSegment:), not just the one that implements the protocol requirement. Swift.String uses this to add fast paths for types conforming to CustomStringConvertible and TextOutputStreamable. Issues with the current design The current design is inefficient and inflexible for conformers. It does not permit special handling such as formatting or interpolation options. Inefficient: Naïve memory management Each init(stringInterpolationSegment:) call creates a temporary instance of Self; these instance are then concatenated together. Depending on the conformer or the segment size, this may trigger a heap allocation and ARC overhead for every single interpolated segment. Furthermore, while the compiler knows the sizes and numbers of literal and interpolated segments, this is not communicated to the conformer. If size information were available to the conformer, they could estimate the final size of the value and preallocate capacity. If segments were not converted to Self before concatenation, their data could be directly written to this preallocated capacity without using temporary instances. Inflexible: No extra parameters, unconstrained segments, lost segment semantics The current approach does not permit conformers to specify additional parameters or options to govern the evaluation of an interpolated expression. Many conformers may want to provide alternative interpolation behaviors, such as disabling escaping in SanitizedHTML. Others may want to accept options, like controlling the format string used in a LocalizableString. String itself would like to support a format argument eventually. init(stringInterpolationSegment:) takes an unconstrained generic value, so its parameter can be of any type. However, some conformers may want to limit the types that can be interpolated. For example, SQLKit.SQLStatement can only bind certain types, like integers and strings, to a SQL statement’s parameters. This unconstrained generic parameter causes a second problem: when a literal is passed to init(stringInterpolationSegment:), it defaults to forming a String, the default literal type. This deviates from the standard library’s common practice of allowing the conformer to supply a literal type for use. Finally, the conformer cannot easily determine whether an incoming segment was from a literal or an expression without resorting to hacks baking in compiler-internal details. Compiler-internal details ##### Baking in assumptions An `init(stringInterpolationSegment:)` implementation cannot determine whether its parameter is a literal segment or an interpolated segment. However, the `init(stringInterpolation:)` call can exploit a compiler quirk to do so: the parser always generates a literal segment first, and always alternates between literal and interpolated segments (generating empty literal segments if necessary), so the position of a segment can tell you whether it is literal or interpolated. Needless to say, this is the sort of obscure implementation detail we don’t want users to depend upon. And preserving enough data for `init(stringInterpolation:)` to treat a segment as either type often requires conformers to add extra properties or otherwise alter the type&#39;s design purely to support string interpolation. ##### Type-checker hacks If semantic analysis simply generated the semantic expression and then type-checked it normally, many string interpolations would be too complex to type-check. Instead, it type-checks each segment separately, then creates the `init(stringInterpolationSegment:)` call for the segment and type-checks just the one call to resolve its overload. String interpolation is the only remaining client of this type-checker entry point; we want to get rid of it. Potential uses An improved string interpolation design could open many doors for future functionality in the standard library, in framework overlays, and in user code. To illustrate, here are some things we could use it for in code shipped with the Swift compiler. We’re not proposing any of this, and any future proposal might look different—we’re just demonstrating what’s possible. Constructing formatted strings There are a number of approaches we could take to formatting values interpolated into strings. Here are a few examples with numbers: // Use printf-style format strings: &quot;The price is $ (cost, format: &quot;%.2f&quot;)&quot; // Use UTS #35 number formats: &quot;The price is (cost, format: &quot;¤###,##0.00&quot;)&quot; // Use Foundation.NumberFormatter, or a new type-safe native formatter: &quot;The price is (cost, format: moneyFormatter)&quot; // Mimic String.init(_:radix:uppercase:) &quot;The checksum is 0x (checksum, radix: 16)&quot; You could imagine analogous formatting tools for other types, like Data, Date, or even just String itself. Logging Some logging facilities restrict the kinds of data that can be logged or require extra metadata on certain values; a more powerful interpolation feature could support that: log(&quot;Processing (public: tagName) tag containing (private: contents)&quot;) Constructing attributed strings NSAttributedString or a value-type wrapper around it could allow users to interpolate dictionaries of attributes to enable and disable them: &quot; ([.link: supportURL])Click here ([.link: nil]) to visit our support site&quot; Localization A LocalizableString type could be expressed by a string literal, which would be used to generate a format string key and a list of arguments; converting a LocalizableString to an ordinary String would look up the key in a Bundle’s localization table, then format the value with the arguments. // Builds a LocalizableString(key: &quot;The document “%@” could not be saved.&quot;, arguments: [name]) let message: LocalizableString = &quot;The document “ (name)” could not be saved.&quot; alert.messageText = String(localized: message) Proposed solution We propose completely reworking the currently-deprecated ExpressibleByStringInterpolation as follows (doc comments omitted for brevity): public protocol ExpressibleByStringInterpolation : ExpressibleByStringLiteral { associatedtype StringInterpolation : StringInterpolationProtocol = String.StringInterpolation where StringInterpolation.StringLiteralType == StringLiteralType init(stringInterpolation: StringInterpolation) } public protocol StringInterpolationProtocol { associatedtype StringLiteralType : _ExpressibleByBuiltinStringLiteral init(literalCapacity: Int, interpolationCount: Int) mutating func appendLiteral(_ literal: StringLiteralType) // Informal requirement: mutating func appendInterpolation(...) } An interpolated string will be converted into code that: Initializes an instance of an associated StringInterpolation type, passing the total literal segment size and interpolation count as parameters. Calls its appendLiteral(_:) method to append literal values, and appendInterpolation to append its interpolated values, one at a time. Interpolations are treated as call parentheses—that is, (x, with: y) becomes a call to appendInterpolation(x, with: y). Passes the instance to init(stringInterpolation:) to produce a final value. Below is code roughly similar to what the compiler would generate: // Semantic expression for: &quot;hello (name)!&quot; String(stringInterpolation: { var temp = String.StringInterpolation(literalCapacity: 7, interpolationCount: 1) temp.appendLiteral(&quot;hello &quot;) temp.appendInterpolation(name) temp.appendLiteral(&quot;!&quot;) return temp }()) We have written a few examples of conforming types. Detailed design This design has been implemented in apple/swift#18590. The StringInterpolation type The associated StringInterpolation type is a sort of buffer or scratchpad where the value of an interpolated string literal is accumulated. By having it be an associated type, rather than Self as it currently is, we realize a few benefits: A new type can serve as a namespace for the various appendLiteral and appendInterpolation methods. This allows conformers to add new interpolation methods without them showing up in code completion, documentation, etc. A separate type can store extra temporary state involved in the formation of the result. For example, Foundation.AttributedString might need to track the current attributes in a property; a type backed by a parsed data structure, like a LambdaCalculusExp or Regexp type, could store an unparsed string or parser state. When a type does not need any extra state, the associated type does not add any overhead. Several different types can share an implementation. For instance, String and Substring both use a common StringInterpolationProtocol-conforming type. The standard library will provide a DefaultStringInterpolation type; StringProtocol, and therefore String and Substring, will use this type for their interpolation. (Substring did not previously permit interpolation.) The standard library will also provide two sets of default implementations: For types using DefaultStringInterpolation, it will provide a default init(stringInterpolation:) that extracts the value after interpolation and forwards it to init(stringLiteral:). Thus, types that currently conform to ExpressibleByStringLiteral and use String as their literal type can add simple interpolation support by merely changing their conformance to ExpressibleByStringInterpolation. For other types, it will provide a default init(stringLiteral:) that constructs a Self.StringInterpolation instance, calls its appendLiteral(_:) method, and forwards it to init(stringInterpolation:). (An unavailable or deprecated init(stringLiteral:) will ensure that this is never used with the init(stringInterpolation:) provided for DefaultStringInterpolation-using types, which would cause infinite recursion.) The appendInterpolation method(s) StringInterpolation types must conform to a StringInterpolationProtocol, which requires the init(literalCapacity:interpolationCount:) and appendLiteral(_:) methods. Non-literal segments are restricted at compile time to the overloads of appendInterpolation supplied by the conformer. This allows conforming types to restrict the values that can be interpolated into them by implementing only methods that accept the types they want to support. appendInterpolation can be overloaded to support several unrelated types. appendInterpolation methods can specify any parameter signature they wish. An appendInterpolation method can accept multiple parameters (with or without default values), can require a label on any parameter (including the first one), and can have variadic parameters. appendInterpolation methods can also throw; if one does, the string literal must be covered by a try, try?, or try! keyword. Future work includes enhancing String to accept formatting control. While this part of the design gives us great flexibility, it does introduce an implicit relationship between the compiler and ad-hoc methods declared by the conformer. It also restricts what values can be interpolated in a context generic over StringInterpolationProtocol, though further constraints can lift this restriction. Even though there is no formal requirement listed in the protocol, we have modified the compiler to emit an error if a StringInterpolationProtocol-conforming type does not have at least one overload of appendInterpolation that is as public as the type, does not return a value (or returns a discardable value), and is not static. Interpolation parsing changes Interpolations will be parsed as argument lists; labels and multiple parameters will be permitted, but trailing closures will not. This change is slightly source-breaking: a 4.2 interpolation like (x, y), which tries to interpolate a tuple, would need to be written ((x, y)). While we could address un-labeled tuples with n-arity overloads of appendInterpolation, labeled tuples would still break. We emulate the current behavior in Swift 4.2 mode, and we can easily correct it during migration to Swift 5. Ancillary changes We will add ExpressibleByStringInterpolation conformance to StringProtocol, and thus to Susbtring, allowing interpolations in string literals used to create Substrings. We will add TextOutputStreamable conformances to Float, Double, and Float80, along with an underscored, defaulted method for writing raw ASCII buffers to TextOutputStreams. These changes together reduce a regression in Float interpolation benchmarks and completely reverse regressions in Double and Float80 interpolation benchmarks. Implementation details The `DefaultStringInterpolation` type The standard library uses `make()` to extract the final value; `CustomStringConvertible` is provided as a public equivalent for types that want to use `DefaultStringInterpolation` but do some processing in their `init(stringInterpolation:)` implementation. swift /// Represents a string literal with interpolations while it is being built up. /// /// Do not create an instance of this type directly. It is used by the compiler /// when you create a string using string interpolation. Instead, use string /// interpolation to create a new string by including values, literals, /// variables, or expressions enclosed in parentheses, prefixed by a /// backslash (` (`...`)`). /// /// let price = 2 /// let number = 3 /// let message = &quot;If one cookie costs (price) dollars, &quot; + /// &quot; (number) cookies cost (price * number) dollars.&quot; /// print(message) /// // Prints &quot;If one cookie costs 2 dollars, 3 cookies cost 6 dollars.&quot; /// /// When implementing an `ExpressibleByStringInterpolation` conformance, /// set the `StringInterpolation` associated type to `DefaultStringInterpolation` /// to get the same interpolation behavior as Swift&#39;s built-in `String` type and /// construct a `String` with the results. If you don&#39;t want the default behavior /// or don&#39;t want to construct a `String`, use a custom type conforming to /// `StringInterpolationProtocol` instead. /// /// Extending default string interpolation behavior /// =============================================== /// /// Code outside the standard library can extend string interpolation on /// `String` and many other common types by extending /// `DefaultStringInterpolation` and adding an `appendInterpolation(...)` /// method. For example: /// /// extension DefaultStringInterpolation { /// fileprivate mutating func appendInterpolation( /// escaped value: String, asASCII forceASCII: Bool = false) { /// for char in value.unicodeScalars { /// appendInterpolation(char.escaped(asASCII: forceASCII) /// } /// } /// } /// /// print(&quot;Escaped string: (escaped: string)&quot;) /// /// See `StringInterpolationProtocol` for details on `appendInterpolation` /// methods. /// /// `DefaultStringInterpolation` extensions should add only `mutating` members /// and should not copy `self` or capture it in an escaping closure. @_fixed_layout public struct DefaultStringInterpolation: StringInterpolationProtocol { /// The string contents accumulated by this instance. @usableFromInline internal var _storage: String = &quot;&quot; /// Creates a string interpolation with storage pre-sized for a literal /// with the indicated attributes. /// /// Do not call this initializer directly. It is used by the compiler when /// interpreting string interpolations. @inlinable public init(literalCapacity: Int, interpolationCount: Int) { let capacityPerInterpolation = 2 let initialCapacity = literalCapacity + interpolationCount * capacityPerInterpolation _storage.reserveCapacity(initialCapacity) } /// Appends a literal segment of a string interpolation. /// /// Do not call this method directly. It is used by the compiler when /// interpreting string interpolations. @inlinable public mutating func appendLiteral(_ literal: String) { _storage += literal } /// Interpolates the given value&#39;s textual representation into the /// string literal being created. /// /// Do not call this method directly. It is used by the compiler when /// interpreting string interpolations. Instead, use string /// interpolation to create a new string by including values, literals, /// variables, or expressions enclosed in parentheses, prefixed by a /// backslash (` (`...`)`). /// /// let price = 2 /// let number = 3 /// let message = &quot;If one cookie costs (price) dollars, &quot; + /// &quot; (number) cookies cost (price * number) dollars.&quot; /// print(message) /// // Prints &quot;If one cookie costs 2 dollars, 3 cookies cost 6 dollars.&quot; @inlinable public mutating func appendInterpolation&lt;T: TextOutputStreamable &amp; CustomStringConvertible&gt;(_ value: T) { value.write(to: &amp;_storage) } /// Interpolates the given value&#39;s textual representation into the /// string literal being created. /// /// Do not call this method directly. It is used by the compiler when /// interpreting string interpolations. Instead, use string /// interpolation to create a new string by including values, literals, /// variables, or expressions enclosed in parentheses, prefixed by a /// backslash (` (`...`)`). /// /// let price = 2 /// let number = 3 /// let message = &quot;If one cookie costs (price) dollars, &quot; + /// &quot; (number) cookies cost (price * number) dollars.&quot; /// print(message) /// // Prints &quot;If one cookie costs 2 dollars, 3 cookies cost 6 dollars.&quot; @inlinable public mutating func appendInterpolation&lt;T: TextOutputStreamable&gt;(_ value: T) { value.write(to: &amp;_storage) } /// Interpolates the given value&#39;s textual representation into the /// string literal being created. /// /// Do not call this method directly. It is used by the compiler when /// interpreting string interpolations. Instead, use string /// interpolation to create a new string by including values, literals, /// variables, or expressions enclosed in parentheses, prefixed by a /// backslash (` (`...`)`). /// /// let price = 2 /// let number = 3 /// let message = &quot;If one cookie costs (price) dollars, &quot; + /// &quot; (number) cookies cost (price * number) dollars.&quot; /// print(message) /// // Prints &quot;If one cookie costs 2 dollars, 3 cookies cost 6 dollars.&quot; @inlinable public mutating func appendInterpolation&lt;T: CustomStringConvertible&gt;(_ value: T) { _storage += value.description } /// Interpolates the given value&#39;s textual representation into the /// string literal being created. /// /// Do not call this method directly. It is used by the compiler when /// interpreting string interpolations. Instead, use string /// interpolation to create a new string by including values, literals, /// variables, or expressions enclosed in parentheses, prefixed by a /// backslash (` (`...`)`). /// /// let price = 2 /// let number = 3 /// let message = &quot;If one cookie costs (price) dollars, &quot; + /// &quot; (number) cookies cost (price * number) dollars.&quot; /// print(message) /// // Prints &quot;If one cookie costs 2 dollars, 3 cookies cost 6 dollars.&quot; @inlinable public mutating func appendInterpolation(_ value: T) { _print_unlocked(value, &amp;_storage) } /// Creates a string from this instance, consuming the instance in the process. @inlinable internal __consuming func make() -&gt; String { return _storage } } extension DefaultStringInterpolation: CustomStringConvertible { @inlinable public var description: String { return _storage } } &lt;/details&gt; Generating the append calls This design puts every `appendLiteral(_:)` and `appendInterpolation` call in its own statement, so there’s no need for special type checker treatment. Each interpolation will naturally be type-checked separately, and the overloads of `appendInterpolation` will be resolved at the same time as the value being interpolated. This helps us with ongoing refactoring of the type checker. Due to issues with capturing of partially initialized variables, we do not enclose these statements in a closure. Instead, we use a new kind of AST node. Performance While some string interpolation benchmarks show regressions of 20–30%, most show improvements, sometimes dramatic ones. | Benchmark | -O speed improvement | -Osize speed improvement | | -- | -- | | | `StringInterpolationManySmallSegments` | 2.15x | 1.80x | | `StringInterpolationSmall` | 2.01x | 2.03x | | `ArrayAppendStrings` | 1.16x | 1.14x | | `FloatingPointPrinting_Double_interpolated` | 1.15x | 1.16x | | `FloatingPointPrinting_Float80_interpolated` | 1.09x | 1.08x | | `StringInterpolation` | 0.82x | 0.79x | | `FloatingPointPrinting_Float_interpolated` | 0.82x | 0.73x | The `StringInterpolation` benchmark&#39;s regression is caused by the specific sizes of literal and interpolated segment sizes; in the new design, these happen to cause the benchmark to grow its buffer an extra time. We don&#39;t think it&#39;s representative of the design&#39;s performance. Initially, all three `FloatingPointPrinting__interpolated` tests regressed with the new design. We conformed these types to `TextOutputStreamable` and added a private ASCII-only fast path in `TextOutputStream`; this increased the performance of `Double` and `Float80` to be small improvements, but did little to help `Float`. Benchmark code size slightly improved on average: | Benchmark file | -O size improvement | -Osize size improvement | | | - | -- | | StringInterpolation.o | 1.18x | 1.16x | | FloatingPointPrinting.o | 1.12x | 1.11x | | All files with notable changes | 1.02x | 1.02x | So did Swift library code size: | Library | Size improvement | | | - | | libswiftSwiftPrivateLibcExtras.dylib | 1.20x | | libswiftFoundation.dylib | 1.15x | | libswiftXCTest.dylib | 1.10x | | libswiftStdlibUnittest.dylib | 1.06x | | libswiftCore.dylib. | 1.04x | | libswiftNetwork.dylib | 1.02x | | libswiftSwiftOnoneSupport.dylib | 1.02x | | libswiftsimd.dylib | 1.01x | | libswiftMetal.dylib | 0.90x | | libswiftSwiftReflectionTest.dylib | 0.92x | We believe the current results already look pretty good, and further performance tuning is possible in the future. Other types can likely improve interpolation performance using `TextOutputStreamable`. Overall, this design has nowhere to go but up. The default `init(stringLiteral:)` (which is only used for types implementing fully custom string interpolation) is currently about 0.5x the speed of a manually-implemented `init(stringLiteral:)`, but prototyping indicates that inlining certain fast paths from `String.reserveCapacity(_:)` and `String.append(_:)` can reduce that penalty to 0.93x, and we may be able to squeeze out gains beyond that. Even if we cannot close this gap completely, performance-sensitive types can always implement `init(stringLiteral:)` manually. &lt;/details&gt; ## Source compatibility Since `ExpressibleByStringInterpolation` has been deprecated since Swift 3, we need not maintain source compatibility with existing conformances, nor do we propose preserving existing conformances to `ExpressibleByStringInterpolation` even in Swift 4 mode. We do not propose preserving existing `init(stringInterpolation:)` or `init(stringInterpolationSegment:)` initializers, since they have always been documented as calls that should not be used directly. However, the source compatibility suite contains code that accidentally uses `init(stringInterpolationSegment:)` by writing `String.init` in a context expecting a `CustomStringConvertible` or `TextOutputStreamable` type. We have devised a set of overloads to `init(describing:)` that will match these accidental, implicit uses of `init(stringInterpolationSegment:)` without preserving explicit uses of `init(stringInterpolationSegment:)`. We propose a set of `String.StringInterpolation.appendInterpolation` overloads that exactly match the current `init(stringInterpolationSegment:)` overloads, so “normal” interpolations will work exactly as before. “Strange” interpolations like ` (x, y)` or ` (foo: x)`, which are currently accepted by the Swift compiler will be errors in Swift 5 mode. In Swift 4.2 mode, we will preserve the existing behavior with a warning; this means that Swift 4.2 code will only be able to use `appendInterpolation` overloads with a single unlabeled parameter, unless all other parameters have default values. Migration involves inserting an extra pair of parens or removing an argument label to preserve behavior. ## Effect on ABI stability `ExpressibleByStringInterpolation` will need to be ABI-stable starting in Swift 5; we should adopt this proposal or some alternative and un-deprecate `ExpressibleByStringInterpolation` before that. ## Effect on API resilience This API is pretty foundational and it would be difficult to change compatibly in the future. ## Alternatives considered ### Variadic-based designs We considered several designs that, like the current design, passed segments to a variadic parameter. For example, we could wrap literal segments in `init(stringLiteral:)` instead of `init(stringInterpolationSegment:)` and otherwise keep the existing design: swift String(stringInterpolation: String(stringLiteral: &quot;hello &quot;), String(stringInterpolationSegment: name), String(stringLiteral: &quot;!&quot;)) Or we could use an enum to differentiate literal segments from interpolated ones: swift String(stringInterpolation: .literal(&quot;hello &quot;), .interpolation(String.StringInterpolationType(name)), .literal(&quot;!&quot;)) However, this requires that conformers expose a homogenous return value, which has expressibility and/or efficiency drawbacks. The proposed approach, which is statement based, keeps this as a detail internal to the conformer. ### Have a formal `appendInterpolation(_:)` requirement We considered having a formal `appendInterpolation(_:)` requirement with an unconstrained generic parameter to mimic current behavior. We could even have a default implementation that vends strings and still honors overloading. However, we would have to give up on conformers being able to restrict the types or interpolation segment forms permitted.",
    "url": "http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html",
    "relUrl": "/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html"
  },
  "228": {
    "id": "228",
    "title": "SE-0229 SIMD Vectors",
    "content": "SIMD Vectors Proposal: SE-0229 Author: Stephen Canon Review Manager: Ben Cohen Status: Implemented (Swift 5) Implementation: apple/swift#20344 Decision Notes: Rationale Previous Revisions: 1, 2 Introduction This proposal would expose a common subset of operations on the SIMD types supported by most processors in the standard library. It is based on Apple’s &lt;simd/simd.h&gt; module, which is used throughout Apple’s platforms as the common currency type for fixed-size vectors and matrices. It is not a complete re-implementation; rather it provides the low-level support needed to import any such library, and tries to make a number of things much nicer in Swift than they are in C or C++. Preliminary Swift-evolution discussion. Motivation Task 1: SIMD programming Essentially every modern CPU has support for SIMD (“Single Instruction, Multiple Data”) instructions in hardware. Without getting into a long discussion of the architectural details, effective use of these instructions allows 2-10x better performance than is otherwise possible for a large class of data-parallel problems, without incurring the synchronization and data-movement hassles of working with the GPU. Historically, there have been a number of obstacles to taking advantage of this hardware. Four programming models have been commonly used, all of which the author has considerable experience with: Assembly: this has the advantage that you get exactly the code you want. It has numerous disadvantages–another language to learn, requiring either macro soup or separate implementations for every target (in effectively a different language for each), there are few good learning resources, and you have to slog through all the tedious things that the compiler normally does for you, like allocating registers and getting the calling conventions right (or wrong, in subtle ways that bite your users many years later). Intrinsics: The model historically pushed by hardware vendors. Each architecture has its own set of C “intrinsic” types like __m128 (x86) or int8x8_t (ARM). These are superficially nicer than assembly, but in practice incur nearly all of the downsides, plus a few additional ones. The biggest problem is that these types are often bolted awkwardly onto the language, and so are incompatible with fundamental language or runtime assumptions about size or alignment. Innumerable bugs have been created by people attempting to use vector intrinsic types together with C++ containers, for example. These types move your implementation into a portable language (C or C++), and then immediately remove that portability by being tied to a specific architecture. “Vector class” libraries: Agner’s is the most well-known. What these generally bring to the table is support for familiar operators rather than arcane intrinsics (e.g. a + b instead of _mm_addps(a, b)). Most are narrowly focused on a single architecture (almost always x86, so they still don’t provide real portability). Apple’s &lt;simd/simd.h&gt; is similar to these, but with full support for every architecture that Apple uses, which in practice makes code written against it fairly portable. Autovectorization: works well for simple problems, but no one has yet demonstrated a satisfactory solution for more general tasks. One of several problems is that the underlying machine model assumed by vector code is fundamentally distinct from the underlying machine model that most scalar code is written against, forcing an autovectorizing compiler to map between the two. Historically this was largely done via an ad-hoc set of transformations, which never really worked all that well. Newer approaches show some promise, but explicit manual vectorization is still frequently needed. A major goal of these new data types in Swift is to provide a better API for vector programming. We want to capture the cross-platform niceties of the &lt;simd/simd.h&gt; module, but also add some new features that were difficult or impossible to do in C; things like enabling generic programming, but also things as simple as a native way to express vector permutations and unaligned loads, or even just conversions between different vector types with the same number of elements (this requires a function call rather than a cast with most vector libraries). Looking ahead, I expect that we will use these primitives to expose things like iterating over vectors extracted from a collection of scalars, to make explicitly vectorized code much more approachable. Task 2: geometry primitives There is a large class of computational tasks (graphics and animation, image processing, AR, VR, computer vision) that want to have 2, 3, and 4 dimensional vector and matrix types. For these applications, these types are just as fundamental as Int and Array are for “normal” programming–they are the foundation upon which everything else is constructed. These tasks require both elementwise operations, as well as some operations on types as abstract vectors–things like the dot and cross products, vector length, and orientation tests. Task 3: GPU data structures Closely related to part 2, short vectors are also essential data types for representing GPU data structures. It’s frequently necessary to handle these on the CPU side do do pre/post processing, or data marshalling, and exposing these types in Swift enables that task. Putting it together Superficially, the only thing that these tasks have in common is that the fundamental types are “homogeneous aggregates”, and that they want to benefit from the SIMD hardware that is available. Two or even three sets of types may seem more appropriate. However, our experience with clients of &lt;simd/simd.h&gt; is that all of our clients use a diverse subset of operations from the module, and that it’s difficult to draw clear boundaries of what belongs where. While it may be reasonable to refine the underlying protocols, the types should probably remain unified. Looking ahead, we would like to enable more sophisticated storage layouts and transforms to and from them, such as SoA - AoS conversion (a fancy way of saying “matrix transpose” or “interleave / deinterleave”; these are all the same thing). Once you start thinking about such transforms, the distinction between these types really goes out the window, because you want to map between things like 16 vectors of 3 floats and 3 vectors of 16 floats. Proposed solution This proposal adds types like SIMD2&lt;Int&gt;, SIMD16&lt;UInt16&gt; etc. to the language, with operations whose semantics map to SIMD types available on most architectures. The full set of types are SIMD2&lt;T&gt;, SIMD3&lt;T&gt;, SIMD4&lt;T&gt;, SIMD8&lt;T&gt;, SIMD16&lt;T&gt;, SIMD32&lt;T&gt;, and SIMD64&lt;T&gt;, where T is any type that conforms to the SIMDScalar protocol (discussed in detail below). All of the standard library integer and floating-point types (except for Float80) conform to SIMDScalar. Detailed design To support SIMD vectors, a type conforms to the SIMDScalar protocol: public protocol SIMDScalar { associatedtype SIMDMaskScalar : SIMDScalar &amp; FixedWidthInteger &amp; SignedInteger associatedtype SIMD2Storage : SIMDStorage where SIMD2Storage.Scalar == Self associatedtype SIMD4Storage : SIMDStorage where SIMD4Storage.Scalar == Self associatedtype SIMD8Storage : SIMDStorage where SIMD8Storage.Scalar == Self associatedtype SIMD16Storage : SIMDStorage where SIMD16Storage.Scalar == Self associatedtype SIMD32Storage : SIMDStorage where SIMD32Storage.Scalar == Self associatedtype SIMD64Storage : SIMDStorage where SIMD64Storage.Scalar == Self } Let’s leave aside SIMDMaskScalar for now, and consider the other six associatedtype requirements. They all have the same form; a type that provides storage for a vector of the designated size with the correct scalar type. The SIMDStorage protocol is extremely simple: public protocol SIMDStorage { /// The type of scalars in the vector space. associatedtype Scalar : Hashable /// The number of elements in the vector. var scalarCount: Int { get } /// A vector with zero or the default value in all lanes. init() /// Element access to the vector. subscript(index: Int) -&gt; Scalar { get set } } This is the bare minimum functionality upon which everything else is built; the expectation is that types conforming to this protocol will wrap LLVM Builtin vector types, but this is not necessary. Users can conform types to this protocol with any backing storage that can provide the necessary operations, which allows them to benefit from the semantics (and many operations will be autovectorized by the compiler in most cases, even without explicit vector types as storage). The SIMD protocol refines SIMDStorage, adding some additional requirements: public protocol SIMD : SIMDStorage, Hashable, CustomStringConvertible { associatedtype MaskStorage : SIMD where MaskStorage.Scalar : FixedWidthInteger &amp; SignedInteger } Let’s discuss Masks. SIMDs are Equatable, so they have the == and != operators, but they also provide the “pointwise comparison” .== and .!= operators, which compare the lanes of two vectors, and produce a Mask, which is a vector of boolean values. Each lane of the mask is either true or false, depending on the result of comparing the values in the corresponding lanes. An example: (swift) let x = SIMD4&lt;Int&gt;(1,2,3,4) // x : SIMD4&lt;Int&gt; = SIMD4&lt;Int&gt;(1, 2, 3, 4) (swift) let y = SIMD4&lt;Int&gt;(3,2,1,0) // y : SIMD4&lt;Int&gt; = SIMD4&lt;Int&gt;(3, 2, 1, 0) (swift) x .== y // r0 : SIMDMask&lt;SIMD4&lt;Int.SIMDMaskScalar&gt;&gt; = SIMDMask&lt;SIMD4&lt;Int&gt;&gt;(false, true, false, false) here, the second lane is true, because 2 == 2, while all other lanes are false because the elements of x and y in those lanes are not equal. Because of some technical details of how these comparisons happen in SIMD hardware on CPUs, it’s often advantageous to store these vectors-of-bools as vectors-of-ints whose width matches that of the vectors being compared. Because of this, there isn’t a single SIMD4&lt;Bool&gt; type, but rather a whole family of SIMDMask&lt;SIMD4&lt;IntN&gt;&gt; types. The MaskStorage associatedtype on SIMDScalar allows us to get to the desired mask type from SIMD4&lt;Scalar&gt;. The concrete SIMD2&lt;T&gt;, SIMD3&lt;T&gt;, etc types conform to SIMD; and almost all of their operations are provided by extensions on the protocol: public extension SIMD { /// The valid indices for subscripting the vector. var indices: Range&lt;Int&gt; { get } /// A vector with value in all lanes. init(repeating value: Scalar) /// Conformance to Equatable static func ==(lhs: Self, rhs: Self) -&gt; Bool /// Conformance to Hashable func hash(into hasher: inout Hasher) /// Conformance to CustomStringConvertible var description: String /// Pointwise equality and inequality static func .==(lhs: Self, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .!=(lhs: Self, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .==(lhs: Scalar, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .!=(lhs: Scalar, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .==(lhs: Self, rhs: Scalar) -&gt; SIMDMask&lt;MaskStorage&gt; static func .!=(lhs: Self, rhs: Scalar) -&gt; SIMDMask&lt;MaskStorage&gt; /// Replaces elements of this vector with `other` in the lanes where /// `mask` is `true`. mutating func replace(with other: Self, where mask: SIMDMask&lt;MaskStorage&gt;) mutating func replace(with other: Scalar, where mask: SIMDMask&lt;MaskStorage&gt;) func replacing(with other: Self, where mask: SIMDMask&lt;MaskStorage&gt;) -&gt; Self func replacing(with other: Scalar, where mask: SIMDMask&lt;MaskStorage&gt;) -&gt; Self /// Initialize from array literal /// /// Precondition: the array must have exactly scalarCount elements. init(arrayLiteral elements: Scalar...) /// Initialize from sequence /// /// Precondition: the sequence must have exactly scalarCount elements. init&lt;S: Sequence&gt;(_ elements: S) where S.Element == Scalar } public extension SIMD where Scalar : Comparable { /// Pointwise ordered comparisons static func .&lt;(lhs: Self, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&lt;=(lhs: Self, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&gt;=(lhs: Self, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&gt;(lhs: Self, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&lt;(lhs: Scalar, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&lt;=(lhs: Scalar, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&gt;=(lhs: Scalar, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&gt;(lhs: Scalar, rhs: Self) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&lt;(lhs: Self, rhs: Scalar) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&lt;=(lhs: Self, rhs: Scalar) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&gt;=(lhs: Self, rhs: Scalar) -&gt; SIMDMask&lt;MaskStorage&gt; static func .&gt;(lhs: Self, rhs: Scalar) -&gt; SIMDMask&lt;MaskStorage&gt; } public extension SIMDMask { /// Boolean operations on Masks; these use the .-prefixed form because /// they do not short-circuit like `&amp;&amp;` and `||`, but the normal /// boolean operators have the wrong precedence for the typical use /// of these operators. static prefix func .!(rhs: SIMDMask) -&gt; SIMDMask static func .&amp;(lhs: SIMDMask, rhs: SIMDMask) -&gt; SIMDMask static func .^(lhs: SIMDMask, rhs: SIMDMask) -&gt; SIMDMask static func .|(lhs: SIMDMask, rhs: SIMDMask) -&gt; SIMDMask static func .&amp;(lhs: Bool, rhs: SIMDMask) -&gt; SIMDMask static func .^(lhs: Bool, rhs: SIMDMask) -&gt; SIMDMask static func .|(lhs: Bool, rhs: SIMDMask) -&gt; SIMDMask static func .&amp;(lhs: SIMDMask, rhs: Bool) -&gt; SIMDMask static func .^(lhs: SIMDMask, rhs: Bool) -&gt; SIMDMask static func .|(lhs: SIMDMask, rhs: Bool) -&gt; SIMDMask static func .&amp;=(lhs: inout SIMDMask, rhs: SIMDMask) static func .^=(lhs: inout SIMDMask, rhs: SIMDMask) static func .|=(lhs: inout SIMDMask, rhs: SIMDMask) static func .&amp;=(lhs: inout SIMDMask, rhs: Bool) static func .^=(lhs: inout SIMDMask, rhs: Bool) static func .|=(lhs: inout SIMDMask, rhs: Bool) static func random&lt;T: RandomNumberGenerator&gt;(using generator: inout T) -&gt; SIMDMask static func random() -&gt; SIMDMask } public extension SIMD where Scalar : FixedWidthInteger { static var zero: Self var leadingZeroBitCount: Self var trailingZeroBitCount: Self var nonzeroBitCount: Self static prefix func ~(rhs: Self) -&gt; Self static func &amp;(lhs: Self, rhs: Self) -&gt; Self static func ^(lhs: Self, rhs: Self) -&gt; Self static func |(lhs: Self, rhs: Self) -&gt; Self static func &amp;&lt;&lt;(lhs: Self, rhs: Self) -&gt; Self static func &amp;&gt;&gt;(lhs: Self, rhs: Self) -&gt; Self static func &amp;+(lhs: Self, rhs: Self) -&gt; Self static func &amp;-(lhs: Self, rhs: Self) -&gt; Self static func &amp;*(lhs: Self, rhs: Self) -&gt; Self static func /(lhs: Self, rhs: Self) -&gt; Self static func %(lhs: Self, rhs: Self) -&gt; Self static func &amp;(lhs: Scalar, rhs: Self) -&gt; Self static func ^(lhs: Scalar, rhs: Self) -&gt; Self static func |(lhs: Scalar, rhs: Self) -&gt; Self static func &amp;&lt;&lt;(lhs: Scalar, rhs: Self) -&gt; Self static func &amp;&gt;&gt;(lhs: Scalar, rhs: Self) -&gt; Self static func &amp;+(lhs: Scalar, rhs: Self) -&gt; Self static func &amp;-(lhs: Scalar, rhs: Self) -&gt; Self static func &amp;*(lhs: Scalar, rhs: Self) -&gt; Self static func /(lhs: Scalar, rhs: Self) -&gt; Self static func %(lhs: Scalar, rhs: Self) -&gt; Self static func &amp;(lhs: Self, rhs: Scalar) -&gt; Self static func ^(lhs: Self, rhs: Scalar) -&gt; Self static func |(lhs: Self, rhs: Scalar) -&gt; Self static func &amp;&lt;&lt;(lhs: Self, rhs: Scalar) -&gt; Self static func &amp;&gt;&gt;(lhs: Self, rhs: Scalar) -&gt; Self static func &amp;+(lhs: Self, rhs: Scalar) -&gt; Self static func &amp;-(lhs: Self, rhs: Scalar) -&gt; Self static func &amp;*(lhs: Self, rhs: Scalar) -&gt; Self static func /(lhs: Self, rhs: Scalar) -&gt; Self static func %(lhs: Self, rhs: Scalar) -&gt; Self static func &amp;=(lhs: inout Self, rhs: Self) static func ^=(lhs: inout Self, rhs: Self) static func |=(lhs: inout Self, rhs: Self) static func &amp;&lt;&lt;=(lhs: inout Self, rhs: Self) static func &amp;&gt;&gt;=(lhs: inout Self, rhs: Self) static func &amp;+=(lhs: inout Self, rhs: Self) static func &amp;-=(lhs: inout Self, rhs: Self) static func &amp;*=(lhs: inout Self, rhs: Self) static func /=(lhs: inout Self, rhs: Self) static func %=(lhs: inout Self, rhs: Self) static func &amp;=(lhs: inout Self, rhs: Scalar) static func ^=(lhs: inout Self, rhs: Scalar) static func |=(lhs: inout Self, rhs: Scalar) static func &amp;&lt;&lt;=(lhs: inout Self, rhs: Scalar) static func &amp;&gt;&gt;=(lhs: inout Self, rhs: Scalar) static func &amp;+=(lhs: inout Self, rhs: Scalar) static func &amp;-=(lhs: inout Self, rhs: Scalar) static func &amp;*=(lhs: inout Self, rhs: Scalar) static func /=(lhs: inout Self, rhs: Scalar) static func %=(lhs: inout Self, rhs: Scalar) static func random&lt;T: RandomNumberGenerator&gt;( in range: Range&lt;Scalar&gt;, using generator: inout T ) -&gt; Self static func random(in range: Range&lt;Scalar&gt;) -&gt; Self static func random&lt;T: RandomNumberGenerator&gt;( in range: ClosedRange&lt;Scalar&gt;, using generator: inout T ) -&gt; Self static func random(in range: ClosedRange&lt;Scalar&gt;) -&gt; Self } public extension SIMD where Scalar : FloatingPoint { static var zero: Self static func +(lhs: Self, rhs: Self) -&gt; Self static func -(lhs: Self, rhs: Self) -&gt; Self static func *(lhs: Self, rhs: Self) -&gt; Self static func /(lhs: Self, rhs: Self) -&gt; Self static func +(lhs: Scalar, rhs: Self) -&gt; Self static func -(lhs: Scalar, rhs: Self) -&gt; Self static func *(lhs: Scalar, rhs: Self) -&gt; Self static func /(lhs: Scalar, rhs: Self) -&gt; Self static func +(lhs: Self, rhs: Scalar) -&gt; Self static func -(lhs: Self, rhs: Scalar) -&gt; Self static func *(lhs: Self, rhs: Scalar) -&gt; Self static func /(lhs: Self, rhs: Scalar) -&gt; Self static func +=(lhs: inout Self, rhs: Self) static func -=(lhs: inout Self, rhs: Self) static func *=(lhs: inout Self, rhs: Self) static func /=(lhs: inout Self, rhs: Self) static func +=(lhs: inout Self, rhs: Scalar) static func -=(lhs: inout Self, rhs: Scalar) static func *=(lhs: inout Self, rhs: Scalar) static func /=(lhs: inout Self, rhs: Scalar) func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self func addingProduct(_ lhs: Scalar, _ rhs: Self) -&gt; Self func addingProduct(_ lhs: Self, _ rhs: Scalar) -&gt; Self mutating func addProduct(_ lhs: Self, _ rhs: Self) mutating func addProduct(_ lhs: Scalar, _ rhs: Self) mutating func addProduct(_ lhs: Self, _ rhs: Scalar) func squareRoot( ) -&gt; Self mutating func formSquareRoot( ) func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self mutating func round(_ rule: FloatingPointRoundingRule) } public extension SIMD where Scalar : BinaryFloatingPoint, Scalar.RawSignificand : FixedWidthInteger { static func random&lt;T: RandomNumberGenerator&gt;( in range: Range&lt;Scalar&gt;, using generator: inout T ) -&gt; Self static func random(in range: Range&lt;Scalar&gt;) -&gt; Self static func random&lt;T: RandomNumberGenerator&gt;( in range: ClosedRange&lt;Scalar&gt;, using generator: inout T ) -&gt; Self static func random(in range: ClosedRange&lt;Scalar&gt;) -&gt; Self } As you can see, this is a fairly huge API. These operations are mostly implemented in terms of each other; the base operations are implemented as for-loops over the elements of the vector. Most of these are already auto- vectorized by the compiler when optimization is enabled, but this will not be the full long- term solution. Instead, they will be annotated with @_semantics to allow them to be lowered to special SIL nodes and from there to the corresponding LLVM IR vector nodes so that we can guarantee vector codegen always occurs. This optimization work does not effect the semantics of the operations at the Swift language level, so it will happen over the next few months as bug fixes. After all that, the actual machinery of the concrete types is pretty boring: public struct SIMD4&lt;Scalar&gt; : SIMD where Scalar : SIMDScalar { public var _storage: Scalar.SIMD4Storage public var scalarCount: Int { return 4 } public init() { _storage = Scalar.SIMD4Storage() } public subscript(index: Int) -&gt; Scalar { get { _precondition(indices.contains(index)) return _storage[index] } set { _precondition(indices.contains(index)) _storage[index] = newValue } } public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar) { self.init() self[0] = v0 self[1] = v1 self[2] = v2 self[3] = v3 } public init(x: Scalar, y: Scalar, z: Scalar, w: Scalar) { self.init(x, y, z, w) } public var x: Scalar { get { return self[0]} set { self[0] = newValue } } public var y: Scalar { get { return self[1]} set { self[1] = newValue } } public var z: Scalar { get { return self[2]} set { self[2] = newValue } } public var w: Scalar { get { return self[3]} set { self[3] = newValue } } public init(lowHalf: SIMD2&lt;Scalar&gt;, highHalf: SIMD2&lt;Scalar&gt;) { self.init() self.lowHalf = lowHalf self.highHalf = highHalf } public var lowHalf: SIMD2&lt;Scalar&gt; { get { var result = SIMD2&lt;Scalar&gt;() for i in result.indices { result[i] = self[i] } return result } set { for i in newValue.indices { self[i] = newValue[i] } } } public var highHalf: SIMD2&lt;Scalar&gt; { get { var result = SIMD2&lt;Scalar&gt;() for i in result.indices { result[i] = self[2+i] } return result } set { for i in newValue.indices { self[2+i] = newValue[i] } } } public var evenHalf: SIMD2&lt;Scalar&gt; { get { var result = SIMD2&lt;Scalar&gt;() for i in result.indices { result[i] = self[2*i] } return result } set { for i in newValue.indices { self[2*i] = newValue[i] } } } public var oddHalf: SIMD2&lt;Scalar&gt; { get { var result = SIMD2&lt;Scalar&gt;() for i in result.indices { result[i] = self[2*i+1] } return result } set { for i in newValue.indices { self[2*i+1] = newValue[i] } } } } Beyond the new Swift API for vector types, there’s an accompanying change to the clang importer that will allow C functions and structures using vector types to be imported. When we find a “clang extended vector type” or “extvector” whose underlying scalar type is imported as a SIMDScalar type in the standard library and whose element count is 2, 3, 4, 8, 16, 32, or 64, we’ll import it as the correponding standard library vector type. Source compatibility No source compatibility changes. Effect on ABI stability No effects on ABI stability at the language level. There are some minor changes around how the &lt;simd/simd.h&gt; types are imported on Apple platforms, but these will have no effect on source compatibility; they only may tweak some low-level ABI details. Effect on API resilience Because these are entirely new types, they come with a large set of API that will become part of the standard library interface. New API can be added in the future, including to protocols, because it is generally possible to provide good default implementations for simd operations. Alternatives considered The main alternative is “don’t do anything, let people write structs, and trust the autovectorizer.” This might even mostly work, but even if it worked flawlessly (which it doesn’t today), you would be left with the problem that these types are common, and everyone would be using their own set of structs, with slightly incompatible size and alignment or operations provided. Even when the layout matches up, you would still need to provide conversion shims between each and every library you work with. There is a lot of merit in providing a single ground-truth for low-level vectors in the stdlib, over which libraries and programs can build additional operations. Notes from pre-review discussion: I have added a static .zero property to integer and floating point vectors based on email conversation with Rick Roe. This is a departure from scalar numeric types, but he convinced me that these are good to have as an explicit alternative to T(). As mentioned above, .-prefixes have been added to some elementwise operations. I see pretty good arguments both in favor of and against this change. I think that it largely comes down to a matter of taste. There are two reasonable alternative positions here. (a) don’t add the prefixes; this makes type checking a little more complex. (b) add .-prefixes to all lanewise operations; this adds a lot of new operators and a fair bit of noise, but there’s reasonable precedent for it as well (julialang). Richard Wei has argued strongly against the spelling of replacing(with: where:), objecting to both the lack of an explicit object of the verb replacing and to the use of where: as a label for an argument that is not a predicate function. I am not ignoring his concerns, but from a pragmatic point of view, I believe that the fact that this operates on elements is implicit, and where: simply reads more clearly (to me and the other people that I surveyed) than any other option we could come up with. Changelog: The first version of this proposal used the &lt;, &lt;=, &gt;=, and &gt; operators. These have been replaced with the .-prefixed operators. The first version of this proposal used .* and .&amp;* for elementwise multiplication; these have been replaced with the “normal” arithmetic operations, matching +, -, /, and %. We have adopted .|, .&amp;, etc on the principle that .-prefixed operators are “pointwise”. An earlier version of this proposal used names of the form Float.Vector4 instead of Vector4&lt;Float&gt;. The core team feels that the latter name is a better direction to take. We have removed several operations whose naming was not totally satisfactory. We expect to add those operations and more in future additive proposals; only the types are necessary for ABI stability. Updates based on discussion on Swift-Evolution and with core team: I have eliminated _-prefixed protocol requirements, to make it somewhat more obvious how user types can be made to conform. This required some renaming to make the function of these associatedtypes more clear. I have also systematically removed Vector from the naming scheme, in order to remove confusion with C++-style vectors or “mathematical” vector structures that might be added at some future point. The resulting names are generally shorter, which is an nice benefit, and they now have a uniform SIMD prefix. Protocols renamed: Old name New name SIMDVector SIMD SIMDVectorizable SIMDScalar SIMDVectorStorage SIMDStorage SIMDMaskVector N/A* Associated types renamed: Old name New name Element Scalar _MaskElement SIMDMaskScalar _Vector${n} SIMD${n}Storage Mask N/A* N/A* MaskStorage Concrete types renamed: Old name New name Vector2&lt;Scalar&gt; SIMD2&lt;Scalar&gt; Vector3&lt;Scalar&gt; SIMD3&lt;Scalar&gt; Vector4&lt;Scalar&gt; SIMD4&lt;Scalar&gt; Vector8&lt;Scalar&gt; SIMD8&lt;Scalar&gt; Vector16&lt;Scalar&gt; SIMD16&lt;Scalar&gt; Vector32&lt;Scalar&gt; SIMD32&lt;Scalar&gt; Vector64&lt;Scalar&gt; SIMD64&lt;Scalar&gt; N/A* SIMDMask&lt;Storage&gt; (*) The way in which masks are implemented has also been simplified somewhat, which allowed me to eliminate the SIMDMaskVector protocol entirely.",
    "url": "http://localhost:4000/docs/2019-08-26-0229-simd.html",
    "relUrl": "/docs/2019-08-26-0229-simd.html"
  },
  "229": {
    "id": "229",
    "title": "SE-0230 Flatten nested optionals resulting from 'try?'",
    "content": "Flatten nested optionals resulting from ‘try?’ Proposal: SE-0230 Author: BJ Homer Review Manager: John McCall Status: Implemented (Swift 5) Implementation: apple/swift#16942 Review: (forum thread) (acceptance) Introduction Swift’s try? statement currently makes it easy to introduce a nested optional. Nested optionals are difficult for users to reason about, and Swift tries to avoid producing them in other common cases. This document proposes giving try? the same optional-flattening behavior found in other common Swift features, to avoid the common occurrence of a nested optional. Swift-evolution thread: Make try? + optional chain flattening work together Motivation It’s currently quite easy to end up with a nested Optional type when using try?. Although it is valid to construct a nested optional, it is usually not what the developer intended. Swift has various mechanisms to avoid accidentally creating nested optionals. For example: // Note how &#39;as?&#39; produces the same type regardless of whether the value // being cast is optional or not. let x = nonOptionalValue() as? MyType // x is of type &#39;MyType?&#39; let y = optionalValue() as? MyType // y is of type &#39;MyType?&#39; // Note how optional chaining produces the same type whether or not the // call produces an optional value. let a = optThing?.pizza() // a is of type &#39;Pizza?&#39; let b = optThing?.optionalPizza() // b is of type &#39;Pizza?&#39; However, try? behaves differently: let q = try? harbor.boat() // q is of type &#39;Boat?&#39; let r = try? harbor.optionalBoat() // r is of type &#39;Boat??&#39; The above examples are contrived, but it’s actually quite common to end up with a nested optional in production code. For example: // The result of &#39;foo?.makeBar()&#39; is &#39;Bar?&#39; because of the optional // chaining on &#39;foo&#39;. The &#39;try?&#39; adds an additional layer of // optionality. So the type of &#39;x&#39; is &#39;Bar??&#39; let x = try? foo?.makeBar() // JSONSerialization.jsonObject(with:) returns an &#39;Any&#39;. We use &#39;as?&#39; to // verify that the result is of the expected type, but the result is that &#39;dict&#39; // is now of type &#39;[String: Any]??&#39; because &#39;try?&#39; added an additional layer. let dict = try? JSONSerialization.jsonObject(with: data) as? [String: Any] Although it is fairly easy to produce a nested optional using try?, a survey of existing code suggests that it is almost never the desired outcome. Code that uses try? with nested optionals is almost always accompanied by one of the following patterns: // Pattern 1: Double if-let or guard-let if let optionalX = try? self.optionalThing(), let x = optionalX { // Use &#39;x&#39; here } // Pattern 2: Introducing parentheses to let &#39;as?&#39; flatten for us if let x = (try? somethingAsAny()) as? JournalEntry { // use &#39;x&#39; here } // Pattern 3: Pattern matching if case let x?? = try? optionalThing() { // use &#39;x&#39; here } The need for these workarounds makes the language more difficult to learn and use, and they don’t really give us any benefit in return. Code using try? generally does not care to distinguish between the error case and the nil-result case, which is why all these patterns focus on extracting the value and ignore the error. If the developer does care to specifically detect errors, they should probably be using do/try/catch instead. Proposed solution In Swift 5, try? someExpr() will mirror the behavior of foo?.someExpr(): If someExpr() produces a non-optional value, it will be wrapped in an Optional. If someExpr() produces an Optional, then no additional optional-ness is added. This results in the following changes to the type of a try? expression: // Swift 4: &#39;Int??&#39; // Swift 5: &#39;Int?&#39; let result = try? database?.countOfRows(matching: predicate) // Swift 4: &#39;String??&#39; // Swift 5: &#39;String?&#39; let myString = try? String(data: someData, encoding: .utf8) // Swift 4: &#39;[String: Any]??&#39; // Swift 5: &#39;[String: Any]?&#39; let dict = try? JSONSerialization.jsonObject(with: data) as? [String: Any] There are no changes to the overall type when the sub-expression produces a non-optional. // Swift 4: &#39;String?&#39; // Swift 5: &#39;String?&#39; let fileContents = try? String(contentsOf: someURL) If the sub-expression already produces a nested optional, the result is equally nested: func doubleOptionalInt() throws -&gt; Int?? { return 3 } // Swift 4: &#39;Int???&#39; // Swift 5: &#39;Int??&#39; let x = try? doubleOptionalInt() A side note about try? and as? Although as? often has the effect of flattening Optionals (as shown in the example in the Motivation section) it does not exhibit exactly the same behavior as proposed here for try?. Because as? takes an explicit type, it can actually flatten multiple levels of nested Optionals. foo as? T will always produce an Optional&lt;T&gt;, regardless of how many optionals were on foo. This can potentially add or subtract levels of optionals, depending on the type specified. (It can also cast between subtypes and supertypes, which is unrelated to the behavior under consideration.) In practice, the most common use of as? with nested optionals is to reduce from T?? to T?, which makes it superficially similar to the use optional-chaining use case and the proposed behavior of try?. But as? is a more powerful and versatile construct than what is proposed for try? here. Detailed design The type of a try? expression in Swift 4 is defined as Optional&lt;T&gt;, where T is the type of the expression following the try? keyword. In Swift 5, the type of a try? expression will be some type U, where U is an Optional&lt;_&gt; type and where the sub-expression type T is coercible to U. The type constraint system automatically chooses the smallest level of optional-nesting needed to satisfy this constraint, which results in the behavior described in this proposal. Generics Some questions have been raised regarding the interoperability with generic code, as in the following example: func test&lt;T&gt;(fn: () throws -&gt; T) -&gt; T? { // Will this line change behavior if T is an Optional? if let result = try? fn() { print(&quot;We got a result!&quot;) return result } else { print(&quot;There was an error&quot;) return nil } } // T is inferred as &#39;Int&#39; here let value = test({ return 15 }) // T is inferred as &#39;Int?&#39; here let value2 = test({ return 15 as Int? }) The answer is that it does not matter if T is optional at runtime. At compile time, result has a clearly-defined type: T. This is true in both Swift 4 and Swift 5 modes; because T is not known to be an Optional type at compile-time, a single layer of Optional is added via the try? expression and then unwrapped via if let. Generic code that uses try? can continue to use it as always without concern for whether the generic type might be optional at runtime. No behavior is changed in this case. Source compatibility This is a source-breaking change for try? expressions that operate on an Optional sub-expression if they do not explicitly flatten the optional themselves. It appears that those cases are rare, though; see the analysis below for details. We can provide backward-compatible behavior when the compiler is running in Swift 4 mode, and a migration should be possible for most common cases. The bar for including source-breaking changes in Swift 5 is high, but I believe it passes the bar. These are the criteria listed in the swift-evolution README: 1. The current syntax/API must be shown to actively cause problems for users. Nested optionals are a complex concept. They have value in the language, but their use should be intentional. Currently, it’s far too easy for beginners to create a nested optional without understanding why, due to the current interaction of try? and optional chaining or as? casting. Code that uses try? to actually detect errors is more difficult to understand than just using try. Compare: // Using &#39;try?&#39; if let result = try? foo?.bar() { // Do something with &#39;result&#39;, which may be nil // even though we are in an &#39;if let&#39;. } else { // There was an error, but we don&#39;t know what it is } // Using &#39;try/catch&#39; do { let result = try foo?.bar() // Do something with &#39;result&#39;, which may be nil due to optional chaining } catch { // Handle the error } The variant using try? is significantly less clear (what is the type of result?), and has no obvious advantages. Using try? is better if you don’t care about the else clause and only want to handle a value if one exists, but that use case is better served by the proposed change. The current syntax is also harmful because of its interaction with as? casting, as seen here: if let x = try? foo() as? String { // We specifically called out `String` as the desired type here, // so it unexpected that `x` is of type `Optional&lt;String&gt;` } 2. The new syntax/API must be clearly better and must not conflict with existing Swift syntax. The proposed change resolves all of the above problems, which is better. This change also clarifies the role of try? as a means for accessing values when possible, rather than as an alternative error-handling mechanism to try/catch. 3. There must be a reasonably automated migration path for existing code. As shown in the analysis below, most source code will require no migration; developers who have encountered code that produces nested Optionals are likely already using patterns that are source-compatible with this change. This proposal simply provides a way to simplify that code. Automated migration is implemented for the double if/guard let and case let value??: patterns mentioned above. Swift Source Compatibility Suite analysis The Swift Source Compatibility Suite suggests that this is unlikely to be a breaking change for most users. I manually inspected the use cases of try? in the compatibility suite. Here are the results: There are 613 total instances of try? in the compatibility suite. The vast majority of those appear to use non-optional sub-expressions, and would be unaffected by this proposal. There are 4 instances of try? ... as?. All four of them wrap the try? in parentheses to get the flattening behavior of as?, and are source-compatible with this change. They all look something like this: (try? JSONSerialization.jsonObject(with: $0)) as? NSDictionary There are 12 cases of try? foo?.bar() across 3 projects. 10 of those assign it to _ = try? foo?.bar() , so the resulting type does not matter. 2 of those cases have a Void sub-expression type, and do not assign the result to any variable. There are 6 instances of try? somethingReturningOptional() . They all flatten it manually using flatMap { $0 }, and are thus source-compatible with this change, as the return type of that expression is the same under either behavior. (try? get(key)).flatMap { $0 } As far as I can tell, there are zero cases in the entire suite where a double-optional is actually used to distinguish between the error case and the nil-as-a-value case. As far as I can tell, there are zero cases of source incompatibility found in the compatibility suite. Effect on ABI stability No impact on ABI. Effect on API resilience A try? expression is never exposed at function boundaries, so API resilience should be unaffected. Alternatives considered Alter the binding precedence of try? For expressions like let x = try? getObject() as? Foo, the nested optional can be eliminated by parsing the expression as (try? getObject) as? Foo. Adding explicit parentheses like this is already a common workaround for the double-optional problem. However, this change would not resolve cases of try? with optional chaining (e.g. try? foo?.bar?.baz()), nor cases where an optional result is returned directly from a funtion (e.g. try? cachedValue(for: key)). Altering the binding precedence of try? would also be far more source-breaking than this proposal. Do nothing It is possible to write correct code under the current model. We are not proposing to eliminate nested Optionals from the language entirely, so we could just expect users to figure them out. This is a workable solution, but it is odd to have such a complex structure produced as part of a syntactic sugar designed to simplify a common case.",
    "url": "http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html",
    "relUrl": "/docs/2019-08-26-0230-flatten-optional-try.html"
  },
  "230": {
    "id": "230",
    "title": "SE-0231 Optional Iteration",
    "content": "Optional Iteration Proposal: SE-0231 Author: Anthony Latsis Review Manager: Joe Groff Status: Rejected Implementation: apple/swift#19207 Decision Notes: Rationale Introduction Optionals are a key feature of Swift and a powerful tool that seamlessly interacts with code. In particular, they serve a great means in expressing “act accordingly if there’s a value, skip otherwise”. Some vivid examples of such behavior are optional chaining, optional invocation foo?(), if let, optional patterns, optional assignments and guard let. This proposal considers further supporting this convenience in for-in loops. Swift-evolution thread: Discussion thread topic for that proposal Motivation Most Swift statements provide convenience patterns and handling for optionals. We have optional binding patterns for while, if and guard. Consider switch, that can be used directly on an optional to match against the unwrapped value. Nevertheless, it is important to keep in mind that exhaustiveness still applies, that is, the nil case must also be handled either explicitly or via the default clause: let str: Int? = nil switch str { case 0: print() case 1: print() default: print() } Optional patterns bring a succint way of handling the .some case when optional binding is unavailable: for case let unwrapped? in sequence { ... } Optional assignment lets you skip an assignment if the lvalue is nil, sparing the need to write an entire if-else or deal with access exclusivity when using the ternary operator. A very useful albeit sparsely documented feature. var ages = [&quot;Amy&quot; : 30, &quot;Graham&quot; : 5] ages[&quot;Anthony&quot;]? = 21 ages[&quot;Graham&quot;]? = 6 print(ages) // [&quot;Amy&quot; : 30, &quot;Graham&quot; : 6] Loops are a common statement in almost every codebase. Similarly, a possibility to optionally iterate over a sequence (iterate if there is a value, otherwise skip) when the nil case is of no interest is self-explanatory. While usage of optional sequences is often treated as misconception, there are several common ways one could end up with an optional sequence through Standard Library APIs and language constructs themselves. Amongst the most prevalent are optional chaining and dictionary getters. An indentation-sensitive area of which optional arrays are an integral part is decoding and deserialization, i.e parsing a JSON response. Swift currently doesn’t offer a mechanism for expressing optional iteration directly: optional sequences are illegal as a for-in loop argument. For a safe option, developers often resort to optional binding, which requires additional nesting: if let sequence = optionalSequence { for element in sequence { ... } } There are several workarounds to avoid that extra level of indentation, none of which can be called a general solution: guard is a pretty straight-forward option for a simple scenario, but guard doesn’t fall through – if handling the nil case is unnecessary and there follows flow-sensitive logic that is resistant to nil or doesn’t depend on that whatsoever, rearranging the flow with guard is likely to become a counterproductive experiment that affects readability while still keeping the indentation. Coalescing ?? with an empty literal is only valid with types that conform to a corresponding ExpressibleByLiteral protocol. Just in the Standard Library, there is a considerable amount of sequence types that cannot be expressed literally. Most of them are frequently used indirectly: Type-erasing and lazy wrappers Zipped and enumerated sequences String views (String.UTF8View, String.UTF16View, String.UnicodeScalarView) Default indices Reversed and repeated collections Strides (StrideTo, StrideThrough) Flattened, joined and unfolding sequences. An empty instance is not guaranteed to exist for an arbitrary sequence regardless of whether it can be expressed literally. This helps to see another flaw in the ?? #placeholder# fix-it from an engineer’s perspective. There are potentially untraceable cases when the fix-it is wrong. Furthermore, literals are unavailable in generic contexts that aren’t additionally constrained to an ExpressibleBy*Literal protocol. Reaching for sequence?.forEach is not an alternative if you are using control transfer statements, such as continue and break. The differences are clearly listed in the documentation: Using the forEach method is distinct from a for-in loop in two important ways: You cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls. Using the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls. Proposed solution This proposal introduces optional iteration (for?) and hence the possibility to use optional sequences as the corresponding attribute in for-in loops. let array: [Int]? = nil for? element in array { ... } // Equivalent to if let unwrappedArray = array { for element in unwrappedArray { ... } } The ? notation here is a semantic emphasis rather than a functional unit: there is no for!. Syntactically marking an optional iteration is redundant, however, in constrast to switch, nil values are skipped silently. Swift strives to follow a style where silent handling of nil is acknowledged via the ? sigil, distinctly reflected in optional chaining syntax. This decision was primarily based on inconsistency and potential confusion that an otherwise left without syntactic changes for-in loop could potentially lead to (“clarity over brevity”). for element in optionalArray { ... } // Silently handling optionals implicitly is a style that Swift prefers to eschew. From the author’s point of view, the solution’s most significant advantage is generality and hence scalability. for? is independent of the nature and form of the sequence argument and freely composes with any possible expression, be it a cast, try, or a mere optional chain. Albeit being an unprecedented optional handling case among statements on the grounds of the need to always omit the identifier to which the unwrapped value is bound, the community points out inconsistency in relation to other statements. Detailed design An optional for-in loop over a nil sequence does nothing. To be precise, it trips over nil when sequence?.makeIterator() is invoked and continues execution. Otherwise, it iterates normally. One can roughly imagine an optional for-in loop as sequence?.forEach with all the pattern-matching features and benefits of a for-in statement. The ? notation in for? is required when the passed sequence is optional and disallowed otherwise. let array: [Int] = [1, 2, 3] let optArray: [Int]? = nil for element in optArray { // The usual &#39;must be force-unwrapped&#39; error, but with the preferred fixit to use &#39;for?&#39; ... } for? element in array { // error: optional for-in loop must not be used on a non-optional sequence of type &#39;[Int]&#39; ... } Source compatibility This feature is purely additive. Effect on ABI stability None Alternatives considered Imitating optional chaining A syntactically less disruptive approach, the idea of which is denoting an optional iteration by selectively following the sequence expression with ?: let array: [Int]? = [1, 2, 3] for element in sequence? { ... } A terminating ? sigil here can be thought of as bringing the for loop into the optional chain with the sequence and mirrors the force-unwrapping case (sequence!). The technique implies that a degenerate optional chain (sequence?) should end with the ? sigil, but expressions that already acknowledge optionality, for instance sequence?.reversed(), data as? [T], try? sequenceReturningMethod(), may be left as-is. It is unclear how to address expressions that don’t acknowledge optionality but carry their own syntax without resorting to parenthesizing. One example of such an expression would be try methodReturningOptionalSequence(). Nested optionals As a mechanism that inherently runs only on non-optional sequences, for-in asks for optional flattening. The position inclines for expressions that acknowledge optionality to keep their optional flattening behavior, while enabling optional flattening on degenerate optional chains, so that types such as [T]???... can be iterated without additional syntactic load. Purely implicit The option of leaving out any syntactic changes was also discussed and met concern from the community. The drawback is briefly explained in the Proposed solution section.",
    "url": "http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html",
    "relUrl": "/docs/2019-08-26-0231-optional-iteration.html"
  },
  "231": {
    "id": "231",
    "title": "SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy",
    "content": "Remove Some Customization Points from the Standard Library’s Collection Hierarchy Proposal: SE-0232 Author: Ben Cohen Review Manager: Ted Kremenek Status: Implemented (Swift 5) Implementation: apple/swift#19995 Review: Discussion thread, Announcement thread Introduction This proposal removes four customization points from protocols in the standard library: map, filter, and forEach from Sequence first, prefix(upTo:), prefix(through:), and suffix(from:) from Collection last on BidirectionalCollection The default implementations of these symbols will remain, so sequences and collections will continue to have the same operations available that they do today. Swift-evolution thread: Discussion thread topic for that proposal Motivation Customization points are methods that are declared on the protocol, as well as given default implementations in an extension. This way, when a type provides its own non-default implementation, this will be dispatched to in a generic context (e.g. when another method defined in an extension on the protocol calls the customized method). Without a customization point, the default implementation is called in the generic context. This serves broadly two purposes: Allowing for differences in behavior. For example, an “add element” method on a set type might exclude duplicates while on a bag it might allow them. Allowing for more efficient implementations. For example, count on forward-only collections takes O(n) (because without random access, the implementation needs to iterate the collection to count it). But some collection types might know their count even if they aren’t random access. Once ABI stability has been declared for a framework, customization points can never be removed, though they can be added. Customization points aren’t free – they add a small cost at both compile time and run time. So they should only be added if there is a realistic possibility that either of the two reasons above apply. In the case of the customization points in this proposal, reason 1 does not apply. In fact it could be considered a serious bug if any type implemented these features with anything other than the default observable behavior. It is also hard to find a good use case for reason 2 – whereas slight slowdowns and code size bloat from the presence of the customization points have been observed. In some cases (for example suffix(from:)), the implementation is so simple that there is no reasonable alternative implementation. While it is possible that a resilient type’s forEach implementation might be able to eke out a small performance benefit (for example, to avoid the reference count bump of putting self into an iterator), it is generally harmful to encourage this kind of “maybe forEach could be faster” micro-optimization. For example, see here, where error control flow was used in order to break out of the forEach early, causing unpleasant interference for debugging workflows that detected when errors were thrown. Future move-only type considerations In the case of first and last there is an additional consideration: in the future, collections of move-only types (including Array) will not be able to reasonably fulfil these requirements. A collection that contains move-only types will only allow elements to be either removed and returned (e.g. with popLast()), or borrowed (e.g. via subscript). Returning an optional to represent the first element fits into neither of these buckets. You cannot write a generic implementation of first that fetches the first move-only element of a collection using a subscript, moves it into an optional, and then returns that optional. This means first and last need to be removed as requirements on the collection protocols in order to make it possible for collections of move only types to conform to them. They would remain on Collection via extensions. When move-only types are introduced, those extensions will be constrained to the collection element being copyable. Once the final functionality for move-only types is designed, it may be that language features will be added that allow for borrowing into an optional, allowing even collections of move-only types to implement a first property. But it’s better to err on the side of caution for now and remove them from the protocol. Proposed solution Remove these customization points from the Collection protocols. The default implementations will remain. Source compatibility These are customization points with an existing default implementation, so there is no effect on source stability. It is theoretically possible that removing these customization points could result in a behavior change on types that rely on the dynamic dispatch to add additional logic. However, this would be an extremely dubious practice e.g. MyCollection.first should really never do anything more than return the first element. Effect on ABI stability Removing customization points is not an ABI-stable operation. The driver for this proposal is to do this before declaring ABI stability. Effect on API resilience None Alternatives considered Leave them in. Live with the slight code/performance impact in the case of map and forEach, and work around the issue when designing move-only types.",
    "url": "http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html",
    "relUrl": "/docs/2019-08-26-0232-remove-customization-points.html"
  },
  "232": {
    "id": "232",
    "title": "SE-0233 Make  `Numeric`  Refine a new  `AdditiveArithmetic`  Protocol",
    "content": "Make Numeric Refine a new AdditiveArithmetic Protocol Proposal: SE-0233 Author: Richard Wei Review Manager: Chris Lattner Status: Implemented (Swift 5) Implementation: apple/swift#20422 Decision Notes: Rationale Introduction This proposal introduces a weakening of the existing Numeric protocol named AdditiveArithmetic , which defines additive arithmetic operators and a zero, making conforming types roughly correspond to the mathematic notion of an additive group. This makes it possible for vector types to share additive arithmetic operators with scalar types, which enables generic algorithms over AdditiveArithmetic to apply to both scalars and vectors. Discussion thread: Should Numeric not refine ExpressibleByIntegerLiteral Motivation The Numeric protocol today refines ExpressibleByIntegerLiteral and defines all arithmetic operators. The design makes it easy for scalar types to adopt arithmetic operators, but makes it hard for vector types to adopt arithmetic operators by conforming to this protocol. What’s wrong with Numeric? Assuming that we need to conform to Numeric to get basic arithmetic operators and generic algorithms, we have three problems. 1. Vectors conforming to Numeric would be mathematically incorrect. Numeric roughly corresponds to a ring. Vector spaces are not rings. Multiplication is not defined between vectors. Requirements * and *= below would make vector types inconsistent with the mathematical definition. static func * (lhs: Self, rhs: Self) -&gt; Self static func *= (lhs: inout Self, rhs: Self) 2. Literal conversion is undefined for dynamically shaped vectors. Vectors can be dynamically shaped, in which case the the shape needs to be provided when we initialize a vector from a scalar. Dynamically shaped vector types often have an initializer init(repeating:shape:). Conforming to Numeric requires a conformance to ExpressibleByIntegerLiteral, which requires init(integerLiteral:). However, the conversion from a scalar to a dynamically shaped vector is not defined when there is no given shape. struct Vector&lt;Scalar: Numeric&gt;: Numeric { // Okay! init(repeating: Scalar, shape: [Int]) { ... } // What&#39;s the shape? init(integerLiteral: Int) } 3. Common operator overloading causes type checking ambiguity. Vector types mathematically represent vector spaces. Vectors by definition do not have multiplication between each other, but they come with scalar multiplication. static func * (lhs: Vector, rhs: Scalar) -&gt; Vector { ... } By established convention in numerical computing communities such as machine learning, many libraries define a multiplication operator * between vectors as element-wise multiplication. Given that scalar multiplication has to exist by definition, element-wise multiplication and scalar multiplication would overload the * operator. static func * (lhs: Vector, rhs: Vector) -&gt; Vector { ... } static func * (lhs: Vector, rhs: Scalar) -&gt; Vector { ... } This compiles, but does not work in practice. The following trivial use case would fail to compile, because literal 1 can be implicitly converted to both a Scalar and a Vector , and * is overloaded for both Vector and Scalar . let x = Vector&lt;Int&gt;(...) x * 1 // Ambiguous! Can be both `x * Vector(integerLiteral: 1)` and `x * (1 as Int)`. Proposed solution We keep Numeric ‘s behavior and requirements intact, and introduce a new protocol that does not require ExpressibleByIntegerLiteral conformance, and shares common properties and operators between vectors and scalars. To achieve these, we can try to find a mathematical concept that is close enough to makes practical sense without depending on unnecessary algebraic abstractions. This concept is additive group, containing a zero and all additive operators that are defined on Numeric today. Numeric will refine this new protocol, and vector types/protocols will conform to/refine the new protocol as well. Detailed design We define a new protocol called AdditiveArithmetic . This protocol requires all additive arithmetic operators that today’s Numeric requires, and a zero. Zero is a fundamental property of an additive group. public protocol AdditiveArithmetic: Equatable { /// A zero value. static var zero: Self { get } /// Adds two values and produces their sum. /// /// The addition operator (`+`) calculates the sum of its two arguments. For /// example: /// /// 1 + 2 // 3 /// -10 + 15 // 5 /// -15 + -5 // -20 /// 21.5 + 3.25 // 24.75 /// /// You cannot use `+` with arguments of different types. To add values of /// different types, convert one of the values to the other value&#39;s type. /// /// let x: Int8 = 21 /// let y: Int = 1000000 /// Int(x) + y // 1000021 /// /// - Parameters: /// - lhs: The first value to add. /// - rhs: The second value to add. static func + (lhs: Self, rhs: Self) -&gt; Self /// Adds two values and stores the result in the left-hand-side variable. /// /// - Parameters: /// - lhs: The first value to add. /// - rhs: The second value to add. static func += (lhs: inout Self, rhs: Self) -&gt; Self /// Subtracts one value from another and produces their difference. /// /// The subtraction operator (`-`) calculates the difference of its two /// arguments. For example: /// /// 8 - 3 // 5 /// -10 - 5 // -15 /// 100 - -5 // 105 /// 10.5 - 100.0 // -89.5 /// /// You cannot use `-` with arguments of different types. To subtract values /// of different types, convert one of the values to the other value&#39;s type. /// /// let x: UInt8 = 21 /// let y: UInt = 1000000 /// y - UInt(x) // 999979 /// /// - Parameters: /// - lhs: A numeric value. /// - rhs: The value to subtract from `lhs`. static func - (lhs: Self, rhs: Self) -&gt; Self /// Subtracts the second value from the first and stores the difference in the /// left-hand-side variable. /// /// - Parameters: /// - lhs: A numeric value. /// - rhs: The value to subtract from `lhs`. static func -= (lhs: inout Self, rhs: Self) -&gt; Self } Remove arithmetic operator requirements from Numeric , and make Numeric refine AdditiveArithmetic . public protocol Numeric: AdditiveArithmetic, ExpressibleByIntegerLiteral { associatedtype Magnitude: Comparable, Numeric init?&lt;T&gt;(exactly source: T) where T : BinaryInteger var magnitude: Self.Magnitude { get } static func * (lhs: Self, rhs: Self) -&gt; Self static func *= (lhs: inout Self, rhs: Self) -&gt; Self } To make sure today’s Numeric -conforming types do not have to define a zero , we provide an extension to AdditiveArithmetic constrained on Self: ExpressibleByIntegerLiteral . extension AdditiveArithmetic where Self: ExpressibleByIntegerLiteral { public static var zero: Self { return 0 } } In the existing standard library, prefix + is provided by an extension to Numeric. Since additive arithmetics are now defined on AdditiveArithmetic, we change this extension to apply to AdditiveArithmetic. extension AdditiveArithmetic { /// Returns the given number unchanged. /// /// You can use the unary plus operator (`+`) to provide symmetry in your /// code for positive numbers when also using the unary minus operator. /// /// let x = -21 /// let y = +21 /// // x == -21 /// // y == 21 /// /// - Returns: The given argument without any changes. public static prefix func + (x: Self) -&gt; Self { return x } } Source compatibility The proposed change is fully source-compatible. Effect on ABI stability The proposed change will affect the existing ABI of the standard library, because it changes the protocol hierarchy and protocol requirements. As such, this protocol must be considered before the Swift 5 branching date. Effect on API resilience The proposed change will affect the existing ABI, and there is no way to make it not affect the ABI because it changes the protocol hierarchy and protocol requirements. Alternatives considered Make Numeric no longer refine ExpressibleByIntegerLiteral and not introduce any new protocol. This can solve the type checking ambiguity problem in vector protocols, but will break existing code: Functions generic over Numeric may use integer literals for initialization. Plus, Steve Canon also pointed out that it is not mathematically accurate – there’s a canonical homomorphism from the integers to every ring with unity. Moreover, it makes sense for vector types to conform to Numeric to get arithmetic operators, but it is uncommon to make vectors, esp. fixed-rank vectors, be expressible by integer literal. On top of AdditiveArithmetic, add a MultiplicativeArithmetic protocol that refines AdditiveArithmetic, and make Numeric refine MultiplicativeArithmetic. This would be a natural extension to AdditiveArithmetic, but the practical benefit of this is unclear. Instead of a zero static computed property requirement, an init() could be used instead, and this would align well with Swift’s preference for initializers. However, this would force conforming types to have an init(), which in some cases could be confusing or misleading. For example, it would be unclear whether Matrix() is creating a zero matrix or an identity matrix. Spelling it as zero eliminates that ambiguity.",
    "url": "http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html",
    "relUrl": "/docs/2019-08-26-0233-additive-arithmetic-protocol.html"
  },
  "233": {
    "id": "233",
    "title": "SE-0234 Remove `Sequence.SubSequence`",
    "content": "Remove Sequence.SubSequence Proposal: SE-0234 Authors: Ben Cohen Review Manager: John McCall Status: Implemented (Swift 5) Implementation: apple/swift#20221 Review: (review thread) (acceptance) Introduction This proposal recommends eliminating the associated type from Sequence, moving it up to start at Collection. Current customization points on Sequence returning a SubSequence will be amended to be extensions returning concrete types. Swift-evolution thread: Discussion thread topic for that proposal Motivation Current usage Today, Sequence declares several methods that return a SubSequence: func dropFirst(_:) -&gt; SubSequence func dropLast(_:) -&gt; SubSequence func drop(while:) -&gt; SubSequence func prefix(_:) -&gt; SubSequence func prefix(while:) -&gt; SubSequence func suffix(_:) -&gt; SubSequence func split(separator:) -&gt; [SubSequence] You don’t have to implement them to implement a Sequence. They all have default implementations for the default type for SubSequence. But if you think about how you’d implement them generically on a single-pass sequence, you’ll quickly realize there is a problem. They all call for completely different return types in their implementation. For example, the ideal way to implement dropFirst would be to return a wrapper type that first drops n elements, then starts returning values. prefix would ideally be implemented the other way around: return elements until you’ve returned n, then stop. suffix and dropLast need to consume the entire sequence to get to the end, buffering as they go, then return what they buffered. drop(while:) needs to eagerly drop non-matching elements as soon as it’s called (because the closure is not @escaping), which means it needs to buffer one element in case that’s the first one it needs to return later. prefix(while:) also needs to eagerly search and buffer everything it reads. But the protocol requires all these methods return the same type – SubSequence. They can’t return specific types for their specific needs. In theory, that could be resolved by having them all return [Element], but that would be wasteful of memory in cases like prefix(_:). The way the std lib works around this is to make the default SubSequence an AnySequence&lt;Element&gt;. So internally, there is a DropFirstSequence type, that is created when you call dropFirst on a Sequence. But it is type-erased to be the same type as returned by prefix, suffix etc., which also return their own custom types, but type erased. Unfortunately this has two major consequences: performance is bad: type-erased wrappers are an optimization barrier; and it blocks conditional conformance going from Sequence to Collection. Additionally, it makes implementing your own custom SubSequence that isn’t AnySequence extremely hard, because you need to then implement your own version of all these methods, even split. So in practice, this is never done. Type erasure performance There is a prototype in this PR that replaces the customization points on Sequence with regular extensions that each return a specific type. To see the performance problem, here is how the benchmarks improve if you return a non-type-erased type instead: Performance: -O TEST OLD NEW DELTA RATIO Improvement         DropWhileSequence 2214 29 -98.7% 76.34x PrefixSequenceLazy 2265 52 -97.7% 43.56x PrefixSequence 2213 52 -97.7% 42.56x DropFirstSequenceLazy 2310 59 -97.4% 39.15x DropFirstSequence 2240 59 -97.4% 37.97x Performance: -Osize TEST OLD NEW DELTA RATIO Improvement         DropWhileAnySeqCRangeIter 17631 163 -99.1% 108.16x DropFirstAnySeqCRangeIterLazy 21259 213 -99.0% 99.81x PrefixAnySeqCRangeIterLazy 16679 176 -98.9% 94.77x PrefixAnySeqCntRangeLazy 15810 168 -98.9% 94.11x DropFirstAnySeqCntRangeLazy 15717 213 -98.6% 73.79x DropWhileSequence 2582 35 -98.6% 73.77x DropFirstSequenceLazy 2671 58 -97.8% 46.05x DropFirstSequence 2649 58 -97.8% 45.67x PrefixSequence 2705 70 -97.4% 38.64x PrefixSequenceLazy 2670 70 -97.4% 38.14x These performance improvements are all down to how well the optimizer can eliminate the wrapper abstractions when there isn’t the barrier of type erasure in the way. In -Onone builds, you don’t see any speedup. How does it block conditional conformance? The problem with SubSequence really became clear when conditional conformance was implemented. With conditional conformance, it becomes really important that an associated type be able to grow and take on capabilities that line up with the capabilities you are adding with each new conformance. For example, the Slice type that is the default SubSequence for Collection grows in capabilities as it’s base grows. So for example, if the Base is a RandomAccessCollection, then so can the Slice be. This then works nicely when you add new conformances to a Collection that uses Slice as it’s SubSequence type. For more detail on this, watch Doug’s explanation in our WWDC Swift Generics talk (starts at about minute 26). But the default type for Sequence.SubSequence is AnySequence, which is a conformance dead end. You cannot add additional capabilities to AnySequence because there is nothing to drive them: the type erases all evidence of it’s wrapped type – that’s it’s point. This in turn forces two implementations of types that would ideally have a single unified implementation. For example, suppose you wanted to write something similar to EnumeratedSequence from the standard library, but have it be a Collection as well when it could support it. First you start with the basic type (note, all this code takes shortcuts for brevity): struct Enumerated&lt;Base: Sequence&gt; { let _base: Base } extension Sequence { func enumerated() -&gt; Enumerated&lt;Self&gt; { return Enumerated(_base: self) } } And add Sequence conformance: extension Enumerated: Sequence { typealias Element = (Int,Base.Element) struct Iterator: IteratorProtocol { var _count: Int let _base: Base.Iterator mutating func next() -&gt; Element? { defer { _count += 1 } return _base.next().map { (_count,$0) } } } func makeIterator() -&gt; Enumerated&lt;Base&gt;.Iterator { return Iterator(_count: 0, _base: _base.makeIterator()) } } Then, you’d want to add Collection conformance when the underlying base is also a collection. Something like this: extension Enumerated: Collection where Base: Collection { struct Index: Comparable { let _count: Int, _base: Base.Index static func &lt; (lhs: Index, rhs: Index) -&gt; Bool { return lhs._base &lt; rhs._base } } var startIndex: Index { return Index(_count: 0, _base: _base.startIndex) } var endIndex: Index { return Index(_count: Int.max, _base: _base.endIndex) } subscript(i: Index) -&gt; Element { return (i._count, _base[i._base]) } } You’d then follow through with conformance to RandomAccessCollection too when the base was. You can see this pattern used throughout the standard library. But this code won’t compile. The reason is that Collection requires that SubSequence also be a collection (and BidirectionalCollection requires it be bi-directional, and so on). This all works perfectly for Slice, the default value for SubSequence from Collection down, which progressively acquires these capabilities and grows along with the protocols it supports. But AnySequence can’t, as described above. It blocks all further capabilities. Because of this, if you want to support collection-like behavior, you’re back to the bad old days before conditional conformance. You have to declare two separate types: EnumeratedSequence and EnumeratedCollection, and define the enumerated function twice. This is bad for code size, and also leaks into user code, where these two different types appear. Why is Sequence like this? The reason why Sequence declares this associated type and then forces all these requirements to return it is to benefit from a specific use case: writing a generic algorithm on Sequence, and then passing a Collection to it. Because these are customization points, when Collection is able to provide a better implementation, that generic algorithm can benefit from it. For example, suppose you pass an Array, which provides random-access, into an algorithm that then calls suffix. Instead of needing to buffer all the elements, requiring linear time and memory allocation, it can just return a slice in constant time and no allocation. You can see this in the regressions from the same PR: Performance: -O TEST OLD NEW DELTA RATIO Regression         DropLastAnySeqCntRangeLazy 9 20366 +226163.8% 0.00x SuffixAnySeqCntRangeLazy 14 20699 +147739.4% 0.00x DropLastAnySeqCntRange 9 524 +5721.6% 0.02x SuffixAnySeqCntRange 14 760 +5328.2% 0.02x Performance: -Osize TEST OLD NEW DELTA RATIO Regression         DropLastAnySeqCRangeIterLazy 3684 20142 +446.7% 0.18x SuffixAnySeqCRangeIterLazy 3973 20223 +409.0% 0.20x SuffixAnySeqCntRangeLazy 5225 20235 +287.3% 0.26x DropLastAnySeqCntRangeLazy 5256 20113 +282.7% 0.26x DropFirstAnySeqCntRange 15730 20645 +31.2% 0.76x What is happening in these is a random-access collection (a CountableRange) is being put inside the type-erasing AnySequence, then suffix or dropLast is being called on it. The type-erased wrapper is then forwarding on the call to the wrapped collection. Fetching the suffix of a countable range is incredibly fast (it basically does nothing, ranges are just two numbers so it’s just adjusting the lower bound upwards), whereas after removing the customization points, the suffix function that’s called is the one for a Sequence, which needs to iterate the range and buffer the elements. This is a nice performance tweak, but it doesn’t justify the significant downsides listed above. It is essentially improving generic performance at the expense of concrete performance. Normally, these kind of generic improvements come at just a tiny cost (e.g. slight increase in compile time or binary size) rather than a significant runtime performance penalty. Proposed solution Remove the SubSequence associated type from Sequence. It should first appear from Collection onwards. Remove the methods on Sequence that return SubSequence from the protocol. They should remain as extensions only. Each one should return a specific type best suited to the task: extension Sequence { public func dropFirst(_ k: Int = 1) -&gt; DropFirstSequence&lt;Self&gt; public func dropLast(_ k: Int = 1) -&gt; [Element] public func suffix(_ maxLength: Int) -&gt; [Element] public func prefix(_ maxLength: Int) -&gt; PrefixSequence&lt;Self&gt; public func drop(while predicate: (Element) throws -&gt; Bool) rethrows -&gt; DropWhileSequence&lt;Self&gt; public func prefix(while predicate: (Element) throws -&gt; Bool) rethrows -&gt; [Element] public func split( maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Element) throws -&gt; Bool ) rethrows -&gt; [ArraySlice&lt;Element&gt;] } DropFirstSequence, DropWhileSequence and PrefixSequence already exist in the standard library in underscored form. This will also have the useful side-effect that these methods can also be removed as customization points from Collection as well, similar to removing prefix(upTo:) in SE-0232, because there’s no longer any reasonable customization to be done on a per-collection basis. Doing this will have considerable benefits to code size as well. For example, the CoreAudio overlay that declares a handful of collections reduces in size by 25% after applying these changes. Once done, this change will allow the following simplifying changes and enhancements to standard library types: LazySequenceProtocol and LazyCollectionProtocol can be collapsed into a single protocol. The following types can be collapsed, dropping the collection variant (with a typealias provided for source compatibility): FlattenSequence and -Collection LazySequence and -Collection LazyMapSequence and -Collection LazyFilterSequence and -Collection LazyDropWhileSequence and -Collection LazyPrefixWhileSequence and -Collection The following types can be extended to support Collection: EnumeratedSequence JoinedSequence Zip2Sequence SubSequence will continue to be an associated type on Collection, and the equivalent take/drop methods (and split) will continue to return it. Once the methods are removed from the Sequence protocol, they will also no longer need to be customizable at the Collection level so can be extensions only. Source compatibility This is a source-breaking change, in that any code that relies on Sequence.SubSequence will no longer work. For example: extension Sequence { func dropTwo() -&gt; SubSequence { return dropFirst(2) } } There are no examples of this kind of code in the compatibility suite. Unfortunately there is no way to remove an associated type in a way that only affects a specific language version, so this would not be something you could handle as part of upgrading to 5.0. Additionally, any sequences that define a custom SubSequence of their own will no longer work. This is really a non-problem, because doing so is almost impossible (it means you even have to implement your own split). Effect on ABI stability This is an ABI-breaking change, so must happen before 5.0 is released. Alternatives considered Other than not doing it, a change that split Sequence.SubSequence into two (say Prefix and Suffix) was considered. This implementation added significant complexity to the standard library, impacting compile time and code size, without being a significant enough improvement over the current situation.",
    "url": "http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html",
    "relUrl": "/docs/2019-08-26-0234-remove-sequence-subsequence.html"
  },
  "234": {
    "id": "234",
    "title": "SE-0235 Add Result to the Standard Library",
    "content": "Add Result to the Standard Library Proposal: SE-0235 Author: Jon Shier Review Manager: Chris Lattner Status: Implemented (Swift 5) Implementation: apple/swift#21073, apple/swift#21225, apple/swift#21378 Review: (initial review) (second review) (acceptance) Introduction Swift’s current error-handling, using throws, try, and catch, offers automatic and synchronous handling of errors through explicit syntax and runtime behavior. However, it lacks the flexibility needed to cover all error propagation and handling in the language. Result is a type commonly used for manual propagation and handling of errors in other languages and within the Swift community. Therefore this proposal seeks to add such a type to the Swift standard library. Motivation Swift’s Error Handling Rationale and Proposal document lays out the reasoning behind and high level details of the current Swift error handling story. Types conforming to Error can be propagated and handled using the do try catch throw syntax. The rationale document refers to this model as a typed and automatically propagating error system. However, this system has several drawbacks, some of which are mentioned in the rationale document. Namely, it cannot compose with asynchronous work, more complex error handling, or with failure values which don’t conform to Error. The added flexibility of typed, marked, but manually propagating error type can address these shortcomings. Namely Result&lt;Value, Error&gt;. Proposed solution public enum Result&lt;Success, Failure: Error&gt; { case success(Success), failure(Failure) } Result&lt;Success, Failure&gt; is a pragmatic compromise between competing error handling concerns both present and future. The Failure type captured in the .failure case is constrained to Error to simplify and underline Result’s intended use for manually propagating the result of a failable computation. Usage Asynchronous APIs Most commonly, and seen in abundance when using Apple or Foundation APIs, Result can serve to unify the awkwardly disparate parameters seen in asynchronous completion handlers. For instance, URLSession’s completion handlers take three optional parameters: func dataTask(with url: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask This can make it quite difficult to elegantly consume the results of these APIs: URLSession.shared.dataTask(with: url) { (data, response, error) in guard error != nil else { self.handleError(error!) } guard let data = data, let response = response else { return // Impossible? } handleResponse(response, data: data) } While this code is only a few lines long, it exposes Swift’s complete lack of automatic error handling for asynchronous APIs. Not only was the error forcibly unwrapped (or perhaps handled using a slightly less elegant if statement), but a possibly impossible scenario was created. What happens if response or data are nil? Is it even possible? It shouldn’t be, but Swift currently lacks the ability to express this impossibility. Using Result for the same scenario allows for much more elegant code: URLSession.shared.dataTask(with: url) { (result: Result&lt;(response: URLResponse, data: Data), Error&gt;) in // Type added for illustration purposes. switch result { case let .success(success): handleResponse(success.response, data: success.data) case let .error(error): handleError(error) } } This API expresses exactly the intended result (either an error or data and response, never all or none) and allows them to be handled much more clearly. More General Usage More generally, there are several scenarios in which Result can make error handling and the surrounding APIs more elegant. Delayed Handling There may be times where a developer wants to immediately execute a throwing function but otherwise delay handling the error until a later time. Currently, if they wish to preserve the error, they must break the value and error apart, as is typically seen in completion handlers (see above). This is made even more obnoxious if the developer needs to store the results of more than one function. // Properties var configurationString: String? var configurationReadError: Error? do { string = try String(contentsOfFile: configuration) } catch { readError = error } // Sometime later... func doSomethingWithConfiguration() { guard let configurationString = configurationString else { handle(configurationError!) } ... } This can be made somewhat cleaner by using a (string: String?, error: Error?) to store the result, but it would still have the same usage issues as in the asynchronous case. Using a Result is the appropriate answer here, especially with the convenience API for creating a result from a throwing function. let configuration = Result { try String(contentsOfFile: configuration) } // Sometime later... func doSomethingWithConfiguration() { switch configuration { ... } } Separating Errors It’s occasionally useful to be able to run throwable functions in such way as to allow the developer to disambiguate between the sources of the errors, especially if the errors don’t contain the information necessary to do so, or the developer doesn’t want to implement such a check. For instance, if we needed to disambiguate between the errors possible when reading files: do { handleOne(try String(contentsOfFile: oneFile)) } catch { handleOneError(error) } do { handleTwo(try String(contentsOfFile: twoFile)) } catch { handleTwoError(error) } do { handleThree(try String(contentsOfFile: threeFile)) } catch { handleThreeError(error) } This case can be expressed much more clearly using Result: let one = Result { try String(contentsOfFile: oneFile) } let two = Result { try String(contentsOfFile: twoFile) } let three = Result { try String(contentsOfFile: threeFile) } handleOne(one) handleTwo(two) handleThree(three) Additional convenience API on Result could make many of these cases even more elegant. Detailed design As implemented in the PR (annotations pending): /// A value that represents either a success or a failure, including an /// associated value in each case. @_frozen public enum Result&lt;Success, Failure: Error&gt; { /// A success, storing a `Success` value. case success(Success) /// A failure, storing a `Failure` value. case failure(Failure) /// Returns a new result, mapping any success value using the given /// transformation. /// /// Use this method when you need to transform the value of a `Result` /// instance when it represents a success. The following example transforms /// the integer success value of a result into a string: /// /// func getNextInteger() -&gt; Result&lt;Int, Error&gt; { /* ... */ } /// /// let integerResult = getNextInteger() /// // integerResult == .success(5) /// let stringResult = integerResult.map({ String($0) }) /// // stringResult == .success(&quot;5&quot;) /// /// - Parameter transform: A closure that takes the success value of this /// instance. /// - Returns: A `Result` instance with the result of evaluating `transform` /// as the new success value if this instance represents a success. public func map&lt;NewSuccess&gt;( _ transform: (Success) -&gt; NewSuccess ) -&gt; Result&lt;NewSuccess, Failure&gt; { } /// Returns a new result, mapping any failure value using the given /// transformation. /// /// Use this method when you need to transform the value of a `Result` /// instance when it represents a failure. The following example transforms /// the error value of a result by wrapping it in a custom `Error` type: /// /// struct DatedError: Error { /// var error: Error /// var date: Date /// /// init(_ error: Error) { /// self.error = error /// self.date = Date() /// } /// } /// /// let result: Result&lt;Int, Error&gt; = // ... /// // result == .failure(&lt;error value&gt;) /// let resultWithDatedError = result.mapError({ e in DatedError(e) }) /// // result == .failure(DatedError(error: &lt;error value&gt;, date: &lt;date&gt;)) /// /// - Parameter transform: A closure that takes the failure value of the /// instance. /// - Returns: A `Result` instance with the result of evaluating `transform` /// as the new failure value if this instance represents a failure. public func mapError&lt;NewFailure&gt;( _ transform: (Failure) -&gt; NewFailure ) -&gt; Result&lt;Success, NewFailure&gt; { } /// Returns a new result, mapping any success value using the given /// transformation and unwrapping the produced result. /// /// - Parameter transform: A closure that takes the success value of the /// instance. /// - Returns: A `Result` instance with the result of evaluating `transform` /// as the new failure value if this instance represents a failure. public func flatMap&lt;NewSuccess&gt;( _ transform: (Success) -&gt; Result&lt;NewSuccess, Failure&gt; ) -&gt; Result&lt;NewSuccess, Failure&gt; { } /// Returns a new result, mapping any failure value using the given /// transformation and unwrapping the produced result. /// /// - Parameter transform: A closure that takes the failure value of the /// instance. /// - Returns: A `Result` instance, either from the closure or the previous /// `.success`. public func flatMapError&lt;NewFailure&gt;( _ transform: (Failure) -&gt; Result&lt;Success, NewFailure&gt; ) -&gt; Result&lt;Success, NewFailure&gt; { } /// Returns the success value as a throwing expression. /// /// Use this method to retrieve the value of this result if it represents a /// success, or to catch the value if it represents a failure. /// /// let integerResult: Result&lt;Int, Error&gt; = .success(5) /// do { /// let value = try integerResult.get() /// print(&quot;The value is (value).&quot;) /// } catch error { /// print(&quot;Error retrieving the value: (error)&quot;) /// } /// // Prints &quot;The value is 5.&quot; /// /// - Returns: The success value, if the instance represents a success. /// - Throws: The failure value, if the instance represents a failure. public func get() throws -&gt; Success { } } extension Result where Failure == Swift.Error { /// Creates a new result by evaluating a throwing closure, capturing the /// returned value as a success, or any thrown error as a failure. /// /// - Parameter body: A throwing closure to evaluate. @_transparent public init(catching body: () throws -&gt; Success) { } } extension Result: Equatable where Success: Equatable, Failure: Equatable { } extension Result: Hashable where Success: Hashable, Failure: Hashable { } Adding Swift.Error self-conformance As part of the prepatory work for this proposal, self-conformance was added for Error (and only Error). This is also generally useful for working with errors in a generic context. This self-conformance does not extend to protocol compositions including the Error protocol, only the exact type Error. It will be possible to add such compositions in the future, but that is out of scope for Swift 5. Other Languages Many other languages have a Result type or equivalent: Kotlin: Result&lt;T&gt; Scala: Try[T] Rust: Result&lt;T, E&gt; Haskell: Exceptional e t C++ (proposed): expected&lt;E, T&gt; Source compatibility This is an additive change which could conflict with existing Result types, but work done to improve type name shadowing has made it a non-issue. Effect on ABI stability This proposal adds a type to the standard library and so will affect the ABI once added. Effect on API resilience Addition of Result&lt;Succes, Failure&gt; should be future proof against additional needs surrounding error handling. Alternatives considered Alternative Spellings of Result&lt;Success, Failure&gt; A few alternate spellings were proposed: A previously revised version of this proposal proposed: enum Result&lt;Value, Error: Swift.Error&gt; { case value(Value) case error(Error) } However, community opposition to this spelling resulted in the current, final spelling. Additionally, a hybrid spelling was proposed: enum Result&lt;Value, Error&gt; { case success(Value) case failure(Error) } This creates an unfortunate asymmetry between the names of the payload types and the names of the cases. This is additional complexity that has to be remembered. Finally, spellings using Wrapped as the success type name were proposed: enum Result&lt;Wrapped, Failure&gt; { case value(Wrapped) case error(Failure) } enum Result&lt;Wrapped, Failure&gt; { case some(Wrapped) case error(Failure) } The use of Wrapped in these spellings emphasizes more of a similarity to Optional than seems appropriate. Alternatives to Result&lt;Success, Failure&gt; Result&lt;T&gt;: A Result without a generic error type fits well with the current error design in Swift. However, it prevents the future addition of typed error handling (typed throws). Either&lt;T, U&gt;: Rather than adopting Result directly, basing it on an Either type has been considered. However, it’s felt that a Result type is a more generally useful case of Either, and Either gives users little in the way of actual API. Also, the two types can exist peacefully alongside each other with little conflict. Additionally, given the relatively unpopularity of the Either type in the community (59 apps use the Either CocoaPod) seems to indicate that lacking this type isn’t affecting Swift users that much. Constraint on the Error type A previous version of this proposal did not constrain the Failure type to conform to Error. This was largely because adding such a requirement would block Error from being used as the Error type, since Error does not conform to itself. Since we’ve now figured out how how to make that conformance work, this constraint is unblocked. Constraining the error type to conform to Error is a very low burden, and it has several benefits: It simplifies interoperation with error handling by making such operations unconditionally available. It encourages better practices for error values, such as using meaningful wrapper types for errors instead of raw Ints and Strings. It immediately catches the simple transposition error of writing Result&lt;Error, Value&gt;. Programmers coming from functional languages that use Either as a Result type are especially prone to this mistake: such languages often write the error type as the first argument due to the useful monadic properties of Either E. Operations A previous version of this proposal included operations for optionally projecting out the value and error cases. These operations are useful, but they should be added uniformly for all enums, and Result should not commit to providing hard-coded versions that may interfere with future language evolution. In the meantime, it is easy for programmers to add these operations with extensions in their own code. A previous version of this proposal included a fold operation. This operation is essentially an expression-based switch, and like the optional case projections, it would be better to provide a general language solution for it than to add a more limited design that covers only a single type. A previous version of this proposal did not label the closure parameter for the catching initializer. Single-argument unlabeled initializers are conventionally used for conversions, which this is not; usually the closure will be written explicitly, but in case it isn’t, a parameter label is appropriate.",
    "url": "http://localhost:4000/docs/2019-08-26-0235-add-result.html",
    "relUrl": "/docs/2019-08-26-0235-add-result.html"
  },
  "235": {
    "id": "235",
    "title": "SE-0236 Package Manager Platform Deployment Settings",
    "content": "Package Manager Platform Deployment Settings Proposal: SE-0236 Authors: Ankit Aggarwal Review Manager: Boris Bügling Status: Implemented (Swift 5) Decision Notes: Rationale Previous Revisions: 1 Introduction This is a proposal for adding support for specifying a per-platform minimum required deployment target in the Package.swift manifest file. Motivation Packages should be able to declare the minimum required platform deployment target version. SwiftPM currently uses a hardcoded value for the macOS deployment target. This creates friction for packages which want to use APIs that were introduced after the hardcoded deployment target version. There are two ways to work around this limitation: 1) using availability checks, or 2) passing the deployment target on the command line while building the package. However, these workarounds are not ideal and the package manager should really provide a proper API for setting the required deployment target version. Proposed solution We propose to add the following API to PackageDescription: /// Represents a supported platform. struct SupportedPlatform { static func macOS(_ version: MacOSVersion) -&gt; SupportedPlatform static func macOS(_ versionString: String) -&gt; SupportedPlatform static func tvOS(_ version: TVOSVersion) -&gt; SupportedPlatform static func tvOS(_ versionString: String) -&gt; SupportedPlatform static func iOS(_ version: IOSVersion) -&gt; SupportedPlatform static func iOS(_ versionString: String) -&gt; SupportedPlatform static func watchOS(_ version: WatchOSVersion) -&gt; SupportedPlatform static func watchOS(_ versionString: String) -&gt; SupportedPlatform } /// List of known versions. extension SupportedPlatform.MacOSVersion { static let v10_10: MacOSVersion static let v10_11: MacOSVersion static let v10_12: MacOSVersion ... } final class Package { init( name: String, platforms: [SupportedPlatform]? = nil, ... ) } // Example usage: let package = Package( name: &quot;NIO&quot;, platforms: [ .macOS(.v10_13), .iOS(.v12), ], products: [ .library(name: &quot;NIO&quot;, targets: [&quot;NIO&quot;]), ], targets: [ .target(name: &quot;NIO&quot;), ] ) A package will be assumed to support all platforms using a predefined minimum deployment version. This predefined deployment version will be the oldest deployment target version supported by the installed SDK for a given platform. One exception to this rule is macOS, for which the minimum deployment target version will start from 10.10. Packages can choose to declare the minimum deployment target version for some platform by using the above APIs. For example: This declaration means that the package should use 10.13 on macOS, 12.0 on iOS and the default deployment target when compiled on other platforms: ... platforms: [ .macOS(.v10_13), .iOS(.v12), ], ... Detailed design Changes in deployment target versions should be considered as a major breaking change for the purposes of semantic versioning since the dependees of a library package can break when a library makes such a change. SwiftPM will emit an error if a dependency is not compatible with the top-level package’s deployment version, i.e., the deployment target of dependencies must be lower than or equal to top-level package’s deployment target version for a particular platform. Each package will be compiled with the deployment target specified by it. In theory, SwiftPM can use the top-level package’s deployment version to compile the entire package graph since the deployment target versions of dependencies are guaranteed to be compatible. This might even produce more efficient compilation output but it also means that the users might start seeing a lot of warnings due to use of a higher version. Each platform API has a string overload that can be used to construct versions that are not already provided by PackageDescription APIs. This could be because the new version was recently released or isn’t appropriate to be included in the APIs (for e.g. dot versions). The version format for each platform will be documented in the API. Invalid values will be diagnosed and presented as manifest parsing errors. SwiftPM will emit appropriate errors when an invalid value is provided for supported platforms. For e.g., an empty array, multiple declarations for the same platform, invalid version specification. The generated Xcode project command will set the deployment target version for each platform. Future directions The Swift compiler supports several platforms like macOS, iOS, Linux, Windows, Android. However, the runtime availability checks currently only work for Apple platforms. It is expected that support for more platforms in the availability APIs will be added gradually as the community and support for Swift compiler grows. We think that the package manager can use a similar direction for declaring the supported platforms. We can start by allowing packages to declare support for Apple platforms with version specifications as proposed by the above APIs. Depending on the need in the community, these APIs can be evolved over time by adding support for declaring the minimum deployment version for other platforms that Swift supports. For e.g., the API can be enhanced to declare the minimum required version for Windows and the API level for Android. This proposal doesn’t handle these problems: Restricting supported platforms: Some packages are only meant to work on certain platforms. This proposal doesn’t provide ability to restrict the list of supported platforms and only allows customizing the deployment target versions. Restricting supported platforms is orthogonal to customizing deployment target and will be explored separately. Platform-specific targets or products: Consider that a package supports multiple platforms but has a product that should be only built for Linux. There is no way to express this intent and the build system may end up trying to build such targets on all platforms. A simple workaround is to use #if to conditionalize the source code of the target. Another use case comes up when you want to keep deployment target of a certain target lower than other targets in a package. A workaround is factoring out the target into its own package. A proper solution to this problem will be explored in a separate proposal, which should provide target-level settings. Platform-specific package dependencies: Similar to the above issue, a package may want to use a certain dependency only when building for a specific platform. It is currently not possible to declare such a dependency without using #if os checks in the manifest file, which doesn’t interact nicely with other features like Package.resolved and the cross-compilation support. This can be solved by providing APIs to declare platform-specific package dependencies in the manifest file. This will also be explored in a separate proposal. Impact on existing packages Existing packages will not be impacted as the behavior described in this proposal is compatible with SwiftPM’s current behavior, i.e., a package is assumed to support all platforms and SwiftPM picks a default deployment target version for the macOS platform. The new APIs will be guarded against the tools version this proposal is implemented in. Packages that want to use this feature will need to update their tools version. Alternatives considered We considered making the supported platform field mandatory. We think that it would provide little value in practice and cause more friction instead. One advantage would be that SwiftPM could use that information to produce error messages when a package tries to use a dependency which is not tested on some platform. We think that is not really a big enough issue. Since Swift is cross-platform, Swift packages should generally work on all platforms that Swift supports. However, there are platform-specific packages that are only meant for certain platforms and the proposed API does provide an option to declare that intent. We considered taking the deployment target version into the dependency resolution process to automatically find a compatible version with the top-level package. This too doesn’t provide enough value in practice. Library packages generally tend to stick with a deployment target to avoid breaking their dependees. When they do bump the version, it is generally a well-thought decision and may require a semver upgrade anyway due to updates in the API.",
    "url": "http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html",
    "relUrl": "/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html"
  },
  "236": {
    "id": "236",
    "title": "SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods",
    "content": "Introduce withContiguous{Mutable}StorageIfAvailable methods Proposal: SE-0237 Author: Ben Cohen Review Manager: Doug Gregor Status: Implemented (Swift 5) Implementation: apple/swift#21138 Decision notes: Rationale Prior revisions: Version 1 Introduction This proposal introduces two new methods, on Sequence and MutableCollection. These methods will allow generic code to make use of the withUnsafe{Mutable}BufferPointer idiom, as well as provide fast paths in the standard library for adopting types. Swift-evolution thread: Contiguous Collection Protocols Motivation Almost every feature of Array is made available via one of the protocols in the standard library, and so most code written against Array can be rewritten generically as an extension of one or more protocols. The exceptions to this are the operations withUnsafeBufferPointer and withUnsafeMutableBufferPointer, which are only available on the concrete types. Given the usefulness of these methods, they should also be made available generically. In addition, it is common to be able to provide an optimized fast path for many operations that are generic over Sequence or MutableCollection, when an unsafe buffer is available. For example, initializing a Data from a [UInt8] should be a memcpy when calling the generic initializer from a Sequence where Element == UInt8. sort currently is implemented as a merge sort, and the movements to/from its auxiliary storage can be done using memory moves for non-trivial types when the sorted collection is contiguously stored. Proposed solution Introduce two new methods, providing access to the with-unsafe capabilities of Array &amp; co when operating generically on protocols: protocol Sequence { /// Call `body(p)`, where `p` is a pointer to the collection&#39;s /// contiguous storage. If no such storage exists, it is /// first created. If the collection does not support an internal /// representation in a form of contiguous storage, `body` is not /// called and `nil` is returned. /// /// A `Collection` that provides its own implementation of this method /// must also guarantee that an equivalent buffer of its `SubSequence` /// can be generated by advancing the pointer by the distance to the /// slice&#39;s `startIndex`. func withContiguousStorageIfAvailable&lt;R&gt;( _ body: (UnsafeBufferPointer&lt;Element&gt;) throws -&gt; R ) rethrows -&gt; R? } protocol MutableCollection { /// Call `body(p)`, where `p` is a pointer to the collection&#39;s /// mutable contiguous storage. If no such storage exists, it is /// first created. If the collection does not support an internal /// representation in a form of mutable contiguous storage, `body` is not /// called and `nil` is returned. /// /// A `Collection` that provides its own implementation of this method /// must also guarantee that an equivalent buffer of its `SubSequence` /// can be generated by advancing the pointer by the distance to the /// slice&#39;s `startIndex`. public mutating func withContiguousMutableStorageIfAvailable&lt;R&gt;( _ body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R ) rethrows -&gt; R? } Existing types (such as Array or ArraySlice) that currently support withUnsafe{MutableBuffer}Pointer will forward on to this method. The default implementations will return nil. Additionally, Unsafe{Mutable}BufferPointer will respond usingself, and Slice&lt;T&gt; will provide an implementation that forwards on to its Base. A customization point already exists with an underscore in the standard library for the mutable version (it just returns nil by default), and should be exposed to general users. In addition, there exist underscored customization points that could be replaced by the immutable variant. There are no guarantees made by the mutable version about the state left behind if the closure throws during mutation. The updates made may or may not be reflected in the collection (which might have given a direct pointer to its internal storage, or could have handed out a temporary buffer that it then does not write back after the error is thrown). The closure should always perform any cleanup it thinks is necessary itself. It should be documented that successive calls to withUnsafe{Mutable}BufferPointer are not guaranteed to give you the same pointer with each call. For example, a packed small string implementation may be giving you a pointer to that string temporarily expanded to a buffer. Use of this entry point can provide significant speedups in some algorithms, e.g. our current sort which needs to move elements of a collection back and forth between some storage. Source compatibility These are additive changes and do not affect source compatibility. Effect on ABI stability These are additive changes and so can be done without affecting ABI stability. However, some existing underscored entry points could be altered as a result if done before ABI stability is declared. Alternatives considered This proposal originally introduced two new protocols: ContiguouslyStored and MutableContiguouslyStored. The introduction of customization points lower in the stack mean that these protocols are not necessary. It may be that valid use cases for asserting contiguity at compile time exist, in which case these protocols could be re-proposed. Some collections are not fully contiguous, but instead consist of multiple contiguous regions (for example, a ring buffer is one or two separate contiguous regions). Protocols or methods that handle this situation are left to subsequent proposals. The inout argument to the closure in the mutating variant is debatable. It does imply the user can change the buffer to a totally different one. Nonetheless, this is better handled in documentation, since the improved ergonomics of the inout version are considerable. It would also be a source-breaking change to alter Array’s implementation at this point.",
    "url": "http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html",
    "relUrl": "/docs/2019-08-26-0237-contiguous-collection.html"
  },
  "237": {
    "id": "237",
    "title": "SE-0238 Package Manager Target Specific Build Settings",
    "content": "Package Manager Target Specific Build Settings Proposal: SE-0238 Decision Notes: Draft Thread Authors: Ankit Aggarwal Review Manager: Boris Bügling Status: Implemented (Swift 5) Decision Notes: Rationale Previous Revisions: 1 Introduction This is a proposal for adding support for declaring some commonly used target-specific build settings in the Package.swift manifest file. As the name suggests, target-specific build settings are only applied to a particular target. SwiftPM also aims to support cross-target build settings that go across the target boundary and impart certain settings on a target’s dependees, but this proposal is only concerned with the former type of build settings and the latter will be explored with a future proposal. Motivation SwiftPM currently has little facility for customizing how the build tools (compilers, linker, etc.) are invoked during a build. This causes a lot of friction for package authors who want to do some basic customizations in order to build their targets. They often have to resort to awkward workarounds like creating custom modulemaps for linking system libraries, symlinking private headers inside the include directory, changing the include statements, and so on. We think most of these workarounds can be removed by providing support for some common build settings at the target level. This proposal will also set the stage for a richer build settings API in the future that has support for various conditional expressions, deployment options, inheritance of build settings, etc. Proposed solution We propose to add four new arguments to the target factory method: cSettings, cxxSettings, swiftSettings and linkerSettings. The build settings specified in these arguments will be used to compile a particular target and the settings will not affect any other target in the package or the package graph. The API will also allow conditionalization using a .when modifier on two parameters: platforms and build configuration. We propose to add the following build settings in this proposal: *Note: &lt;BuildSettingType&gt; represents the concrete type of a certain setting. Possible types are CSetting, CXXSetting, SwiftSetting or LinkerSetting. Each build setting in the upcoming section contains the method signature that will be available in their corresponding .* Header search path (C/CXX) static func headerSearchPath(_ path: String, _ condition: BuildSettingCondition? = nil) -&gt; &lt;BuildSettingType&gt; Many C-family projects are structured in a way that requires adding header search paths to different directories of the project. Currently, SwiftPM only adds a search path to the include directory which makes it difficult for many C projects to add support for building with SwiftPM. This specified path should be relative to the target and should not escape the package boundary. Absolute paths are disallowed. Note: It is not recommended to use this setting for adding search paths of public headers as the target-specific settings are not imparted onto other targets. Define (C/CXX) static func define(_ name: String, to value: String? = nil, _ condition: BuildSettingCondition? = nil) -&gt; &lt;BuildSettingType&gt; This setting will add the -D&lt;name&gt;=&lt;value&gt; flag during a target’s compilation. This is useful for projects that want to specify a compile-time condition. Note: It is not recommended to use this setting for public headers as the target-specific settings are not imparted. Define (Swift) static func define(_ name: String, _ condition: BuildSettingCondition? = nil) -&gt; SwiftSetting This setting enables the specified compilation condition for Swift targets. Unlike C/CXX’s define, it doesn’t have an associated value. Link library (Linker) static func linkLibrary(_ libraryName: String, _ condition: BuildSettingCondition? = nil) -&gt; &lt;BuildSettingType&gt; This is useful for packages that want to link against a library present in the system. The current approach requires them to create a module map using system library targets or a fake C target in order to achieve this effect. There is also no provision for conditionalization based on the platform in the existing approach, which is valuable when writing cross-platform packages. Link framework (Linker) static func linkFramework(_ frameworkName: String, _ condition: BuildSettingCondition? = nil) -&gt; &lt;BuildSettingType&gt; Frameworks are autolinked for Swift and C/ObjC targets so most packages shouldn’t require this build setting. However, packages that contain C++ files can’t autolink the frameworks. Since frameworks are widely used on Apple platforms, it is recommended to use this setting with a platform conditional. Unsafe flags (All) static func unsafeFlags(_ flags: [String], _ condition: BuildSettingCondition? = nil) -&gt; &lt;BuildSettingType&gt; This is an escape hatch that will allow targets to pass arbitrary command-line flags to the corresponding build tool. The “unsafe” here implies that SwiftPM can’t safely determine if the build flags will have any negative side-effect to the build since certain flags can change the behavior of how a build is performed. It is similar to how the -Xcc, -Xswiftc, -Xlinker option work in the command-line SwiftPM tools. The primary purpose of this escape hatch is to enable experimentation and exploration for packages that currently use a makefile or script to pass the -X* flags. Products that contain a target which uses an unsafe flag will be ineligible to act as a dependency for other packages. We have several such conditions (use of local dependencies, branch-based dependencies etc) that makes a package (individual products in this case) ineligible for acting as a dependency. This feature would be one more in that category. SwiftPM could provide a “pre-publish” command to detect and report such cases. RFC: https://forums.swift.org/t/rfc-swift-package-publish-precheck/15398 Conditionalization static func when(platforms: [Platform]? = nil, configuration: BuildConfiguration? = nil) -&gt; BuildSettingCondition By default, build settings will be applicable for all platforms and build configurations. The .when modifier can be used to conditionalize a build setting. SwiftPM will diagnose invalid usage of .when and emit a manifest parsing error. For e.g., it is invalid to specify a when condition with both parameter as nil. Example Here is an example usage of the proposed APIs: ... .target( name: &quot;MyTool&quot;, dependencies: [&quot;Yams&quot;], cSettings: [ .define(&quot;BAR&quot;), .headerSearchPath(&quot;path/relative/to/my/target&quot;), .define(&quot;DISABLE_SOMETHING&quot;, .when(platforms: [.iOS], configuration: .release)), .define(&quot;ENABLE_SOMETHING&quot;, .when(configuration: .release)), // Unsafe flags will be rejected by SwiftPM when a product containing this // target is used as a dependency. .unsafeFlags([&quot;-B=imma/haxx0r&quot;]), ], swiftSettings: [ .define(&quot;API_VERSION_5&quot;), ], linkerSettings: [ .linkLibrary(&quot;z&quot;), .linkFramework(&quot;CoreData&quot;), .linkLibrary(&quot;openssl&quot;, .when(platforms: [.linux])), .linkFramework(&quot;CoreData&quot;, .when(platforms: [.macOS], configuration: .debug)), // Unsafe flags will be rejected by SwiftPM when a product containing this // target is used as a dependency. .unsafeFlags([&quot;-L/path/to/my/library&quot;, &quot;-use-ld=gold&quot;], .when(platforms: [.linux])), ] ), ... Detailed design Use of a declarative model Using a declarative model for build settings (and, in general, all PackageDescription APIs) allows SwiftPM to understand the complete package manifest, including the conditionals that may currently evaluate to false. This information can be used to build some advanced features like mechanically editing the manifest file and it also allows possibility for a “migrator” feature for upgrading the APIs as they evolve. It is important to consider the impact of each build setting that is allowed to be used in a package. Certain build flags can be unsafe when configured without a more expressive build settings model, which can lead to non-hermetic builds. They can also cause bad interaction with the compilation process as certain flags can have a large impact on how the build is performed (for e.g. Swift compiler’s -wmo). Some flags can even be exploited to link pre-compiled binaries without being officially supported by the package manager, which can be a huge security issue. Other flags (like -B) can be used to change the directory where the tools are looked up by the compiler. In the future, we can enhance the build system to perform builds in a highly sandboxed environment and potentially loosen the restrictions from unsafe flags as such vulnerabilities will no longer be possible. The package author will immediately run into build errors in such a sandbox. Sharing build settings between tools If a Swift target specifies both Swift and C settings, the flags produced by C settings will be added to Swift compiler by prefixing each flag with -Xcc. Similarly, if a C-family target specifies both C and CXX settings, the flags produced by C settings will be added to C++ compiler by prefixing the flags with -Xcc. This behavior is similar to what the command-line SwiftPM does for the -X* overrides. This strategy doesn’t allow passing C flags that should be only passed to the C++ compiler but that is a very rare case. Future direction One of the major goal of this proposal is to introduce the infrastructure for build settings with some frequently used ones. There are many other build settings that can be safely added to the proposed API. Such additional build settings can be explored in a separate proposal. In the long term, SwiftPM aims to have a more complex build settings model with a rich API that allows expressing conditionalization on the various parameter, macro expansion, etc. We believe that the experience we gain with the proposed API will help us in fleshing out the future build settings API. Impact on existing packages There is no impact on existing packages as this is an additive feature. Packages that want to use the new build settings APIs will need to upgrade their manifest’s tools version to the version this proposal implemented in. Alternatives considered We considered making the API to be just an array of String that can take arbitrary build flags. However, that requires SwiftPM to implement parsing logic in order to determine if the flags are in the whitelist or not. The compiler flags are very difficult to parse and there are several variations accepted by the compiler for different flags. The other option was standardizing on the syntax of each whitelisted flag but that would require package authors to lookup SwiftPM’s documentation to figure out which variation is accepted. We considered another spelling for the proposal API but rejected it because we expect that most packages that need to add a build settings will require only one of the four type. It seems unnecessary to have package authors do nesting in order to add a single flag. ... .target( name: &quot;foo&quot;, dependencies: [&quot;Yams&quot;], settings: [ .swift([ .define(&quot;BAR&quot;), ]), .linker([ .linkLibrary(&quot;z&quot;), ]), ] ), ...",
    "url": "http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html",
    "relUrl": "/docs/2019-08-26-0238-package-manager-build-settings.html"
  },
  "238": {
    "id": "238",
    "title": "SE-0239 Add Codable conformance to Range types",
    "content": "Add Codable conformance to Range types Proposal: SE-0239 Authors: Dale Buckley, Ben Cohen, Maxim Moiseev Review Manager: Ted Kremenek Implementation: apple/swift#19532, apple/swift#21857 Status: Implemented (Swift 5) Review: Discussion thread Introduction SE-0167 introduced Codable conformance for some types in the standard library, but not the Range family of types. This proposal adds that conformance. Swift-evolution thread: Range conform to Codable Motivation Range is a very useful type to have conform to Codable. A good usage example is a range being sent to/from a client/server to convey a range of time using Date, or a safe operating temperature range using Measurement&lt;UnitTemperature&gt;. Proposed solution The following Standard Library range types will gain Codable conformance when their Bound is also Codable: Range ClosedRange PartialRangeFrom PartialRangeThrough PartialRangeUpTo These types will use an unkeyed container of their lower/upper bound (in sorted order, in cases of Range and ClosedRange). In addition, ContiguousArray is also missing a conformance to Codable, which will be added. Effect on ABI stability, resilience, and source stability This is a purely additive change, and so has no impact. Alternatives considered One area of concern mentioned during the discussion is that of potential data corruption. Consider this: if an application implements its own Codable conformance for Range or ClosedRange (which is, by the way, not recommended, as both the protocol and the type are defined in the standard library), there might be data permanently stored somewhere (in the database, in a JSON or PLIST file, etc.) which was serialized using that conformance. Unless the serialization format is exactly the same as the one used in the standard library, that data will be considered invalid. When this proposal is implemented, any Codable conformance to the Range type outside standard library will result in a compiler error as duplicate conformance. At which point, we suggest the following course of action to avoid data loss. Define your own type wrapping Range. public struct MyRangeWrapper&lt;Bound&gt; where Bound: Comparable { public var range: Range&lt;Bound&gt; } Port Codable conformance from Range to this new type. extension MyRangeWrapper { enum CodingKeys: CodingKey { case lowerBound case upperBound } } extension MyRangeWrapper: Decodable where Bound: Decodable { public init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) let lowerBound = try container.decode(Bound.self, forKey: .lowerBound) let upperBound = try container.decode(Bound.self, forKey: .upperBound) self.range = lowerBound ..&lt; upperBound } } Note that unless you wish to keep using this serialization format in the future, and are OK with using what’s provided by the standard library, only the Decodable conformance is needed for data migration purposes. Support both old and new formats when deserializing your data that contains ranges. extension JSONDecoder { func decodeRange&lt;Bound&gt;( _ type: Range&lt;Bound&gt;.Type, from data: Data ) throws -&gt; Range&lt;Bound&gt; where Bound: Decodable { do { return try self.decode(Range&lt;Bound&gt;.self, from: data) } catch DecodingError.typeMismatch(_, _) { return try self.decode(MyRangeWrapper&lt;Bound&gt;.self, from: data).range } } }",
    "url": "http://localhost:4000/docs/2019-08-26-0239-codable-range.html",
    "relUrl": "/docs/2019-08-26-0239-codable-range.html"
  },
  "239": {
    "id": "239",
    "title": "SE-0240 Ordered Collection Diffing",
    "content": "Ordered Collection Diffing Proposal: SE-0240 Authors: Scott Perry, Kyle Macomber Review Manager: Doug Gregor Status: Implemented (Swift 5.1) Implementation: apple/swift#21845 Decision notes: Rationale Introduction This proposal describes additions to the standard library that provide an interchange format for diffs as well as diffing/patching functionality for appropriate collection types. Motivation Representing, manufacturing, and applying transactions between states today requires writing a lot of error-prone code. This proposal is inspired by the convenience of the diffutils suite when interacting with text files, and the reluctance to solve similar problems in code by linking libgit2. Many state management patterns would benefit from improvements in this area, including undo/redo stacks, generational stores, and syncing differential content to/from a service. Proposed solution A new type representing the difference between collections is introduced along with methods that support its production and application. Using this API, a line-by-line three-way merge can be performed in a few lines of code: // Split the contents of the sources into lines let baseLines = base.components(separatedBy: &quot; n&quot;) let theirLines = theirs.components(separatedBy: &quot; n&quot;) let myLines = mine.components(separatedBy: &quot; n&quot;) // Create a difference from base to theirs let diff = theirLines.difference(from:baseLines) // Apply it to mine, if possible guard let patchedLines = myLines.applying(diff) else { print(&quot;Merge conflict applying patch, manual merge required&quot;) return } // Reassemble the result let patched = patchedLines.joined(separator: &quot; n&quot;) print(patched) Detailed design Producing diffs Most diffing algorithms have collection access patterns that are not appropriate for basic collections, so difference production is dependant on conformance to BidirectionalCollection: @available(swift, introduced: 5.1) extension BidirectionalCollection { /// Returns the difference needed to produce the receiver&#39;s state from the /// parameter&#39;s state, using the provided closure to establish equivalence /// between elements. /// /// This function does not infer moves. /// /// - Parameters: /// - other: The base state. /// - areEquivalent: A closure that returns whether the two /// parameters are equivalent. /// /// - Returns: The difference needed to produce the reciever&#39;s state from /// the parameter&#39;s state. /// /// - Complexity: For pathological inputs, worst case performance is /// O(`self.count` * `other.count`). Faster execution can be expected /// when the collections share many common elements. public func difference&lt;C&gt;( from other: C, by areEquivalent: (Element, C.Element) -&gt; Bool ) -&gt; CollectionDifference&lt;Element&gt; where C : BidirectionalCollection, C.Element == Self.Element } extension BidirectionalCollection where Element: Equatable { /// Returns the difference needed to produce the receiver&#39;s state from the /// parameter&#39;s state, using equality to establish equivalence between /// elements. /// /// This function does not infer element moves, but they can be computed /// using `CollectionDifference.inferringMoves()` if desired. /// /// - Parameters: /// - other: The base state. /// /// - Returns: The difference needed to produce the reciever&#39;s state from /// the parameter&#39;s state. /// /// - Complexity: For pathological inputs, worst case performance is /// O(`self.count` * `other.count`). Faster execution can be expected /// when the collections share many common elements, or if `Element` /// also conforms to `Hashable`. public func difference&lt;C&gt;(from other: C) -&gt; CollectionDifference&lt;Element&gt; where C: BidirectionalCollection, C.Element == Self.Element The difference(from:) method produces an instance of a difference type, defined as: /// A type that represents the difference between two collection states. @available(swift, introduced: 5.1) public struct CollectionDifference&lt;ChangeElement&gt; { /// A type that represents a single change to a collection. /// /// The `offset` of each `insert` refers to the offset of its `element` in /// the final state after the difference is fully applied. The `offset` of /// each `remove` refers to the offset of its `element` in the original /// state. Non-`nil` values of `associatedWith` refer to the offset of the /// complementary change. public enum Change { case insert(offset: Int, element: ChangeElement, associatedWith: Int?) case remove(offset: Int, element: ChangeElement, associatedWith: Int?) } /// Creates an instance from a collection of changes. /// /// For clients interested in the difference between two collections, see /// `BidirectionalCollection.difference(from:)`. /// /// To guarantee that instances are unambiguous and safe for compatible base /// states, this initializer will fail unless its parameter meets to the /// following requirements: /// /// 1) All insertion offsets are unique /// 2) All removal offsets are unique /// 3) All offset associations between insertions and removals are symmetric /// /// - Parameter changes: A collection of changes that represent a transition /// between two states. /// /// - Complexity: O(*n* * log(*n*)), where *n* is the length of the /// parameter. public init?&lt;C: Collection&gt;(_ c: C) where C.Element == Change /// The `.insert` changes contained by this difference, from lowest offset to highest public var insertions: [Change] { get } /// The `.remove` changes contained by this difference, from lowest offset to highest public var removals: [Change] { get } } /// A CollectionDifference is itself a Collection. /// /// The enumeration order of `Change` elements is: /// /// 1. `.remove`s, from highest `offset` to lowest /// 2. `.insert`s, from lowest `offset` to highest /// /// This guarantees that applicators on compatible base states are safe when /// written in the form: /// /// /// for c in diff { /// switch c { /// case .remove(offset: let o, element: _, associatedWith: _): /// arr.remove(at: o) /// case .insert(offset: let o, element: let e, associatedWith: _): /// arr.insert(e, at: o) /// } /// } /// extension CollectionDifference : Collection { public typealias Element = CollectionDifference&lt;ChangeElement&gt;.Change public struct Index: Comparable, Hashable {} } extension CollectionDifference.Change: Equatable where ChangeElement: Equatable {} extension CollectionDifference: Equatable where ChangeElement: Equatable {} extension CollectionDifference.Change: Hashable where ChangeElement: Hashable {} extension CollectionDifference: Hashable where ChangeElement: Hashable { /// Infers which `ChangeElement`s have been both inserted and removed only /// once and returns a new difference with those associations. /// /// - Returns: an instance with all possible moves inferred. /// /// - Complexity: O(*n*) where *n* is `self.count` public func inferringMoves() -&gt; CollectionDifference&lt;ChangeElement&gt; } extension CollectionDifference: Codable where ChangeElement: Codable {} A Change is a single mutating operation, a CollectionDifference is a plurality of such operations that represents a complete transition between two states. Given the interdependence of the changes, CollectionDifference has no mutating members, but it does allow index- and Slice-based access to its changes via Collection conformance as well as a validating initializer taking a Collection. Fundamentally, there are only two operations that mutate collections, insert(_:at:) and remove(_:at:), but there are benefits from being able to represent other operations such as moves and replacements, especially for UIs that may want to animate a move differently from an insert/remove pair. These operations are represented using associatedWith:. When non-nil, they refer to the offset of the counterpart as described in the headerdoc. Application of instances of CollectionDifference extension RangeReplaceableCollection { /// Applies a difference to a collection. /// /// - Parameter difference: The difference to be applied. /// /// - Returns: An instance representing the state of the receiver with the /// difference applied, or `nil` if the difference is incompatible with /// the receiver&#39;s state. /// /// - Complexity: O(*n* + *c*), where *n* is `self.count` and *c* is the /// number of changes contained by the parameter. @available(swift, introduced: 5.1) public func applying(_ difference: CollectionDifference&lt;Element&gt;) -&gt; Self? } Applying a diff to an incompatible base state is the only way application can fail. applying(_:) expresses this by returning nil. Source compatibility This proposal is additive and the names of the types it proposes are not likely to already be in wide use, so it does not represent a significant risk to source compatibility. Effect on ABI stability This proposal does not affect ABI stability. Effect on API resilience This feature is additive and symbols marked with @available(swift, introduced: 5.1) as appropriate. Alternatives considered The following is an incomplete list based on common feedback received during the process of developing this API: Communicating changes via a series of callbacks Breaking up a transaction into a sequence of imperative events is not very Swifty, and the pattern has proven to be fertile ground for defects. More cases in CollectionDifference.Change While other cases such as .move are tempting, the proliferation of code in switch statements is unwanted overhead for clients that don’t care about the “how” of a state transition so much as the “what”. The use of associated offsets allows for more information to be encoded into the diff without making it more difficult to use. You’ve already seen how associated offsets can be used to illustrate moves (as produced by inferringMoves()): CollectionDifference&lt;String&gt;([ .remove(offset:0, element: &quot;value&quot;, associatedWith: 4), .insert(offset:4, element: &quot;value&quot;, associatedWith: 0) ]) But they can also be used to illustrate replacement when the offsets refer to the same position (and the element is different): CollectionDifference&lt;String&gt;([ .remove(offset:0, element: &quot;oldvalue&quot;, associatedWith: 0), .insert(offset:0, element: &quot;newvalue&quot;, associatedWith: 0) ]) Differing offsets and elements can be combined when a value is both moved and replaced (or changed): CollectionDifference&lt;String&gt;([ .remove(offset:4, element: &quot;oldvalue&quot;, associatedWith: 0), .insert(offset:0, element: &quot;newvalue&quot;, associatedWith: 4) ]) Neither of these two latter forms can be inferred from a diff by inferringMoves(), but they can be legally expressed by any API that vends a difference. applying(_:) throws -&gt; Self instead of applying(_:) -&gt; Self? Applying a diff can only fail when the base state is incompatible. As such, the additional granularity provided by an error type does not add any value. Use Index instead of offset in Change Because indexes cannot be navigated in the absence of the collection instance that generated them, a diff based on indexes instead of offsets would be much more limited in usefulness as a boundary type. If indexes are required, they can be rehydrated from the offsets in the presence of the collection(s) to which they belong. Change generic on both BaseElement and OtherElement instead of just Element Application of differences would only be possible when both Element types were equal, and there would be additional cognitive overhead with comparators with the type (Element, Other.Element) -&gt; Bool. Since the comparator forces both types to be effectively isomorphic, a diff generic over only one type can satisfy the need by mapping one (or both) collections to force their Element types to match. difference(from:using:) with an enum parameter for choosing the diff algorithm instead of difference(from:) This is an attractive API concept, but it can be very cumbersome to extend. This is especially the case for types like OrderedSet that—through member uniqueness and fast membership testing—have the capability to support very fast diff algorithms that aren’t appropriate for other types. CollectionDifference or just Difference instead of CollectionDifference The name CollectionDifference gives us the opportunity to build a family of related types in the future, as the difference type in this proposal is (intentionally) unsuitable for representing differences between keyed collections (which don’t shift their elements’ keys on insertion/removal) or structural differences between treelike collections (which are multidimensional). Intentional omissions: Further adoption This API allows for more interesting functionality that is not included in this proposal. For example, this propsal could have included a inverted() function on the difference type that would return a new difference that would undo the application of the original. The lack of additional conveniences and functionality is intentional; the goal of this proposal is to lay the groundwork that such extensions would be built upon. In the case of inverted(), clients of the API in this proposal can use Collection.map() to invert the case of each Change and feed the result into CollectionDifference.init(_:): let diff: CollectionDifference&lt;Int&gt; = /* ... */ let inverted = CollectionDifference&lt;Int&gt;( diff.map({(change) -&gt; CollectionDifference&lt;Int&gt;.Change in switch change { case .insert(offset: let o, element: let e, associatedWith: let a): return .remove(offset: o, element: e, associatedWith: a) case .remove(offset: let o, element: let e, associatedWith: let a): return .insert(offset: o, element: e, associatedWith: a) } }) )! mutating apply(_:) There is no mutating applicator because there is no algorithmic advantage to in-place application. mutating inferringMoves() While there may be savings to be had from in-place move inferencing; we’re holding this function for a future proposal. Formalizing the concept of an ordered collection This problem warrants a proposal of its own.",
    "url": "http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html",
    "relUrl": "/docs/2019-08-26-0240-ordered-collection-diffing.html"
  },
  "240": {
    "id": "240",
    "title": "SE-0241 Deprecate String Index Encoded Offsets",
    "content": "Deprecate String Index Encoded Offsets Proposal: SE-0241 Author: Michael Ilseman Review Manager: John McCall Status: Implemented (Swift 5) Implementation: apple/swift#22108 Review: (review) (acceptance) Introduction [SE-0180][] introduced a computed variable and initializer surrounding the concept of an encodedOffset for serialization purposes. Unfortunately, that approach is flawed for its intended purpose and is commonly misused in ways that Swift 5 is more likely to expose. It is too late in the Swift 5.0 release to solve all existing problems, so we propose deprecating encodedOffset and introducing a targeted, semantics-preserving alternative. Motivation String abstracts away details about the underlying encoding used in its storage. String.Index is opaque and represents a position within a String or Substring. This can make serializing a string alongside its indices difficult, and for that reason [SE-0180][] added a computed variable and initializer encodedOffset in Swift 4.0. String was always meant to be capable of handling multiple backing encodings for its contents, and this is realized in Swift 5. String now uses UTF-8 for its preferred “fast” native encoding, but has a resilient fallback for strings of different encodings. Currently, we only use this fall-back for lazily-bridged Cocoa strings, which are commonly encoded as UTF-16, though it can be extended in the future thanks to resilience. Unfortunately, [SE-0180][]’s approach of a single notion of encodedOffset is flawed. A string can be serialized with a choice of encodings, and the offset is therefore encoding-dependent and requires access to the contents of the string to calculate. A comment in [SE-0180][]’s example source mentioned that encodedOffset assumes UTF-16, which happened to be the only encoding used internally by String at the time (for offset purposes). Furthermore, the majority of uses of encodedOffset in the wild are not following [SE-0180][]’s intended purpose and are sensitive to encoding changes. encodedOffset is frequently misused under the assumption that all Characters are comprised of a single code unit, which is error-prone and Swift 5 might surface the underlying bugs in more situations. It is also sometimes used for mapping Cocoa string indices, which happens to work in Swift 4 but might not in Swift 5, and Foundation already provides better alternatives. Proposed solution We propose a targeted semantics-preserving off-ramp for uses of encodedOffset. Because Swift 5 may introduce a semantic difference in behavior, it is important to rush this fix into the 5.0 release so that developers can preserve existing semantics. Potential solutions to other problems, including the original intended purpose of encodedOffset, are highlighted in “Alternatives Considered”. Detailed design extension String.Index { /// The UTF-16 code unit offset corresponding to this Index public func utf16Offset&lt;S: StringProtocol&gt;(in s: S) -&gt; Int { return s.utf16.distance(from: s.utf16.startIndex, to: self) } /// Creates a new index at the specified UTF-16 code unit offset /// /// - Parameter offset: An offset in UTF-16 code units. public init&lt;S: StringProtocol&gt;(utf16Offset offset: Int, in s: S) { let (start, end) = (s.utf16.startIndex, s.utf16.endIndex) guard offset &gt;= 0, let idx = s.utf16.index(start, offsetBy: offset, limitedBy: end) else { self = end.nextEncoded // internal method returning endIndex+1 return } self = idx } } We try to match the original semantics as close as we reasonably can. If the user supplies an out-of-bounds offset to the initializer, we will form an invalid index. If the out-of-bounds offset is exactly equivalent to the count, the returned index will compare equal with endIndex, otherwise it will compare greater than endIndex. Source Compatibility This deprecates existing API and provides a semantics-preserving alternative. Deprecation preserves source compatibility and strongly hints towards correct usage. But, other changes in Swift 5 introduce potential semantic drift in old code. Effect of ABI stability This change is ABI-additive, but necessary due to other ABI changes in Swift 5. Effect on API resilience Added APIs are all resilient and can be replaced with more efficient implementations that preserve correctness as String evolves. Alternatives Considered Do Nothing If encodedOffset was only used for serialization, and such serialization/deserialization would record and preserve the original encoding, and we amend [SE-0180][]’s comment to avoid nailing it down to any given encoding, no change would be necessary. Unfortunately, there is no way to query or preserve internal encoding and there is considerable use and misuse in the wild, as mentioned in the “Uses in the Wild” disclosure section. Fix all the Bugs This proposal originally introduced a set of API attempting to solve 3 problems: [SE-0180][]’s encodedOffset, meant for serialization purposes, needs to be parameterized over the encoding in which the string will be serialized in Existing uses of encodedOffset need a semantics-preserving off-ramp for Swift 5, which is expressed in terms of UTF-16 offsets Existing misuses of encodedOffset, which assume all characters are a single UTF-16 code unit, need a semantics-fixing alternative Details: String’s views and encodings String has 3 views which correspond to the most popular Unicode encodings: UTF-8, UTF-16, and UTF-32 (via the Unicode scalar values). String’s default view is of Characters. swift let myString = &quot;abc r nいろは&quot; Array(myString.utf8) // UTF-8 encoded Array(myString.utf16) // UTF-16 encoded Array(myString.unicodeScalars.lazy.map { $0.value }) // UTF-32 encoded Array(myString); Array(myString.indices) // Not an encoding, but provides offset-based access to `Characters` Uses in the Wild GitHub code search yields [nearly 1500 uses](https://github.com/search?l=Swift&amp;q=encodedOffset&amp;type=Code) , and nearly-none of them are for [SE-0180][]’s intended purpose. Below I present the 3 most common uses. swift // Common code for these examples let myString: String = ... let start: String.Index = ... let end: String.Index = ... let utf16OffsetRange: Range = ... let nsRange: NSRange = ... #### Offset-based `Character` indexing The most common misuse of `encodedOffset` assumes that all Characters in a String are comprised of a single code unit. This is wrong and a source of surprising bugs, even for exclusively ASCII content: `&quot; r n&quot;.count == 1`. swift let (i, j): (Int, Int) = ... // Something computed in terms of myString.count // Problematic code myString[String.Index(encodedOffset: i]..&lt;String.Index(encodedOffset: j)] // Semantic preserving alternative from this proposal myString[String.Index(offset: i, within: myString)..&lt;String.Index(offset: j, within: myString)] // Even better alternative let myIndices = Array(myString.indices) let (i, j): (Int, Int) = ... // Something computed in terms of myIndices.count myString[myIndices[i]..&lt;myIndices[j]] #### Range Mapping Many of the uses in the wild are trying to map between `Range` and `NSRange`. Foundation already provides convenient initializers for this purpose already, and using them is the preferred approach: swift // Problematic code let myNSRange = NSRange(location: start.encodedOffset, length: end.encodedOffset - start.encodedOffset) let myStrRange = String.Index(encodedOffset: nsRange.lowerBound)..&lt;String.Index(encodedOffset: nsRange.upperBound) // Better alternative let myNSRange = NSRange(start..&lt;end, in: myString) let myStrRange = Range(nsRange, in: myString) #### Naked Ints Some uses in the wild, through no fault of their own, have an Int which represents a position in UTF-16 encoded contents and need to convert that to a `String.Index`. swift // Problematic code let strLower = String.Index(encodedOffset: utf16OffsetRange.lowerBound) let strUpper = String.Index(encodedOffset: utf16OffsetRange.upperBound) let subStr = myString[strLower..&lt;strUpper] // Semantic preserving alternative from this proposal let strLower = String.Index(offset: utf16OffsetRange.lowerBound, within: str.utf16) let strUpper = String.Index(offset: utf16OffsetRange.upperBound, within: str.utf16) let subStr = myString[strLower..&lt;strUpper] &lt;/details&gt; #### Potential Solution Original Proposed Solution Here is a (slightly revised) version of the original proposal: swift /// The UTF-16 code unit offset corresponding to this Index public func offset&lt;S: StringProtocol&gt;(in utf16: S.UTF16View) -&gt; Int { ... } /// The UTF-8 code unit offset corresponding to this Index public func offset&lt;S: StringProtocol&gt;(in utf8: S.UTF8View) -&gt; Int { ... } /// The Unicode scalar offset corresponding to this Index public func offset&lt;S: StringProtocol&gt;(in scalars: S.UnicodeScalarView) -&gt; Int { ... } /// The Character offset corresponding to this Index public func offset&lt;S: StringProtocol&gt;(in str: S) -&gt; Int { ... } /// Creates a new index at the specified UTF-16 code unit offset /// /// - Parameter offset: An offset in UTF-16 code units. public init&lt;S: StringProtocol&gt;(offset: Int, in utf16: S.UTF16View) { ... } /// Creates a new index at the specified UTF-8 code unit offset /// /// - Parameter offset: An offset in UTF-8 code units. public init&lt;S: StringProtocol&gt;(offset: Int, in utf8: S.UTF8View) { ... } /// Creates a new index at the specified Unicode scalar offset /// /// - Parameter offset: An offset in terms of Unicode.Scalars public init&lt;S: StringProtocol&gt;(offset: Int, in scalars: S.UnicodeScalarView) { ... } /// Creates a new index at the specified Character offset /// /// - Parameter offset: An offset in terms of Characters public init&lt;S: StringProtocol&gt;(offset: Int, in str: S) { ... } } This gives developers: 1. The ability to choose a specific encoding for serialization, the original intended purpose. 2. The ability to fix any code that assumed fixed-encoding-width Characters by choosing the most-natural variant that just takes a String. 3. The ability to migrate their uses for Cocoa index mapping by choosing UTF-16. However, it’s not clear this is the best approach for Swift and more design work is needed: * Overloading only on view type makes it easy to accidentally omit a view and end up with character offsets. E.g. `String.Index(offset: myUTF16Offset, in: myUTF16String)` instead of `String.Index(offset: myUTF16Offset, in: myUTF16String.utf16)`. * Producing new indices is usually done by the collection itself rather than parameterizing an index initializer. This should be handled with something more ergonomic such as offset-based indexing in a future release. * In real code in the wild, almost all created indices are immediately used to subscript the string or one of its views. This should be handled with something more ergonomic such as [offset-based subscripting](https://forums.swift.org/t/shorthand-for-offsetting-startindex-and-endindex/9397) in a future release. #### Conclusion It is too late in the Swift 5.0 release to design and add all of these API. Instead, we’re proposing an urgent, targeted fix for the second problem. [SE-0180]: &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md&gt;",
    "url": "http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html",
    "relUrl": "/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html"
  },
  "241": {
    "id": "241",
    "title": "SE-0242 Synthesize default values for the memberwise initializer",
    "content": "Synthesize default values for the memberwise initializer Proposal: SE-0242 Author: Alejandro Alonso Review Manager: Ted Kremenek Status: Implemented (Swift 5.1) Decision Notes: Rationale Implementation: apple/swift#19743 Introduction This proposal aims to solve a simple outstanding problem with the way the Swift compiler currently synthesizes the memberwise initializer for structures by synthesizing default values for properties with default initializers. This is mentioned in the “State of the Memberwise Initializer” forum post: here Motivation Currently the Swift compiler is able to synthesize a fairly basic memberwise initializer for structures. struct Dog { var age: Int var name: String } The compiler is able to synthesize a memberwise iniailizer for this structure which simply looks like this: init(age: Int, name: String) But, lets say we want all dogs to have a default value of 0 for the age: struct Dog { var age: Int = 0 var name: String } A user might naively try using this default value when constructing their Dog instance: // I just want to set the name of Dog, sparky is a newborn let sparky = Dog(name: &quot;Sparky&quot;) To their surprise, they can’t. missing argument for parameter &#39;age&#39; in call. Using the compiler synthesized memberwise initializer has turned to become a nuisance rather than a nice removal of boilerplate. In many cases the user may optionally just define their own initializer with a default value for the age parameter. struct Dog { var age: Int = 0 var name: String // This is defined because the Swift compiler can&#39;t generate default values for properties with an initial value init(age: Int = 0, name: String) { self.age = age self.name = name } } Proposed solution I propose simply doing the obvious and synthesizing default values for properties with default initializers in the memberwise initializer. Simple code like the following will simply work: struct Dog { var age: Int = 0 var name: String // The generated memberwise init: init(age: Int = 0, name: String) } // This now works let sparky = Dog(name: &quot;Sparky&quot;) // Dog(age: 0, name: &quot;Sparky&quot;) The following example displays the memberwise initializer being produced by the compiler with a combination of variables with default values. struct Alphabet { var a: Int = 97 let b: String var c: String = &quot;c&quot; let d: Bool = true var e: Double = Double.random(in: 0 ... .pi) // The generated memberwise init: init( a: Int = 97, b: String, c: String = &quot;c&quot;, e: Double = Double.random(in: 0 ... .pi) ) } Notice the d variable does not get an entry in the memberwise initializer because it is a constant whose value is already assigned. This behavior already exists with the current initializer. In the case where multiple variables are being initialized together, we cannot generate a default value for them in the memberwise initializer. For example: struct Person { var (firstName, lastName) = (&quot;First&quot;, &quot;Last&quot;) // The generated memberwise init: init(firstName: String, lastName: String) } Detailed design This change does not alter the requirements needed to synthesize the memberwise initializer, but rather if we can synthesize the memberwise initializer, also synthesize default values for properties with default initializers. Note that we can only synthesize values for variables that have declared default initializers and not constants. Source compatibility This is a purely additive feature, thus source compatibility is not affected. Effect on ABI stability This feature does not alter ABI, thus ABI stability is not affected. Effect on API resilience As the memberwise initializer is only synthesized as an internal initializer, this feature does not affect API resilience. Alternatives considered We could simply not do this and save this proposal for a solution much larger in regards to fixing more problems the memberwise initializer has. The downside is that we put off obvious changes like this for much longer because of wanting to solve a bigger problem. I agree we should solve the bigger problems, but by solving problems like this it aids in the solution of the larger problem.",
    "url": "http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html",
    "relUrl": "/docs/2019-08-26-0242-default-values-memberwise.html"
  },
  "242": {
    "id": "242",
    "title": "SE-0243 Integer-convertible character literals",
    "content": "Integer-convertible character literals Proposal: SE-0243 Authors: Kelvin Ma (“Taylor Swift”), Chris Lattner, John Holdsworth Review manager: Ben Cohen Status: Rejected (Rationale) Implementation: apple/swift#21873 Threads: 1 Introduction Swift’s String type is designed for Unicode correctness and abstracts away the underlying binary representation of the string to model it as a Collection of grapheme clusters. This is an appropriate string model for human-readable text, as to a human reader, the atomic unit of a string is (usually) the extended grapheme cluster. When treated this way, many logical string operations “just work” the way users expect. However, it is also common in programming to need to express values which are intrinsically numeric, but have textual meaning, when taken as an ASCII value. We propose adding a new literal syntax takes single-quotes (&#39;), and is transparently convertible to Swift’s integer types. This syntax, but not the behavior, will extend to all “single element” text literals, up to and including Character, and will become the preferred literal syntax these types. Motivation A pain point of using characters in Swift is they lack a first-class literal syntax. Users have to manually coerce string literals to a Character or Unicode.Scalar type using as Character or as Unicode.Scalar, respectively. Having the collection share the same syntax as its element also harms code clarity and makes it difficult to tell if a double-quoted literal is being used as a string or character in some cases. Additional challenges arise when using ASCII scalars in Swift. Swift currently provides no static mechanism to assert that a unicode scalar literal is restricted to the ASCII range, and lacks a readable literal syntax for such values as well. In C, &#39;a&#39; is a uint8_t literal, equivalent to 97. Swift has no such equivalent, requiring awkward spellings like UInt8(ascii: &quot;a&quot;), or spelling out the values in hex or decimal directly. This harms readability of code, and makes bytestring processing in Swift painful. static char const hexcodes[16] = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39; ,&#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; }; let hexcodes = [ UInt8(ascii: &quot;0&quot;), UInt8(ascii: &quot;1&quot;), UInt8(ascii: &quot;2&quot;), UInt8(ascii: &quot;3&quot;), UInt8(ascii: &quot;4&quot;), UInt8(ascii: &quot;5&quot;), UInt8(ascii: &quot;6&quot;), UInt8(ascii: &quot;7&quot;), UInt8(ascii: &quot;8&quot;), UInt8(ascii: &quot;9&quot;), UInt8(ascii: &quot;a&quot;), UInt8(ascii: &quot;b&quot;), UInt8(ascii: &quot;c&quot;), UInt8(ascii: &quot;d&quot;), UInt8(ascii: &quot;e&quot;), UInt8(ascii: &quot;f&quot;) ] Higher-level constructs can regain some readability, let hexcodes = [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ].map{ UInt8(ascii: $0) } but may not be familiar to all users, and can come at a runtime cost. In addition, the init(ascii:) initializer only exists on UInt8. If you’re working with other types like Int8 (common when dealing with C APIs that take char), it is much more awkward. Consider scanning through a char* buffer as an UnsafeBufferPointer&lt;Int8&gt;: for scalar in int8buffer { switch scalar { case Int8(UInt8(ascii: &quot;a&quot;)) ... Int8(UInt8(ascii: &quot;f&quot;)): // lowercase hex letter case Int8(UInt8(ascii: &quot;A&quot;)) ... Int8(UInt8(ascii: &quot;F&quot;)): // uppercase hex letter case Int8(UInt8(ascii: &quot;0&quot;)) ... Int8(UInt8(ascii: &quot;9&quot;)): // hex digit default: // something else } } Transforming Unicode.Scalar literals also sacrifices compile-time guarantees. The statement let char: UInt8 = 1989 is a compile time error, whereas let char: UInt8 = .init(ascii: &quot;߅&quot;) is a run time error. ASCII scalars are inherently textual, so it should be possible to express them with a textual literal directly. Just as applying the String APIs runs counter to Swift’s stated design goals of safety and efficiency, requiring users to express basic data values in such a verbose way runs counter to our design goal of expressiveness. Integer character literals would provide benefits to String users. One of the future directions for String is to provide performance-sensitive or low-level users with direct access to code units. Having numeric character literals for use with this API is highly motivating. Furthermore, improving Swift’s bytestring ergonomics is an important part of our long term goal of expanding into embedded platforms. Proposed solution The most straightforward solution is to conform Swift’s integer types to ExpressibleByUnicodeScalarLiteral. Due to ABI constraints, it is not currently possible to add this conformance, so we will add the conformance implementations to the standard library, and allow users to “enable” to the feature by declaring this conformance in user code, for example: extension Int8: ExpressibleByUnicodeScalarLiteral { } Once the Swift ABI supports retroactive conformances, this conformance can be declared in the standard library, making it available by default. These integer conversions will only be valid for the ASCII range U+0 ..&lt; U+128; unicode scalar literals outside of that range will be invalid and will generate compile-time errors similar to the way we currently diagnose overflowing integer literals. This is a conservative approach, as allowing transparent unicode conversion to integer types carries encoding pitfalls users may not anticipate or easily understand. Because it is currently possible to call literal initializers at run-time, a run-time precondition failure will occur if a non-ASCII value is passed to the integer initializer. (We expect the compiler to elide this precondition check for “normal” invocations.) let u: Unicode.Scalar = &#39; u{FF}&#39; let i1: Int = &#39; u{FF}&#39; // compile-time error let i2: Int = .init(unicodeScalarLiteral: u) // run-time error ExpressibleBy… UnicodeScalarLiteral ExtendedGraphemeClusterLiteral StringLiteral UInt8:, … , Int: yes* (initially opt-in) no no Unicode.Scalar: yes no no Character: yes (inherited) yes no String: yes yes yes StaticString: yes yes yes Cells marked with an asterisk * indicate behavior that is different from the current language behavior. The ASCII range restriction will only apply to single-quote literals coerced to a Unicode.Scalar and (either statically or dynamically) converted to an integer type. Any valid Unicode.Scalar can be written as a single-quoted unicode scalar literal, and any valid Character can be written as a single-quoted character literal.   &#39;a&#39; &#39;é&#39; &#39;β&#39; &#39;𓀎&#39; &#39;👩‍✈️&#39; &quot;ab&quot; :String &quot;a&quot; &quot;é&quot; &quot;β&quot; &quot;𓀎&quot; &quot;👩‍✈️&quot; “ab” :Character &#39;a&#39; &#39;é&#39; &#39;β&#39; &#39;𓀎&#39; &#39;👩‍✈️&#39;   :Unicode.Scalar U+0061 U+00E9 U+03B2 U+1300E     :UInt32 97           :UInt16 97           :UInt8 97           :Int8 97           With these changes, the hex code example can be written much more naturally: let hexcodes: [UInt8] = [ &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ] for scalar in int8buffer { switch scalar { case &#39;a&#39; ... &#39;f&#39;: // lowercase hex letter case &#39;A&#39; ... &#39;F&#39;: // uppercase hex letter case &#39;0&#39; ... &#39;9&#39;: // hex digit default: // something else } } Choice of single quotes We propose to adopt the &#39;x&#39; syntax for all textual literal types up to and including ExtendedGraphemeClusterLiteral, but not including StringLiteral. These literals will be used to express integer types, Character, Unicode.Scalar, and types like UTF16.CodeUnit in the standard library. The default inferred literal type for let x = &#39;a&#39; will be Character, following the principle of least surprise. This also allows for a natural user-side syntax for differentiating methods overloaded on both Character and String. Use of single quotes for character/scalar literals is precedented in other languages, including C, Objective-C, C++, Java, and Rust, although different languages have slightly differing ideas about what a “character” is. We choose to use the single quote syntax specifically because it reinforces the notion that strings and character values are different: the former is a sequence, the later is an element. Character types also don’t support string literal interpolation, which is another reason to move away from double quotes. Single quotes in Swift, a historical perspective In Swift 1.0, single quotes were reserved for some yet-to-be determined syntactical purpose. Since then, pretty much all of the things that might have used single quotes have already found homes in other parts of the Swift syntactical space: syntax for multi-line string literals uses triple quotes (&quot;&quot;&quot;) string interpolation syntax uses standard double quote syntax. raw-mode string literals settled into the #&quot;&quot;# syntax. In current discussions around regex literals, most people seem to prefer slashes (/). Given that, and the desire for lightweight syntax for single chararcter syntax, and the precedent in other languages for characters, it is natural to use single quotes for this purpose. Existing double quote initializers for characters We propose deprecating the double quote literal form for Character and Unicode.Scalar types and slowly migrating them out of Swift. let c2 = &#39;f&#39; // preferred let c1: Character = &quot;f&quot; // deprecated Detailed Design The only standard library changes will be to extend FixedWidthInteger to have the init(unicodeScalarLiteral:) initializer required by ExpressibleByUnicodeScalarLiteral. Static ASCII range checking will be done in the type checker, dynamic ASCII range checking will be done by a runtime precondition. extension FixedWidthInteger { init(unicodeScalarLiteral: Unicode.Scalar) } The default inferred type for all single-quoted literals will be Character. This addresses a language pain point where declaring a Character requires type context. Source compatibility This proposal could be done in a way that is strictly additive, but we feel it is best to deprecate the existing double quote initializers for characters, and the UInt8.init(ascii:) initializer. Here is a specific sketch of a deprecation policy: Continue accepting these in Swift 5 mode with no change. Introduce the new syntax support into Swift 5.1. Swift 5.1 mode would start producing deprecation warnings (with a fixit to change double quotes to single quotes.) The Swift 5 to 5.1 migrator would change the syntax (by virtue of applying the deprecation fixits.) Swift 6 would not accept the old syntax. During the transition period, &quot;a&quot; will remain a valid unicode scalar literal, but attempting to initialize integer types with double-quoted ASCII literals will produce an error. let ascii:Int8 = &quot;a&quot; // error However, as this will only be possible in new code, and will produce a deprecation warning from the outset, this should not be a problem. Effect on ABI stability All changes except deprecating the UInt8.init(ascii:) initializer are either additive, or limited to the type checker, parser, or lexer. Removing UInt8.init(ascii:) would break ABI, but this is not necessary to implement the proposal, it’s merely housekeeping. Effect on API resilience None. Alternatives considered Integer initializers Some have proposed extending the UInt8(ascii:) initializer to other integer types (Int8, UInt16, … , Int). However, this forgoes compile-time validity checking, and entails a substantial increase in API surface area for questionable gain. Lifting the ASCII range restriction Some have proposed allowing any unicode scalar literal whose codepoint index does not overflow the target integer type to be convertible to that integer type. Consensus was that this is an easy source of unicode encoding bugs, and provides little utility to the user. If people change their minds in the future, this restriction can always be lifted in a source and ABI compatible way. Single-quoted ASCII strings Some have proposed allowing integer array types to be expressible by multi-character ASCII strings such as &#39;abcd&#39;. We consider this to be out of scope of this proposal, as well as unsupported by precedent in C and related languages.",
    "url": "http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html",
    "relUrl": "/docs/2019-08-26-0243-codepoint-and-character-literals.html"
  },
  "243": {
    "id": "243",
    "title": "SE-0244 Opaque Result Types",
    "content": "Opaque Result Types Proposal: SE-0244 Authors: Doug Gregor, Joe Groff Review Manager: Ben Cohen Status: Active review (April 11 - April 17, 2019) Implementation: apple/swift#22072 Toolchain: https://github.com/apple/swift/pull/21137#issuecomment-468118328 Previous revisions: (1) Previous review threads: https://forums.swift.org/t/se-0244-opaque-result-types/21252 Introduction This proposal is the first part of a group of changes we’re considering in a design document for improving the UI of the generics model. We’ll try to make this proposal stand alone to describe opaque return types, their design, and motivation, but we also recommend reading the design document for more in-depth exploration of the relationships among other features we’re considering. We’ll link to relevant parts of that document throughout this proposal. This specific proposal addresses the problem of type-level abstraction for returns. Many libraries consist of composable generic components. For example, a graphics library might provide primitive types for basic shapes: protocol Shape { func draw(to: Surface) func collides&lt;Other: Shape&gt;(with: Other) -&gt; Bool } struct Rectangle: Shape { /* ... */ } struct Circle: Shape { /* ... */ } along with composable transformations to combine and modify primitive shapes into more complex ones: struct Union&lt;A: Shape, B: Shape&gt;: Shape { var a: A, b: B // ... } struct Intersect&lt;A: Shape, B: Shape&gt;: Shape { var a: A, b: B // ... } struct Transformed&lt;S: Shape&gt;: Shape { var shape: S var transform: Matrix3x3 // ... } One could compose these transformations by using the existential type Shape instead of generic arguments, but doing so would imply more dynamism and runtime overhead than may be desired. If we directly compose the generic containers, maintaining the concrete types, then generic specialization can more readily optimize together the composed operations together, and the type system can also be used . A game or graphics app may want to define objects in terms of their shapes: protocol GameObject { // The shape of the object associatedtype Shape: Shapes.Shape var shape: Shape { get } } However, users of the GameObject protocol would now be burdened with writing out long, explicit types for their shapes: struct EightPointedStar: GameObject { var shape: Union&lt;Rectangle, Transformed&lt;Rectangle&gt;&gt; { return Union(Rectangle(), Transformed(Rectangle(), by: .fortyFiveDegrees) } } This is unsightly because it’s verbose, but it’s also not very helpful for someone reading this declaration. The exact return type doesn’t really matter, only the fact that it conforms to Shape. Spelling out the return type also effectively reveals most of the implementation of shape, making the declaration brittle; clients of EightPointedStar could end up relying on its exact return type, making it harder if the author of EightPointedStar wants to change how they implement its shape, such as if a future version of the library provides a generic NPointedStar primitive. Right now, if you want to abstract the return type of a declaration from its signature, existentials or manual type erasure are your only options, and these come with tradeoffs that are not always acceptable. Proposed solution Instead of declaring the specific return type of EightPointedStar.shape’s current implementation, all we really want to say is that it returns something that conforms to Shape. We propose the syntax some Protocol: struct EightPointedStar: GameObject { var shape: some Shape { return Union(Rectangle(), Transformed(Rectangle(), by: .fortyFiveDegrees) } } to declare that an EightPointedStar has some Shape without having to specify exactly what shape that is. The underlying concrete type is hidden, and can even change from one version of the library to the next without breaking those clients, because the underlying type identity is never exposed to clients. Unlike an existential, though, clients still have access to the type identity. This allows the library to provide a potentially-more-efficient design that leverages Swift’s type system, without expanding the surface area of the library or making implementors of the library’s protocols rely on exposing verbose implementation types. An opaque type behaves like a “reverse generic”. In a traditional generic function, the caller decides what types get bound to the callee’s generic arguments: func generic&lt;T: Shape&gt;() -&gt; T { ... } let x: Rectangle = generic() // T == Rectangle, chosen by caller let x: Circle = generic() // T == Circle, chosen by caller An opaque return type can be thought of as putting the generic signature “to the right” of the function arrow; instead of being a type chosen by the caller that the callee sees as abstracted, the return type is chosen by the callee, and comes back to the caller as abstracted: // Strawman syntax func reverseGeneric() -&gt; &lt;T: Shape&gt; T { return Rectangle(...) } let x = reverseGeneric() // abstracted type chosen by reverseGeneric&#39;s implementation Reverse generics are a great mental model for understanding opaque return types, but the notation is admittedly awkward. We expect the common use case for this feature to be a single return value behind a set of protocol conformances, so we’re proposing to start with the more concise some Shape syntax: // Proposed syntax func reverseGeneric() -&gt; some Shape { return Rectangle(...) } let x = reverseGeneric() // abstracted type chosen by reverseGeneric&#39;s implementation Following the some keyword is a set of constraints on the implicit generic type variable: a class, protocol, Any, AnyObject, or some composition thereof (joined with &amp;). This some Protocol sugar can be generalized to generic arguments and structural positions in return types in the future, and we could also eventually support a fully general generic signature for opaque returns. To enable incremental progress on the implementation, we propose starting by only supporting the some syntax in return position. Type identity Generics give us an idea of what to expect from opaque return types. The return values from different calls to the same function have the same return type, like two variables of the same generic argument type: func foo&lt;T: Equatable&gt;(x: T, y: T) -&gt; some Equatable { let condition = x == y // OK to use ==, x and y are the same generic type T return condition ? 1738 : 679 } let x = foo(&quot;apples&quot;, &quot;bananas&quot;) let y = foo(&quot;apples&quot;, &quot;some fruit nobody&#39;s ever heard of&quot;) print(x == y) // also OK to use ==, x and y are the same opaque return type If the opaque type exposes associated types, those associated types’ identities are also maintained. This allows the full API of protocols like the Collection family to be used: func makeMeACollection&lt;T&gt;(with: T) -&gt; some RangeReplaceableCollection &amp; MutableCollection { ... } var c = makeMeACollection(with: 17) c.append(c.first!) // ok: it&#39;s a RangeReplaceableCollection c[c.startIndex] = c.first! // ok: it&#39;s a MutableCollection print(c.reversed()) // ok: all Collection/Sequence operations are available func foo&lt;C: Collection&gt;(_ : C) { } foo(c) // ok: C inferred to opaque result type of makeMeACollection&lt;Int&gt; Moreover, opaque result types preserve their identity when composed into other types, such as when forming a collection of the results: var cc = [c] cc.append(c) // ok: cc&#39;s Element == the result type of makeMeACollection&lt;Int&gt; var c2 = makeMeACollection(with: 38) cc.append(c2) // ok: Element == the result type of makeMeACollection&lt;Int&gt; The opaque return type can however depend on the generic arguments going into the function when it’s called, so the return types of the same function invoked with different generic arguments are different: var d = makeMeACollection(with: &quot;seventeen&quot;) c = d // error: types or makeMeACollection&lt;Int&gt; and makeMeACollection&lt;String&gt; are different Like a generic argument, the static type system does not consider the opaque type to be statically equivalent to the type it happens to be bound to: func foo() -&gt; some BinaryInteger { return 219 } var x = foo() x = 912 // error: Int is not known to be the same as the return type as foo() However, one can inspect an opaque type’s underlying type at runtime using dynamic casting: if let x = foo() as? Int { print(&quot;It&#39;s an Int, (x) n&quot;) } else { print(&quot;Guessed wrong&quot;) } In other words, like generic arguments, opaque result types are only opaque to the static type system. They don’t have an independent existence at runtime. Implementing a function returning an opaque type The implementation of a function returning an opaque type must return a value of the same concrete type T from each return statement, and T must meet all of the constraints stated on the opaque type. For example: protocol P { } extension Int : P { } extension String : P { } func f1() -&gt; some P { return &quot;opaque&quot; } func f2(i: Int) -&gt; some P { // ok: both returns produce Int if i &gt; 10 { return i } return 0 } func f2(flip: Bool) -&gt; some P { if flip { return 17 } return &quot;a string&quot; // error: different return types Int and String } func f3() -&gt; some P { return 3.1419 // error: Double does not conform to P } func f4() -&gt; some P { let p: P = &quot;hello&quot; return p // error: protocol type P does not conform to P } func f5() -&gt; some P { return f1() // ok: f1() returns an opaque type that conforms to P } protocol Initializable { init() } func f6&lt;T: P &amp; Initializable&gt;(_: T.Type) -&gt; some P { return T() // ok: T will always be a concrete type conforming to P } These rules guarantee that there is a single concrete type produced by any call to the function. The concrete type can depend on the generic type arguments (as in the f6() example), but must be consistent across all return statements. Note that recursive calls are allowed, and are known to produce a value of the same concrete type, but that the concrete type itself is not known: func f7(_ i: Int) -&gt; some P { if i == 0 { return f7(1) // ok: returning our own opaque result type } else if i &lt; 0 { let result: Int = f7(-i) // error: opaque result type of f7() is not convertible to Int return result } else { return 0 // ok: grounds the recursion with a concrete type } } Of course, there must be at least one return statement that provides a concrete type. Note that a function cannot call itself recursively in a way that forms a type parameterized on the function’s own opaque result type, since this would mean that the opaque type is infinitely recursive: struct Wrapper&lt;T: P&gt;: P { var value: T } func f8(_ i: Int) -&gt; some P { // invalid; this binds the opaque result type to Wrapper&lt;return type of f8&gt;, // which is Wrapper&lt;Wrapper&lt;return type of f8&gt;&gt;, which is // Wrapper&lt;Wrapper&lt;Wrapper&lt;...&gt;&gt;&gt;... return Wrapper(f8(i + 1)) } A function with an opaque result type is also required to have a return statement even if it does not terminate: func f9() -&gt; some P { fatalError(&quot;not implemented&quot;) // error: no return statement to get opaque type } This requirement is necessary because, even though f9’s return value cannot be reached, the return type of f9 can still be propagated by local type inference or generic instantiation in ways that don’t require evaluating f9, so a type for f9 must be available: let delayedF9 = { f9() } // closure has type () -&gt; return type of f9 We can’t necessarily default the underlying type to Never, since Never may not conform to the constraints of the opaque type. If Never does conform, and it is desired as the underlying return type, that can be written explicitly as a return statement: extension Never: P {} func f9b() -&gt; some P { return fatalError(&quot;not implemented&quot;) // OK, explicitly binds return type to Never } This restriction on non-terminating functions could be something we lift in the future, by synthesizing bottom-type conformances to the protocols required by the opaque type. We leave that as a future extension. Properties and subscripts Opaque result types can also be used with properties and subscripts: struct GameObject { var shape: some Shape { /* ... */ } } For computed properties, the concrete type is determined by the return statements in the getter. Opaque result types can also be used in stored properties that have an initializer, in which case the concrete type is the type of the initializer: let strings: some Collection = [&quot;hello&quot;, &quot;world&quot;] Properties and subscripts of opaque result type can be mutable. For example: // Module A public protocol P { mutating func flip() } private struct Witness: P { mutating func flip() { /* ... */ } } public var someP: some P = Witness() // Module B import A someP.flip() // ok: flip is a mutating function called on a variable With a subscript or a computed property, the type of the value provided to the setter (e.g., newValue) is determined by the return statements in the getter, so the type is consistent and known only to the implementation of the property or subscript. For example: protocol P { } private struct Impl: P { } public struct Vendor { private var storage: [Impl] = [/* ... */] public var count: Int { return storage.count } public subscript(index: Int) -&gt; some P { get { return storage[index] } set (newValue) { storage[index] = newValue } } } var vendor = Vendor() vendor[0] = vendor[2] // ok: can move elements around Associated type inference While one can use type inference to declare variables of the opaque result type of a function, there is no direct way to name the opaque result type: func f1() -&gt; some P { /* ... */ } let vf1 = f1() // type of vf1 is the opaque result type of f1() However, type inference can deduce an opaque result type as the associated type of the protocol: protocol GameObject { associatedtype ObjectShape: Shape var shape: ObjectShape } struct Player: GameObject { var shape: some Shape { /* ... */ } // infers typealias Shape = opaque result type of Player.shape } let pos: Player.ObjectShape // ok: names the opaque result type of S.someValue() pos = Player().shape // ok: returns the same opaque result type Note that having a name for the opaque result type still doesn’t give information about the underlying concrete type. For example, the only way to create an instance of the type S.SomeType is by calling S.someValue(). Associated type inference can only infer an opaque result type for a non-generic requirement, because the opaque type is parameterized by the function’s own generic arguments. For instance, in: protocol P { associatedtype A: P func foo&lt;T: P&gt;(x: T) -&gt; A } struct Foo: P { func foo&lt;T: P&gt;(x: T) -&gt; some P { return x } } there is no single underlying type to infer A to, because the return type of foo is allowed to change with T. Detailed design Grammar of opaque result types The grammatical production for opaque result types is straightforward: type ::= opaque-type opaque-type ::= &#39;some&#39; type The type following the &#39;some&#39; keyword is semantically restricted to be a class or existential type, meaning it must consist only of Any, AnyObject, protocols, or base classes, possibly composed using &amp;. This type is used to describe the constraints on the implicit “reverse generic” parameter. Restrictions on opaque result types Opaque result types can only be used as the result type of a function, the type of a variable, or the result type of a subscript. The opaque type must be the entire return type of the function, For example, one cannot return an optional opaque result type: func f(flip: Bool) -&gt; (some P)? { // error: `some P` is not the entire return type // ... } This restriction could be lifted in the future. More fundamentally, opaque result types cannot be used in the requirements of a protocol: protocol Q { func f() -&gt; some P // error: cannot use opaque result type within a protocol } Associated types provide a better way to model the same problem, and the requirements can then be satisfied by a function that produces an opaque result type. (There might be an interesting shorthand feature here, where using some in a protocol requirement implicitly introduces an associated type, but we leave that for future language design to explore.) Similarly to the restriction on protocols, opaque result types cannot be used for a non-final declaration within a class: class C { func f() -&gt; some P { /* ... */ } // error: cannot use opaque result type with a non-final method final func g() -&gt; some P { /* ... */ } // ok } This restriction could conceivably be lifted in the future, but it would mean that override implementations would be constrained to returning the same type as their super implementation, meaning they must call super.method() to produce a valid return value. Uniqueness of opaque result types Opaque result types are uniqued based on the function/property/subscript and any generic type arguments. For example: func makeOpaque&lt;T&gt;(_: T.Type) -&gt; some Any { /* ... */ } var x = makeOpaque(Int.self) x = makeOpaque(Double.self) // error: &quot;opaque&quot; type from makeOpaque&lt;Double&gt; is distinct from makeOpaque&lt;Int&gt; This includes any generic type arguments from outer contexts, e.g., extension Array where Element: Comparable { func opaqueSorted() -&gt; some Sequence { /* ... */ } } var x = [1, 2, 3]. opaqueSorted() x = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].opaqueSorted() // error: opaque result types for [Int].opaqueSorted() and [String].opaqueSorted() differ Implementation strategy From an implementation standpoint, a client of a function with an opaque result type needs to treat values of that result type like any other resilient value type: its size, alignment, layout, and operations are unknown. However, when the body of the function is known to the client (e.g., due to inlining or because the client is in the same compilation unit as the function), the compiler’s optimizer will have access to the specific concrete type, eliminating the indirection cost of the opaque result type. Source compatibility Opaque result types are purely additive. They can be used as a tool to improve long-term source (and binary) stability, by not exposing the details of a result type to clients. If opaque result types are retroactively adopted in a library, it would initially break source compatibility (e.g., if types like EnumeratedSequence, FlattenSequence, and JoinedSequence were removed from the public API) but could provide longer-term benefits for both source and ABI stability because fewer details would be exposed to clients. There are some mitigations for source compatibility, e.g., a longer deprecation cycle for the types or overloading the old signature (that returns the named types) with the new signature (that returns an opaque result type). Effect on ABI stability Opaque result types are an ABI-additive feature, so do not in and of themselves impact existing ABI. However, additional runtime support is however needed to support instantiating opaque result types across ABI boundaries, meaning that a Swift 5.1 runtime will be required to deploy code that uses opaque types in public API. Also, changing an existing API to make use of opaque result types instead of returning concrete types would be an ABI-breaking change, so one of the source compatibility mitigations mentioned above would also need to be deployed to maintain ABI compatibility with existing binary clients. Effect on API resilience Opaque result types are part of the result type of a function/type of a variable/element type of a subscript. The requirements that describe the opaque result type cannot change without breaking the API/ABI. However, the underlying concrete type can change from one version to the next without breaking ABI, because that type is not known to clients of the API. One notable exception to the above rule is @inlinable: an @inlinable declaration with an opaque result type requires that the underlying concrete type be public or @usableFromInline. Moreover, the underlying concrete type cannot be changed without breaking backward compatibility, because it’s identity has been exposed by inlining the body of the function. That makes opaque result types somewhat less compelling for the compactMap example presented in the introduction, because one cannot have compactMap be marked @inlinable with an opaque result type, and then later change the underlying concrete type to something more efficient. We could allow an API originally specified using an opaque result type to later evolve to specify the specific result type. The result type itself would have to become visible to clients, and this might affect source compatibility, but (mangled name aside) such a change would be resilient. Rust’s impl Trait The proposed Swift feature is largely inspired by Rust’s impl Trait language feature, described by Rust RFC 1522 and extended by Rust RFC 1951. There are only a small number of differences between this feature as expressed in Swift vs. Rust’s impl Trait as described in RFC 1522: Swift’s need for a stable ABI necessitates translation of opaque result types as resilient types, which is unnecessary in Rust’s model, where the concrete type can always be used for code generation. Swift’s opaque result types are fully opaque, because Swift doesn’t have pass-through protocols like Rust’s Send trait, which simplifies the type checking problem slightly. Due to associated type inference, Swift already has a way to “name” an opaque result type in some cases. Alternatives considered Return type inference Part of the motivation of this feature is to avoid having to spell out elaborate return types. This proposal achieves that for types that can be abstracted behind protocols, but in doing so introduces complexity in the form of a new kind of “reverse generic” type. Meanwhile, there are kinds of verbose return types that can’t be effectively hidden behind protocol interfaces, like deeply nested collections: func jsonBlob() -&gt; [String: [String: [[String: Any]]]] { ... } We could theoretically address the verbosity problem in its full generality and without introducing new type system features by allowing return types to be inferred, like C++14’s or D’s auto return types: func jsonBlob() -&gt; auto { ... } Although this would superficially address the problem of verbose return types, that isn’t really the primary problem this proposal is trying to solve, which is to allow for more precise description of interfaces. The case of a verbose composed generic adapter type is fundamentally different from a deeply nested collection; in the former case, the concrete type is not only verbose, but it’s largely irrelevant, because clients should only care about the common protocols the type conforms to. For a nested collection, the verbose type is the interface: the full type is necessary to fully describe how someone interacts with that collection. Return type inference also has several undesirable traits as a language feature: It violates separate compilation of function bodies, since the body of the function must be type-checked to infer the return type. Swift already has type inference for stored property declarations, and we consider this a mistake, since it has been an ongoing source of implementation complexity and performance problems due to the need to type-check the property initializer across files. This is not a problem for opaque return types, because callers only interface with the declaration through the opaque type’s constraints. Code can be compiled against a function with an opaque return type without having to know what the underlying type is; it is “just an optimization” to specialize away the opaque type when the underlying type is known. Similarly, inferred return types wouldn’t provide any semantic abstraction once the type is inferred. Code that calls the function would still see the full concrete type, allowing clients to rely on unintentional details of the concrete type, and the implementation would be bound by ABI and source compatibility constraints if it needed to change the return type. Module interfaces and documentation would also still expose the full return type, meaning they don’t get the benefit of the shorter notation. We see opaque return types as not only sugar for syntactically heavy return types, but also a tool for writing clearer, more resilient APIs. Return type inference would achieve the former but not the latter, while also introducing another compile-time performance footgun into the language. Syntax for opaque return types This proposal suggests the word some to introduce opaque return types, since it has the right connotation by analogy to Any which is used to describe dynamically type-erased containers (and has been proposed to be a general way of referring to existential types)–a function that has an opaque return type returns some specific type that conforms to the given constraints, whereas an existential can contain any type dynamically at any point in time. The spelling would also work well if generalized to implicit generic arguments in the future. There are nonetheless reasonable objections to this keyword: some is already used in the language as one of the case names for Optional; it is rare to need to spell Optional.some or .some explicitly, but it could nonetheless introduce confusion. In spoken language, some type and sum type sound the same. swift some could be a difficult term to search for. (However, on Google it currently gives reasonable results about Optional in Swift.) Another obvious candidate is opaque, following the title of this very proposal. The word “opaque” is itself an overloaded term with existing meaning in many domains, which is unfortunate: protocol Shape {} func translucentRectangle() -&gt; opaque Shape { /* ... */ } The term “opaque” is also fairly heavily overloaded in the Swift implementation (albeit not so much the source-level programming model). It may be that there is a better term, such as “abstract return types”, to refer to this feature in its entirety. opaque is also not as good a fit for generalization to implicit generic arguments. In swift-evolution discussion, several other names came up, including: func translucentRectangle() -&gt; unspecified Shape { ... } func translucentRectangle() -&gt; anyOld Shape { ... } func translucentRectangle() -&gt; hazyButSpecific Shape { ... } func translucentRectangle() -&gt; someSpecific Shape { ... } func translucentRectangle() -&gt; someConcrete Shape { ... } func translucentRectangle() -&gt; nonspecific Shape { ... } func translucentRectangle() -&gt; unclear Shape { ... } func translucentRectangle() -&gt; arbitrary Shape { ... } func translucentRectangle() -&gt; someThing Shape { ... } func translucentRectangle() -&gt; anonymized Shape { ... } func translucentRectangle() -&gt; nameless Shape { ... } In our opinion, most of these are longer and not much clearer, and many wouldn’t work well as generalized sugar for arguments and returns. Opaque type aliases As proposed, opaque result types are tied to a specific declaration. They offer no way to state that two related APIs with opaque result types produce the same underlying concrete type. The idea of “reverse generics” could however be decoupled from function declarations, if you could write an “opaque typealias” that describes the abstracted interface to a type, while giving it a name, then you could express that relationship across declarations. For example: public typealias LazyCompactMapCollection&lt;Elements, ElementOfResult&gt; -&gt; &lt;C: Collection&gt; C where C.Element == ElementOfResult = LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt; In this strawman syntax, the “reverse generic” signature following the -&gt; is how clients see LazyCompactMapCollection. The underlying concrete type, spelled after the =, is visible only to the implementation (in some way that would have to be designed). With this feature, multiple APIs could be described as returning a LazyCompactMapCollection: extension LazyMapCollection { public func compactMap&lt;U&gt;(_ transform: @escaping (Element) -&gt; U?) -&gt; LazyCompactMapCollection&lt;Base, U&gt; { // ... } public func filter(_ isIncluded: @escaping (Element) -&gt; Bool) -&gt; LazyCompactMapCollection&lt;Base, Element&gt; { // ... } } From the client perspective, both APIs would return the same type, but the specific underlying type would not be known. var compactMapOp = values.lazy.map(f).compactMap(g) if Bool.random() { compactMapOp = values.lazy.map(f).filter(h) // ok: both APIs have the same type } This would be a great feature to explore as a future direction, since it has some important benefits relative to opaque result types. However, we don’t think it’s the best place to start with this feature. Compare a declaration using opaque typealiases like: func foo&lt;T&gt;() -&gt; ReturnTypeOfFoo&lt;T&gt; { return 1 } opaque typealias ReturnTypeOfFoo&lt;T&gt; -&gt; &lt;U: P&gt; P = Int to one using opaque return types: func foo&lt;T&gt;() -&gt; some P { return 1 } The one using opaque typealiases requires an intermediate name, which one must read and follow to its definition to understand the interface of foo. The definition of ReturnTypeOfFoo also needs to spell out the underlying concrete return type of foo, and the two declarations are tightly coupled; a change to foo will likely require a lockstep change to ReturnTypeOfFoo. We expect that, in the common use case for this feature, the types being abstracted are going to be tied to specific declarations, and there wouldn’t be any better name to really give than “return type of (decl),” so making opaque type aliases the only way of expressing return type abstraction would introduce a lot of obscuring boilerplate. Future Directions As noted in the introduction, this proposal is the first part of a group of changes we’re considering in a design document for improving the UI of the generics model. That design document lays out a number of related directions we can go based on the foundation establised by this proposal, including: allowing fully generalized reverse generics generalizing the some syntax as shorthand for generic arguments, and allowing structural use in generic returns more compact constraint syntax that can also work with generalized existentials introducing any as a dual to some for explicitly spelling existential types We recommend reading that document for a more in-depth exploration of these related ideas.",
    "url": "http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html",
    "relUrl": "/docs/2019-08-26-0244-opaque-result-types.html"
  },
  "244": {
    "id": "244",
    "title": "SE-0245 Add an Array Initializer with Access to Uninitialized Storage",
    "content": "Add an Array Initializer with Access to Uninitialized Storage Proposal: SE-0245 Author: Nate Cook Review Manager: Ted Kremenek Status: Implemented (Swift 5.1) Previous Proposal: SE-0223 Implementation: apple/swift#23134 Bug: SR-3087 Introduction This proposal suggests a new initializer for Array and ContiguousArray that provides access to an array’s uninitialized storage buffer. Swift-evolution thread: https://forums.swift.org/t/array-initializer-with-access-to-uninitialized-buffer/13689 Motivation Some collection operations require working on a fixed-size buffer of uninitialized memory. For example, one O(n) algorithm for performing a stable partition of an array is as follows: Create a new array the same size as the original array. Iterate over the original array, copying matching elements to the beginning of the new array and non-matching elements to the end. When finished iterating, reverse the slice of non-matching elements. Unfortunately, the standard library provides no way to create an array of a particular size without initializing every element. Even if we avoid initialization by manually allocating the memory using an UnsafeMutableBufferPointer, there’s no way to convert that buffer into an array without copying the contents. There simply isn’t a way to implement this particular algorithm with maximum efficiency in Swift. We also see this limitation when working with C APIs that fill a buffer with an unknown number of elements and return the count. The workarounds are the same as above: either initialize an array before passing it or copy the elements from an unsafe mutable buffer into an array after calling. Proposed solution Add a new Array initializer that lets a program work with an uninitialized buffer. The new initializer takes a closure that operates on an UnsafeMutableBufferPointer and an inout count of initialized elements. This closure has access to the uninitialized contents of the newly created array’s storage, and must set the intialized count of the array before exiting. var myArray = Array&lt;Int&gt;(unsafeUninitializedCapacity: 10) { buffer, initializedCount in for x in 1..&lt;5 { buffer[x] = x } buffer[0] = 10 initializedCount = 5 } // myArray == [10, 1, 2, 3, 4] With this new initializer, it’s possible to implement the stable partition as an extension to the Collection protocol, without any unnecessary copies: func stablyPartitioned(by belongsInFirstPartition: (Element) throws -&gt; Bool) rethrows -&gt; [Element] { return try Array&lt;Element&gt;(unsafeUninitializedCapacity: count) { buffer, initializedCount in var low = buffer.baseAddress! var high = low + buffer.count do { for element in self { if try belongsInFirstPartition(element) { low.initialize(to: element) low += 1 } else { high -= 1 high.initialize(to: element) } } let highIndex = high - buffer.baseAddress! buffer[highIndex...].reverse() initializedCount = buffer.count } catch { let lowCount = low - buffer.baseAddress! let highCount = (buffer.baseAddress! + buffer.count) - high buffer.baseAddress!.deinitialize(count: lowCount) high.deinitialize(count: highCount) throw error } } } This also facilitates efficient interfacing with C functions. For example, suppose you wanted to wrap the function vDSP_vsadd in a Swift function that returns the result as an array. This function requires you give it an unsafe buffer into which it writes results. This is easy to do with an array, but you would have to initialize the array with zeroes first. With a function like vDSP_vsadd, this unnecessary zeroing out would eat into the slight speed edge that the function gives you, defeating the point. This can be neatly solved by using the proposed initializer: extension Array where Element == Float { func dspAdd(scalar: Float) -&gt; [Float] { let n = self.count return self.withUnsafeBufferPointer { buf in var scalar = scalar return Array&lt;Float&gt;(unsafeUninitializedCapacity: n) { rbuf, count in vDSP_vsadd(buf.baseAddress!, 1, &amp;scalar, rbuf.baseAddress!, 1, UInt(n)) count = n } } } } Detailed design The new initializer is added to both Array and ContiguousArray. /// Creates an array with the specified capacity, then calls the given closure /// with a buffer covering the array&#39;s uninitialized memory. /// /// The closure must set its second parameter to a number `c`, the number /// of elements that are initialized. The memory in the range `buffer[0..&lt;c]` /// must be initialized at the end of the closure&#39;s execution, and the memory /// in the range `buffer[c...]` must be uninitialized. This postcondition /// must hold even if the `initializer` closure throws an error. /// /// - Note: While the resulting array may have a capacity larger than the /// requested amount, the buffer passed to the closure will cover exactly /// the requested number of elements. /// /// - Parameters: /// - unsafeUninitializedCapacity: The number of elements to allocate space /// for in the new array. /// - initializer: A closure that initializes elements and sets the count of /// the new array. /// - Parameters: /// - buffer: A buffer covering uninitialized memory with room /// for the specified number of elements. /// - initializedCount: The count of the array&#39;s initialized elements. /// After initializing any elements inside `initializer`, update /// `initializedCount` with the new count for the array. public init( unsafeUninitializedCapacity: Int, initializingWith initializer: ( _ buffer: inout UnsafeMutableBufferPointer&lt;Element&gt;, _ initializedCount: inout Int ) throws -&gt; Void ) rethrows Specifying a capacity The initializer takes the specific capacity that a user wants to work with as a parameter. The buffer passed to the closure has a count that is exactly the same as the specified capacity, even if the ultimate capacity of the new array is larger. Guarantees after throwing If the closure parameter to the initializer throws, the initializedCount value at the time an error is thrown is assumed to be correct. This means that a user who needs to throw from inside the closure has one of two options. Before throwing, they must: deinitialize any newly initialized instances, or update initializedCount to the correct count. In either case, the postconditions that buffer[0..&lt;initializedCount] are initialized and buffer[initializedCount...] are deinitialized still hold. Naming considerations The argument labels on the initializer are definitely a little on the long side! There are two important details of this API that led to the proposed spelling. First, the initializer is unsafe, in that the user must be sure to properly manage the memory addressed by the closure’s buffer pointer parameter. Second, the initializer provides access to the array’s uninitialized storage, unlike the other Array.withUnsafe... methods that already exist. Because trailing closures are commonly used, it’s important to include those terms in the initial argument label, such that they’re always visible at the use site. Unused terminology This proposal leaves out wording that would reference two other relevant concepts: reserving capacity: Arrays currently have a reserveCapacity(_:) method, which is somewhat akin to the first step of the initializer. However, that method is used for the sake of optimizing performance when adding to an array, rather than providing direct access to the array’s capacity. In fact, as part of the RangeReplaceableCollection protocol, that method doesn’t even require any action to be taken by the targeted type. For those reasons, the idea of “reserving” capacity doesn’t seem as appropriate as providing a specific capacity that will be used. unmanaged: The proposed initializer is unusual in that it converts the lifetime management of manually initialized instances to be automatically managed, as elements of an Array instance. The only other type that performs this kind of conversion is Unmanaged, which is primarily used at the border of Swift and C interoperability, particularly with Core Foundation. Additionally, Unmanaged can be used to maintain and manage the lifetime of an instance over a long period of time, while this initializer performs the conversion as soon as the closure executes. As above, this term doesn’t seem appropriate for use with this new API. Source compatibility This is an additive change to the standard library, so there is no effect on source compatibility. Effect on ABI stability These initializers will need to be gated by OS versions on platforms that ship the standard library in the OS. Effect on API resilience The additional APIs will be a permanent part of the standard library, and will need to remain public API. Alternatives considered Returning the new count from the initializer closure An earlier proposal included a method that allowed for access to the uninitialized spare capacity of an array that also contained initialized elements. Handling cases where the passed-in closure throws when there are existing initialized elements is more complicated than in the initializer case, and the proposal was returned for revision. Given the utilility and need of the initializer part of the proposal is far greater, these two proposals are being split out to unblock progress on that. An earlier proposal had the initializer’s closure return the new count, instead of using an inout parameter. This proposal uses the parameter instead, so that the method and initializer use the same closure type. In addition, the throwing behavior described above requires that the initialized count be set as an inout parameter instead of as a return value. Not every Element type can be trivially initialized, so a user that deinitializes some elements and then needs to throw an error would be stuck. (This is only an issue with the mutating method.) Removing the throws capability from the closure would solve this problem and simplify the new APIs’ semantics, but would be inconsistent with the other APIs in this space and would make them more difficult to use as building blocks for higher-level operations like stablyPartitioned(by:). Creating an array from a buffer An Array initializer that simply converts an UnsafeMutableBufferPointer into an array’s backing storage seems like it would be another solution. However, an array’s storage includes information about the count and capacity at the beginning of its buffer, so an UnsafeMutableBufferPointer created from scratch isn’t usable. Addendum You can Try This At Home™ with this extension, which provides the semantics (but not the copy-avoiding performance benefits) of the proposed additions: extension Array { public init( unsafeUninitializedCapacity: Int, initializingWith initializer: ( _ buffer: inout UnsafeMutableBufferPointer&lt;Element&gt;, _ initializedCount: inout Int ) throws -&gt; Void ) rethrows { var buffer = UnsafeMutableBufferPointer&lt;Element&gt; .allocate(capacity: unsafeUninitializedCapacity) defer { buffer.deallocate() } var count = 0 do { try initializer(&amp;buffer, &amp;count) } catch { buffer.baseAddress!.deinitialize(count: count) throw error } self = Array(buffer[0..&lt;count]) } }",
    "url": "http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html",
    "relUrl": "/docs/2019-08-26-0245-array-uninitialized-initializer.html"
  },
  "245": {
    "id": "245",
    "title": "SE-0246 Generic Math(s) Functions",
    "content": "Generic Math(s) Functions Proposal: SE-0246 Author: Stephen Canon Review Manager: John McCall Status: Accepted with modifications Implementation: apple/swift#23140 Previous Revision: 1 2 Review: (review) (acceptance) This proposal was accepted with modifications which have not yet been applied to this document. Please see the acceptance post for further details. Introduction This proposal introduces two new protocols to the standard library: ElementaryFunctions and Real. These protocols combine to provide “basic math functions” in generic contexts for floating-point and SIMD types, and provide a path to extend that functionality to planned complex types in the future. Swift Evolution Pitch thread Motivation BinaryFloatingPoint (and the protocols it refines) provides a powerful set of abstractions for writing numerical code, but it does not include the transcendental operations defined by the C math library, which are instead imported by the platform overlay as a set of overloaded concrete free functions. There are two deficiencies with the current approach. First, what you need to import to get this functions varies depending on platform, forcing the familiar but awkward #if dance: #if canImport(Darwin) import Darwin #elseif canImport(GlibC) ... This shouldn’t be required for functionality that is intended to be available on all platforms. Second, these bindings are overloaded for the various concrete BinaryFloatingPoint types, but there’s no way to use them generically. Suppose we want to implement the “sigmoid” function generically: func sigmoid&lt;T&gt;(_ x: T) -&gt; T where T: FloatingPoint { return 1/(1 + exp(-x)) } This doesn’t work, because exp is not available on the FloatingPoint protocol. Currently, you might work around this limitation by doing something like: func sigmoid&lt;T&gt;(_ x: T) -&gt; T where T: FloatingPoint { return 1/(1 + T(exp(-Double(x)))) } but that’s messy, inefficient if T is less precise than Double, and inaccurate if T is more precise than Double. We can and should do better in Swift. With the changes in this proposal, the full implementation would become: import Math func sigmoid&lt;T&gt;(_ x: T) -&gt; T where T: Real { return 1/(1 + exp(-x)) } Proposed solution There are four pieces of this proposal: first, we introduce the protocol ElementaryFunctions: public protocol ElementaryFunctions { /// The cosine of `x`. static func cos(_ x: Self) -&gt; Self /// The sine of `x`. static func sin(_ x: Self) -&gt; Self /// The tangent of `x`. static func tan(_ x: Self) -&gt; Self ... } Conformance to this protocol means that the elementary functions are available as static functions: (swift) Float.exp(1) // r0 : Float = 2.7182817 (For the full set of functions provided, see Detailed Design below). All of the standard library FloatingPoint types conform to ElementaryFunctions; a future Complex type would also conform. SIMD types do not conform themselves, but the operations are defined on them when their scalar type conforms to the protocol. The second piece of the proposal is the protocol Real: public protocol Real: FloatingPoint, ElementaryFunctions { /// `atan(y/x)` with quadrant fixup. /// /// There is an infinite family of angles whose tangent is `y/x`. /// `atan2` selects the representative that is the angle between /// the vector `(x, y)` and the real axis in the range [-π, π]. static func atan2(y: Self, x: Self) -&gt; Self /// The error function evaluated at `x`. static func erf(_ x: Self) -&gt; Self /// The complimentary error function evaluated at `x`. static func erfc(_ x: Self) -&gt; Self /// sqrt(x*x + y*y) computed without undue overflow or underflow. /// /// Returns a numerically precise result even if one or both of x*x or /// y*y overflow or underflow. static func hypot(_ x: Self, _ y: Self) -&gt; Self ... } This protocol does not add much API surface, but it is what most users will write generic code against. The benefit of this protocol is that it allows us to avoid multiple constraints for most simple generic functions, and to adopt a clearer naming scheme for the protocol that most users see, while also giving ElementaryFunctions a more precise name, suitable for sophisticated uses. The third piece of the proposal is the Math module. This module sits next to the standard library, and provides generic free function implementations of math operations. Unlike the previous two additions, the availability of these functions is gated on Swift 5.1. (swift) import Math (swift) exp(1.0) // r0 : Float = 2.7182817 Finally, we will update the platform imports to obsolete existing functions covered by the new free functions in the Math module, and also remove the imports of the suffixed functions (which were actually never intended to be available in Swift). The Platform module will re-export the Math module, which allows most source code to migrate without any changes necessary. Updates will only be necessary with functions like `atan2(y: x:)` where we are adding argument labels or `logGamma( )` where we have new function names. In these cases we will deprecate the old functions instead of obsoleting them to allow users time to migrate. Detailed design The full API provided by ElementaryFunctions is as follows: /// The square root of `x`. /// /// For real types, if `x` is negative the result is `.nan`. For complex /// types there is a branch cut on the negative real axis. static func sqrt(_ x: Self) -&gt; Self /// The cosine of `x`, interpreted as an angle in radians. static func cos(_ x: Self) -&gt; Self /// The sine of `x`, interpreted as an angle in radians. static func sin(_ x: Self) -&gt; Self /// The tangent of `x`, interpreted as an angle in radians. static func tan(_ x: Self) -&gt; Self /// The inverse cosine of `x` in radians. static func acos(_ x: Self) -&gt; Self /// The inverse sine of `x` in radians. static func asin(_ x: Self) -&gt; Self /// The inverse tangent of `x` in radians. static func atan(_ x: Self) -&gt; Self /// The hyperbolic cosine of `x`. static func cosh(_ x: Self) -&gt; Self /// The hyperbolic sine of `x`. static func sinh(_ x: Self) -&gt; Self /// The hyperbolic tangent of `x`. static func tanh(_ x: Self) -&gt; Self /// The inverse hyperbolic cosine of `x`. static func acosh(_ x: Self) -&gt; Self /// The inverse hyperbolic sine of `x`. static func asinh(_ x: Self) -&gt; Self /// The inverse hyperbolic tangent of `x`. static func atanh(_ x: Self) -&gt; Self /// The exponential function applied to `x`, or `e**x`. static func exp(_ x: Self) -&gt; Self /// Two raised to to power `x`. static func exp2(_ x: Self) -&gt; Self /// Ten raised to to power `x`. static func exp10(_ x: Self) -&gt; Self /// `exp(x) - 1` evaluated so as to preserve accuracy close to zero. static func expm1(_ x: Self) -&gt; Self /// The natural logarithm of `x`. static func log(_ x: Self) -&gt; Self /// The base-two logarithm of `x`. static func log2(_ x: Self) -&gt; Self /// The base-ten logarithm of `x`. static func log10(_ x: Self) -&gt; Self /// `log(1 + x)` evaluated so as to preserve accuracy close to zero. static func log1p(_ x: Self) -&gt; Self /// `x**y` interpreted as `exp(y * log(x))` /// /// For real types, if `x` is negative the result is NaN, even if `y` has /// an integral value. For complex types, there is a branch cut on the /// negative real axis. static func pow(_ x: Self, _ y: Self) -&gt; Self /// `x` raised to the `n`th power. /// /// The product of `n` copies of `x`. static func pow(_ x: Self, _ n: Int) -&gt; Self /// The `n`th root of `x`. /// /// For real types, if `x` is negative and `n` is even, the result is NaN. /// For complex types, there is a branch cut along the negative real axis. static func root(_ x: Self, _ n: Int) -&gt; Self Real builds on this set by adding the following additional operations that are either difficult to implement for complex types or only make sense for real types: /// `atan(y/x)` with quadrant fixup. /// /// There is an infinite family of angles whose tangent is `y/x`. `atan2` /// selects the representative that is the angle between the vector `(x, y)` /// and the real axis in the range [-π, π]. static func atan2(y: Self, x: Self) -&gt; Self /// The error function evaluated at `x`. static func erf(_ x: Self) -&gt; Self /// The complimentary error function evaluated at `x`. static func erfc(_ x: Self) -&gt; Self /// sqrt(x*x + y*y) computed without undue overflow or underflow. /// /// Returns a numerically precise result even if one or both of x*x or /// y*y overflow or underflow. static func hypot(_ x: Self, _ y: Self) -&gt; Self /// The gamma function evaluated at `x`. /// /// For integral `x`, `gamma(x)` is `(x-1)` factorial. static func gamma(_ x: Self) -&gt; Self /// `log(gamma(x))` computed without undue overflow. /// /// `log(abs(gamma(x)))` is returned. To recover the sign of `gamma(x)`, /// use `signGamma(x)`. static func logGamma(_ x: Self) -&gt; Self /// The sign of `gamma(x)`. /// /// This function is typically used in conjunction with `logGamma(x)`, which /// computes `log(abs(gamma(x)))`, to recover the sign information that is /// lost to the absolute value. /// /// `gamma(x)` has a simple pole at each non-positive integer and an /// essential singularity at infinity; we arbitrarily choose to return /// `.plus` for the sign in those cases. For all other values, `signGamma(x)` /// is `.plus` if `x &gt;= 0` or `trunc(x)` is odd, and `.minus` otherwise. static func signGamma(_ x: Self) -&gt; FloatingPointSign These functions directly follow the math library names used in most other languages, as there is not a good reason to break with existing precedent. The changes worth noting are as follows: exp10 does not exist in most C math libraries. It is a generally useful function, corresponding to log10. We’ll fall back on implementing it as pow(10, x) on platforms that don’t have it in the system library. There are two functions named pow with different signatures. One implements the IEEE 754 powr function (nan if x is negative), the other restricts the exponent to have type Int, and implements the IEEE 754 pown function. The function root does not exist in most math libraries; it computes the nth root of x. For now this is implemented in terms of pow, but we may adopt other implementations for better speed or accuracy in the future. Argument labels have been added to atan2(y:x:). This is the only math.h function whose argument order regularly causes bugs, so it would be good to clarify here. logGamma is introduced instead of the existing lgamma, and returns a single value instead of a tuple. The sign is still available via a new signGamma function, but requires a separate function call. The motivation for this approach is two-fold: first, the more common use case is to want only the first value, so returning a tuple creates noise: let (result, _) = lgamma(x) Second, there’s an outstanding bug that results from the C interfaces being re-exported in Swift where lgamma is ambiguous; it can be either the platform shim returning (T, Int), or the C library function returning Double; we want to deprecate the first and make the second unavailable. Simulataneously introducing yet another function with the same name would create a bit of a mess. Future expansion The following functions recommended by IEEE 754 are not provided at this point (because implementations are not widely available), but are planned for future expansion, possibly with implementation directly in Swift: cospi, sinpi, tanpi, acospi, asinpi, atanpi, exp2m1, exp10m1, log2p1, log10p1, compound (these are the names used by IEEE 754; Swift can use different names if we like). Functions not defined on ElementaryFunctions The following functions are exported by , but will not be defined on ElementaryFunctions: `frexp`, `ilogb`, `ldexp`, `logb`, `modf`, `scalbn`, `scalbln`, `fabs`, `ceil`, `floor`, `nearbyint`, `rint`, `lrint`, `llrint`, `round`, `lround`, `llround`, `trunc`, `fmod`, `remainder`, `remquo`, `copysign`, `nan`, `nextafter`, `nexttoward`, `fdim`, `fmin`, `fmax`, `fma`. Most of these are not defined on ElementaryFunctions because they are inherently bound to the semantics of FloatingPoint or BinaryFloatingPoint, and so cannot be defined for types such as Complex or Decimal. Equivalents to many of them are already defined on [Binary]FloatingPoint anyway–in those cases free functions are defined by the Math module, but will be generic over FloatingPoint or BinaryFloatingPoint: @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func ceil&lt;T&gt;(_ x: T) -&gt; T where T: FloatingPoint { return x.rounded(.up) } @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func floor&lt;T&gt;(_ x: T) -&gt; T where T: FloatingPoint { return x.rounded(.down) } @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func round&lt;T&gt;(_ x: T) -&gt; T where T: FloatingPoint { return x.rounded() } @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func trunc&lt;T&gt;(_ x: T) -&gt; T where T: FloatingPoint { return x.rounded(.towardZero) } @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func fma&lt;T&gt;(_ x: T, _ y: T, _ z: T) -&gt; T where T: FloatingPoint { return z.addingProduct(x, y) } @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func remainder&lt;T&gt;(_ x: T, _ y: T) -&gt; T where T: FloatingPoint { return x.remainder(dividingBy: y) } @available(swift, introduced: 5.1) @_alwaysEmitIntoClient public func fmod&lt;T&gt;(_ x: T, _ y: T) -&gt; T where T: FloatingPoint { return x.truncatingRemainder(dividingBy: y) } These definitions replace the definitions existing in the platform module. A few of the other functions (nearbyint, rint) are fundamentally tied to the C language notion of dynamic floating-point rounding-modes, which is not modeled by Swift (and which we do not have plans to support–even if Swift adds rounding-mode control, we should avoid the C fenv model). These are deprecated. The remainder will not be moved into the Math module at this point, as they can be written more naturally in terms of the FloatingPoint API. We intend to deprecate them. Source compatibility This is an additive change, but it entails some changes for platform modules; the existing platform implementations provided by the Darwin or GLibc should be deprecated and made to redirect people to the new operations. Effect on ABI stability For the standard library, this is an additive change. We’ll need to continue to support the old platform hooks to provide binary stability, but will mark them deprecated or obsoleted. Effect on API resilience This is an additive change. Alternatives considered The name ElementaryFunctions is a marked improvement on the earlier Mathable, but is still imperfect. As discussed above, the introduction of the Real protocol mostly renders this issue moot; most code will be constrained to that instead. The names of these functions are strongly conserved across languages, but they are not universal; we could consider more verbose names inline with Swift usual patterns. sine, cosine, inverseTangent, etc. This holds some appeal especially for the more niche functions (like expm1), but the weight of common practice is pretty strong here; almost all languages use essentially the same names for these operations. Another alternative would be to break these up into TrigonometricFunctions, HyperbolicFunctions, ExponentialFunctions, etc, but I don’t think that actually buys us very much. We may also want to add log(_ base: T, _ x: T) -&gt; T at some future point as a supplement to the existing log, log2, and log10 functions. Python and Julia both provide a similar interface. Doing this correctly requires a building block that the C math library doesn’t provide (an extra-precise log or log2 that returns a head-tail representation of the result); without this building block rounding errors creep in even for exact cases: &gt;&gt;&gt; from math import log &gt;&gt;&gt; log(3**20, 3) 19.999999999999996 Julia includes a warning about this in their documentation that basically says “Use log2 or log10 instead if base is 2 or 10”. We could take that approach, but base 2 and 10 cover 99% of uses, so I would rather wait to provide this function until we have time to do it correctly. We could spell log (the natural logarithm) ln. This would resolve some ambiguity for users with a background in certain fields, at the cost of diverging from the vast majority of programming languages. Rust and Kotlin do spell it this way, so we wouldn’t be completely alone. It would also avoid using a function name that potentially conflicts (visually or syntactically) with an obvious name for logging facilities. However, depending on font, ln is easily confused with in, and it breaks the similarity with the other log functions. As an assistance, we will add ln in the Math module but mark it unavailable, referring users to log. We could put the free functions into the standard library instead of a separate module. Having them in a separate module helps avoid adding stuff to the global namespace unless you’re actually using it, which is generally nice, and the precedent from other languages is pretty strong here: #include &lt;cmath&gt;, import math, etc. Having the implementation hooks defined in the standard library makes them available in modules that only need them in a few places or want to use them in inlinable functions but don’t want to have them in the global namespace or re-export them. We could define an operator like ^ or ** for one or both definitions of pow. I have opted to keep new operators out of this proposal, in the interests of focusing on the functions and their implementation hooks. I would consider such an operator to be an additive change to be considered in a separate proposal. Add the constants pi and e to T.Math. There’s a bit of a question about how to handle these with hypothetical arbitrary-precision types, but that’s not a great reason to keep them out for the concrete types we already have. Plus we already have pi on FloatingPoint, so someone implementing such a type already needs to make a decision about how to handle it. There’s a second question of how to handle these with Complex or SIMD types; one solution would be to only define them for types conforming to Real. Changes from previous revisions A number of functions (atan2, erf, erfc, gamma, logGamma) have been moved from ElementaryFunctions onto Real. The rationale for this is threefold: atan2 never made much sense for non-real arguments. Implementations of erf, erfc, gamma and logGamma are not available on all platforms. Finally, those four functions are not actually “elementary”, so the naming is more accurate following this change. hypot has been added to Real. We would like to have a more general solution for efficiently rescaling computations in the future, but hypot is a tool that people can use today. I have dropped the .Math pseudo-namespace associatedtype from the protocols. In earlier versions of the proposal, the static functions were spelled Float.Math.sin(x). This was motivated by a desire to avoid “magic” underscore-prefixed implementation trampolines, while still grouping these functions together under a single .Math in autocompletion lists. Whatever stylistic benefits this might have were judged to be not worth the extra layer of machinery that would be fixed into the ABI even if we get a “real” namespace mechanism at some future point. These functions now appear simply as Float.sin(x).",
    "url": "http://localhost:4000/docs/2019-08-26-0246-mathable.html",
    "relUrl": "/docs/2019-08-26-0246-mathable.html"
  },
  "246": {
    "id": "246",
    "title": "SE-0247 Contiguous Strings",
    "content": "Contiguous Strings Proposal: SE-0247 Author: Michael Ilseman Review Manager: Doug Gregor Status: Implemented (Swift 5.1) Implementation: apple/swift#23051 Bugs: SR-6475 Introduction One of the most common API requests from performance-minded users of string is a way to get direct access to the raw underlying code units. Now that Swift 5 uses UTF-8 for its preferred encoding, we can provide this. “Contiguous strings” are strings that are capable of providing a pointer and length to validly encoded UTF-8 contents in constant time. Contiguous strings include: All native Swift string forms Lazily bridged Cocoa strings that provide a pointer to contiguous ASCII Any “shared string” concept we may add in the future Noncontiguous strings include: Lazily-bridged Cocoa strings that don’t provide a pointer to contiguous ASCII (even if they do have contiguous UTF-16 code units) Any “foreign string” concept we may add in the future Contiguous strings are heavily optimized and more efficient to process than noncontiguous strings. However, noncontiguous string contents don’t have to be copied when imported into Swift, which is profitable for strings which may never be read from, such as imported NSString dictionary keys. Swift-evolution thread: Pitch: Contiguous Strings Motivation In Swift 5.0, String.UTF8View supports withContiguousStorageIfAvailable(), which succeeds on contiguous strings but returns nil on noncontiguous strings. While it’s nice to run a fast algorithm when you can, users are left in the dark if this doesn’t succeed. Even if it’s known to probably succeed, guarding against nil and having a valid fall-back path is not ergonomic. Proposed solution We propose adding to String and Substring: A way to query if a string is contiguous A way to force a string to be contiguous A way to run a closure over the raw UTF-8 contents of a string (For rationale on why StringProtocol was excluded, see “What about StringProtocol?” in Alternatives Considered) Detailed design extension String { /// Returns whether this string is capable of providing access to /// validly-encoded UTF-8 contents in contiguous memory in O(1) time. /// /// Contiguous strings always operate in O(1) time for withUTF8 and always /// give a result for String.UTF8View.withContiguousStorageIfAvailable. /// Contiguous strings also benefit from fast-paths and better optimizations. /// public var isContiguousUTF8: Bool { get } /// If this string is not contiguous, make it so. If this mutates the string, /// it will invalidate any pre-existing indices. /// /// Complexity: O(n) if non-contiguous, O(1) if already contiguous /// public mutating func makeContiguousUTF8() /// Runs `body` over the content of this string in contiguous memory. If this /// string is not contiguous, this will first make it contiguous, which will /// also speed up subsequent access. If this mutates the string, /// it will invalidate any pre-existing indices. /// /// Note that it is unsafe to escape the pointer provided to `body`. For /// example, strings of up to 15 UTF-8 code units in length may be represented /// in a small-string representation, and thus will be spilled into /// temporary stack space which is invalid after `withUTF8` finishes /// execution. /// /// Complexity: O(n) if non-contiguous, O(1) if already contiguous /// public mutating func withUTF8&lt;R&gt;( _ body: (UnsafeBufferPointer&lt;UInt8&gt;) throws -&gt; R ) rethrows -&gt; R } // Contiguous UTF-8 strings extension Substring { /// Returns whether this string is capable of providing access to /// validly-encoded UTF-8 contents in contiguous memory in O(1) time. /// /// Contiguous strings always operate in O(1) time for withUTF8 and always /// give a result for String.UTF8View.withContiguousStorageIfAvailable. /// Contiguous strings also benefit from fast-paths and better optimizations. /// public var isContiguousUTF8: Bool { get } /// If this string is not contiguous, make it so. If this mutates the /// substring, it will invalidate any pre-existing indices. /// /// Complexity: O(n) if non-contiguous, O(1) if already contiguous /// public mutating func makeContiguousUTF8() /// Runs `body` over the content of this substring in contiguous memory. If /// this substring is not contiguous, this will first make it contiguous, /// which will also speed up subsequent access. If this mutates the substring, /// it will invalidate any pre-existing indices. /// /// Note that it is unsafe to escape the pointer provided to `body`. For /// example, strings of up to 15 UTF-8 code units in length may be represented /// in a small-string representation, and thus will be spilled into /// temporary stack space which is invalid after `withUTF8` finishes /// execution. /// /// Complexity: O(n) if non-contiguous, O(1) if already contiguous /// public mutating func withUTF8&lt;R&gt;( _ body: (UnsafeBufferPointer&lt;UInt8&gt;) throws -&gt; R ) rethrows -&gt; R } (For rationale as to why withUTF8 is marked mutating, see “Wait, why is withUTF8 marked as mutating?” in Alternatives Considered.) Source compatibility All changes are additive. Effect on ABI stability All changes are additive. ABI-relevant attributes are provided in “Detailed design”. Effect on API resilience The APIs for String and Substring have their implementations exposed, as they are expressed in terms of assumptions and mechanisms already (non-resiliently) present in Swift 5.0. Alternatives considered Wait, why is withUTF8 marked as mutating? If the string is noncontiguous, something has to happen to get contiguous UTF-8 contents in memory. We have 3 basic options here: 1. Copy into a new heap allocation, run the closure, then throw it away This approach takes inspiration from Array’s withUnsafeBufferPointer, which runs directly on its contents if it can, otherwise it makes a temporary copy to run over. However, unlike Array, noncontiguous strings are much more common and there are no type-level guarantees of contiguity. For example, Array with a value-type Element is always contiguous, so the vast majority of performance sensitive operations over arrays (e.g. Array&lt;Int&gt;) can never trigger this allocation. Because String does not have Array’s guarantee, this approach would harm the ability to reason about the performance characteristics of code. This approach would also keep the string on the slow-path for access after the method is called. If the contents are worth reading, they’re worth ensuring contiguity. 2. Trap if noncontiguous This would be the ideal API for platforms without Cocoa interoperability (unless/until we introduce noncontiguous foreign strings, at least), as it will always succeed. However, this would be a terrible source of crashes in libraries and applications that forget to exhaustively test their code with noncontiguous strings. This would hit cross-platform packages especially hard. Even for libraries confined to Cocoa-interoperable platforms, whether an imported NSString is contiguous or not could change version-to-version of the OS, producing difficult to reason about bugs. 3. Fine, make it mutating The proposed compromise makes withUTF8 mutating, forcing the contents to be bridged if noncontiguous. This has the downside of forcing such strings to be declared var rather than let, but mitigates the downsides of the other approaches. If the contents are worth reading, they’re worth ensuring contiguity. Or, introduce a separate type, ContiguousUTF8String, instead Introducing a new type would introduce an API schism and further complicate the nature of StringProtocol. We don’t consider the downsides to be worth the upside of dropping mutable. What about StringProtocol? Adding these methods to StringProtocol would allow code to be generic over String and Substring (and in the somewhat unlikely event we add new conformers, those as well). This can be done at any time, but there are some issues with doing this right now. When it comes to adding these methods on StringProtocol, we have two options: 1. Add it as a protocol extension This approach would add the functions in an extension, ideally resilient and versioned. Unfortunately, makeContiguousUTF8() wouldn’t be implementable, as we cannot reassign self to a concrete type, so we’d have to add some additional requirements to StringProtocol surrounding forming a new contiguous string of the same concrete type. 2. Add it as a requirement with a default implementation This approach would add it as a customization hook that’s dynamically dispatched to the concrete type’s real implementations. The default implementation would be resilient and versioned and trap if called; any new conformers to StringProtocol would need to be versioned and accommodated here. Adding new versioned-and-defaulted requirements to a protocol can be done at any point while preserving ABI stability. For now, we’re not sure it’s worth the extra witness table entries at this point. This also hits some of the pain points of option 1: any conformers to StringProtocol must satisfy makeContiguousUTF8’s post-condition of ensuring contiguity without changing concrete type. This can be added in the future. Put this on the UTF8View Contiguous UTF-8 is baked into String’s ABI as the fastest representation; this is about directly exposing that fact to performance-minded users. Other views will not have this, so we believe it makes sense to put directly on String. UTF-8 is special for performance and contiguity concerns. The Most Viable Alternative Here’s an alternative formulation that avoids mutating and index-invalidation (by using strategy #1 above). extension [Sub]String { /// &lt;as above&gt; public var isContiguousUTF8: Bool { get } /// Produce a contiguous UTF-8 string with the same contents as `self`. /// Returns `self` is already contiguous, otherwise returns a new copy. /// /// Complexity: O(1) if `self` is contiguous UTF-8, otherwise O(n) /// public var contiguousUTF8: [Sub]String { get } /// Runs `body` over the content of this string in contiguous memory. If this /// string is not contiguous UTF-8, this will first make a contiguous copy and /// run over that. /// /// Note that it is unsafe to escape the pointer provided to `body`, even if /// `self` is contiguous UTF-8. For example, strings of up to 15 UTF-8 code /// units in length may be represented in a small-string representation, and /// thus will be spilled into temporary stack space which is invalid after /// `withUTF8` returns. /// /// Complexity: O(1) if `self` is contiguous UTF-8, otherwise O(n) /// public func withUTF8&lt;R&gt;( _ body: (UnsafeBufferPointer&lt;UInt8&gt;) throws -&gt; R ) rethrows -&gt; R } This formulation would be preferable for situations where strings are nearly- always contiguous UTF-8. Also, the computed property is less invasive than a mutating method as it can be used on the right-hand-side of a let binding. Choosing between this and the version proposed depends on how users expect to use it. We’re eagerly awaiting feedback during the review.",
    "url": "http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html",
    "relUrl": "/docs/2019-08-26-0247-contiguous-strings.html"
  },
  "247": {
    "id": "247",
    "title": "SE-0248 String Gaps and Missing APIs",
    "content": "String Gaps and Missing APIs Proposal: SE-0248 Author: Michael Ilseman Review Manager: Ted Kremenek Status: Implemented (Swift 5.1) Implementation: apple/swift#22869 Bugs: SR-9955 Introduction String and related types are missing trivial and obvious functionality, much of which currently exists internally but has not been made API. We propose adding 9 new methods/properties and 3 new code unit views. Swift-evolution thread: Pitch: String Gaps and Missing APIs Motivation These missing APIs address commonly encountered gaps and missing functionality for users of String and its various types, often leading developers to reinvent the same trivial definitions. Proposed solution We propose: 6 simple APIs on Unicode’s various encodings 2 generic initializers for string indices and ranges of indices Substring.base, equivalent to Slice.base Make Character.UTF8View and Character.UTF16View public Add Unicode.Scalar.UTF8View Detailed design 1. Unicode obvious/trivial additions This functionality existed internally as helpers and is generally useful (even if they’re simple) for anyone working with Unicode. extension Unicode.ASCII { /// Returns whether the given code unit represents an ASCII scalar public static func isASCII(_ x: CodeUnit) -&gt; Bool } extension Unicode.UTF8 { /// Returns the number of code units required to encode the given Unicode /// scalar. /// /// Because a Unicode scalar value can require up to 21 bits to store its /// value, some Unicode scalars are represented in UTF-8 by a sequence of up /// to 4 code units. The first code unit is designated a *lead* byte and the /// rest are *continuation* bytes. /// /// let anA: Unicode.Scalar = &quot;A&quot; /// print(anA.value) /// // Prints &quot;65&quot; /// print(UTF8.width(anA)) /// // Prints &quot;1&quot; /// /// let anApple: Unicode.Scalar = &quot;🍎&quot; /// print(anApple.value) /// // Prints &quot;127822&quot; /// print(UTF16.width(anApple)) /// // Prints &quot;4&quot; /// /// - Parameter x: A Unicode scalar value. /// - Returns: The width of `x` when encoded in UTF-8, from `1` to `4`. public static func width(_ x: Unicode.Scalar) -&gt; Int /// Returns whether the given code unit represents an ASCII scalar public static func isASCII(_ x: CodeUnit) -&gt; Bool } extension Unicode.UTF16 { /// Returns a Boolean value indicating whether the specified code unit is a /// high or low surrogate code unit. public static func isSurrogate(_ x: CodeUnit) -&gt; Bool /// Returns whether the given code unit represents an ASCII scalar public static func isASCII(_ x: CodeUnit) -&gt; Bool } extension Unicode.UTF32 { /// Returns whether the given code unit represents an ASCII scalar public static func isASCII(_ x: CodeUnit) -&gt; Bool } 2. Generic initializers for String.Index and Range Concrete versions of this exist parameterized over String, but versions generic over StringProtocol are missing. extension String.Index { /// Creates an index in the given string that corresponds exactly to the /// specified position. /// /// If the index passed as `sourcePosition` represents the start of an /// extended grapheme clusterthe element type of a stringthen the /// initializer succeeds. /// /// The following example converts the position of the Unicode scalar `&quot;e&quot;` /// into its corresponding position in the string. The character at that /// position is the composed `&quot;é&quot;` character. /// /// let cafe = &quot;Cafe u{0301}&quot; /// print(cafe) /// // Prints &quot;Café&quot; /// /// let scalarsIndex = cafe.unicodeScalars.firstIndex(of: &quot;e&quot;)! /// let stringIndex = String.Index(scalarsIndex, within: cafe)! /// /// print(cafe[...stringIndex]) /// // Prints &quot;Café&quot; /// /// If the index passed as `sourcePosition` doesn&#39;t have an exact /// corresponding position in `target`, the result of the initializer is /// `nil`. For example, an attempt to convert the position of the combining /// acute accent (`&quot; u{0301}&quot;`) fails. Combining Unicode scalars do not have /// their own position in a string. /// /// let nextScalarsIndex = cafe.unicodeScalars.index(after: scalarsIndex) /// let nextStringIndex = String.Index(nextScalarsIndex, within: cafe) /// /// print(nextStringIndex) /// // Prints &quot;nil&quot; /// /// - Parameters: /// - sourcePosition: A position in a view of the `target` parameter. /// `sourcePosition` must be a valid index of at least one of the views /// of `target`. /// - target: The string referenced by the resulting index. public init?&lt;S: StringProtocol&gt;( _ sourcePosition: String.Index, within target: S ) } extension Range where Bound == String.Index { public init?&lt;S: StringProtocol&gt;(_ range: NSRange, in string: __shared S) } 3. Substring provides access to its base Slice, the default SubSequence type, provides base for accessing the original Collection. Substring, String’s SubSequence, should as well. extension Substring { /// Returns the underlying string from which this Substring was derived. public var base: String { get } } 4. Add in missing views on Character Character’s UTF8View and UTF16View has existed internally, but we should make it public. extension Character { /// A view of a character&#39;s contents as a collection of UTF-8 code units. See /// String.UTF8View for more information public typealias UTF8View = String.UTF8View /// A UTF-8 encoding of `self`. public var utf8: UTF8View { get } /// A view of a character&#39;s contents as a collection of UTF-16 code units. See /// String.UTF16View for more information public typealias UTF16View = String.UTF16View /// A UTF-16 encoding of `self`. public var utf16: UTF16View { get } } 5. Add in a RandomAccessCollection UTF8View on Unicode.Scalar Unicode.Scalar has a UTF16View with is a RandomAccessCollection, but not a UTF8View. extension Unicode.Scalar { public struct UTF8View { internal init(value: Unicode.Scalar) internal var value: Unicode.Scalar } public var utf8: UTF8View { get } } extension Unicode.Scalar.UTF8View : RandomAccessCollection { public typealias Indices = Range&lt;Int&gt; /// The position of the first code unit. public var startIndex: Int { get } /// The &quot;past the end&quot; positionthat is, the position one /// greater than the last valid subscript argument. /// /// If the collection is empty, `endIndex` is equal to `startIndex`. public var endIndex: Int { get } /// Accesses the code unit at the specified position. /// /// - Parameter position: The position of the element to access. `position` /// must be a valid index of the collection that is not equal to the /// `endIndex` property. public subscript(position: Int) -&gt; UTF8.CodeUnit } Source compatibility All changes are additive. Effect on ABI stability All changes are additive. Effect on API resilience Unicode encoding additions and Substring.base are trivial and can never change in definition, so their implementations are exposed. String.Index initializers are resilient and versioned. Character’s views already exist as inlinable in 5.0, we just replace internal with public Unicode.Scalar.UTF8View’s implementation is fully exposed (for performance), but is versioned Alternatives considered Do Nothing Various flavors of “do nothing” include stating a given API is not useful or waiting for a rethink of some core concept. Each of these API gaps frequently come up on the forums, bug reports, or seeing developer usage in the wild. Rethinks are unlikely to happen anytime soon. We believe these gaps should be closed immediately. Do More This proposal is meant to round out holes and provide some simple additions, keeping the scope narrow for Swift 5.1. We could certainly do more in all of these areas, but that would require a more design iteration and could be dependent on other missing functionality.",
    "url": "http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html",
    "relUrl": "/docs/2019-08-26-0248-string-gaps-missing-apis.html"
  },
  "248": {
    "id": "248",
    "title": "SE-0249 Key Path Expressions as Functions",
    "content": "Key Path Expressions as Functions Proposal: SE-0249 Authors: Stephen Celis, Greg Titus Review Manager: Ben Cohen Status: Accepted Implementation: apple/swift#19448 Introduction This proposal introduces the ability to use the key path expression Root.value wherever functions of (Root) -&gt; Value are allowed. Swift-evolution thread: Key Path Expressions as Functions Previous discussions: Allow key path literal syntax in expressions expecting function type Key path getter promotion [Pitch] KeyPath based map, flatMap, filter Motivation One-off closures that traverse from a root type to a value are common in Swift. Consider the following User struct: struct User { let email: String let isAdmin: Bool } Applying map allows the following code to gather an array of emails from a source user array: users.map { $0.email } Similarly, filter can collect an array of admins: users.filter { $0.isAdmin } These ad hoc closures are short and sweet but Swift already has a shorter and sweeter syntax that can describe this: key paths. The Swift forum has previously proposed adding map, flatMap, and compactMap overloads that accept key paths as input. Popular libraries define overloads of their own. Adding an overload per function, though, is a losing battle. Proposed solution Swift should allow Root.value key path expressions wherever it allows (Root) -&gt; Value functions: users.map( .email) users.filter( .isAdmin) Detailed design As implemented in apple/swift#19448, occurrences of Root.value are implicitly converted to key path applications of { $0[keyPath: Root.value] } wherever (Root) -&gt; Value functions are expected. For example: users.map( .email) Is equivalent to: users.map { $0[keyPath: User.email] } The implementation is limited to key path literal expressions (for now), which means the following is not allowed: let kp = User.email // KeyPath&lt;User, String&gt; users.map(kp) 🛑 Cannot convert value of type ‘WritableKeyPath&lt;Person, String&gt;’ to expected argument type ‘(Person) throws -&gt; String’ But the following is: let f1: (User) -&gt; String = User.email users.map(f1) let f2: (User) -&gt; String = .email users.map(f2) let f3 = User.email as (User) -&gt; String users.map(f3) let f4 = .email as (User) -&gt; String users.map(f4) Any key path expression can be used where a function of the same shape is expected. A few more examples include: // Multi-segment key paths users.map( .email.count) // `self` key paths [1, nil, 3, nil, 5].compactMap( .self) Effect on source compatibility, ABI stability, and API resilience This is a purely additive change and has no impact. Future direction @callable It was suggested in the proposal thread that a future direction in Swift would be to introduce a @callable mechanism or Callable protocol as a static equivalent of @dynamicCallable. Functions could be treated as the existential of types that are @callable, and KeyPath could be @callable to adopt the same functionality as this proposal. Such a change would be backwards-compatible with this proposal and does not need to block its implementation. ExpressibleByKeyPathLiteral protocol It was also suggested in the implementation’s discussion that it might be appropriate to define an ExpressibleByKeyPathLiteral protocol, though discussion in the proposal thread questioned the limited utility of such a protocol. Alternatives considered ^ prefix operator The ^ prefix operator offers a common third party solution for many users: prefix operator ^ prefix func ^ &lt;Root, Value&gt;(keyPath: KeyPath&lt;Root, Value&gt;) -&gt; (Root) -&gt; Value { return { root in root[keyPath: keyPath] } } users.map(^ .email) users.filter(^ .isAdmin) Although handy, it is less readable and less convenient than using key path syntax alone. Accept KeyPath instead of literal expressions There has been some concern expressed that accepting the literal syntax but not key paths may be confusing, though this behavior is in line with how other literals work, and the most general use case will be with literals, not key paths that are passed around. Accepting key paths directly would also be more limiting and prevent exploring the future directions of Callable or ExpressibleByKeyPathLiteral protocols.",
    "url": "http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html",
    "relUrl": "/docs/2019-08-26-0249-key-path-literal-function-expressions.html"
  },
  "249": {
    "id": "249",
    "title": "SE-0250 Swift Code Style Guidelines and Formatter",
    "content": "Swift Code Style Guidelines and Formatter Proposal: SE-0250 Authors: Tony Allevato, Dave Abrahams Review Manager: Ted Kremenek Status: Returned for revision Discussion thread: An Official Style Guide and Formatter for Swift Introduction We propose that the Swift project adopt a set of code style guidelines and provide a formatting tool that lets users easily diagnose and update their code according to those guidelines. These guidelines would not be mandatory for all projects, but encouraged for Swift code to follow for general consistency. Motivation At the time of this writing, there is no single style agreed on by developers using Swift. Indeed, even Apple’s own Swift projects on GitHub—such as the standard library, Foundation, Swift NIO, and so forth—have adopted their own varying styles. Furthermore, in many cases the code in those projects—despite the owners’ best efforts—is not always completely consistent in terms of style. In the absence of strict or recommended language-specific guidelines, many organizations adopt company-wide or project-wide style guides, which other developers may, and do, choose to adopt. But creating code style guidelines that are maintained by the language owners and community, along with tooling that allows users to easily adopt those guidelines, provides a number of additional benefits: The guidelines serve as a clear and easily referenceable source of language best practices and patterns, rather than developers trying to glean these by reading existing code. Developers can move from one codebase to another without incurring the mental load of learning and conforming to a different style or being required to reconfigure their development environment. Developers spend less time worrying about how to format their code and more on the program’s logic. Likewise, code reviewers spend less time commenting on code formatting issues and more on its logic and design. The first two points in particular align well with the Swift team’s goal of making the language easy to learn. They also remove learning barriers for developers who want to contribute to a new open-source project, or to the language itself. Proposed solution This proposal consists of two parts, discussed below: We propose that Swift adopt a set of code style guidelines for the Swift language. We propose formally adopting a formatting tool into the Swift project that will allow users to update their code in accordance with those guidelines. Style Guide This meta-proposal does not attempt to define any specific style guidelines. Its purpose is to answer the following existential question: Should the Swift language adopt a set of code style guidelines and a formatting tool? If the answer to this is “yes”, then subsequent proposals will be pitched to discuss and ratify those guidelines. In order to keep those discussions scoped and focused, we plan to present proposed guidelines to the community in multiple phases with each centered around a particular theme, such as (but not necessarily limited to) typographical concerns, code consistency, and best practices. The proposal authors wish to emphasize that we are not proposing that users be required or forced to use a particular set of style conventions. The Swift compiler will not be changed in any way that would prevent otherwise syntactically valid code from compiling. Users who wish to reject the style guidelines and adopt a different style for their own projects are free to do so without the tooling pushing back on that decision. Formatting Tool If the proposal is accepted, the Swift project will adopt an official code formatting tool. The adoption of such a tool into the Swift project will not preclude other similar tools being written, but the expectation is that this tool will be officially maintained as part of the Swift project and will (once the details are decided) format users’ code in accordance with the accepted code style guidelings. The proposal authors (among others) have collaborated on the swift-format tool currently hosted at https://github.com/google/swift/tree/format and propose its adoption into the Swift project. We propose this specific tool because it satisfies all of the following goals: It is syntax-oriented, which provides high reliability and performance (especially once it adopts recently developed in-process parsing APIs) as compared to SourceKit-based solutions. It uses SwiftSyntax to process code—the Swift project’s preferred method of developing such tools—rather than a distinct parsing implementation that must separately track language evolution. It comes with a continuing support commitment from active maintainers. The tool will be used as part of evaluating options for the proposed code style guidelines, as part of a follow-up proposal on the details of the guidelines themselves. Configurability of Formatting swift-format will allow configuration of some practical formatting decisions like indentation size, line length, and respecting existing newlines. In mixed-language projects, some tools in a developer’s workflow may not easily support configuring these on a per-language basis. We are also willing to consider additional degrees of configurability. A tool that is not configurable only works for users who are completely satisfied with the defaults. A tool that is configurable is still usable by anyone who wants to leave it configured to the default settings, but can also be tailored to the unique needs of individual code bases. Even if style guidelines ratified later encourage a particular default configuration, users with different needs should still be able to reap benefits from using the tool. As with the style guidelines above, the adopted formatting tool will not be forced upon a developer’s workflow by any part of the Swift toolchain. Users who wish not to use it will have the option to simply not run it on their code. Alternatives considered We could not propose any particular style guidelines and leave it to individual developers and teams to create their own (if they so desired). That does not address the points listed in Motivation above. We could propose style guidelines but no official formatting tool. However, we feel that a tool that works out-of-the-box without any other installation requirements or mandatory configuration is a major benefit to users. The existence of such a tool does not diminish the value of other tools that aim to enforce good coding patterns, be they the same, complementary, or outright different patterns than those proposed in future Swift coding style guidelines. We could make style guidelines mandatory, or at least enforced in a very opinionated manner by the formatter (similar to Go). We have chosen not to do so given that Swift is a well-established language. Users who are happy with the default guidelines can simply use them as-is, developers who have different preferences are not unnecessarily constrained. Some Swift users have suggested that instead of proposing any style guidelines, tooling should be able to transform code to the developer’s personal style upon checkout and then back to some canonical style upon check-in, allowing individual developers to code in whatever style they wished. While such ideas are intriguing, we find them to be more of an academic curiosity than a practical solution: Varying personal styles would hinder team communication. Team members should be able to discuss code on a whiteboard without it looking foreign to other people in the room, and to make API and language design decisions based on a clear idea of how the code will look. This approach assumes that all tools on all platforms used in the developer’s workflow support this approach. The development experience would suffer if the code does not use the same format locally as it does on their code review system, if remote builds reported errors at different line numbers because they used a checked-in snapshot with a different style, or if symbolicated crash logs contain line numbers that must be matched to one specific “rendering” of the project’s source code long after the fact. If the source of truth of the source code is saved in some canonical format and transformed when checked in/out, then there must still be some decision about what that canonical style is. Indeed, nothing in this proposal would prevent a developer from using a workflow like the one described above, if they wished to implement it. Acknowledgments We gratefully acknowledge the following contributors, without whom this work would not have been possible: the other contributors to swift-format: Austin Belknap (@dabelknap), Harlan Haskins (@harlanhaskins), Alexander Lash (@abl), Lauren White (@LaurenWhite), and Andrés Tamez Hernandez (@atamez31), Argyrios Kyrtzidis (@akyrtzi) for his insight and help on using SwiftSyntax, and Kyle Macomber (@kylemacomber), who advocated for using results of existing research for swift-format’s implementation and found the Oppen paper, instead of inventing solutions from whole cloth.",
    "url": "http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html",
    "relUrl": "/docs/2019-08-26-0250-swift-style-guide-and-formatter.html"
  },
  "250": {
    "id": "250",
    "title": "SE-0251 SIMD additions",
    "content": "SIMD additions Proposal: SE-0251 Author: Stephen Canon Review Manager: John McCall Status: Accepted with Modifications Implementation: apple/swift#23421 Review: (review) (acceptance) Introduction Early adopters of SIMD types and protocols have encountered a few missing things as they’ve started to write more code that uses them. In addition, there are some features we punted out of the original review because we were up against a hard time deadline to which we would like to give further consideration. This is a bit of a grab bag of SIMD features, so I’m deviating from the usual proposal structure. Each new addition has its own motivation, proposed solution, and alternatives considered section. Table of Contents Static scalarCount Extending Vectors Swizzling Reductions Lanewise min, max, and clamp .one any and all Static scalarCount Motivation In functions that construct new SIMD vectors, especially initializers, one frequently wants to perform some validation involving scalarCount before doing the work to create the vector. Currently, scalarCount is defined as an instance property (following the pattern of count on collection). However, all SIMD vectors of a given type have the same scalarCount, so semantically it makes sense to have available as a static property as well. There’s precedent for having this duplication in the .bitWidth property on fixed-width integers. Detailed Design extension SIMDStorage { /// The number of scalars, or elements, in a vector of this type. public static var scalarCount: Int { return Self().scalarCount } } The property is defined as an extension on SIMDStorage because it makes semantic sense there (SIMD refines SIMDStorage). It is defined in terms of the existing member property (instead of the apparently more-logical vise-versa) because that way it automatically works for all existing SIMD types with no changes. In practice this introduces no extra overhead at runtime. Alternatives Considered Not doing anything. Users can always fall back on the weird-but-effective Self().scalarCount. Extending vectors Motivation When working with homogeneous coordinates in graphics, the last component frequently needs to be treated separately–this means that you frequently want to extract the first (n-1) components, do arithmetic on them and the final component separately, and then re-assemble them. At API boundaries, you frequently take in (n-1) component vectors, immediately extend them to perform math, and then return out only the first (n-1) components. Detailed design In order to support extending vectors from (n-1) to n components, add the following two initializers: extension SIMD3 { public init(_ xy: SIMD2&lt;Scalar&gt;, _ z: Scalar) { self.init(xy.x, xy.y, z) } } extension SIMD4 { public init(_ xyz: SIMD3&lt;Scalar&gt;, _ w: Scalar) { self.init(xyz.x, xyz.y, xyz.z, w) } } Alternatives Considered These could alternatively be spelled like xy.appending(z); there are two reasons that I’m avoiding that: I would expect appending( ) to return the same type; but the result type is different. I would expect appending( ) to be available on all SIMD types, but it breaks down beyond SIMD4, because there is no SIMD5 in the standard library. We could have also used an explicit parameter label. let v = SIMD3(...) let x = SIMD4(v, 1) // proposed above let y = SIMD4(v, appending: 1) // with parameter label My feeling is that the behavior is clear without the label, but it’s very reasonable to argue for an explicit label instead. Swizzling Motivation In C-family languages, clang defines “vector swizzles” (aka permutes, aka shuffles, … ) that let you select and re-arrange elements from a vector: #import &lt;simd/simd.h&gt; simd_float4 x = { 1, 2, 3, 4}; x.zyx; // (simd_float3){3, 2, 1}; This comes from an identical feature in graphics shader-languages, where it is very heavily used. Detailed design For Swift, we want to restrict the feature somewhat, but also make it more powerful. In shader languages and clang extensions, you can even use swizzled vectors as lvalues, so long as the same element does not appear twice. I proposed to define general permutes as get-only subscripts. By restricting them from appearing as setters, we gain the flexibility to not require they be compile-time constants: extension SIMD { /// Extracts the scalars at specified indices to form a SIMD2. /// /// The elements of the index vector are wrapped modulo the count of elements /// in this vector. Because of this, the index is always in-range and no trap /// can occur. public subscript&lt;Index&gt;(index: SIMD2&lt;Index&gt;) -&gt; SIMD2&lt;Scalar&gt; where Index: FixedWidthInteger { var result = SIMD2&lt;Scalar&gt;() for i in result.indices { result[i] = self[Int(index[i]) % scalarCount] } return result } } let v = SIMD4&lt;Float&gt;(1,2,3,4) let xyz = SIMD3(2,1,0) let w = v[xyz] // SIMD3&lt;Float&gt;(3,2,1) Alternatives Considered We might want an explicit label on this subscript, but as with the extending inits, I believe that its use is generally clear enough in context. The main question is “what should the behavior for out-of-range indices be?” The definition I have chosen here is simple to explain and maps efficiently to the hardware, but there are at least two other good options: it could be a precondition failure, or it could fill the vector with zero in lanes that have out of range indices. The first option (trapping) is undesirable because it’s less efficient with dynamic indices. The second would be slightly more efficient on some architectures, but is also significantly more magic. I believe that the proposed alternative has the best balance of explainable behavior and efficiency. Reductions (or “Horizontal Operations”) Motivation Generally in SIMD programming you try to avoid horizontal operations as much as possible, but frequently you need to do a few of them at the end of a chain of computations. For example, if you’re summing an array, you would sum into a bank of vector accumulators first, then sum those down to a single vector. Now you need to get from that vector to a scalar by summing the elements. This is where reductions enter. sum is also a basic building block for things like the dot product (and hence matrix multiplication), so it’s very valuable to have an efficient implementation provided by the standard library. Similarly you want to have min and max to handle things like rescaling for computational geometry. Detailed design extension SIMD where Scalar: Comparable { /// The least element in the vector. public func min() -&gt; Scalar /// The greatest element in the vector. public func max() -&gt; Scalar } extension SIMD where Scalar: FixedWidthInteger { /// Returns the sum of the scalars in the vector, computed with /// wrapping addition. /// /// Equivalent to indices.reduce(into: 0) { $0 &amp;+= self[$1] }. public func wrappedSum() -&gt; Scalar } extension SIMD where Scalar: FloatingPoint { /// Returns the sum of the scalars in the vector. public func sum() -&gt; Scalar } Alternatives Considered We could call the integer operation sum as well, but it seems better to reserve that name for the trapping operation in case we ever want to add it (just like we use &amp;+ for integer addition on vectors, even though there is no +). We may want to define a floating-point sum with relaxed semantics for accumulation ordering at some point in the future (I plan to define sum as the binary tree sum here–that’s the best tradeoff between reproducibility and performance). I dropped indexOfMinValue and indexOfMaxValue from this proposal for two reasons: there’s some disagreement about whether or not they’re important enough to include it’s not clear what we should name them; If they’re sufficiently important, we probably want to have them on Collection some day, too, so the bar for the naming pattern that we establish is somewhat higher. any and all Motivation any and all are special reductions that operate on boolean vectors (SIMDMask). They return true if and only if any (or all) lanes of the boolean vector are true. These are used to do things like branch around edge-case fixup: if any(x .&lt; 0) { // handle negative x } Detailed design any and all are free functions: public func any&lt;Storage&gt;(_ mask: SIMDMask&lt;Storage&gt;) -&gt; Bool { return mask._storage.min() &lt; 0 } public func all&lt;Storage&gt;(_ mask: SIMDMask&lt;Storage&gt;) -&gt; Bool { return mask._storage.max() &lt; 0 } Alternatives Considered Why are any and all free functions while max and min and sum are member properties? Because of readability in their typical use sites. min, max, and sum are frequently applied to a named value: let accumulator = /* do some work */ return accumulator.sum any and all are most often used with nameless comparison results: if any(x .&lt; minValue .| x .&gt; maxValue) { // handle special cases } To my mind, this would read significantly less clearly as if (x .&lt; minValue .| x .&gt; maxValue).any` { or if (x .&lt; minValue .| x .&gt; maxValue).anyIsTrue` { because there’s no “noun” that the property applies to. There was a proposal in the fall to make them static functions on Bool so that one could write if .any(x .&lt; minValue) { } but I’m not convinced that’s actually better than a free function. min, max, and clamp Motivation We have lanewise arithmetic on SIMD types, but we don’t have lanewise min and max. We’re also missing clamp to restrict values to a specified range. Detailed design extension SIMD where Scalar: Comparable { /// Replace any values less than lowerBound with lowerBound, and any /// values greater than upperBound with upperBound. /// /// For floating-point vectors, `.nan` is replaced with `lowerBound`. public mutating func clamp(lowerBound: Self, upperBound: Self) { self = self.clamped(lowerBound: lowerBound, upperBound: upperBound) } /// The vector formed by replacing any values less than lowerBound /// with lowerBound, and any values greater than upperBound with /// upperBound. /// /// For floating-point vectors, `.nan` is replaced with `lowerBound`. public func clamped(lowerBound: Self, upperBound: Self) -&gt; Self { return Self.min(upperBound, Self.max(lowerBound, self)) } } /// The lanewise minimum of two vectors. /// /// Each element of the result is the minimum of the corresponding /// elements of the inputs. public func min&lt;V&gt;(_ lhs: V, _ rhs: V) -&gt; V where V: SIMD, V.Scalar: Comparable /// The lanewise maximum of two vectors. /// /// Each element of the result is the maximum of the corresponding /// elements of the inputs. public func max&lt;V&gt;(_ lhs: V, _ rhs: V) -&gt; V where V: SIMD, V.Scalar: Comparable Alternatives Considered These could be spelled out lanewiseMaximum or similar, to clarify that they operate lanewise (Chris suggested this in the pitch thread), but we don’t spell out + as “lanewise-plus”, so it seems weird to do it here. The default assumption is that SIMD operations are lanewise. .one Motivation SIMD types cannot be ExpressibleByIntegerLiteral (it results in type system ambiguity for common expressions). We already have .zero, so adding .one makes sense as a convenience. Detailed design extension SIMD where Scalar: ExpressibleByIntegerLiteral { public static var one: Self { return Self(repeating: 1) } } Alternatives Considered Do nothing. We don’t need this, but it has turned out to be a useful convenience. Why stop at one? Why not two? Because that way lies madness. Source compatibility These are all purely additive changes with no effect on source stability. Effect on ABI stability These are all purely additive changes with no effect on source stability. Effect on API resilience These are all purely additive changes with no effect on source stability. Alternatives Considered The pitch for this proposal included some operations for loading and storing from a collection. As Jordan pointed out in the pitch thread, we already have an init from Sequence, which together with slices makes the load mostly irrelevant. The store operation did not have satisfactory naming, and I would like to come up with a better pattern for these that handles iterating over a sequence of SIMD vectors loaded from a collection of scalars and storing them out as a single pattern, rather than building it up one piece at a time.",
    "url": "http://localhost:4000/docs/2019-08-26-0251-simd-additions.html",
    "relUrl": "/docs/2019-08-26-0251-simd-additions.html"
  },
  "251": {
    "id": "251",
    "title": "SE-0252 Key Path Member Lookup",
    "content": "Key Path Member Lookup Proposal: SE-0252 Authors: Doug Gregor, Pavel Yaskevich Review Manager: Ted Kremenek Status: Accepted Implementation: PR #23436 Introduction This proposal attempts to enable stronger-typed version of the dynamic member lookup by extending functionality of an existing @dynamicMemberLookup attribute with key path based variants. Swift Evolution Pitch Motivation Dynamic member lookup allows a type to opt in to extending member lookup (“dot” syntax) for arbitrary member names, turning them into a string that can then be resolved at runtime. Dynamic member lookup allows interoperability with dynamic languages where the members of a particular instance can only be determined at runtime… but no earlier. Dynamic member lookups, therefore, tend to work with type-erased wrappers around foreign language objects (e.g., PyVal for an arbitrary Python object), which don’t provide much static type information. On the other hand, key paths provide a dynamic representation of a property that can be used to read or write the referenced property. Key paths maintain static type information about the type of the property being accessed, making them a good candidate for abstractly describing a reference to data that is modeled via Swift types. However, key paths can be cumbersome to create and apply. Consider a type Lens&lt;T&gt; that abstractly refers to some value of type T, through which one can read (and possibly write) the value of that T: struct Lens&lt;T&gt; { let getter: () -&gt; T let setter: (T) -&gt; Void var value: T { get { return getter() } set { setter(newValue) } } } Given some Lens, we would like to produce a new Lens referring to a property of the value produced by the lens. Key paths allow us to write such a projection function directly: extension Lens { func project&lt;U&gt;(_ keyPath: WritableKeyPath&lt;T, U&gt;) -&gt; Lens&lt;U&gt; { return Lens&lt;U&gt;( getter: { self.value[keyPath: keyPath] }, setter: { self.value[keyPath: keyPath] = $0 }) } } As an example, consider a Lens&lt;Rectangle&gt;: struct Point { var x, y: Double } struct Rectangle { var topLeft, bottomRight: Point } func projections(lens: Lens&lt;Rectangle&gt;) { let topLeft = lens.project( .topLeft) // inferred type is Lens&lt;Point&gt; let top = lens.project( .topLeft.y) // inferred type is Lens&lt;Double&gt; } Forming the projection is a bit unwieldy: it’s a call to project in which we need to use . to then describe the key path. Why not support the most direct syntax to form a lens referring to some part of the stored value, e.g., lens.topLeft or lens.topLeft.y, respectively? Proposed solution Augment existing @dynamicMemberLookup attribute to support key path based dynamic member lookup by rewriting “dot” and “subscript” syntax into a call to a special subscript whose argument is a key path describing the member. Here, we reimplement Lens in terms of new @dynamicMemberLookup capabilities: @dynamicMemberLookup struct Lens&lt;T&gt; { let getter: () -&gt; T let setter: (T) -&gt; Void var value: T { get { return getter() } set { setter(newValue) } } subscript&lt;U&gt;(dynamicMember keyPath: WritableKeyPath&lt;T, U&gt;) -&gt; Lens&lt;U&gt; { return Lens&lt;U&gt;( getter: { self.value[keyPath: keyPath] }, setter: { self.value[keyPath: keyPath] = $0 }) } } Given a Lens&lt;Rectangle&gt; named lens, the expression lens.topLeft will be evaluated as lens[dynamicMember: .topLeft], allowing normal member accesses on a Lens to produce a new Lens. The formation of the key path follows a “single step” approach where each key path component is split into a separate [dynamicMember: KeyPath&lt;T, U&gt;] invocation. For example, the expression lens.topLeft.y will be evaluated as lens[dynamicMember: .topLeft][dynamicMember: .y], producing a Lens&lt;Double&gt;. Detailed design Proposed solution builds on existing functionality of the @dynamicMemberLookup attribute. It adopts restrictions associated with existing string-based design as well as a couple of new ones: Key path member lookup only applies when the @dynamicMemberLookup type does not contain a member with the given name. This privileges the members of the @dynamicMemberLookup type (e.g., Lens&lt;Rectangle&gt;), hiding those of whatever type is that the root of the keypath (e.g., Rectangle). @dynamicMemberLookup can only be written directly on the definition of a type, not an an extension of that type. A @dynamicMemberLookup type must define a subscript with a single, non-variadic parameter whose argument label is dynamicMember and that accepts one of the key path types (e.g., KeyPath, WritableKeyPath). In case both string-based and keypath-based overloads match, keypath takes priority as one carrying more typing information. Source compatibility This is an additive proposal, which makes ill-formed syntax well-formed but otherwise does not affect existing code. First, only types that opt in to @dynamicMemberLookup will be affected. Second, even for types that adopt @dynamicMemberLookup, the change is source-compatible because the transformation to use subscript(dynamicMember:) is only applied when there is no member of the given name. Effect on ABI stability This feature is implementable entirely in the type checker, as (effectively) a syntactic transformation on member access expressions. It, therefore, has no impact on the ABI. Effect on API resilience Adding @dynamicMemberLookup is a resilient change to a type, as is the addition of the subscript. Alternatives considered The main alternative would be to not do this at all. Another alternative would be to use a different attribute to separate this feature from @dynamicMemberLookup, e.g. @keyPathMemberLookup since string based design doesn’t, at the moment, provide any static checking for member access. We recognize this as a valid concern, but at the same time consider both to be fundamentally the same feature with different amount of static checking. Using the same attribute allows us to adhere to “fewer conceptular features” concept, as well as, enables powerful combinations where string based dynamic lookup could be used as a fallback when key path dynamic lookup fails.",
    "url": "http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html",
    "relUrl": "/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html"
  },
  "252": {
    "id": "252",
    "title": "SE-0253 Introduce callables ",
    "content": "Introduce callables Proposal: SE-0253 Authors: Richard Wei, Dan Zheng Review Manager: Chris Lattner Status: Active review (March 27 - April 5, 2019) Implementation: apple/swift#23517 Introduction This proposal introduces callables to Swift. Callables are values that define function-like behavior and can be applied using function application syntax. In a nutshell, we propose to introduce a new declaration syntax with the keyword call: struct Adder { var base: Int call(_ x: Int) -&gt; Int { return base + x } } Values that have a call member can be applied like functions, forwarding arguments to the call member. let add3 = Adder(base: 3) add3(10) // =&gt; 13 Motivation Currently, in Swift, only a few kinds of values are syntactically callable: Values with function types. Type names (e.g. T can be called like T(...), which is desugared to T.init(...)). Values with a @dynamicCallable type. However, call-syntax can also be useful for other values, primarily those that behave like functions. This includes: Values that represent functions: mathematical functions, function expressions, etc. Values that have one main use and want to provide a simple call-syntax interface: neural network layers, parsers, efficient bound closures, etc. Here are some concrete sources of motivation. Values representing functions Values of some nominal types exactly represent functions: in the mathematical sense (a mapping from inputs to outputs), or in the context of programming languages. Here are some examples: /// Represents a polynomial function, e.g. `2 + 3x + 4x²`. struct Polynomial { /// Represents the coefficients of the polynomial, starting from power zero. let coefficients: [Float] } Since these types represent functions, naturally they can be applied to inputs. However, currently in Swift, the “function application” functionality must be defined as a method. extension Polynomial { func evaluated(at input: Float) -&gt; Float { var result: Float = 0 for (i, c) in coefficients.enumerated() { result += c * pow(input, Float(i)) } return result } } let polynomial = Polynomial(coefficients: [2, 3, 4]) print(polynomial.evaluated(at: 2)) // =&gt; 24 The mathematical notation for function application is simply output = f(input). Using subscript methods achieve a similar application syntax f[x], but subscripts and square brackets typically connote “indexing into a collection”, which is not the behavior here. extension Polynomial { subscript(input: Float) -&gt; Float { ... } } let polynomial = Polynomial(coefficients: [2, 3, 4]) // Subscript syntax, may be confusing. print(polynomial[2]) // =&gt; 24 The proposed feature enables the same call syntax as the mathematical notation: extension Polynomial { call(_ input: Float) -&gt; Float { ... } } let polynomial = Polynomial(coefficients: [2, 3, 4]) // Call syntax. print(polynomial(2)) // =&gt; 24 Bound closures Variable-capturing closures can be modeled explicitly as structs that store the bound variables. This representation is more performant and avoids the type-erasure of closure contexts. // Represents a nullary function capturing a value of type `T`. struct BoundClosure&lt;T&gt; { var function: (T) -&gt; Void var value: T call() { return function(value) } } let x = &quot;Hello world!&quot; let closure = BoundClosure(function: { print($0) }, value: x) closure() // prints &quot;Hello world!&quot; A call syntax sugar would enable BoundClosure instances to be applied like normal functions. Nominal types with one primary method Some nominal types have a “primary method” that performs their main use. For example: Calculators calculate: calculator.calculating(query). Parsers parse: parser.parsing(text). Neural network layers apply to inputs: layer.applied(to: input). Types representing functions apply to arguments: function.applied(to: arguments). Types that have a primary method usually call that method frequently. Thus, it may be desirable to sugar applications of the main method with call syntax to reduce noise. Let’s explore neural network layers and string parsers in detail. Neural network layers Machine learning models often represent a function that contains an internal state called “trainable parameters”, and the function takes an input and predicts the output. In code, models are often represented as a data structure that stores trainable parameters, and a method that defines the transformation from an input to an output in terms of these trained parameters. Here’s an example: struct Perceptron { var weight: Vector&lt;Float&gt; var bias: Float func applied(to input: Vector&lt;Float&gt;) -&gt; Float { return weight • input + bias } } Stored properties weight and bias are considered as trainable parameters, and are used to define the transformation from model inputs to model outputs. Models can be trained , during which parameters like weight are updated, thus changing the behavior of applied(to:). When a model is used, the call site looks just like a function call. let model: Perceptron = ... let ŷ = model.applied(to: x) Many deep learning models are composed of layers, or layers of layers. In the definition of those models, repeated calls to applied(to:) significantly complicate the look of the program and reduce the clarity of the resulting code. struct Model { var conv = Conv2D&lt;Float&gt;(filterShape: (5, 5, 3, 6)) var maxPool = MaxPool2D&lt;Float&gt;(poolSize: (2, 2), strides: (2, 2)) var flatten = Flatten&lt;Float&gt;() var dense = Dense&lt;Float&gt;(inputSize: 36 * 6, outputSize: 10) func applied(to input: Tensor&lt;Float&gt;) -&gt; Tensor&lt;Float&gt; { return dense.applied(to: flatten.applied(to: maxPool.applied(to: conv.applied(to: input)))) } } These repeated calls to applied(to:) harm clarity and makes code less readable. If model could be called like a function, which it mathematically represents, the definition of Model becomes much shorter and more concise. The proposed feature promotes clear usage by omitting needless words. struct Model { var conv = Conv2D&lt;Float&gt;(filterShape: (5, 5, 3, 6)) var maxPool = MaxPool2D&lt;Float&gt;(poolSize: (2, 2), strides: (2, 2)) var flatten = Flatten&lt;Float&gt;() var dense = Dense&lt;Float&gt;(inputSize: 36 * 6, outputSize: 10) call(_ input: Tensor&lt;Float&gt;) -&gt; Tensor&lt;Float&gt; { // Call syntax. return dense(flatten(maxPool(conv(input)))) } } let model: Model = ... let ŷ = model(x) There are more ways to further simplify model definitions, but making models callable like functions is a good first step. Domain specific languages DSL constructs like string parsers represent functions from inputs to outputs. Parser combinators are often implemented as higher-order functions operating on parser values, which are themselves data structures—some implementations store closures, while some other efficient implementations store an expression tree. They all have an “apply”-like method that performs an application of the parser (i.e. parsing). struct Parser&lt;Output&gt; { // Stored state... func applied(to input: String) throws -&gt; Output { // Using the stored state... } func many() -&gt; Parser&lt;[Output]&gt; { ... } func many&lt;T&gt;(separatedBy separator: Parser&lt;T&gt;) -&gt; Parser&lt;[Output]&gt; { ... } } When using a parser, one would need to explicitly call applied(to:), but this is a bit cumbersome—the naming this API often repeats the type. Since parsers are like functions, it would be cleaner if the parser itself were callable. call(_ input: String) throws -&gt; Output { // Using the stored state... } let sexpParser: Parser&lt;Expression&gt; = ... // Call syntax. let sexp = sexpParser(&quot;(+ 1 2)&quot;) A static counterpart to @dynamicCallable SE-0216 introduced user-defined dynamically callable values. In its alternatives considered section, it was requested that we design and implement the “static callable” version of this proposal in conjunction with the dynamic version proposed. See its pitch thread for discussions about “static callables”. Prior art Many languages offer the call syntax sugar: Python: object.__call__(self[, args...]) C++: operator() (function call operator) Scala: def apply(...) (apply methods) Unifying compound types and nominal types A long term goal with the type system is to unify compound types (e.g. function types and tuple types) and nominal types, to allow compound types to conform to protocols and have members. When function types can have members, it will be most natural for them to have a call member, which can help unify the compiler’s type checking rules for call expressions. Proposed design We propose to introduce a new keyword call and a new declaration syntax–the call declaration syntax. struct Adder { var base: Int call(_ x: Int) -&gt; Int { return base + x } } Values that have a call member can be called like a function, forwarding arguments to the call member. let add3 = Adder(base: 3) add3(10) // =&gt; 13 Note: there are many alternative syntaxes for marking “call-syntax delegate methods”. These are listed and explored in the “Alternatives considered” section. Detailed design call member declarations call members can be declared in structure types, enumeration types, class types, protocols, and extensions thereof. A call member declaration is similar to subscript in the following ways: It does not take a name. It must be an instance member of a type. (Though there is a pitch to add static and class subscripts.) But it is more similar to a func declaration in that: It does not allow get and set declarations inside the body. When a parameter has a name, the name is treated as the argument label. The rest of the call declaration grammar and semantics is identical to that of function declarations – it supports the same syntax for: Access levels. Generic parameter clauses. Argument labels. Return types. throws and rethrows. mutating. where clauses. call declarations can be overloaded based on argument and result types. call declarations are inherited from superclasses, just like other class members. Most modifiers/attributes that can be applied to function declarations can also be applied to call declarations. Click here for a comprehensive list of modifiers/attributes supported by call declarations. Preface: `call` declarations are implemented as a `CallDecl` class, inheriting from `FuncDecl`, which in tern inherits from `AbstractFunctionDecl`. ### Supported modifiers/attributes on `call` declarations The following attributes are supported on `AbstractFunctionDecl` or all declarations, and thus by default are supported on `call` declarations. (Disabling these attributes on `call` declarations is possible, but may require ad-hoc implementation changes.) * `fileprivate`, `internal`, `public`, `open` * `@available` * `@objc` * `@inlinable` * `@inline` * `@usableFromInline` * `@_alwaysEmitIntoClient` * `@_dynamicReplacement` * `@_effects` * `@_forbidSerializingReference`` * `@_optimize` * `@_silgen_name` * `@_semantics` * `@__raw_doc_comment` The following attributes are supported on `FuncDecl`, and are also are supported on `call` declarations. * `final` * `optional` * `dynamic` * `__consuming` * `mutating` * `nonmutating` * `override` * `private` * `rethrows` * `@discardableResult` * `@nonobjc` * `@_cdecl` * `@_implements` * `@_implicitly_unwrapped_optional` * `@_nonoverride` * `@_specialize_` * `@_transparent` * `@_weakLinked` ### Notable unsupported modifiers/attributes on `call` declarations * `@warn_unqualified_access` * Qualified access is not possible because direct references to `call` declarations is not supported. To support source compatibility, call is treated as a keyword only when parsing members of a nominal type. Otherwise, it is treated as a normal identifier. See the source compatibility section below. call-declaration → call-head generic-parameter-clause? function-signature generic-where-clause? function-body? call-head → attributes? declaration-modifiers? &#39;call&#39; Examples struct Adder { var base: Int call(_ x: Int) -&gt; Int { return base + x } call(_ x: Float) -&gt; Float { return Float(base) + x } call&lt;T&gt;(_ x: T, bang: Bool) throws -&gt; T where T: BinaryInteger { if bang { return T(Int(exactly: x)! + base) } else { return T(Int(truncatingIfNeeded: x) + base) } } // This is a normal function, not a `call` member. func call(x: Int) {} } Call expressions When type-checking a call expression, the type checker will try to resolve the callee. Currently, the callee can be a value with a function type, a type name, or a value of a @dynamicCallable type. This proposal adds a fourth kind of a callee: a value with a matching call member. let add1 = Adder(base: 1) add1(2) // =&gt; 3 try add1(4, bang: true) // =&gt; 5 When type-checking fails, error messages look like those for function calls. When there is ambiguity, the compiler will show relevant call member candidates. add1(&quot;foo&quot;) // error: cannot invoke &#39;add1&#39; with an argument list of type &#39;(String)&#39; // note: overloads for &#39;call&#39; exist with these partially matching parameter lists: (Float), (Int) add1(1, 2, 3) // error: cannot invoke &#39;add1&#39; with an argument list of type &#39;(Int, Int, Int)&#39; When the type is also @dynamicCallable A type can both have call members and be declared with @dynamicCallable. When type-checking a call expression, the type checker will first try to resolve the call to a function or initializer call, then a call member call, and finally a dynamic call. Using call members Currently, call members cannot be directly referenced; create a closure to call them instead. let add1 = Adder(base: 1) let f: (Int) -&gt; Int = { x in add1(x) } f(2) // =&gt; 3 [1, 2, 3].map { x in add1(x) } // =&gt; [2, 3, 4] call members are represented as instance methods with a special-case name and not as instance methods with the actual name “call”. Thus, no redeclaration error is produced for types that define an instance method named “call” and a call member with the exact same type signature. struct S { func call() {} // ok call() {} // ok } When a type does not have call members, but has instance methods or an instance properties named “call”, direct references to call are resolved via existing overload resolution logic. There’s nothing new here. struct S { var call: Int = 0 } S().call // resolves to the property A value cannot be implicitly converted to a function when the destination function type matches the type of the call member. let h: (Int) -&gt; Int = add1 // error: cannot convert value of type `Adder` to expected type `(Int) -&gt; Int` Implicit conversions impact the entire type system and require runtime support to work with dynamic casts; thus, further exploration is necessary for a formal proposal. This base proposal is self-contained; incremental proposals involving conversion can come later. A less controversial future direction is to support explicit conversion via as: let h = add1 as (Int) -&gt; Int Source compatibility The proposed feature adds a call keyword. Normally, this would require existing identifiers named “call” to be escaped as `call`. However, this would break existing code using call identifiers, e.g. func call. To maintain source compatibility, we propose making call a contextual keyword: that is, it is a keyword only in declaration contexts and a normal identifier elsewhere (e.g. in expression contexts). This means that func call and call(...) (apply expressions) continue to parse correctly. Here’s a comprehensive example of parsing call in different contexts: struct Callable { // declaration call(_ body: () -&gt; Void) { // expression call() {} // expression call {} struct U { // declaration call(x: Int) {} // declaration call(function: (Int) -&gt; Void) {} // error: expression in declaration context // expected &#39;(&#39; for &#39;call&#39; member parameters call {} } let u = U() // expression u { x in } } } // expression call() {} // expression call {} Effect on ABI stability Adding a new call declaration is an additive change to the ABI. call declarations will not be supported when deploying to a Swift 5.0 runtime. Effect on API resilience call declarations will not be supported when deploying to a Swift 5.0 runtime. Alternatives considered Alternative ways to denote call-syntax delegate methods Use unnamed func declarations to mark call-syntax delegate methods struct Adder { var base: Int // Option: unnamed `func`. func(_ x: Int) -&gt; Int { return base + x } // Option: `call` declaration modifier on unnamed `func` declarations. // Makes unnamed `func` less weird and clearly states &quot;call&quot;. call func(_ x: Int) -&gt; Int { ... } } This approach represents call-syntax delegate methods as unnamed func declarations instead of creating a new call declaration kind. One option is to use func(...) without an identifier name. Since the word “call” does not appear, it is less clear that this denotes a call-syntax delegate method. Additionally, it’s not clear how direct references would work: the proposed design of referencing call declarations via foo.call is clear and consistent with the behavior of init declarations. To make unnamed func(...) less weird, one option is to add a call declaration modifier: call func(...). The word call appears in both this option and the proposed design, clearly conveying “call-syntax delegate method”. However, declaration modifiers are currently also treated as keywords, so with both approaches, parser changes to ensure source compatibility are necessary. call func(...) requires additional parser changes to allow func to sometimes not be followed by a name. The authors lean towards call declarations for terseness. Use an attribute to mark call-syntax delegate methods struct Adder { var base: Int @callDelegate func addingWithBase(_ x: Int) -&gt; Int { return base + x } } This approach achieves a similar effect as call declarations, except that methods can have a custom name and be directly referenced by that name. This is useful for types that want to make use of the call syntax sugar, but for which the name “call” does not accurately describe the callable functionality. However, we feel that using a @callableMethod method attribute is more noisy. Introducing a call declaration kind makes the concept of “callables” feel more first-class in the language, just like subscripts. call is to () as subscript is to []. For reference: other languages with callable functionality typically require call-syntax delegate methods to have a particular name (e.g. def __call__ in Python, def apply in Scala). Use func with a special name to mark call-syntax delegate methods struct Adder { var base: Int // Option: specially-named `func` declarations. func _(_ x: Int) -&gt; Int func self(_ x: Int) -&gt; Int } This approach represents call-syntax delegate methods as func declarations with a special name instead of creating a new call declaration kind. However, such func declarations do not convey “call-syntax delegate method” as clearly as the call keyword. Use a type attribute to mark types with call-syntax delegate methods @staticCallable // alternative name `@callable`; similar to `@dynamicCallable` struct Adder { var base: Int // Informal rule: all methods with a particular name (e.g. `func call`) are deemed call-syntax delegate methods. // // `StringInterpolationProtocol` has a similar informal requirement for // `func appendInterpolation` methods. // https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md#proposed-solution func call(_ x: Int) -&gt; Int { return base + x } } We feel this approach is not ideal because: A marker type attribute is not particularly meaningful. The call-syntax delegate methods of a type are what make values of that type callable - a type attribute means nothing by itself. There’s an unforunate edge case that must be explicitly handled: if a @staticCallable type defines no call-syntax delegate methods, an error must be produced. The name for call-syntax delegate methods (e.g. func call ) is not first-class in the language, while their call site syntax is. Use a Callable protocol to represent callable types // Compiler-known `Callable` marker protocol. struct Adder: Callable { var base: Int // Informal rule: all methods with a particular name (e.g. `func call`) are deemed call-syntax delegate methods. func call(_ x: Int) -&gt; Int { return base + x } } We feel this approach is not ideal for the same reasons as the marker type attribute. A marker protocol by itself is not meaningful and the name for call-syntax delegate methods is informal. Additionally, protocols should represent particular semantics, but call-syntax behavior has no inherent semantics. In comparison, call declarations have a formal representation in the language and exactly indicate callable behavior (unlike a marker attribute or protocol). Property-like call with getter and setter In C++, operator() can return a reference, which can be used on the left hand side of an assignment expression. This is used by some DSLs such as Halide: Halide::Func foo; Halide::Var x, y; foo(x, y) = x + y; This can be achieved via Swift’s subscripts, which can have a getter and a setter. foo[x, y] = x + y Since the proposed call declaration syntax is like subscript in many ways, it’s in theory possible to allow get and set in a call declaration’s body. call(x: T) -&gt; U { get { ... } set { ... } } However, we do not believe call should behave like a storage accessor like subscript. Instead, call’s appearance should be as close to function calls as possible. Function call expressions today are not assignable because they can’t return an l-value reference, so a call to a call member should not be assignable either. Static call members Static call members could in theory look like initializers at the call site. extension Adder { static call(base: Int) -&gt; Int { ... } static call(_ x: Int) -&gt; Int { ... } } Adder(base: 3) // error: ambiguous static member; do you mean `init(base:)` or `call(base:)`? Adder(3) // okay, returns an `Int`, but it looks really like an initializer that returns an `Adder`. We believe that the initializer call syntax in Swift is baked tightly into programmers’ mental model, and thus do not think overloading that is a good idea. We could also make it so that static call members can only be called via call expressions on metatypes. Adder.self(base: 3) // okay But since this would be an additive feature on top of this proposal and that subscript cannot be static yet, we’d like to defer this feature to future discussions. Direct references to call members Direct references to call members are intentionally not supported. An earlier version of the proposal included support for direct references to call members via foo.call (like referring to an instance method with the name “call”). However, the direction for “callable values” is not to support direct call member references, but to support conversions of callable values to function-typed values. Supporting explicit conversion via as seems relatively non-controversial in forum discussions. Implicit conversion was a highly requested feature, but it likely has type-system-wide impact and requires more exploration. call members should be thought of and represented as “instance methods with a special-case name”, not “instance methods with the name ‘call’”. For now, without support for conversion to function-typed values, create closures like { foo(...) } instead. Unify callable functionality with @dynamicCallable Both @dynamicCallable and the proposed call members involve syntactic sugar related to function applications. However, the rules of the sugar are different, making unification difficult. In particular, @dynamicCallable provides a special sugar for argument labels that is crucial for usability. // Let `PythonObject` be a `@dynamicMemberLookup` type with callable functionality. let np: PythonObject = ... // `PythonObject` with `@dynamicCallable. np.random.randint(-10, 10, dtype: np.float) // `PythonObject` with `call` members. The empty strings are killer. np.random.randint([&quot;&quot;: -10, &quot;&quot;: 10, &quot;dtype&quot;: np.float])",
    "url": "http://localhost:4000/docs/2019-08-26-0253-callable.html",
    "relUrl": "/docs/2019-08-26-0253-callable.html"
  },
  "253": {
    "id": "253",
    "title": "SE-0254 Static and class subscripts",
    "content": "Static and class subscripts Proposal: SE-0254 Author: Brent Royal-Gordon Review Manager: Doug Gregor Status: Implemented (Swift 5.1) Implementation: apple/swift#23358 Review: (review, acceptance) Introduction We propose allowing static subscript and, in classes, class subscript declarations. These could be used through either TypeName[index] or TypeName.self[index] and would have all of the capabilities you would expect of a subscript. We also propose extending dynamic member lookup to static properties by using static subscripts. Swift-evolution thread: Static Subscript (2016), Pitch: Static and class subscripts Motivation Subscripts have a unique and useful combination of features. Like functions, they can take arguments to change their behavior and generic parameters to support many types; like properties, they are permitted as lvalues so their results can be set, modified, and passed as inout. This is a powerful feature set, which is why they are used for features like key paths and @dynamicMemberLookup. Unfortunately, unlike functions and properties, Swift only supports subscripts on regular types, not metatypes. This not only makes the language inconsistent, it also prevents us from supporting important language features on metatypes. (Wait, what the heck is a &quot;metatype&quot;?) A type like `Int` has many instances, like `0` and `-42`. But Swift also creates a special instance representing the `Int` type itself, as opposed to any specific `Int` belonging to that type. This special instance can be directly accessed by writing `Int.self`; it is also returned by `type(of:)` and used in various other places. In fact, static members of `Int` are instance members of `Int.self`, so you use it any time you call one of those. Since `Int.self` is an instance, it must have a type, but the type of `Int.self` is not `Int`; after all, `Int.self` cannot do the things an `Int` can do, like arithmetic and comparison. Instead, `Int.self` is an instance of the type `Int.Type`. Because `Int.Type` is the type of a type, it is called a &quot;metatype&quot;. And occasionally a subscript on a type is truly the best way to represent an operation. For instance, suppose you’re offering access to the process’s environment variables. Since the environment is global and environment variables can be both retrieved and set, a static subscript would be an excellent representation of them. Without them, users must either introduce a singleton instance or use static properties or subscripts to expose the same operations with less fidelity. Swift originally omitted static subscripts for a good reason: They conflicted with an early sugar syntax for arrays, Element[]. But we have long since changed that syntax to [Element] and we aren’t going back. There is no longer a technical obstacle to supporting them, and there never was a philosophical one. The only obstacle to this feature is inertia. It’s time we gave it a little push. Proposed solution In any place where it was previously legal to declare a subscript, it will now be legal to declare a static subscript as well. In classes it will also be legal to declare a class subscript. public enum Environment { public static subscript(_ name: String) -&gt; String? { get { return getenv(name).map(String.init(cString:)) } set { guard let newValue = newValue else { unsetenv(name) return } setenv(name, newValue, 1) } } } The static and class subscripts on a type T can be used on any expression of type T.Type, including T.self[...] and plain T[...]. Environment[&quot;PATH&quot;] += &quot;:/some/path&quot; A static subscript with the parameter label dynamicMember can also be used to look up static properties on types marked with @dynamicMemberLookup. @dynamicMemberLookup public enum Environment { public static subscript(_ name: String) -&gt; String? { // as before } public static subscript(dynamicMember name: String) -&gt; String? { get { return self[name] } set { self.name = newValue } } } Environment.PATH += &quot;:/some/path&quot; We do not currently propose to add support for metatype key paths, but this proposal is a necessary prerequisite for any future work on them. One concern brought up during the pitch phase was discoverability. We think that code completion changes will help with this, but those are outside the scope of an Evolution proposal. Detailed design Static subscripts Static and class subscripts can be declared everywhere static and class computed properties can be, with analogous language rules. In particular, static and class subscript accessors are implicitly nonmutating and cannot be made mutating, just like static and class computed property accessors. If a static or class subscript is declared on a type T, it can be applied to any value of type T, including T.self, T, and variables or other expressions evaluating to a value of type T.Type. Objective-C class methods with the same selectors as instance subscript methods (like +objectAtIndexedSubscript:) will not be imported to Swift as class subscripts; Objective-C technically allows them but doesn’t make them usable in practice, so this is no worse than the native experience. Likewise, it will be an error to mark a static or class subscript with @objc. Dynamic member lookup @dynamicMemberLookup can be applied to any type with an appropriate subscript(dynamicMember:) or static subscript(dynamicMember:) (or class subscript(dynamicMember:), of course). If subscript(dynamicMember:) is present, it will be used to find instance members; if static subscript(dynamicMember:) is present, it will be used to find static members. A type can provide both. Source compatibility This proposal is purely additive; it does not change any prevously existing behavior. All syntax it will add support for was previously illegal. ABI compatibility and backwards deployment Static subscripts are an additive change to the ABI. They do not require any runtime support; the Swift 5.0 runtime should even demangle their names correctly. Dynamic member lookup is implemented in the type checker and has no backwards deployment concerns. Effect on API resilience The rules for the resilience of static and class subscripts will be the same as the rules of their instance subscript equivalents. Dynamic member lookup does not impact resilience. Alternatives considered Leave our options open The main alternative is to defer this feature again, leaving this syntax unused and potentially available for some other purpose. The most compelling suggestion we’ve seen is using Element[n] as type sugar for fixed-size arrays, but we don’t think we would want to do that anyway. If fixed-size arrays need a sugar at all, we would want one that looked like an extension of the existing Array sugar, like [Element * n]. We can’t really think of any other possibilities, so we feel confident that we won’t want the syntax back in a future version of Swift. Future directions Metatype key paths Swift does not currently allow you to form keypaths to or through static properties. This was no loss before static subscripts, since you wouldn’t have been able to apply them to a metatype anyway. But now that we have static subscripts, metatype keypaths could be supported. Metatype key paths were left out of this proposal because they are more complex than dynamic member lookup: Making them backwards deploy requires certain compromises, such as always using opaque accessors. Are these worth the cost? If we allow users to form key paths to properties in resilient libraries built before static key paths are supported, their Equatable and Hashable conformances may return incorrect results. Should we accept that as a minor issue, or set a minimum deployment target? Metatypes have kinds of members not seen in instances; should we allow you to form key paths to them? (Forming a key path to a no-argument case may be particularly useful.) These issues both require more implementation effort and deserve more design attention than metatype key paths could get as part of this proposal, so it makes sense to defer them. Nevertheless, this proposal is an important step in the right direction.",
    "url": "http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html",
    "relUrl": "/docs/2019-08-26-0254-static-subscripts.html"
  },
  "254": {
    "id": "254",
    "title": "SE-0255 Implicit returns from single-expression functions",
    "content": "Implicit returns from single-expression functions Proposal: SE-0255 Author: Nate Chandler Review Manager: Ben Cohen Status: Active review (April 2 - April 11, 2019) Implementation: apple/swift#23251 Previous Proposal: SE-NNNN Introduction Swift provides a pleasant shorthand for short closures: if a closure contains just a single expression, that expression is implicitly returned–the return keyword can be omitted. We should provide this shorthand for functions as well. Swift-evolution thread: Pitch: Implicit Returns from Single-Expression Functions Motivation Consider the following implementation of the popular Collection.sum() extension: extension Sequence where Element == Int { func sum() -&gt; Element { return reduce(0, +) } } The implementation is extremely brief, weighing in at 19 characters. Of those 19, however, 7 are consumed by the return keyword. Proposed solution Here’s how that same property would look if the single-expression in the body is implicitly returned: func sum() -&gt; Element { reduce(0, +) } The expression which is being returned is front and center, not tucked away behind the return keyword. For readers previously exposed to single-expression closure syntax, this will feel completely familiar. Even to readers without such exposure, though, the meaning will be clear: When reading the implementation–after the var keyword and name–you first encounter the return type and then the single expression within the body. Since you’ve just read the return type, can see that there’s only one expression in the body, and are told by the compiler that the code is legal, you are forced to conclude that the expression must indeed be returned. In fact, exposure to functions–whose types are always stated–without an explicit return keyword will help prepare new Swift users to understand code like let ages = persons.map { $0.name } Their prior exposure to functions which implicitly return the single expression in their bodies will lead them to conclude that the closure being passed to map is returning the expression $0.name and that the return type of the closure is String (the type of name, here). Detailed design Interpret the bodies of function-like entities which consist of a single expression as returning that expression–unless the entity’s return type is Void or the single expression’s type is uninhabited. Function-like entities The following are the function-like entities eligible to implicitly return the single expression in their bodies: Functions. For example: func add(lhs: Int, rhs: Int) -&gt; Int { lhs + rhs } Property accessors. With an implicit getter: var location: Location { .init(latitude: lat, longitude: long) } With an explicit getter and setter: var location: Location { get { .init(latitude: lat, longitude: long) } set { self.lat = newValue.latitude self.long = newValue.longitude } } Since only the get accessor may return a value, implicit returns from single-expression accessors will only affect them. Subscript accessors. With an implicit getter: struct Echo&lt;T&gt; { subscript(_ value: T) -&gt; T { value } } With an explicit getter and setter: struct GuaranteedDictionary&lt;Key : Hashable, Value&gt; { var storage: [Key : Value] var fallback: Value subscript(key: Key) -&gt; Value { get { storage[key] ?? fallback } set { storage[key] = newValue } } } As with property accessors, since only the get accessor may return a value, implicit returns only affect them. Initializers. class Derived : Base { required init?() { nil } } The only legal return from an initializer is nil, and that only in the context of a failable initializer. As a result, that is the only place where an implicit return from an initializer can occur. Exceptions When a function-like entity’s body consists of a single expression, there are two cases where no implicit return will be inserted: Void return. In the following code func foo() { logAndReturn(&quot;foo was called&quot;) } @discardableResult func logAndReturn(_ string: String) -&gt; String { ... } adding an implicit return to foo would result in a type error, namely, unexpected non-void return in a void function. It is reasonable to be able to call a function (here, logAndReturn) which returns a value as the only operation performed by another function (here foo) which does not return a value. Moreover, foo as written is legal code, so we want to avoid treating this as a type error since doing so would result in source breakage. Uninhabited expressions. In the following code func vendAnInteger() -&gt; Int { fatalError() } adding an implicit return would result in the analogous type error (cannot convert return expression of type &#39;Never&#39; to return type &#39;Int&#39;). Functions which return values but whose implementations consist solely of a single call to a Never returning function are an established practice in Swift–they allow users to put off defining their functions until they are ready to (or forever). With implicit returns, this function’s implementation will have the same meaning as it has today: The code will compile. No implicit return will be inserted. And at runtime the call to fatalError() will never return. Source compatibility will be preserved. There is one exception, as described in the section below: Source compatibility For the most part, the change is additive, making legal code that is currently illegal. It does, however, break source compatibility in one case. In current Swift, when the following code is compiled func bad(value: Int = 0) -&gt; Int { return 0 } func bad() -&gt; Never { return fatalError() } func callBad() -&gt; Int { bad() } the call to bad() in callBad() resolves to the second overload of that name (whose signature is () -&gt; Never). With implicit return, the call will instead resolve to the first overload. The large downside of breaking source-compatibility is mitigated by the fact that overload sets of which only one member returns Never are very rare: Extensive source compatibility tests have been run against this change without issue. Effect on ABI stability None. Implementation is only in the parser and type checker. Effect on API resilience None. Alternatives considered Maintain source compatibility. Maintaining source compatibility entails teaching the overload resolution system a special case for single-expression functions. It is possible to do this but would require complicating the type checker. Far worse it would complicate the language model: If source compatibility were maintained, the following two functions func callBad_1() -&gt; Int { bad() } func callBad_2() -&gt; Int { return bad() } would have different behaviors: callBad_1 would trap and callBad_2 would return an Int. In a Swift with implicit return for single-expression functions, the mental model for users should be that a return can be omitted in certain cases and that it doesn’t matter whether one is included or not. Preserving source-compatibility in this case would break that mental model.   Permit implicit return for a subset of declarations. This document proposes allowing return to be omitted from the following declarations: functions properties subscripts initializers An alternative would be to allow that omission in only a subset of these. Concretely, several reasons were given for allowing it in only get-only computed properties: (1) Unlike functions, get-only properties already have one shorthand, the omission of get. By analogy to the situation with closures, that indicates that they are eligible for the further shorthand of omitting return. Response: This argument applies equally to subscripts which support the same shorthand as properties. If the reason to permit the return to be omitted from properties is that get can already be omitted, then that reason leads also to permitting return to be omitted from get-only subscripts. The differences between get-only subscripts and functions are already few and may be getting fewer ( https://forums.swift.org/t/pitch-static-and-class-subscripts/21850 , https://forums.swift.org/t/draft-throwing-properties-and-subscripts/1786 ). It would amount to a language inconsistency to allow get-only subscripts but not functions to omit return. (2) Unlike functions, get-only properties always have a return type. Response: In standard usage, it is much more common to encounter functions which return Void than properties. However, while that usage is far more common, the following is still part of the language: var doWork: Void { work() }   Making uninhabited types be bottom types. As currently implemented, an implicit conversion from an uninhabited type to any arbitrary type is permitted only if the uninhabited type is the type of the expression in a single-argument function and the arbitrary type is the the result type of that function. If every uninhabited type were a subtype of every type, this implicit conversion could be applied across the board without special casing for the single-argument return scenario. While such a feature can be implemented (see the uninhabited-upcast branch), it doesn’t maintain source compatibility or otherwise relate to this feature except in terms of the compiler’s implementation.   Use braceless syntax for single-expression functions. Some other languages such as Scala and Kotlin allow single-expression functions to be declared without braces. In Kotlin, this looks like fun squareOf(x: Int): Int = x * x and in Scala, it looks almost identical (the only difference being the use of def instead of fun). def squareOf(x: Int): Int = x * x Those languages’ syntax suggests a similar approach be taken in Swift: func square(of x: Int) -&gt; Int = x * x For functions, this might be fine. For Swift to be self-consistent, a somewhat similar would be needed for properties and subscripts. var value: Int { get = _storedValue set { _storedValue = newValue } } Unfortunately, this begins moving into ambiguous territory: var get: () var value: Void { get = () } In this example, it’s unclear whether the braces of value either (1) enclose an explicit getter for value whose implementation is a single-expression function returning () or alternatively (2) enclose the body of an implicit getter whose implementation sets the get property to ().   Allow implicit return of the last expression even from bodies which consist of more than a single expression. Rust, for example, permits this. Given functions foo, bar, and baz, all which return integers, the following is a legal function in Rust: fn call() -&gt; i64 { foo(); bar(); baz() } While this could be permitted in Swift, doing so would lead to asymmetry in code resulting from the fact that Swift is not expression-oriented as Rust is. Consider a function with some basic branching: func evenOrOdd(_ int: Int) -&gt; EvenOrOdd { if int % 2 == 0 { return .even } .odd } Here .even is returned for even Ints and .odd for odd. Notice that only one of the two returns from the function uses the return keyword! The same unpleasant function could be written in Rust: fn even_or_odd(i: i64) -&gt; EvenOrOdd { if i % 2 == 0 { return EvenOrOdd::Even } EvenOrOdd::Odd } In Rust, though, the asymmetry could be resolved by implicitly returning the entire if expression: fn even_or_odd(i: i64) -&gt; EvenOrOdd { if i % 2 == 0 { EvenOrOdd::Even } else { EvenOrOdd::Odd } } That option is not open to us in Swift because conditionals are statements, not expressions in Swift. Changing Swift into an expression-oriented language would be a radical transformation to the language and is beyond the scope of this change.   Allow the return type to be omitted from the function declarations. Scala, for example, permits this. In the following code def squareOf(x: Int) = x * x the compiler infers that the type of squareOf is (Int) -&gt; Int. Haskell takes this further, permitting functions to be written without either explicit inputs or outputs: {-# LANGUAGE PartialTypeSignatures #-} fac :: _ fac 0 = 1 fac n = n * fac (n - 1) While these features are arguably nice, they greatly increase the complexity of type inference, and are out of scope for this change. Acknowledgments A special thanks to Adrian Zubarev for his prior exploration of the design space culminating in his proposal.",
    "url": "http://localhost:4000/docs/2019-08-26-0255-omit-return.html",
    "relUrl": "/docs/2019-08-26-0255-omit-return.html"
  },
  "255": {
    "id": "255",
    "title": "SE-0256 Introduce `{Mutable}ContiguousCollection` protocol",
    "content": "Introduce {Mutable}ContiguousCollection protocol Proposal: SE-0256 Authors: Ben Cohen Review Manager: Ted Kremenek Status: Active review (April 3 - April 12, 2019) Previous Proposal: SE-0237 Implementation: apple/swift#23616 Introduction This proposal introduces two new protocols: ContiguousCollection, which refines Collection, and MutableContiguousCollection, which refines MutableCollection. Both provide guaranteed access to an underlying unsafe buffer. Motivation SE-0237 introduced two new methods, withContiguous{Mutable}StorageIfAvailable, to allow generic algorithms to test for and use an underlying unsafe buffer when it is available. This has significant performance benefit for certain algorithms, such as sort, which can achieve big speedups when they have access to the unsafe buffer, but can still operate without that fast path if needed. There is another class of operation that only wants to be available when there is a fast path. A good example would be a Swift-friendly wrapper for the vDSP suite of algorithms. For example, you might want to write a convenient wrapper for vDSP_vadd. // note this is **not** a proposal about vDSP wrappers, this is just a // simplified example :) func dspAdd&lt;A: Collection, B: Collection&gt;( _ a: A, _ b: B, _ result: inout [Float] ) where A.Element == Float, B.Element == Float { let n = a.count // try accessing contiguous underlying buffers: let wasContiguous: ()?? = a.withContiguousStorageIfAvailable { abuf in b.withContiguousStorageIfAvailable { bbuf in vDSP_vadd(abuf.baseAddress!, 1, bbuf.baseAddress!, 1, &amp;result, 1, UInt(n)) } } // if they weren&#39;t contiguous, create two arrays try again if wasContiguous == nil || wasContiguous! == nil { dspAdd(Array(a), Array(b), &amp;result) } } This follows a similar pattern to sort: provide a fast path when available, but fall back to a slower path when it isn’t. But in the case of functions like vDSP_vsaddi this is very much the wrong thing to do. These functions often operate on a thin (but very material) performance edge over their open-coded equivalent, and allocating and initializing two arrays purely to be able to call it would probably vastly outweigh the speed benefits gained by using the function instead of a regular loop. This encourages misuse by the caller, who might not realize they are getting worse performance than if they reorganized their code. Trapping on non-contiguous inputs would flag the problem more clearly to the user, who could realize immediately on first use, that types like Range should not be used with this API. But ideally we would use Swift’s type system to enforce this instead, guiding the user to a better solution. Proposed solution Introduce two new protocols which guarantee access to a contiguous underlying buffer. /// A collection that supports access to its underlying contiguous storage. public protocol ContiguousCollection: Collection where SubSequence: ContiguousCollection { /// Calls a closure with a pointer to the array&#39;s contiguous storage. func withUnsafeBufferPointer&lt;R&gt;( _ body: (UnsafeBufferPointer&lt;Element&gt;) throws -&gt; R ) rethrows -&gt; R } /// A collection that supports mutable access to its underlying contiguous /// storage. public protocol MutableContiguousCollection: ContiguousCollection, MutableCollection where SubSequence: MutableContiguousCollection { /// Calls the given closure with a pointer to the array&#39;s mutable contiguous /// storage. mutating func withUnsafeMutableBufferPointer&lt;R&gt;( _ body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R ) rethrows -&gt; R } Conformances will be added for the following types: Array, ArraySlice and ContiguousArray will conform to MutableContiguousCollection UnsafeBufferPointer will conform to ContiguousCollection UnsafeMutableBufferPointer will conform to MutableContiguousCollection Slice will conditionally conform: to ContiguousCollection where Base: ContiguousCollection to MutableContiguousCollection where Base: MutableContiguousCollection Conforming to to ContiguousCollection should also provide types with a default implementation of Collection.withContiguousStorageIfAvailable, via an extension that calls withUnsafeBufferPointer. Same for MutableContiguousCollection and Collection.withMutableContiguousStorageIfAvailable. Detailed design The introduction of these protocols allows an appropriate constraint that would prevent a user passing a Range or Repeating collection into our dspAdd function. It also allows an easy path to a generic result buffer instead of a concrete array; this is important as often these functions are used in a tiled mode where you would want to repeatedly pass in an array slice. As a nice side-benefit, it also cleans up the function implementation: func dspAdd&lt;A: ContiguousCollection, B: ContiguousCollection, R: MutableContiguousCollection&gt;( _ a: A, _ b: B, _ result: inout R ) where A.Element == Float, B.Element == Float, R.Element == Float { let n = a.count a.withUnsafeBufferPointer { abuf in b.withUnsafeBufferPointer { bbuf in result.withUnsafeMutableBufferPointer { rbuf in vDSP_vadd(abuf.baseAddress!, 1, bbuf.baseAddress!, 1, rbuf.baseAddress!, 1, UInt(n)) } } } } Source compatibility These are additive changes and do not affect source compatibility. Effect on ABI stability These are additive changes of new protocols and so can be introduced in an ABI-stable way. On platforms that have declared ABI stability, they will need to have availability annotations. Effect on API resilience N/A Alternatives considered This is a re-pitch of these protocols. They originally appeared in SE-0237, but were deferred pending further use cases. This proposal is motivated by such cases. As mentioned in the motivation, there are some alternatives available in the absense of this protocol: Libraries can add their own version of the protocol, and retroactively conform standard library types to it. This is a workable solution, but has some downsides: Non-standard types will not conform. Callers will need to conform these types to the library’s protocol themselves manually. A standard library protocol is more likely to be adopted by other types. If this pattern proves common, it will lead to multiple libraries declaring the same protocol. Libraries can use the IfAvailable variant, and document that using types without contiguous storage is inefficient. This leaves enforcing the correct usage to the user. This is not always possible in a generic context, where the calling function does not know exactly what concrete type they are using. Libraries can use the IfAvailable variant, and trap when not available. This could alert callers to inefficient usage on first use. For example, if you ever pass in a Range, your call will always fail, detectable by any testing. Some types, however, may respond to the IfAvailable call in some cases but not others. For example, a ring buffer might often not have wrapped around, so can provide a single contiguous buffer sometimes, but not always. Trapping then would lead to unpredictable crashes. Array and lazy bridging The conformance of Array to these protocols presents a particular concern. Array at its core is a contiguously stored block of memory, and so naturally lends itself to conformance to ContiguousCollection. However, this has one specific carved-out exception on Darwin platforms for the purposes of Objective-C interop. When an NSArray of classes is bridged from Objective-C code, it remains as an NSArray, and the Array forwards element accesses to that bridged NSArray. This is very different from NSArray itself, which abstracts away the storage to a much greater degree, giving it flexibility to present an “array-like” interface to multiple different backings. Here’s a run-down of when Array will be contiguously stored: Arrays created in Swift will always be contiguously stored; Arrays of structs and enums will always be contiguously stored; Arrays on platforms without an Objective-C runtime (i.e. non-Darwin platforms) are always contiguously stored; The only time an array won’t be contiguously stored is if it is of classes and has been bridged from an NSArray. Even then, in many cases, the NSArray will be contiguously stored and could present a pointer at no or amortized cost. These caveats should be documented clearly on both the protocol and on Array. Note that in use cases such as the vDSP family of functions, this is not a concern as the element types involved are structs. The documented caveat approach has precedent in several places already in Swift: the conformance of floating-point types to Comparable, the complexity of operations like first and last on some lazy random-access types, and of the existing implementation of withUnsafeBufferPointer on Array itself. Note that these caveats only apply to the un-mutable variant. The first thing an array does when you call a mutating method is ensure that it’s uniquely referenced and contiguous, so even lazily bridged arrays will become contiguous at that point. This copying occurs naturally in other cases, such as multiply-referenced CoW buffers.",
    "url": "http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html",
    "relUrl": "/docs/2019-08-26-0256-contiguous-collection.html"
  },
  "256": {
    "id": "256",
    "title": "SE-0257 Eliding commas from multiline expression lists",
    "content": "Eliding commas from multiline expression lists Proposal: SE-0257 Author: Nate Chandler, Matthew Johnson Review Manager: Ted Kremenek Status: Active review (April 9 - April 18, 2019) Implementation: apple/swift#21876 Previous Pitch: Trailing commas in all expression lists Previous Pitch: SE-0084 spinoff: Newlines as item separators Introduction Swift requires a semicolon “;” to separate statements unless those statements are separated by newlines, in which case the semicolon can be elided. Currently, Swift requires a comma “,” to separate expressions even when those statements are separated by newlines. We should ease this restriction, allowing the comma between two expressions to be elided when they are separated by a newline. Implementation: apple/swift#21876 Previous Pitch: SE-0084 spinoff: Newlines as item separators Reducing visual clutter When writing a list of expressions, you insert commas to tell the compiler where one expression ends and the next begins. When you add a newline between the expressions, though, you provide that same information by way of the newline characters. When newlines are present, commas provide clarity neither to human readers nor to the compiler. In these cases, at best, commas can be overlooked by human readers. At worst, they cause visual clutter and obscure the meaning you are trying to communicate in our code. Consider the following sample, taken from Alamofire: let protectionSpace = URLProtectionSpace( host: host, port: url.port ?? 0, protocol: url.scheme, realm: host, authenticationMethod: NSURLAuthenticationMethodHTTPBasic ) The commas here are not communicating anything. The writer has to put them in, the compiler has to observe that they’re there and move along, and the reader has to filter them out. They’re noise for all parties involved. Compare that to the following: let protectionSpace = URLProtectionSpace( host: host port: url.port ?? 0 protocol: url.scheme realm: host authenticationMethod: NSURLAuthenticationMethodHTTPBasic ) The difference is small, but significant: There are no spurious characters between the parentheses. You are presented with a list of the names of the ingredients being used to construct the URLProtectionSpace on the left hand side of the colons and on the right hand side you see the values which are serving as those ingredients. The lines are symmetric. the last line, lacking a comma, looks no different from the others, because they all lack a comma. Each line stands on its own. Because they appear in single line argument lists, a comma at the end of a line has the effect of drawing your eye down to the next line. Without the commas, you have a moment to breathe at the end of the line, maybe to glance back at the argument label before moving on to the next line. Let’s take a look at a couple more examples. To begin with, let’s look at constructing another type which takes many arguments. Here it is with commas: let config = TestConfig( delim: &quot;abc&quot;, sampleTime: 42.0, numIters: nil, numSamples: nil, quantile: nil, delta: true, verbose: false, logMemory: true, afterRunSleep: nil ) and without: let config = TestConfig( delim: &quot;abc&quot; sampleTime: 42.0 numIters: nil numSamples: nil quantile: nil delta: true verbose: false logMemory: true afterRunSleep: nil ) Once again, the result is cleaner. All the characters that you see are relevant and meaningful. Each line you see is like the others. You’re not drawn from one line to the next by the comma, you’re free to scan through the items at your leisure. These same improvements are visible in expression lists besides the arguments to an initializer. Consider the following function calls, first with commas: StringTests.test(&quot;AssociatedTypes-UTF8View&quot;) { typealias View = String.UTF8View expectCollectionAssociatedTypes( collectionType: View.self, iteratorType: View.Iterator.self, subSequenceType: Substring.UTF8View.self, indexType: View.Index.self, indicesType: DefaultIndices&lt;View&gt;.self) } StringTests.test(&quot;AssociatedTypes-UTF16View&quot;) { typealias View = String.UTF16View expectCollectionAssociatedTypes( collectionType: View.self, iteratorType: View.Iterator.self, subSequenceType: Substring.UTF16View.self, indexType: View.Index.self, indicesType: View.Indices.self) } and then without: StringTests.test(&quot;AssociatedTypes-UTF8View&quot;) { typealias View = String.UTF8View expectCollectionAssociatedTypes( collectionType: View.self iteratorType: View.Iterator.self subSequenceType: Substring.UTF8View.self indexType: View.Index.self indicesType: DefaultIndices&lt;View&gt;.self) } StringTests.test(&quot;AssociatedTypes-UTF16View&quot;) { typealias View = String.UTF16View expectCollectionAssociatedTypes( collectionType: View.self iteratorType: View.Iterator.self subSequenceType: Substring.UTF16View.self indexType: View.Index.self indicesType: View.Indices.self) } The difference is subtle but striking. Making domain-specific languages first-class One case where the problem of visual clutter is especially pronounced is in domain-specific languages embedded (EDSLs) within Swift. Particularly when those EDSLs are “declarative”. Consider an EDSL for specifying a table in a database: let table = Table( name: &quot;Employees&quot;, columns: guid (&quot;record_id&quot;, isPrimaryKey: true, nullable: false), guid (&quot;manager_id&quot;, isPrimaryKey: false, nullable: true), string (&quot;name&quot;, length: 1024, nullable: false), int64 (&quot;employee_id&quot;, nullable: false), date (&quot;start_date&quot;, nullable: false) ) Beyond merely defining a table, the intent is to do so in a way that feels natural in this context, to define a table “in its own terms”. The majority of defining the table is taken up providing a list of columns, declaring them type first, in C style. The corresponding declaration in native Swift would look something like this: let recordID = SQLGUIDColumn(isPrimaryKey: true, nullable: false); let managerID = SQLGUIDColumn(isPrimaryKey: true, nullable: true); let name = SQLStringColumn(length: 1024, nullable: false); let employeeID = SQLInt64Column(nullable: false); let startDate = SQLDateColumn(nullable: false); Note in particular the use of semicolons at the end. While the semicolons are not a huge problem, they are unpleasant. The main reason that they are unpleasant is that they are superfluous. We are merely going through some ceremony that is of service to nobody: not the writer, not the reader, and not the compiler. For that reason, semicolons are not required to end statements that are terminated by line endings in Swift. Instead, Swift allows you to write let recordID = SQLGUIDColumn(isPrimaryKey: true, nullable: false) let managerID = SQLGUIDColumn(isPrimaryKey: true, nullable: true) let name = SQLStringColumn(length: 1024, nullable: false) let employeeID = SQLInt64Column(nullable: false) let startDate = SQLDateColumn(nullable: false) The situation with definition of the table in the EDSL is the same. The commas are providing information to nothing and nobody. They are ceremony for its own sake. Moreover, they are a constant visual reminder that you are looking at a list of arguments being passed to a function rather than a list of declarations in the EDSL. Just as Swift allows semicolons to be omitted, it should also allow the commas to be omitted, permitting let table = Table( name: &quot;Employees&quot; columns: guid (&quot;record_id&quot;, isPrimaryKey: true, nullable: false) guid (&quot;manager_id&quot;, isPrimaryKey: false, nullable: true) string (&quot;name&quot;, length: 1024, nullable: false) int64 (&quot;employee_id&quot;, nullable: false) date (&quot;start_date&quot;, nullable: false) ) With the commas present, the reader is saddled with a constant reminder that she is “just” reading a list of arguments, not language uses that stand on their own. Once they are removed, the author can express her intent directly, that the table is defined by a series of declarations, not by passing a series of arguments to a function. That fact, while still visible, is reduced from its current overbearing status to an implementation detail of the EDSL. Without the commas, each column can be viewed as intended: as a declaration in the EDSL. By allowing statement separators to be omitted when a newline is present while requiring expression separators Swift exhibits a subtle bias, making imperative code look clean where declarative code must be cluttered with punctuation. By providing the same affordance for declarative style, this bias towards imperative style is lifted, allowing declarative EDSLs to feel just as natural as imperative Swift code. This example EDSL is not taken from a real library. There are, despite the current limitation, many shipping Swift libraries that make extensive use of EDSLs. Let’s take a look at the EDSLs from those in several different domains to see how they would be improved by comma elision: Networking EDSL case study: HTTP Requests HTTP requests are pervasive in modern applications. To avoid dealing directly with networking-layer API, higher-level abstractions are often used to specify requests. Here’s an example taken from some real-world code: Request( method: .get, host: .someHost, path: &quot;/path/to/model&quot;, query: [ &quot;page&quot;: 10, &quot;order&quot;: &quot;ascending&quot;, ] ) A request is specified by a series of declarations. The request will use the GET verb. It will be made against someHost at “/path/to/model”. The content should be ordered ascending and there should be ten entities per page. The commas here add no value. At the least, they are line noise. At worst, they obscure the fact that there is a series of declarations, forcing the reader back into viewing the each line as just an argument to an initializer. Here’s the same code without commas: Request( method: .get host: .someHost path: &quot;/path/to/model&quot; query: [ &quot;page&quot;: 10 &quot;order&quot;: &quot;ascending&quot; ] ) As you read the code, first you see that a Request is being initialized. In that context, you see a number of declarations about the request, that it uses the GET verb and so on. The elision of commas allows you to focus on what’s important, the declarations that make up the definition of the Request. You are not constantly reminded that each line is an argument passed to an initializer but are instead free to think of each as a declaration in the language in which HTTP requests are specified. App Routing EDSL case study: Jason Prasad’s Routing library The routing library provides a convenient API for specifying which screen of an app should be displayed when the app is launched via a URL. Here’s an example usage taken from the project’s README: router.map(&quot;routingexample://present/login&quot;, source: .storyboard(storyboard: &quot;Main&quot;, identifier: &quot;LoginViewController&quot;, bundle: nil), style: .inNavigationController(.present(animated: true)), setup: presentationSetup) This code specifies that when the app is launched with the present/login path, the LoginViewController from the Main storyboard will be presented in a navigation controller. Here’s how that code looks without commas and with newlines added instead: router.map( &quot;routingexample://present/login&quot; source: .storyboard(name: &quot;Main&quot; identifier: &quot;LoginViewController&quot; bundle: nil) style: .inNavigationController(.present(animated: true)) setup: presentationSetup ) Without the commas, and with newlines added to the storyboard example, the code looks much cleaner. Moreover, while in Swift an instance of the ControllerSource enum is being instantiated via the .storyboard implicit member access, in this code snippet, you are free to ignore those mechanics and focus instead on the declaration of a location from which to obtain a view controller in a storyboard named “Main” under the identifier “LoginViewController”. Improving the editing experience Another, more minor point is that commas in these positions cause problems when editing code. In Swift today, you can easily add or remove any item–even the last–from a collection literal by commenting it in or out: let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, // &quot;cerulean&quot; ] Unfortunately that convenience is not available fully in the other expression lists. For example, in a multiline function call, it is a breeze to comment out any argument print( &quot;red&quot;, // &quot;green&quot;, // ok &quot;blue&quot;, &quot;cerulean&quot; ) except the last; commenting it out raises an error: print( &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, // error: unexpected &#39;,&#39; separator // &quot;cerulean&quot; ) The reason for these inconsistent behaviors is that trailing commas are permitted in collection literals but not in any other expression list. One solution would be to allow trailing commas in all expression lists. That change, however, only addresses part of the problem. The visual noise that the commas cause not only remains but is magnified: to get this convenience, we would be incentivized to write our code with trailing commas in all multiline expression lists. Instead, we should allow commas to be elided from multiline expression lists entirely. Without commas, the original function call would instead look like print( &quot;red&quot; &quot;green&quot; &quot;blue&quot; &quot;cerulean&quot; ) with its arguments untarnished by commas. We would be free to comment out any line of it, including the last print( &quot;red&quot; &quot;green&quot; &quot;blue&quot; // &quot;cerulean&quot; ) because what remains is again a multiline expression list with commas elided. Proposed solution Rather than allowing comma elision in just some expression lists in an ad hoc fashion, this document proposes allowing commas to be elided uniformly in all multiline expression lists. When will you still use commas? When parsing an expression, the compiler keeps going until it can’t any longer, following the maximal munch principle. Sometimes, though, you want one expression to end and the next to begin before the parser would otherwise stop. In those situations, you will use a comma to communicate that intent. There are two scenarios where you will use commas to clarify that one expression is ending and the next is beginning: Implicit members When parsing a multiline expression list featuring a member expression which appears after a newline foo( bar .baz ) the member expression will be interpreted as modifying the expression that preceded it foo(bar.baz) rather than as a separate expression foo(bar, .baz) If you actually want .baz to be as an implicit member, an expression in its own right, you will add a comma: foo( bar, .baz ) Diagnostics When this situation comes up, the issue can be ameliorated via a good diagnostic experience. If you attempt to compile the original function call foo( bar .baz ) in a context where baz is not an instance member of bar’s type but is a static member of the type of the second parameter accepted by foo enum E { case baz } func foo(_ bar: Bar, _ e: E) {...} the error can be diagnosed with a fixit to insert a comma at the end of the line before .baz, right after bar, leaving you with the code you intended: foo( bar, .baz ) If you attempt to compile the original function call foo( bar .baz ) in a context where both foo(bar.baz) and foo(bar, .baz) are legal, a warning can be emitted with several fixits to clarify the intent by doing one of the following: inserting a comma foo( bar, .baz ) eliminating the newline foo( bar.baz ) indenting the second expression foo( bar .baz ) as is suggested today for an expression on the line after the return keyword at its same indentation level. Closures In a similar vein, when parsing a multiline expression list featuring a closure which appears after a newline foo( bar { print(&quot;baz&quot;) } ) the closure will be interpreted as a trailing closure passed as an argument to the expression that preceded it. foo(bar { print(&quot;baz&quot;) }) rather than as a separate expression foo(bar, { print(&quot;baz&quot;) } If you actually want the closure to stand on its own, to be its own expression, you will add a comma to separate it from the preceding expression. foo( bar, { print(&quot;baz&quot;) } ) Diagnostics As with implicit members, we will be able to provide a good diagnostic experience here including both an error with a fixit to insert a comma before the closure which is being parsed as a trailing closure in the case where using the closure as a trailing closure doesn’t typecheck a warning with multiple fixits to insert a comma or change whitespace in the case where the closure could be used both as a trailing closure and as a top level expression in the list Alternatives to adding commas These situations may sound familiar–they are exactly the same situations where we need to use semicolons to separate items in statement lists, even in the presence of newlines. In practice, you will need to use commas more often than semicolons because it is more often for these expressions to appear in expression lists than in statement lists. That said, you will need to use them less often than it might at first seem. Consider closures: Trailing closure syntax means that most of the time, closures appear after the end of the expression list. Typically, the above example would actually be written foo( bar ) { print(&quot;baz&quot;) } What about implicit members? Consider a function call like this: buyTreat( .sweet .orange ) This would be parsed as .sweet.orange, which may not be what you want. Even to a human, reader, though, it’s not clear what is meant. To make code obvious to readers, you often use argument labels (flavor: .orange) to provide a hint to readers of what the implicit member may be a member of: buyTreat( .sweet flavor: .orange ) If you would prefer to leave out an argument label, you could also provide the type Flavor.orange in order to provide a reader with that context: buyTreat( .sweet Flavor.orange ) If you don’t want to use either of those approaches, only then will you end the prior expression with a comma. Without this change, you are forced to use commas everywhere. In multiline expression lists, they are reduced to line noise and meaninglessness. A comma is a character to be ignored. With this change, if you omit commas whenever possible, when you write a comma, you will mean something: “without this, the previous expression would keep going; I want it to end here.” Detailed design Swift will allow the comma separating two expressions in an expression list to be elided provided that there is a newline separating the expressions. The grammatical productions from The Swift Programming Language will be modified as follows: expression-list -&gt; expression | expression , expression-list | expression n expression-list function-call-argument-list -&gt; function-call-argument | function-call-argument , function-call-argument-list | function-call-argument n function-call-argument-list tuple-element-list -&gt; tuple-element | tuple-element , tuple-element-list | tuple-element n tuple-element-list With these few changes to the grammatical productions, comma elision will be accepted in the following positions: array literals [ &quot;red&quot; &quot;green&quot; ] dictionary literals [ &quot;red&quot; : 4 &quot;green&quot; : 8 ] free function calls print( &quot;red&quot; &quot;green&quot; ) method calls foo.print( &quot;red&quot; &quot;green&quot; ) initializer calls let instance = Widget( &quot;red&quot; &quot;green&quot; ) subscript reads foo[ &quot;red&quot; &quot;green&quot; ] subscript writes foo[ &quot;red&quot; &quot;green&quot; ] = &quot;yellow&quot; super method calls super.print( &quot;red&quot; &quot;green&quot; ) super initializer calls super.init( &quot;red&quot; &quot;green&quot; ) super subscript reads super[ &quot;red&quot; &quot;green&quot; ] super subscript writes super[ &quot;red&quot; &quot;green&quot; ] = &quot;yellow&quot; enum instantiations let e = E.foo( &quot;red&quot; &quot;green&quot; ) tuple instantiations let t = ( &quot;red&quot; &quot;green&quot; ) key-path subscripts let path = Gadget[ 0 1 ] Source compatibility This is not a source-breaking change. Extensive compatibility tests have been run against the change. This document does not propose removing commas from the language. All code that is legal today will continue to be legal. This document proposes easing a restriction, making more code legal. @blangmuir looked into SourceKit’s under the change and determined everything just works without any other changes. Autocomplete continues to function as before. Because statement separator (i.e. semicolon) elision has been in the language for so long, all the engineering problems for expression separator (i.e. comma) elision have already been solved. Effect on ABI stability N/A Effect on API resilience N/A Alternatives considered Allow trailing commas in expression lists. While trailing commas in expression lists would provide the same improvements in the editing experience that comma elision does, they do not bring the same readability improvements to the language as comma elision. Base interpretation of arguments off of semantic information. The two cases where commas will still be written listed above may seem less than ideal. It is tempting to ask whether we could decide the number of expressions in the expression list based on the context in which it appears. Swift does not currently do this sort of interpretation based on semantic information and doing so massively complicates the language.",
    "url": "http://localhost:4000/docs/2019-08-26-0257-elide-comma.html",
    "relUrl": "/docs/2019-08-26-0257-elide-comma.html"
  },
  "257": {
    "id": "257",
    "title": " Feature name",
    "content": "Feature name Proposal: SE-NNNN Authors: Author 1, Author 2 Review Manager: TBD Status: Awaiting implementation During the review process, add the following fields as needed: Implementation: apple/swift#NNNNN Decision Notes: Rationale, Additional Commentary Bugs: SR-NNNN, SR-MMMM Previous Revision: 1 Previous Proposal: SE-XXXX Introduction A short description of what the feature is. Try to keep it to a single-paragraph “elevator pitch” so the reader understands what problem this proposal is addressing. Swift-evolution thread: Discussion thread topic for that proposal Motivation Describe the problems that this proposal seeks to address. If the problem is that some common pattern is currently hard to express, show how one can currently get a similar effect and describe its drawbacks. If it’s completely new functionality that cannot be emulated, motivate why this new functionality would help Swift developers create better Swift code. Proposed solution Describe your solution to the problem. Provide examples and describe how they work. Show how your solution is better than current workarounds: is it cleaner, safer, or more efficient? Detailed design Describe the design of the solution in detail. If it involves new syntax in the language, show the additions and changes to the Swift grammar. If it’s a new API, show the full API and its documentation comments detailing what it does. The detail in this section should be sufficient for someone who is not one of the authors to be able to reasonably implement the feature. Source compatibility Relative to the Swift 3 evolution process, the source compatibility requirements for Swift 4 are much more stringent: we should only break source compatibility if the Swift 3 constructs were actively harmful in some way, the volume of affected Swift 3 code is relatively small, and we can provide source compatibility (in Swift 3 compatibility mode) and migration. Will existing correct Swift 3 or Swift 4 applications stop compiling due to this change? Will applications still compile but produce different behavior than they used to? If “yes” to either of these, is it possible for the Swift 4 compiler to accept the old syntax in its Swift 3 compatibility mode? Is it possible to automatically migrate from the old syntax to the new syntax? Can Swift applications be written in a common subset that works both with Swift 3 and Swift 4 to aid in migration? Effect on ABI stability Does the proposal change the ABI of existing language features? The ABI comprises all aspects of the code generation model and interaction with the Swift runtime, including such things as calling conventions, the layout of data types, and the behavior of dynamic features in the language (reflection, dynamic dispatch, dynamic casting via as?, etc.). Purely syntactic changes rarely change existing ABI. Additive features may extend the ABI but, unless they extend some fundamental runtime behavior (such as the aforementioned dynamic features), they won’t change the existing ABI. Features that don’t change the existing ABI are considered out of scope for Swift 4 stage 1. However, additive features that would reshape the standard library in a way that changes its ABI, such as where clauses for associated types, can be in scope. If this proposal could be used to improve the standard library in ways that would affect its ABI, describe them here. Effect on API resilience API resilience describes the changes one can make to a public API without breaking its ABI. Does this proposal introduce features that would become part of a public API? If so, what kinds of changes can be made without breaking ABI? Can this feature be added/removed without breaking ABI? For more information about the resilience model, see the library evolution document in the Swift repository. Alternatives considered Describe alternative approaches to addressing the same problem, and why you chose this approach instead.",
    "url": "http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html",
    "relUrl": "/docs/2019-08-26-xxxx-synthesize-computed-property.html"
  },
  "258": {
    "id": "258",
    "title": "",
    "content": "404 Page not found :( The requested page could not be found.",
    "url": "http://localhost:4000/404.html",
    "relUrl": "/404.html"
  },
  "259": {
    "id": "259",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com You can find the source code for Minima at GitHub: jekyll / minima You can find the source code for Jekyll at GitHub: jekyll / jekyll",
    "url": "http://localhost:4000/about/",
    "relUrl": "/about/"
  },
  "260": {
    "id": "260",
    "title": "",
    "content": "See what you can learn from here 🙂 Lets search!",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  
}
