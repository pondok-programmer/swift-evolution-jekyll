<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>SE-0143 Conditional conformances - Swift Evolution List</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>SE-0143 Conditional conformances | Swift Evolution List</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="SE-0143 Conditional conformances" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Yuhuu!" /> <meta property="og:description" content="Yuhuu!" /> <link rel="canonical" href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" /> <meta property="og:url" content="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" /> <meta property="og:site_name" content="Swift Evolution List" /> <script type="application/ld+json"> {"url":"http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html","headline":"SE-0143 Conditional conformances","description":"Yuhuu!","@type":"WebPage","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Swift Evolution List</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/about/" class="navigation-list-link">About</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html" class="navigation-list-link">SE-0001 Allow (most) keywords as argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0002-remove-currying.html" class="navigation-list-link">SE-0002 Removing currying `func` declaration syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html" class="navigation-list-link">SE-0003 Removing `var` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html" class="navigation-list-link">SE-0004 Remove the `++` and `--` operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html" class="navigation-list-link">SE-0005 Better Translation of Objective-C APIs Into Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html" class="navigation-list-link">SE-0006 Apply API Guidelines to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html" class="navigation-list-link">SE-0007 Remove C-style for-loops with conditions and incrementers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html" class="navigation-list-link">SE-0008 Add a Lazy flatMap for Sequences of Optionals #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html" class="navigation-list-link">SE-0009 Require self for accessing instance members</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html" class="navigation-list-link">SE-0010 Add StaticString.UnicodeScalarView</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html" class="navigation-list-link">SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html" class="navigation-list-link">SE-0012 Add `@noescape` to public library API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html" class="navigation-list-link">SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html" class="navigation-list-link">SE-0014 Constraining `AnySequence.init`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html" class="navigation-list-link">SE-0015 Tuple comparison operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html" class="navigation-list-link">SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html" class="navigation-list-link">SE-0017 Change `Unmanaged` to use `UnsafePointer`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html" class="navigation-list-link">SE-0018 Flexible Memberwise Initialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html" class="navigation-list-link">SE-0019 Swift Testing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html" class="navigation-list-link">SE-0020 Swift Language Version Build Configuration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html" class="navigation-list-link">SE-0021 Naming Functions with Argument Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html" class="navigation-list-link">SE-0022 Referencing the Objective-C selector of a method</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html" class="navigation-list-link">SE-0023 API Design Guidelines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html" class="navigation-list-link">SE-0024 Optional Value Setter `??=`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html" class="navigation-list-link">SE-0025 Scoped Access Level</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html" class="navigation-list-link">SE-0026 Abstract classes and methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html" class="navigation-list-link">SE-0027 Expose code unit initializers on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html" class="navigation-list-link">SE-0028 Modernizing Swift's Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html" class="navigation-list-link">SE-0029 Remove implicit tuple splat behavior from function applications</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html" class="navigation-list-link">SE-0030 Property Behaviors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html" class="navigation-list-link">SE-0031 Adjusting `inout` Declarations for Type Decoration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html" class="navigation-list-link">SE-0032 Add `first(where:)` method to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html" class="navigation-list-link">SE-0033 Import Objective-C Constants as Swift Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html" class="navigation-list-link">SE-0034 Disambiguating Line Control Statements from Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html" class="navigation-list-link">SE-0035 Limiting `inout` capture to `@noescape` contexts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0036-enum-dot.html" class="navigation-list-link">SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html" class="navigation-list-link">SE-0037 Clarify interaction between comments & operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html" class="navigation-list-link">SE-0038 Package Manager C Language Target Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html" class="navigation-list-link">SE-0039 Modernizing Playground Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0040-attributecolons.html" class="navigation-list-link">SE-0040 Replacing Equal Signs with Colons For Attribute Arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html" class="navigation-list-link">SE-0041 Updating Protocol Naming Conventions for Conversions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html" class="navigation-list-link">SE-0042 Flattening the function type of unapplied method references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html" class="navigation-list-link">SE-0043 Declare variables in 'case' labels with multiple patterns </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0044-import-as-member.html" class="navigation-list-link">SE-0044 Import as member</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html" class="navigation-list-link">SE-0045 Add prefix(while:) and drop(while:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0046-first-label.html" class="navigation-list-link">SE-0046 Establish consistent label behavior across all parameters including first labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html" class="navigation-list-link">SE-0047 Defaulting non-Void functions so they warn on unused results</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html" class="navigation-list-link">SE-0048 Generic Type Aliases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html" class="navigation-list-link">SE-0049 Move @noescape and @autoclosure to be type attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html" class="navigation-list-link">SE-0050 Decoupling Floating Point Strides from Generic Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html" class="navigation-list-link">SE-0051 Conventionalizing `stride` semantics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html" class="navigation-list-link">SE-0052 Change IteratorType post-nil guarantee</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html" class="navigation-list-link">SE-0053 Remove explicit use of `let` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html" class="navigation-list-link">SE-0054 Abolish `ImplicitlyUnwrappedOptional` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html" class="navigation-list-link">SE-0055 Make unsafe pointer nullability explicit using Optional</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html" class="navigation-list-link">SE-0056 Allow trailing closures in `guard` conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html" class="navigation-list-link">SE-0057 Importing Objective-C Lightweight Generics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html" class="navigation-list-link">SE-0058 Allow Swift types to provide custom Objective-C representations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html" class="navigation-list-link">SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html" class="navigation-list-link">SE-0060 Enforcing order of defaulted parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html" class="navigation-list-link">SE-0061 Add Generic Result and Error Handling to autoreleasepool()</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html" class="navigation-list-link">SE-0062 Referencing Objective-C key-paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html" class="navigation-list-link">SE-0063 SwiftPM System Module Search Paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0064-property-selectors.html" class="navigation-list-link">SE-0064 Referencing the Objective-C selector of property getters and setters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html" class="navigation-list-link">SE-0065 A New Model for Collections and Indices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html" class="navigation-list-link">SE-0066 Standardize function type argument syntax to require parentheses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html" class="navigation-list-link">SE-0067 Enhanced Floating Point Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0068-universal-self.html" class="navigation-list-link">SE-0068 Expanding Swift `Self` to class members and value types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html" class="navigation-list-link">SE-0069 Mutability and Foundation Value Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html" class="navigation-list-link">SE-0070 Make Optional Requirements Objective-C-only</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0071-member-keywords.html" class="navigation-list-link">SE-0071 Allow (most) keywords in member references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html" class="navigation-list-link">SE-0072 Fully eliminate implicit bridging conversions from Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0073-noescape-once.html" class="navigation-list-link">SE-0073 Marking closures as executing exactly once</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0074-binary-search.html" class="navigation-list-link">SE-0074 Implementation of Binary Search functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0075-import-test.html" class="navigation-list-link">SE-0075 Adding a Build Configuration Import Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html" class="navigation-list-link">SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html" class="navigation-list-link">SE-0077 Improved operator declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html" class="navigation-list-link">SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html" class="navigation-list-link">SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html" class="navigation-list-link">SE-0080 Failable Numeric Conversion Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html" class="navigation-list-link">SE-0081 Move `where` clause to end of declaration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html" class="navigation-list-link">SE-0082 Package Manager Editable Packages</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html" class="navigation-list-link">SE-0083 Remove bridging conversion behavior from dynamic casts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html" class="navigation-list-link">SE-0084 Allow trailing commas in parameter lists and tuples</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html" class="navigation-list-link">SE-0085 Package Manager Command Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html" class="navigation-list-link">SE-0086 Drop NS Prefix in Swift Foundation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html" class="navigation-list-link">SE-0087 Rename `lazy` to `@lazy`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html" class="navigation-list-link">SE-0088 Modernize libdispatch for Swift 3 naming conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html" class="navigation-list-link">SE-0089 Renaming `String.init<T>(_: T)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html" class="navigation-list-link">SE-0090 Remove `.self` and freely allow type references in expressions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html" class="navigation-list-link">SE-0091 Improving operator requirements in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html" class="navigation-list-link">SE-0092 Typealiases in protocols and protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0093-slice-base.html" class="navigation-list-link">SE-0093 Adding a public `base` property to slices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0094-sequence-function.html" class="navigation-list-link">SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html" class="navigation-list-link">SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0096-dynamictype.html" class="navigation-list-link">SE-0096 Converting `dynamicType` from a property to an operator</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html" class="navigation-list-link">SE-0097 Normalizing naming for "negative" attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html" class="navigation-list-link">SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html" class="navigation-list-link">SE-0099 Restructuring Condition Clauses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html" class="navigation-list-link">SE-0100 Add sequence-based initializers and merge methods to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html" class="navigation-list-link">SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html" class="navigation-list-link">SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html" class="navigation-list-link">SE-0103 Make non-escaping closures the default</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0104-improved-integers.html" class="navigation-list-link">SE-0104 Protocol-oriented integers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html" class="navigation-list-link">SE-0105 Removing Where Clauses from For-In Loops</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html" class="navigation-list-link">SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" class="navigation-list-link">SE-0107 UnsafeRawPointer API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html" class="navigation-list-link">SE-0108 Remove associated type inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html" class="navigation-list-link">SE-0109 Remove the `Boolean` protocol </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html" class="navigation-list-link">SE-0110 Distinguish between single-tuple and multiple-argument function types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html" class="navigation-list-link">SE-0111 Remove type system significance of function argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html" class="navigation-list-link">SE-0112 Improved NSError Bridging</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html" class="navigation-list-link">SE-0113 Add integral rounding functions to FloatingPoint</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html" class="navigation-list-link">SE-0114 Updating Buffer "Value" Names to "Header" Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html" class="navigation-list-link">SE-0115 Rename Literal Syntax Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0116-id-as-any.html" class="navigation-list-link">SE-0116 Import Objective-C `id` as Swift `Any` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html" class="navigation-list-link">SE-0117 Allow distinguishing between public access and public overridability</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html" class="navigation-list-link">SE-0118 Closure Parameter Names and Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html" class="navigation-list-link">SE-0119 Remove access modifiers from extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html" class="navigation-list-link">SE-0120 Revise `partition` Method Signature</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html" class="navigation-list-link">SE-0121 Remove `Optional` Comparison Operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html" class="navigation-list-link">SE-0122 Use colons for subscript declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html" class="navigation-list-link">SE-0123 Disallow coercion to optionals in operator arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html" class="navigation-list-link">SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html" class="navigation-list-link">SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html" class="navigation-list-link">SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html" class="navigation-list-link">SE-0127 Cleaning up stdlib Pointer and Buffer Routines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html" class="navigation-list-link">SE-0128 Change failable UnicodeScalar initializers to failable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html" class="navigation-list-link">SE-0129 Package Manager Test Naming Conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html" class="navigation-list-link">SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0131-anyhashable.html" class="navigation-list-link">SE-0131 Add `AnyHashable` to the standard library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html" class="navigation-list-link">SE-0132 Rationalizing Sequence end-operation names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html" class="navigation-list-link">SE-0133 Rename `flatten()` to `joined()`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html" class="navigation-list-link">SE-0134 Rename two UTF8-related properties on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html" class="navigation-list-link">SE-0135 Package Manager Support for Differentiating Packages by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html" class="navigation-list-link">SE-0136 Memory layout of values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html" class="navigation-list-link">SE-0137 Avoiding Lock-In to Legacy Protocol Designs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" class="navigation-list-link">SE-0138 UnsafeRawBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html" class="navigation-list-link">SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html" class="navigation-list-link">SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html" class="navigation-list-link">SE-0141 Availability by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html" class="navigation-list-link">SE-0142 Permit where clauses to constrain associated types</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" class="navigation-list-link active">SE-0143 Conditional conformances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html" class="navigation-list-link">SE-0144 Allow Single Dollar Sign as a Valid Identifier</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html" class="navigation-list-link">SE-0145 Package Manager Version Pinning</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html" class="navigation-list-link">SE-0146 Package Manager Product Definitions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html" class="navigation-list-link">SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html" class="navigation-list-link">SE-0148 Generic Subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html" class="navigation-list-link">SE-0149 Package Manager Support for Top of Tree development</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html" class="navigation-list-link">SE-0150 Package Manager Support for branches</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html" class="navigation-list-link">SE-0151 Package Manager Swift Language Compatibility Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html" class="navigation-list-link">SE-0152 Package Manager Tools Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html" class="navigation-list-link">SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html" class="navigation-list-link">SE-0154 Provide Custom Collections for Dictionary Keys and Values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html" class="navigation-list-link">SE-0155 Normalize Enum Case Representation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html" class="navigation-list-link">SE-0156 Class and Subtype existentials</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html" class="navigation-list-link">SE-0157 Support recursive constraints on associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html" class="navigation-list-link">SE-0158 Package Manager Manifest API Redesign</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html" class="navigation-list-link">SE-0159 Fix Private Access Levels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0160-objc-inference.html" class="navigation-list-link">SE-0160 Limiting `@objc` inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0161-key-paths.html" class="navigation-list-link">SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html" class="navigation-list-link">SE-0162 Package Manager Custom Target Layouts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html" class="navigation-list-link">SE-0163 String Revision: Collection Conformance, C Interop, Transcoding</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html" class="navigation-list-link">SE-0164 Remove final support in protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0165-dict.html" class="navigation-list-link">SE-0165 Dictionary & Set Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" class="navigation-list-link">SE-0166 Swift Archival & Serialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html" class="navigation-list-link">SE-0167 Swift Encoders</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html" class="navigation-list-link">SE-0168 Multi-Line String Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html" class="navigation-list-link">SE-0169 Improve Interaction Between `private` Declarations and Extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html" class="navigation-list-link">SE-0170 NSNumber bridging and Numeric types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html" class="navigation-list-link">SE-0171 Reduce with `inout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html" class="navigation-list-link">SE-0172 One-sided Ranges</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0173-swap-indices.html" class="navigation-list-link">SE-0173 Add `MutableCollection.swapAt(_:_:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html" class="navigation-list-link">SE-0174 Change `filter` to return an associated type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html" class="navigation-list-link">SE-0175 Package Manager Revised Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" class="navigation-list-link">SE-0176 Enforce Exclusive Access to Memory</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html" class="navigation-list-link">SE-0177 Add clamp(to:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html" class="navigation-list-link">SE-0178 Add `unicodeScalars` property to `Character`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html" class="navigation-list-link">SE-0179 Swift `run` Command</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html" class="navigation-list-link">SE-0180 String Index Overhaul</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html" class="navigation-list-link">SE-0181 Package Manager C/C++ Language Standard Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html" class="navigation-list-link">SE-0182 String Newline Escaping</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html" class="navigation-list-link">SE-0183 Substring performance affordances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html" class="navigation-list-link">SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html" class="navigation-list-link">SE-0185 Synthesizing `Equatable` and `Hashable` conformance</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html" class="navigation-list-link">SE-0186 Remove ownership keyword support in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html" class="navigation-list-link">SE-0187 Introduce Sequence.compactMap(_:)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html" class="navigation-list-link">SE-0188 Make Standard Library Index Types Hashable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html" class="navigation-list-link">SE-0189 Restrict Cross-module Struct Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html" class="navigation-list-link">SE-0190 Target environment platform condition</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html" class="navigation-list-link">SE-0191 Eliminate `IndexDistance` from `Collection`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" class="navigation-list-link">SE-0192 Handling Future Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html" class="navigation-list-link">SE-0193 Cross-module inlining and specialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html" class="navigation-list-link">SE-0194 Derived Collection of Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html" class="navigation-list-link">SE-0195 Introduce User-defined "Dynamic Member Lookup" Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html" class="navigation-list-link">SE-0196 Compiler Diagnostic Directives</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0197-remove-where.html" class="navigation-list-link">SE-0197 Adding in-place `removeAll(where:)` to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html" class="navigation-list-link">SE-0198 Playground QuickLook API Revamp #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html" class="navigation-list-link">SE-0199 Adding `toggle` to `Bool`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html" class="navigation-list-link">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html" class="navigation-list-link">SE-0201 Package Manager Local Dependencies</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0202-random-unification.html" class="navigation-list-link">SE-0202 Random Unification</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html" class="navigation-list-link">SE-0203 Rename Sequence.elementsEqual</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html" class="navigation-list-link">SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html" class="navigation-list-link">SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html" class="navigation-list-link">SE-0206 Hashable Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0207-containsOnly.html" class="navigation-list-link">SE-0207 Add an `allSatisfy` algorithm to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html" class="navigation-list-link">SE-0208 Package Manager System Library Targets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html" class="navigation-list-link">SE-0209 Package Manager Swift Language Version API Update</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html" class="navigation-list-link">SE-0210 Add an `offset(of:)` method to `MemoryLayout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html" class="navigation-list-link">SE-0211 Add Unicode Properties to `Unicode.Scalar`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html" class="navigation-list-link">SE-0212 Compiler Version Directive</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html" class="navigation-list-link">SE-0213 Literal initialization via coercion</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html" class="navigation-list-link">SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html" class="navigation-list-link">SE-0215 Conform `Never` to `Equatable` and `Hashable`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html" class="navigation-list-link">SE-0216 Introduce user-defined dynamically "callable" types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0217-bangbang.html" class="navigation-list-link">SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html" class="navigation-list-link">SE-0218 Introduce `compactMapValues` to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html" class="navigation-list-link">SE-0219 Package Manager Dependency Mirroring</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0220-count-where.html" class="navigation-list-link">SE-0220 `count(where:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0221-character-properties.html" class="navigation-list-link">SE-0221 Character Properties</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html" class="navigation-list-link">SE-0222 Lazy CompactMap Sequence</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html" class="navigation-list-link">SE-0223 Accessing an Array's Uninitialized Buffer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html" class="navigation-list-link">SE-0224 Support 'less than' operator in compilation conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html" class="navigation-list-link">SE-0225 Adding `isMultiple` to `BinaryInteger`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html" class="navigation-list-link">SE-0226 Package Manager Target Based Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html" class="navigation-list-link">SE-0227 Identity key path</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html" class="navigation-list-link">SE-0228 Fix `ExpressibleByStringInterpolation`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0229-simd.html" class="navigation-list-link">SE-0229 SIMD Vectors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html" class="navigation-list-link">SE-0230 Flatten nested optionals resulting from 'try?'</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html" class="navigation-list-link">SE-0231 Optional Iteration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html" class="navigation-list-link">SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html" class="navigation-list-link">SE-0233 Make `Numeric` Refine a new `AdditiveArithmetic` Protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html" class="navigation-list-link">SE-0234 Remove `Sequence.SubSequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0235-add-result.html" class="navigation-list-link">SE-0235 Add Result to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html" class="navigation-list-link">SE-0236 Package Manager Platform Deployment Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html" class="navigation-list-link">SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html" class="navigation-list-link">SE-0238 Package Manager Target Specific Build Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0239-codable-range.html" class="navigation-list-link">SE-0239 Add Codable conformance to Range types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html" class="navigation-list-link">SE-0240 Ordered Collection Diffing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html" class="navigation-list-link">SE-0241 Deprecate String Index Encoded Offsets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html" class="navigation-list-link">SE-0242 Synthesize default values for the memberwise initializer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html" class="navigation-list-link">SE-0243 Integer-convertible character literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html" class="navigation-list-link">SE-0244 Opaque Result Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html" class="navigation-list-link">SE-0245 Add an Array Initializer with Access to Uninitialized Storage</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0246-mathable.html" class="navigation-list-link">SE-0246 Generic Math(s) Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html" class="navigation-list-link">SE-0247 Contiguous Strings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html" class="navigation-list-link">SE-0248 String Gaps and Missing APIs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html" class="navigation-list-link">SE-0249 Key Path Expressions as Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html" class="navigation-list-link">SE-0250 Swift Code Style Guidelines and Formatter</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0251-simd-additions.html" class="navigation-list-link">SE-0251 SIMD additions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html" class="navigation-list-link">SE-0252 Key Path Member Lookup</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0253-callable.html" class="navigation-list-link">SE-0253 Introduce callables </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html" class="navigation-list-link">SE-0254 Static and class subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0255-omit-return.html" class="navigation-list-link">SE-0255 Implicit returns from single-expression functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html" class="navigation-list-link">SE-0256 Introduce `{Mutable}ContiguousCollection` protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0257-elide-comma.html" class="navigation-list-link">SE-0257 Eliding commas from multiline expression lists</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html" class="navigation-list-link"> Feature name</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Swift Evolution List" aria-label="Search Swift Evolution List" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/pondok-programmer/swift-evolution-jekyll">Swift Evolution List</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h1 id="conditional-conformances"> <a href="#conditional-conformances" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Conditional conformances </h1> <ul> <li>Proposal: <a href="0143-conditional-conformances.md">SE-0143</a></li> <li>Author: <a href="https://github.com/DougGregor">Doug Gregor</a></li> <li>Review Manager: <a href="https://github.com/jckarter">Joe Groff</a></li> <li>Status: <strong>Implemented (Swift 4.2)</strong></li> <li>Decision Notes: <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161107/028745.html">Review extended</a>, <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161114/028888.html">Rationale</a></li> <li>Previous Revision: <a href="https://github.com/apple/swift-evolution/blob/91725ee83fa34c81942a634dcdfa9d2441fbd853/proposals/0143-conditional-conformances.md">1</a></li> </ul> <h2 id="introduction"> <a href="#introduction" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduction </h2> <p>Conditional conformances express the notion that a generic type will conform to a particular protocol only when its type arguments meet certain requirements. For example, the <code class="highlighter-rouge">Array</code> collection can implement the <code class="highlighter-rouge">Equatable</code> protocol only when its elements are themselves <code class="highlighter-rouge">Equatable</code>, which can be expressed via the following conditional conformance on <code class="highlighter-rouge">Equatable</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Array</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This feature is part of the <a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-">generics manifesto</a> because its something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.</p> <p>Swift-evolution thread: <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027300.html">here</a></p> <h2 id="motivation"> <a href="#motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Motivation </h2> <p>Conditional conformances address a hole in the composability of the generics system. Continuing the <code class="highlighter-rouge">Array</code> example from above, its always been the case that one could use the <code class="highlighter-rouge">==</code> operator on two arrays of <code class="highlighter-rouge">Equatable</code> type, e.g., <code class="highlighter-rouge">[Int] == [Int]</code> would succeed. However, it doesnt compose: arrays of arrays of <code class="highlighter-rouge">Equatable</code> types cannot be compared (e.g., <code class="highlighter-rouge">[[Int]] == [[Int]]</code> will fail to compile) because, even though there is an <code class="highlighter-rouge">==</code> for arrays of <code class="highlighter-rouge">Equatable</code> type, the arrays themselves are never <code class="highlighter-rouge">Equatable</code>.</p> <p>Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the lazy functionality of the Swift standard librarys collections: using the <code class="highlighter-rouge">lazy</code> member of a sequence produces a lazy adapter that conforms to the <code class="highlighter-rouge">Sequence</code> protocol, while using the <code class="highlighter-rouge">lazy</code> member of a collection produces a lazy adapter that conforms to the <code class="highlighter-rouge">Collection</code> protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: <code class="highlighter-rouge">LazySequence</code>, <code class="highlighter-rouge">LazyCollection</code>, <code class="highlighter-rouge">LazyBidirectionalCollection</code>, and <code class="highlighter-rouge">LazyRandomAccessCollection</code>. The Swift standard library uses overloading of the <code class="highlighter-rouge">lazy</code> property to decide among these:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Sequence</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">lazy</span><span class="p">:</span> <span class="kt">LazySequence</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">lazy</span><span class="p">:</span> <span class="kt">LazyCollection</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">BidirectionalCollection</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">lazy</span><span class="p">:</span> <span class="kt">LazyBidirectionalCollection</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">RandomAccessCollection</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">lazy</span><span class="p">:</span> <span class="kt">LazyRandomAccessCollection</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This approach causes an enormous amount of repetition, and doesnt scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., <code class="highlighter-rouge">Sequence</code>), but which scale their capabilities with their type argument (e.g., the <code class="highlighter-rouge">LazySequence</code> conforms to <code class="highlighter-rouge">Collection</code> when the type argument does, and so on).</p> <h2 id="proposed-solution"> <a href="#proposed-solution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Proposed solution </h2> <p>In a nutshell, the proposed solution is to allow a constrained extension of a <code class="highlighter-rouge">struct</code>, <code class="highlighter-rouge">enum</code>, or <code class="highlighter-rouge">class</code> (but <a href="#alternatives-considered">not a protocol</a>) to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t.swift:1:1: error: extension of type 'Array' with constraints cannot have an inheritance clause
extension Array: Equatable where Element: Equatable { }
^                ~~~~~~~~~
</code></pre></div></div> <p>Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned <code class="highlighter-rouge">Array</code> conformance to <code class="highlighter-rouge">Equatable</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">struct</span> <span class="kt">NotEquatable</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nv">a1</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">a2</span><span class="p">:</span> <span class="p">[</span><span class="kt">NotEquatable</span><span class="p">])</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>    <span class="c1">// okay: [Int] conforms to Equatable because Int conforms to Equatable</span>
  <span class="nf">f</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>    <span class="c1">// error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable</span>
<span class="p">}</span>
</code></pre></div></div> <p>Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">S</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"S"</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Array conforms to P if it's element type conforms to P</span>
<span class="kd">extension</span> <span class="kt">Array</span><span class="p">:</span> <span class="kt">P</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="k">self</span> <span class="p">{</span>
      <span class="n">value</span><span class="o">.</span><span class="nf">doSomething</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Dynamically query and use conformance to P.</span>
<span class="kd">func</span> <span class="nf">doSomethingIfP</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="n">value</span> <span class="k">as?</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="nf">doSomething</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Not a P"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">doSomethingIfP</span><span class="p">([</span><span class="kt">S</span><span class="p">(),</span> <span class="kt">S</span><span class="p">(),</span> <span class="kt">S</span><span class="p">()])</span> <span class="c1">// prints "S" three times</span>
<span class="nf">doSomethingIfP</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>       <span class="c1">// prints "Not a P"</span>
</code></pre></div></div> <p>The <code class="highlighter-rouge">if-let</code> in <code class="highlighter-rouge">doSomethingIfP(_:)</code> dynamically queries whether the type stored in <code class="highlighter-rouge">value</code> conforms to the protocol <code class="highlighter-rouge">P</code>. In the case of an <code class="highlighter-rouge">Array</code>, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to <code class="highlighter-rouge">P</code>: in the first call to <code class="highlighter-rouge">doSomethingIfP(_:)</code>, the lookup finds the conformance of <code class="highlighter-rouge">S</code> to <code class="highlighter-rouge">P</code>. In the second case, there is no conformance of <code class="highlighter-rouge">Int</code> to <code class="highlighter-rouge">P</code>, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.</p> <h2 id="detailed-design"> <a href="#detailed-design" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Detailed design </h2> <p>Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.</p> <h3 id="multiple-conformances"> <a href="#multiple-conformances" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Multiple conformances </h3> <p>Swift already bans programs that attempt to make the same type conform to the same protocol twice, e.g.:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">struct</span> <span class="kt">X</span> <span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">X</span> <span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// error: X already stated conformance to P</span>
</code></pre></div></div> <p>This existing ban on multiple conformances is extended to conditional conformances, including attempts to conform to the same protocol in two different ways. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">wrapped</span><span class="p">:</span> <span class="kt">Wrapped</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">HasIdentity</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">===</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="k">Self</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// error: SomeWrapper already stated conformance to Equatable</span>
<span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">HasIdentity</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">===</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Furthermore, for consistency, the ban extends even to multiple conformances that are clearly disjoint, e.g.,</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span> <span class="o">==</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// error: SomeWrapper already stated conformance to Equatable</span>
<span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span> <span class="o">==</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The section <a href="#overlapping-conformances">overlapping conformances</a> describes some of the complexities introduced by multiple conformances, to justify their exclusion from this proposal. A follow-on proposal could introduce support for multiple conformances, but should likely also cover related features such as <a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#private-conformances">private conformances</a> that are orthogonal to conditional conformances.</p> <h3 id="implied-conditional-conformances"> <a href="#implied-conditional-conformances" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Implied conditional conformances </h3> <p>Stating a non-conditional conformance to a protocol implicitly states conformances to any of the protocols that the protocol inherits: one can declare conformance to the <code class="highlighter-rouge">Collection</code> protocol, and it implies conformance to <code class="highlighter-rouge">Sequence</code> as well. However, with conditional conformances, the constraints for the conformance to the inherited protocol may not be clear, and even when there is a clear choice, it will often be incorrect, so the conformance to the inherited protocol will need to be stated explicitly. For example, for the first case:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">Q</span> <span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">R</span> <span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">struct</span> <span class="kt">X</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">extension</span> <span class="kt">X</span><span class="p">:</span> <span class="kt">Q</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Q</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">X</span><span class="p">:</span> <span class="kt">R</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// error: X does not conform to protocol P; add</span>
<span class="c1">//</span>
<span class="c1">//   extension X: P where &lt;#constraints#&gt; { ... }</span>
<span class="c1">//</span>
<span class="c1">// to state conformance to P.</span>
</code></pre></div></div> <p>Note that both of the constrained extensions could imply the conformance to <code class="highlighter-rouge">P</code>. However, because the two extensions have disjoint sets of constraints (one requires <code class="highlighter-rouge">T: Q</code>, the other <code class="highlighter-rouge">T: R</code>), it becomes unclear which constraints should apply to the conformance to <code class="highlighter-rouge">P</code>: picking one set of constraints (e.g. <code class="highlighter-rouge">T: Q</code>, from the conformance of <code class="highlighter-rouge">X</code> to <code class="highlighter-rouge">Q</code>) makes the inherited conformance unusable for <code class="highlighter-rouge">X</code> instances where <code class="highlighter-rouge">T: R</code>, which would break type safety (because we could have <code class="highlighter-rouge">X</code> instances that conform to <code class="highlighter-rouge">R</code> but not <code class="highlighter-rouge">P</code>!). Moreover, the previously-discussed ban on multiple conformances prohibits introducing two different conformances of <code class="highlighter-rouge">X</code> to <code class="highlighter-rouge">P</code> (one where <code class="highlighter-rouge">T: Q</code> and one where <code class="highlighter-rouge">T: R</code>). Therefore, the program above is ill-formed, and the correct fix is for the user to introduce an explicit conformance of <code class="highlighter-rouge">X</code> to <code class="highlighter-rouge">P</code> with the appropriate set of constraints, e.g.:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">X</span><span class="p">:</span> <span class="kt">P</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>For the second problem mentioned above, when there is an obvious set of requirements to use in an implied conformance, it is likely to be wrong, because of how often conditional conformances are used for wrapper types. For instance:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">R</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">S</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Y</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Y</span><span class="p">:</span> <span class="kt">R</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Y</span><span class="p">:</span> <span class="kt">S</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">S</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>The conformances of <code class="highlighter-rouge">Y: R</code> and <code class="highlighter-rouge">Y: S</code> both imply the conformance <code class="highlighter-rouge">Y: P</code>, however the constraints <code class="highlighter-rouge">T: R</code> are less specialized (more general) than the constraints <code class="highlighter-rouge">T: S</code>, because every <code class="highlighter-rouge">S</code> is also an <code class="highlighter-rouge">R</code>. Therefore, it could be that <code class="highlighter-rouge">Y</code> will conform to <code class="highlighter-rouge">P</code> when <code class="highlighter-rouge">T: R</code>, e.g.:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// compiler produces the following implied inherited conformance:</span>
<span class="kd">extension</span> <span class="kt">Y</span><span class="p">:</span> <span class="kt">P</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>However, it is likely that the best conformance is actually the more relaxed (that is, applicable for more choices of <code class="highlighter-rouge">T</code>):</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Y</span><span class="p">:</span> <span class="kt">P</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>This is the case for almost all wrappers for the <code class="highlighter-rouge">Sequence</code>/<code class="highlighter-rouge">Collection</code>/<code class="highlighter-rouge">BidirectionalCollection</code>/ hierarchy (for instance, as discussed below, <code class="highlighter-rouge">Slice : BidirectionalCollection where Base : BidirectionalCollection</code> and similarly for <code class="highlighter-rouge">RandomAccessCollection</code>), and for most types conforming to several of <code class="highlighter-rouge">Equatable</code>, <code class="highlighter-rouge">Comparable</code> and <code class="highlighter-rouge">Hashable</code>.</p> <p>Implicitly constructing these conformances could be okay if it were possible to relax the overly-strong requirements when theyre noticed in future. However, it can be backwards incompatible, and so not doing it implicitly is defaulting to the safer option. The backwards incompatibility comes from how requirements are inferred in function signatures: given <code class="highlighter-rouge">struct Z&lt;A: P&gt; {}</code>, Swift notices that a declaration <code class="highlighter-rouge">func foo&lt;A&gt;(x: Z&lt;Y&lt;A&gt;&gt;)</code> requires that <code class="highlighter-rouge">Y&lt;A&gt; : P</code>, since it is used in <code class="highlighter-rouge">Z</code>, and thus, if the implicit inherited conformance above existed, <code class="highlighter-rouge">A: R</code>. This conformance is part of the functions signature (and mangling!) and is available to be used inside <code class="highlighter-rouge">foo</code>: that function can use requirements from <code class="highlighter-rouge">R</code> on values of type <code class="highlighter-rouge">A</code>. If the library declaring <code class="highlighter-rouge">Y</code> was to change to the declaration of the conformance <code class="highlighter-rouge">Y: P</code>, the inferred requirement becomes <code class="highlighter-rouge">A: P</code>, which changes the <code class="highlighter-rouge">foo</code>s mangled name, and what can be done with values of type <code class="highlighter-rouge">A</code>. This breaks both API and ABI compatibility.</p> <p>(Note: the inference above is driven by having a unique conformance, and thus <code class="highlighter-rouge">Y: P</code> if <em>and only if</em> <code class="highlighter-rouge">A: P</code>. If overlapping conformances were allowed, this inference would not be possible. A possible alternative thats more directly future-proof with overlapping conformances would be to disable this sort of inference from conditional conformances, and instead require the user to write <code class="highlighter-rouge">func foo&lt;A: P&gt;</code>. This could also allow the conformances to be implied, since it would no longer be such a backwards-compatibility problem.)</p> <p>On the other hand, not allowing implicit inherited conformances means that one cannot insert a superprotocol to an existing protocol: for instance, if the second example started as <code class="highlighter-rouge">protocol R { }</code> and was changed to <code class="highlighter-rouge">protocol R: P { }</code>. However, we believe this is already incompatible, for unrelated reasons.</p> <p>Finally, it is a small change to get implicit behaviour explicitly, by adding the conformance declaration to the extension that would be implying the conformance. For instance, if it is correct for the second example to have <code class="highlighter-rouge">T: R</code> as the requirement on <code class="highlighter-rouge">Y: P</code>, the <code class="highlighter-rouge">Y: R</code> extension only needs to be changed to include <code class="highlighter-rouge">, P</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Y</span><span class="p">:</span> <span class="kt">R</span><span class="p">,</span> <span class="kt">P</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>This is something compilers can, and should, suggest as a fixit.</p> <h2 id="standard-library-adoption"> <a href="#standard-library-adoption" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Standard library adoption </h2> <p>Adopt conditional conformances to make various standard library types that already have a suitable <code class="highlighter-rouge">==</code> conform to <code class="highlighter-rouge">Equatable</code>. Specifically:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Optional</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span> <span class="cm">/*== already exists */</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Array</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span> <span class="cm">/*== already exists */</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">ArraySlice</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span> <span class="cm">/*== already exists */</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">ContiguousArray</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span> <span class="cm">/*== already exists */</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Dictionary</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span> <span class="cm">/*== already exists */</span> <span class="p">}</span>
</code></pre></div></div> <p>In addition, implement conditional conformances to <code class="highlighter-rouge">Hashable</code> for the types above, as well as <code class="highlighter-rouge">Range</code> and <code class="highlighter-rouge">ClosedRange</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Optional</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Array</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">ArraySlice</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">ContiguousArray</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Dictionary</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Range</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Bound</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">ClosedRange</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="k">where</span> <span class="kt">Bound</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</code></pre></div></div> <p>While the standard library did not previously provide existing implementations of <code class="highlighter-rouge">hashValue</code> for these types, conditional <code class="highlighter-rouge">Hashable</code> conformance is a natural expectation for them.</p> <p>Note that <code class="highlighter-rouge">Set</code> is already (unconditionally) <code class="highlighter-rouge">Equatable</code> and <code class="highlighter-rouge">Hashable</code>.</p> <p>In addition, it is intended that the standard library adopt conditional conformance to collapse a number of variants of base types where other generic parameters enable conformance to further protocols.</p> <p>For example, there is a type:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ReversedCollection</span><span class="o">&lt;</span><span class="kt">Base</span><span class="p">:</span> <span class="kt">BidirectionalCollection</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">BidirectionalCollection</span>
</code></pre></div></div> <p>that provides a low-cost lazy reversal of any bidirecitonal collection. There is a variation on that type,</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ReversedRandomAccessCollection</span><span class="o">&lt;</span><span class="kt">Base</span><span class="p">:</span> <span class="kt">RandomAccessCollection</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">RandomAccessCollection</span>
</code></pre></div></div> <p>that additionaly conforms to <code class="highlighter-rouge">RandomAccessCollection</code> when its base does. Users create these types via the <code class="highlighter-rouge">reversed()</code> extension method on <code class="highlighter-rouge">BidirectionalCollection</code> and <code class="highlighter-rouge">RandomAccessCollection</code> respectively.</p> <p>With conditional conformance, the <code class="highlighter-rouge">ReversedRandomAccessCollection</code> variant can be replaced with a conditional extension:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ReversedCollection</span><span class="p">:</span> <span class="kt">RandomAccessCollection</span> <span class="k">where</span> <span class="kt">Base</span><span class="p">:</span> <span class="kt">RandomAccessCollection</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">@available(*, deprecated, renamed: "ReversedCollection")</span>
<span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">ReversedRandomAccessCollection</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">RandomAccessCollection</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">ReversedCollection</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
</code></pre></div></div> <p>Similar techniques can be used for variants of <code class="highlighter-rouge">Slice</code>, <code class="highlighter-rouge">LazySequence</code>, <code class="highlighter-rouge">DefaultIndices</code>, <code class="highlighter-rouge">Range</code> and others. These refactorings are considered an implementation detail of the existing functionality standard library and should be applied across the board where applicable.</p> <h2 id="source-compatibility"> <a href="#source-compatibility" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Source compatibility </h2> <p>From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntaxan extension that both declares a protocol conformance and has a <code class="highlighter-rouge">where</code> clausewhose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.</p> <h2 id="effect-on-abi-stability"> <a href="#effect-on-abi-stability" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on ABI Stability </h2> <p>As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:</p> <ol> <li>Improve composability: the example in the <a href="#introduction">introduction</a> made <code class="highlighter-rouge">Array</code> conform to <code class="highlighter-rouge">Equatable</code> when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., <code class="highlighter-rouge">Optional</code>) can compose better with generic algorithms. Most of these changes wont be ABI- or source-breaking, because theyre additive.</li> <li>Eliminating repetition: the <code class="highlighter-rouge">lazy</code> wrappers described in the <a href="#motivation">motivation</a> section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply arent part of Swift 4.</li> </ol> <p>Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.</p> <h2 id="effect-on-resilience"> <a href="#effect-on-resilience" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on Resilience </h2> <p>One of the primary goals of Swift 4 is resilience, which allows libraries to evolve without breaking binary compatibility with the applications that use them. While the specific details of the impact of conditional conformances on resilience will be captured in a more-complete proposal on resilience, possible rules are summarized here:</p> <ul> <li>A conditional conformance cannot be removed in the new version of a library, because existing clients might depend on it.</li> <li>A conditional conformance can be added in a new version of a library, roughly following the rules described in the <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#new-conformances">library evolution document</a>. The conformance itself will need to be annotated with the version in which it was introduced.</li> <li> <p>A conditional conformance can be <em>generalized</em> in a new version of the library, i.e., it can be effectively replaced by a (possibly conditional) conformance in a new version of the library that is less specialized than the conditional conformance in the older version of the library. For example.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">X</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>
  
<span class="c1">// Conformance in version 1.0</span>
<span class="kd">public</span> <span class="kd">extension</span> <span class="kt">X</span><span class="p">:</span> <span class="kt">Sequence</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  
<span class="c1">// Can be replaced by this less-specialized conformance in version 1.1</span>
<span class="kd">public</span> <span class="kd">extension</span> <span class="kt">X</span><span class="p">:</span> <span class="kt">Sequence</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Sequence</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div> </div> <p>Such conformances would likely need some kind of annotation.</p> </li> </ul> <h2 id="alternatives-considered"> <a href="#alternatives-considered" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Alternatives considered </h2> <h3 id="overlapping-conformances"> <a href="#overlapping-conformances" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Overlapping conformances </h3> <p>As noted in the section on <a href="#multiple-conformances">multiple conformances</a>, Swift already bans programs that attempt to make the same type conform to the same protocol twice. This proposal extends the ban to cases where the conformances are conditional. Reconsider the example from that section:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">wrapped</span><span class="p">:</span> <span class="kt">Wrapped</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">HasIdentity</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">===</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="k">Self</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">HasIdentity</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">===</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note that, for an arbitrary type <code class="highlighter-rouge">T</code>, there are four potential answers to the question of whether <code class="highlighter-rouge">SomeWrapper&lt;T&gt;</code> conforms to <code class="highlighter-rouge">Equatable</code>:</p> <ol> <li>No, it does not conform because <code class="highlighter-rouge">T</code> is neither <code class="highlighter-rouge">Equatable</code> nor <code class="highlighter-rouge">HasIdentity</code>.</li> <li>Yes, it conforms via the first extension of <code class="highlighter-rouge">SomeWrapper</code> because <code class="highlighter-rouge">T</code> conforms to <code class="highlighter-rouge">Equatable</code>.</li> <li>Yes, it conforms via the second extension of <code class="highlighter-rouge">SomeWrapper</code> because <code class="highlighter-rouge">T</code> conforms to <code class="highlighter-rouge">HasIdentity</code>.</li> <li>Ambiguity, because <code class="highlighter-rouge">T</code> conforms to both <code class="highlighter-rouge">Equatable</code> and <code class="highlighter-rouge">HasIdentity</code>.</li> </ol> <p>It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as <em>overlapping</em>. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Possible tie-breaker conformance</span>
<span class="kd">extension</span> <span class="kt">SomeWrapper</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="o">&amp;</span> <span class="kt">HasIdentity</span><span class="p">,</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">SomeWrapper</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">wrapped</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The design is consistent, because this third conditional conformance is more <em>specialized</em> than either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:</p> <ol> <li>To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To <em>statically</em> resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).</li> <li>It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness weve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.</li> <li>All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.</li> </ol> <p>For these reasons, this proposal <em>bans overlapping conformances</em> entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost.</p> <p>There are several potential solutions to the problem of overlapping conformances (e.g., admitting some form of overlapping conformances that can be resolved at runtime or introducing the notion of conformances that cannot be queried a runtime), but the feature is large enough to warrant a separate proposal that explores the solutions in greater depth.</p> <h3 id="extending-protocols-to-conform-to-protocols"> <a href="#extending-protocols-to-conform-to-protocols" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Extending protocols to conform to protocols </h3> <p>The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Collection</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="k">where</span> <span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="k">Self</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This protocol extension would make any <code class="highlighter-rouge">Collection</code> of <code class="highlighter-rouge">Equatable</code> elements <code class="highlighter-rouge">Equatable</code>, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to <code class="highlighter-rouge">Collection</code> could declare its own conformance to <code class="highlighter-rouge">Equatable</code>, conditional or otherwise.</p> <h3 id="overloading-across-constrained-extensions"> <a href="#overloading-across-constrained-extensions" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Overloading across constrained extensions </h3> <p>Conditional conformances may exacerbate existing problems with overloading behaving differently with concrete types vs. in a generic context. For example, consider:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">Q</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">R</span><span class="p">:</span> <span class="kt">Q</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">struct</span> <span class="kt">X1</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">extension</span> <span class="kt">X1</span><span class="p">:</span> <span class="kt">Q</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Q</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// #1: basic implementation of 'f()'</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">X1</span><span class="p">:</span> <span class="kt">R</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// #2: superfast implementation of f() using some knowledge of 'R'</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// note: compiler implicitly creates conformance `X1: P` equivalent to</span>
<span class="c1">//   extension X1: P where T: Q { }</span>

<span class="kd">struct</span> <span class="kt">X2</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="kt">X1</span><span class="o">&lt;</span><span class="kt">X2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">as</span> <span class="kt">P</span><span class="p">)</span><span class="o">.</span><span class="nf">f</span><span class="p">()</span> <span class="c1">// calls #1, which was used to satisfy the requirement for 'f'</span>
<span class="kt">X1</span><span class="o">&lt;</span><span class="kt">X2</span><span class="o">&gt;</span><span class="p">()</span><span class="o">.</span><span class="nf">f</span><span class="p">()</span>        <span class="c1">// calls #2, which is preferred by overload resolution</span>
</code></pre></div></div> <p>When satisfying a protocol requirement, Swift chooses the most specific member that can be used <em>given the constraints of the conformance</em>. In this case, the conformance of <code class="highlighter-rouge">X1</code> to <code class="highlighter-rouge">P</code> has the constraints <code class="highlighter-rouge">T: Q</code>, so the only <code class="highlighter-rouge">f()</code> that can be used under those constraints is the <code class="highlighter-rouge">f()</code> from the first extension. The <code class="highlighter-rouge">f()</code> in the second extension wont necessarily always be available, because <code class="highlighter-rouge">T</code> may not conform to <code class="highlighter-rouge">R</code>. Hence, the call that treats an <code class="highlighter-rouge">X1&lt;X2&gt;</code> as a <code class="highlighter-rouge">P</code> gets the first implementation of <code class="highlighter-rouge">X1.f()</code>. When using the concrete type <code class="highlighter-rouge">X1&lt;X2&gt;</code>, where <code class="highlighter-rouge">X2</code> conforms to <code class="highlighter-rouge">R</code>, both <code class="highlighter-rouge">X1.f()</code> implementations are visible and the second is more specialized.</p> <p>This is not a new problem to Swift. We can write a similar example using a constrained extension and non-conditional conformances:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">Q</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">struct</span> <span class="kt">X3</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">extension</span> <span class="kt">X3</span><span class="p">:</span> <span class="kt">Q</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// #1: basic implementation of 'f()'</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">X3</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// #2: superfast implementation of f() using some knowledge of 'R'</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// note: compiler implicitly creates conformance `X3: P` equivalent to</span>
<span class="c1">//   extension X3: P { }</span>

<span class="kd">struct</span> <span class="kt">X2</span><span class="p">:</span> <span class="kt">R</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="kt">X3</span><span class="o">&lt;</span><span class="kt">X2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">as</span> <span class="kt">P</span><span class="p">)</span><span class="o">.</span><span class="nf">f</span><span class="p">()</span> <span class="c1">// calls #1, which was used to satisfy the requirement for 'f'</span>
<span class="kt">X3</span><span class="o">&lt;</span><span class="kt">X2</span><span class="o">&gt;</span><span class="p">()</span><span class="o">.</span><span class="nf">f</span><span class="p">()</span>        <span class="c1">// calls #2, which is preferred by overload resolution</span>
</code></pre></div></div> <p>That said, the introduction of conditional conformances might increase the likelihood of these problems surprising developers.</p> </div> </div> </div> </div> </body> </html>
