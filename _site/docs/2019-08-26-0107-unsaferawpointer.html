<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>SE-0107 UnsafeRawPointer API - Swift Evolution List</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>SE-0107 UnsafeRawPointer API | Swift Evolution List</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="SE-0107 UnsafeRawPointer API" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Yuhuu!" /> <meta property="og:description" content="Yuhuu!" /> <link rel="canonical" href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" /> <meta property="og:url" content="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" /> <meta property="og:site_name" content="Swift Evolution List" /> <script type="application/ld+json"> {"url":"http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html","headline":"SE-0107 UnsafeRawPointer API","description":"Yuhuu!","@type":"WebPage","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Swift Evolution List</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/about/" class="navigation-list-link">About</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html" class="navigation-list-link">SE-0001 Allow (most) keywords as argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0002-remove-currying.html" class="navigation-list-link">SE-0002 Removing currying `func` declaration syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html" class="navigation-list-link">SE-0003 Removing `var` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html" class="navigation-list-link">SE-0004 Remove the `++` and `--` operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html" class="navigation-list-link">SE-0005 Better Translation of Objective-C APIs Into Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html" class="navigation-list-link">SE-0006 Apply API Guidelines to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html" class="navigation-list-link">SE-0007 Remove C-style for-loops with conditions and incrementers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html" class="navigation-list-link">SE-0008 Add a Lazy flatMap for Sequences of Optionals #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html" class="navigation-list-link">SE-0009 Require self for accessing instance members</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html" class="navigation-list-link">SE-0010 Add StaticString.UnicodeScalarView</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html" class="navigation-list-link">SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html" class="navigation-list-link">SE-0012 Add `@noescape` to public library API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html" class="navigation-list-link">SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html" class="navigation-list-link">SE-0014 Constraining `AnySequence.init`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html" class="navigation-list-link">SE-0015 Tuple comparison operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html" class="navigation-list-link">SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html" class="navigation-list-link">SE-0017 Change `Unmanaged` to use `UnsafePointer`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html" class="navigation-list-link">SE-0018 Flexible Memberwise Initialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html" class="navigation-list-link">SE-0019 Swift Testing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html" class="navigation-list-link">SE-0020 Swift Language Version Build Configuration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html" class="navigation-list-link">SE-0021 Naming Functions with Argument Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html" class="navigation-list-link">SE-0022 Referencing the Objective-C selector of a method</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html" class="navigation-list-link">SE-0023 API Design Guidelines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html" class="navigation-list-link">SE-0024 Optional Value Setter `??=`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html" class="navigation-list-link">SE-0025 Scoped Access Level</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html" class="navigation-list-link">SE-0026 Abstract classes and methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html" class="navigation-list-link">SE-0027 Expose code unit initializers on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html" class="navigation-list-link">SE-0028 Modernizing Swift's Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html" class="navigation-list-link">SE-0029 Remove implicit tuple splat behavior from function applications</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html" class="navigation-list-link">SE-0030 Property Behaviors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html" class="navigation-list-link">SE-0031 Adjusting `inout` Declarations for Type Decoration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html" class="navigation-list-link">SE-0032 Add `first(where:)` method to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html" class="navigation-list-link">SE-0033 Import Objective-C Constants as Swift Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html" class="navigation-list-link">SE-0034 Disambiguating Line Control Statements from Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html" class="navigation-list-link">SE-0035 Limiting `inout` capture to `@noescape` contexts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0036-enum-dot.html" class="navigation-list-link">SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html" class="navigation-list-link">SE-0037 Clarify interaction between comments & operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html" class="navigation-list-link">SE-0038 Package Manager C Language Target Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html" class="navigation-list-link">SE-0039 Modernizing Playground Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0040-attributecolons.html" class="navigation-list-link">SE-0040 Replacing Equal Signs with Colons For Attribute Arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html" class="navigation-list-link">SE-0041 Updating Protocol Naming Conventions for Conversions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html" class="navigation-list-link">SE-0042 Flattening the function type of unapplied method references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html" class="navigation-list-link">SE-0043 Declare variables in 'case' labels with multiple patterns </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0044-import-as-member.html" class="navigation-list-link">SE-0044 Import as member</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html" class="navigation-list-link">SE-0045 Add prefix(while:) and drop(while:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0046-first-label.html" class="navigation-list-link">SE-0046 Establish consistent label behavior across all parameters including first labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html" class="navigation-list-link">SE-0047 Defaulting non-Void functions so they warn on unused results</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html" class="navigation-list-link">SE-0048 Generic Type Aliases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html" class="navigation-list-link">SE-0049 Move @noescape and @autoclosure to be type attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html" class="navigation-list-link">SE-0050 Decoupling Floating Point Strides from Generic Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html" class="navigation-list-link">SE-0051 Conventionalizing `stride` semantics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html" class="navigation-list-link">SE-0052 Change IteratorType post-nil guarantee</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html" class="navigation-list-link">SE-0053 Remove explicit use of `let` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html" class="navigation-list-link">SE-0054 Abolish `ImplicitlyUnwrappedOptional` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html" class="navigation-list-link">SE-0055 Make unsafe pointer nullability explicit using Optional</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html" class="navigation-list-link">SE-0056 Allow trailing closures in `guard` conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html" class="navigation-list-link">SE-0057 Importing Objective-C Lightweight Generics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html" class="navigation-list-link">SE-0058 Allow Swift types to provide custom Objective-C representations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html" class="navigation-list-link">SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html" class="navigation-list-link">SE-0060 Enforcing order of defaulted parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html" class="navigation-list-link">SE-0061 Add Generic Result and Error Handling to autoreleasepool()</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html" class="navigation-list-link">SE-0062 Referencing Objective-C key-paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html" class="navigation-list-link">SE-0063 SwiftPM System Module Search Paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0064-property-selectors.html" class="navigation-list-link">SE-0064 Referencing the Objective-C selector of property getters and setters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html" class="navigation-list-link">SE-0065 A New Model for Collections and Indices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html" class="navigation-list-link">SE-0066 Standardize function type argument syntax to require parentheses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html" class="navigation-list-link">SE-0067 Enhanced Floating Point Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0068-universal-self.html" class="navigation-list-link">SE-0068 Expanding Swift `Self` to class members and value types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html" class="navigation-list-link">SE-0069 Mutability and Foundation Value Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html" class="navigation-list-link">SE-0070 Make Optional Requirements Objective-C-only</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0071-member-keywords.html" class="navigation-list-link">SE-0071 Allow (most) keywords in member references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html" class="navigation-list-link">SE-0072 Fully eliminate implicit bridging conversions from Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0073-noescape-once.html" class="navigation-list-link">SE-0073 Marking closures as executing exactly once</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0074-binary-search.html" class="navigation-list-link">SE-0074 Implementation of Binary Search functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0075-import-test.html" class="navigation-list-link">SE-0075 Adding a Build Configuration Import Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html" class="navigation-list-link">SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html" class="navigation-list-link">SE-0077 Improved operator declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html" class="navigation-list-link">SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html" class="navigation-list-link">SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html" class="navigation-list-link">SE-0080 Failable Numeric Conversion Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html" class="navigation-list-link">SE-0081 Move `where` clause to end of declaration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html" class="navigation-list-link">SE-0082 Package Manager Editable Packages</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html" class="navigation-list-link">SE-0083 Remove bridging conversion behavior from dynamic casts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html" class="navigation-list-link">SE-0084 Allow trailing commas in parameter lists and tuples</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html" class="navigation-list-link">SE-0085 Package Manager Command Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html" class="navigation-list-link">SE-0086 Drop NS Prefix in Swift Foundation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html" class="navigation-list-link">SE-0087 Rename `lazy` to `@lazy`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html" class="navigation-list-link">SE-0088 Modernize libdispatch for Swift 3 naming conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html" class="navigation-list-link">SE-0089 Renaming `String.init<T>(_: T)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html" class="navigation-list-link">SE-0090 Remove `.self` and freely allow type references in expressions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html" class="navigation-list-link">SE-0091 Improving operator requirements in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html" class="navigation-list-link">SE-0092 Typealiases in protocols and protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0093-slice-base.html" class="navigation-list-link">SE-0093 Adding a public `base` property to slices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0094-sequence-function.html" class="navigation-list-link">SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html" class="navigation-list-link">SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0096-dynamictype.html" class="navigation-list-link">SE-0096 Converting `dynamicType` from a property to an operator</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html" class="navigation-list-link">SE-0097 Normalizing naming for "negative" attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html" class="navigation-list-link">SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html" class="navigation-list-link">SE-0099 Restructuring Condition Clauses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html" class="navigation-list-link">SE-0100 Add sequence-based initializers and merge methods to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html" class="navigation-list-link">SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html" class="navigation-list-link">SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html" class="navigation-list-link">SE-0103 Make non-escaping closures the default</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0104-improved-integers.html" class="navigation-list-link">SE-0104 Protocol-oriented integers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html" class="navigation-list-link">SE-0105 Removing Where Clauses from For-In Loops</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html" class="navigation-list-link">SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" class="navigation-list-link active">SE-0107 UnsafeRawPointer API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html" class="navigation-list-link">SE-0108 Remove associated type inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html" class="navigation-list-link">SE-0109 Remove the `Boolean` protocol </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html" class="navigation-list-link">SE-0110 Distinguish between single-tuple and multiple-argument function types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html" class="navigation-list-link">SE-0111 Remove type system significance of function argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html" class="navigation-list-link">SE-0112 Improved NSError Bridging</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html" class="navigation-list-link">SE-0113 Add integral rounding functions to FloatingPoint</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html" class="navigation-list-link">SE-0114 Updating Buffer "Value" Names to "Header" Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html" class="navigation-list-link">SE-0115 Rename Literal Syntax Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0116-id-as-any.html" class="navigation-list-link">SE-0116 Import Objective-C `id` as Swift `Any` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html" class="navigation-list-link">SE-0117 Allow distinguishing between public access and public overridability</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html" class="navigation-list-link">SE-0118 Closure Parameter Names and Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html" class="navigation-list-link">SE-0119 Remove access modifiers from extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html" class="navigation-list-link">SE-0120 Revise `partition` Method Signature</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html" class="navigation-list-link">SE-0121 Remove `Optional` Comparison Operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html" class="navigation-list-link">SE-0122 Use colons for subscript declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html" class="navigation-list-link">SE-0123 Disallow coercion to optionals in operator arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html" class="navigation-list-link">SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html" class="navigation-list-link">SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html" class="navigation-list-link">SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html" class="navigation-list-link">SE-0127 Cleaning up stdlib Pointer and Buffer Routines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html" class="navigation-list-link">SE-0128 Change failable UnicodeScalar initializers to failable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html" class="navigation-list-link">SE-0129 Package Manager Test Naming Conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html" class="navigation-list-link">SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0131-anyhashable.html" class="navigation-list-link">SE-0131 Add `AnyHashable` to the standard library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html" class="navigation-list-link">SE-0132 Rationalizing Sequence end-operation names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html" class="navigation-list-link">SE-0133 Rename `flatten()` to `joined()`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html" class="navigation-list-link">SE-0134 Rename two UTF8-related properties on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html" class="navigation-list-link">SE-0135 Package Manager Support for Differentiating Packages by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html" class="navigation-list-link">SE-0136 Memory layout of values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html" class="navigation-list-link">SE-0137 Avoiding Lock-In to Legacy Protocol Designs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" class="navigation-list-link">SE-0138 UnsafeRawBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html" class="navigation-list-link">SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html" class="navigation-list-link">SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html" class="navigation-list-link">SE-0141 Availability by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html" class="navigation-list-link">SE-0142 Permit where clauses to constrain associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" class="navigation-list-link">SE-0143 Conditional conformances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html" class="navigation-list-link">SE-0144 Allow Single Dollar Sign as a Valid Identifier</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html" class="navigation-list-link">SE-0145 Package Manager Version Pinning</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html" class="navigation-list-link">SE-0146 Package Manager Product Definitions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html" class="navigation-list-link">SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html" class="navigation-list-link">SE-0148 Generic Subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html" class="navigation-list-link">SE-0149 Package Manager Support for Top of Tree development</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html" class="navigation-list-link">SE-0150 Package Manager Support for branches</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html" class="navigation-list-link">SE-0151 Package Manager Swift Language Compatibility Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html" class="navigation-list-link">SE-0152 Package Manager Tools Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html" class="navigation-list-link">SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html" class="navigation-list-link">SE-0154 Provide Custom Collections for Dictionary Keys and Values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html" class="navigation-list-link">SE-0155 Normalize Enum Case Representation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html" class="navigation-list-link">SE-0156 Class and Subtype existentials</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html" class="navigation-list-link">SE-0157 Support recursive constraints on associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html" class="navigation-list-link">SE-0158 Package Manager Manifest API Redesign</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html" class="navigation-list-link">SE-0159 Fix Private Access Levels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0160-objc-inference.html" class="navigation-list-link">SE-0160 Limiting `@objc` inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0161-key-paths.html" class="navigation-list-link">SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html" class="navigation-list-link">SE-0162 Package Manager Custom Target Layouts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html" class="navigation-list-link">SE-0163 String Revision: Collection Conformance, C Interop, Transcoding</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html" class="navigation-list-link">SE-0164 Remove final support in protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0165-dict.html" class="navigation-list-link">SE-0165 Dictionary & Set Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" class="navigation-list-link">SE-0166 Swift Archival & Serialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html" class="navigation-list-link">SE-0167 Swift Encoders</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html" class="navigation-list-link">SE-0168 Multi-Line String Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html" class="navigation-list-link">SE-0169 Improve Interaction Between `private` Declarations and Extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html" class="navigation-list-link">SE-0170 NSNumber bridging and Numeric types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html" class="navigation-list-link">SE-0171 Reduce with `inout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html" class="navigation-list-link">SE-0172 One-sided Ranges</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0173-swap-indices.html" class="navigation-list-link">SE-0173 Add `MutableCollection.swapAt(_:_:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html" class="navigation-list-link">SE-0174 Change `filter` to return an associated type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html" class="navigation-list-link">SE-0175 Package Manager Revised Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" class="navigation-list-link">SE-0176 Enforce Exclusive Access to Memory</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html" class="navigation-list-link">SE-0177 Add clamp(to:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html" class="navigation-list-link">SE-0178 Add `unicodeScalars` property to `Character`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html" class="navigation-list-link">SE-0179 Swift `run` Command</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html" class="navigation-list-link">SE-0180 String Index Overhaul</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html" class="navigation-list-link">SE-0181 Package Manager C/C++ Language Standard Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html" class="navigation-list-link">SE-0182 String Newline Escaping</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html" class="navigation-list-link">SE-0183 Substring performance affordances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html" class="navigation-list-link">SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html" class="navigation-list-link">SE-0185 Synthesizing `Equatable` and `Hashable` conformance</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html" class="navigation-list-link">SE-0186 Remove ownership keyword support in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html" class="navigation-list-link">SE-0187 Introduce Sequence.compactMap(_:)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html" class="navigation-list-link">SE-0188 Make Standard Library Index Types Hashable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html" class="navigation-list-link">SE-0189 Restrict Cross-module Struct Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html" class="navigation-list-link">SE-0190 Target environment platform condition</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html" class="navigation-list-link">SE-0191 Eliminate `IndexDistance` from `Collection`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" class="navigation-list-link">SE-0192 Handling Future Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html" class="navigation-list-link">SE-0193 Cross-module inlining and specialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html" class="navigation-list-link">SE-0194 Derived Collection of Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html" class="navigation-list-link">SE-0195 Introduce User-defined "Dynamic Member Lookup" Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html" class="navigation-list-link">SE-0196 Compiler Diagnostic Directives</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0197-remove-where.html" class="navigation-list-link">SE-0197 Adding in-place `removeAll(where:)` to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html" class="navigation-list-link">SE-0198 Playground QuickLook API Revamp #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html" class="navigation-list-link">SE-0199 Adding `toggle` to `Bool`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html" class="navigation-list-link">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html" class="navigation-list-link">SE-0201 Package Manager Local Dependencies</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0202-random-unification.html" class="navigation-list-link">SE-0202 Random Unification</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html" class="navigation-list-link">SE-0203 Rename Sequence.elementsEqual</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html" class="navigation-list-link">SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html" class="navigation-list-link">SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html" class="navigation-list-link">SE-0206 Hashable Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0207-containsOnly.html" class="navigation-list-link">SE-0207 Add an `allSatisfy` algorithm to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html" class="navigation-list-link">SE-0208 Package Manager System Library Targets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html" class="navigation-list-link">SE-0209 Package Manager Swift Language Version API Update</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html" class="navigation-list-link">SE-0210 Add an `offset(of:)` method to `MemoryLayout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html" class="navigation-list-link">SE-0211 Add Unicode Properties to `Unicode.Scalar`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html" class="navigation-list-link">SE-0212 Compiler Version Directive</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html" class="navigation-list-link">SE-0213 Literal initialization via coercion</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html" class="navigation-list-link">SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html" class="navigation-list-link">SE-0215 Conform `Never` to `Equatable` and `Hashable`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html" class="navigation-list-link">SE-0216 Introduce user-defined dynamically "callable" types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0217-bangbang.html" class="navigation-list-link">SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html" class="navigation-list-link">SE-0218 Introduce `compactMapValues` to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html" class="navigation-list-link">SE-0219 Package Manager Dependency Mirroring</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0220-count-where.html" class="navigation-list-link">SE-0220 `count(where:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0221-character-properties.html" class="navigation-list-link">SE-0221 Character Properties</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html" class="navigation-list-link">SE-0222 Lazy CompactMap Sequence</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html" class="navigation-list-link">SE-0223 Accessing an Array's Uninitialized Buffer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html" class="navigation-list-link">SE-0224 Support 'less than' operator in compilation conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html" class="navigation-list-link">SE-0225 Adding `isMultiple` to `BinaryInteger`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html" class="navigation-list-link">SE-0226 Package Manager Target Based Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html" class="navigation-list-link">SE-0227 Identity key path</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html" class="navigation-list-link">SE-0228 Fix `ExpressibleByStringInterpolation`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0229-simd.html" class="navigation-list-link">SE-0229 SIMD Vectors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html" class="navigation-list-link">SE-0230 Flatten nested optionals resulting from 'try?'</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html" class="navigation-list-link">SE-0231 Optional Iteration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html" class="navigation-list-link">SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html" class="navigation-list-link">SE-0233 Make `Numeric` Refine a new `AdditiveArithmetic` Protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html" class="navigation-list-link">SE-0234 Remove `Sequence.SubSequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0235-add-result.html" class="navigation-list-link">SE-0235 Add Result to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html" class="navigation-list-link">SE-0236 Package Manager Platform Deployment Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html" class="navigation-list-link">SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html" class="navigation-list-link">SE-0238 Package Manager Target Specific Build Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0239-codable-range.html" class="navigation-list-link">SE-0239 Add Codable conformance to Range types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html" class="navigation-list-link">SE-0240 Ordered Collection Diffing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html" class="navigation-list-link">SE-0241 Deprecate String Index Encoded Offsets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html" class="navigation-list-link">SE-0242 Synthesize default values for the memberwise initializer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html" class="navigation-list-link">SE-0243 Integer-convertible character literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html" class="navigation-list-link">SE-0244 Opaque Result Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html" class="navigation-list-link">SE-0245 Add an Array Initializer with Access to Uninitialized Storage</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0246-mathable.html" class="navigation-list-link">SE-0246 Generic Math(s) Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html" class="navigation-list-link">SE-0247 Contiguous Strings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html" class="navigation-list-link">SE-0248 String Gaps and Missing APIs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html" class="navigation-list-link">SE-0249 Key Path Expressions as Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html" class="navigation-list-link">SE-0250 Swift Code Style Guidelines and Formatter</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0251-simd-additions.html" class="navigation-list-link">SE-0251 SIMD additions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html" class="navigation-list-link">SE-0252 Key Path Member Lookup</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0253-callable.html" class="navigation-list-link">SE-0253 Introduce callables </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html" class="navigation-list-link">SE-0254 Static and class subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0255-omit-return.html" class="navigation-list-link">SE-0255 Implicit returns from single-expression functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html" class="navigation-list-link">SE-0256 Introduce `{Mutable}ContiguousCollection` protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0257-elide-comma.html" class="navigation-list-link">SE-0257 Eliding commas from multiline expression lists</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html" class="navigation-list-link"> Feature name</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Swift Evolution List" aria-label="Search Swift Evolution List" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/pondok-programmer/swift-evolution-jekyll">Swift Evolution List</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h1 id="unsaferawpointer-api"> <a href="#unsaferawpointer-api" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> UnsafeRawPointer API </h1> <ul> <li>Proposal: <a href="0107-unsaferawpointer.md">SE-0107</a></li> <li>Author: <a href="https://github.com/atrick">Andrew Trick</a></li> <li>Review Manager: <a href="http://github.com/lattner">Chris Lattner</a></li> <li>Status: <strong>Implemented (Swift 3)</strong></li> <li>Decision Notes: <a href="https://lists.swift.org/pipermail/swift-evolution-announce/2016-July/000231.html">Rationale</a></li> </ul> <p>For detailed instructions on how to migrate your code to this new Swift 3 API refer to the <a href="https://swift.org/migration-guide-swift3/se-0107-migrate.html">UnsafeRawPointer Migration Guide</a>. See also: See <code class="highlighter-rouge">bindMemory(to:capacity:)</code>, <code class="highlighter-rouge">assumingMemoryBound(to:)</code>, and <code class="highlighter-rouge">withMemoryRebound(to:capacity:)</code>.</p> <p>For quick reference on the full API, jump to:</p> <ul> <li><a href="#full-unsaferawpointer-api">Full UnsafeRawPointer API</a></li> </ul> <p>Contents:</p> <ul> <li><a href="#introduction">Introduction</a></li> <li><a href="#proposed-solution">Proposed Solution</a></li> <li><a href="#motivation">Motivation</a></li> <li><a href="#memory-model-explanation">Memory model explanation</a></li> <li><a href="#expected-use-cases">Expected use cases</a></li> <li><a href="#detailed-design">Detailed design</a></li> <li><a href="#impact-on-existing-code">Impact on existing code</a></li> <li><a href="#implementation-status">Implementation status</a></li> <li><a href="#future-improvements-and-planned-additive-api">Future improvements and planned additive API</a></li> <li><a href="#variations-under-consideration">Variations under consideration</a></li> <li><a href="#alternatives-previously-considered">Alternatives previously considered</a></li> </ul> <h2 id="introduction"> <a href="#introduction" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduction </h2> <p>Swift enforces type safe access to memory and follows strict aliasing rules. However, code that uses unsafe APIs or imported types can circumvent the languages natural type safety. Consider the following example of <em>type punning</em> using the <code class="highlighter-rouge">UnsafePointer</code> type:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">ptrT</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span>
<span class="c1">// Store T at this address.</span>
<span class="n">ptrT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kt">T</span><span class="p">()</span>
<span class="c1">// Load U at this address</span>
<span class="k">let</span> <span class="nv">u</span> <span class="o">=</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptrT</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <p>This code violates assumptions made by the compiler and falls into the category of <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">undefined behavior</a>. Undefined behavior is a way of saying that we cannot easily specify constraints on the behavior of programs that violate a rule. The program may crash, corrupt memory, or be miscompiled in other ways. Miscompilation may include optimizing away code that was expected to execute or executing code that was not expected to execute.</p> <p>Swift already protects against undefined behavior as long as the code does not use unsafe constructs. However, <code class="highlighter-rouge">UnsafePointer</code> is an important API for interoperability and building high performance data structures. As such, the rules for safe, well-defined usage of the API should be clear. Currently, it is too easy to use <code class="highlighter-rouge">UnsafePointer</code> improperly. For example, innocuous argument conversion such as this could lead to undefined behavior:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">takesUIntPtr</span><span class="p">(</span><span class="n">_</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">UInt</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UInt</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">takesIntPtr</span><span class="p">(</span><span class="nv">q</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UInt</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">takesUIntPtr</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p>Furthermore, no API currently exists for accessing raw, untyped memory. <code class="highlighter-rouge">UnsafePointer&lt;Pointee&gt;</code> and <code class="highlighter-rouge">UnsafeMutablePointer&lt;Pointee&gt;</code> refer to a typed region of memory, and the compiler assumes that the element type (<code class="highlighter-rouge">Pointee</code>) is consistent with other access to the same memory. For details of the compilers rules for memory aliasing, see <a href="https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst">proposed Type Safe Memory Access documentation</a>. Making <code class="highlighter-rouge">UnsafePointer</code> safer requires introducing a new pointer type that is not subject to the same strict aliasing rules.</p> <p>This proposal aims to achieve several goals in one coherent design:</p> <ol> <li> <p>Specify a memory model that encompasses all UnsafePointer access and defines which memory operations are subject to strict aliasing rules.</p> </li> <li> <p>Inhibit <code class="highlighter-rouge">UnsafePointer</code> conversion that violates strict aliasing, in order to make violations of the model clear and verifiable.</p> </li> <li> <p>Provide an untyped pointer type.</p> </li> <li> <p>Provide an API for raw, untyped memory access (<code class="highlighter-rouge">memcpy</code> semantics).</p> </li> <li> <p>Provide an API for manual memory layout (bytewise pointer arithmetic).</p> </li> </ol> <p>Swift-evolution threads:</p> <ul> <li> <p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160509/thread.html#16909">[RFC] UnsafeBytePointer API for In-Memory Layout</a></p> </li> <li> <p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/thread.html#18156">[RFC] UnsafeBytePointer API for In-Memory Layout (Round 2)</a></p> </li> <li> <p>[RFC] UnsafeRawPointer API (Round 3)</p> <ul> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160620/thread.html#22005">Week #1</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/thread.html#22230">Week #2</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/thread.html#23384">Week #3</a></li> </ul> </li> </ul> <p>Mentions of <code class="highlighter-rouge">UnsafePointer</code> that appear in this documents prose also apply to <code class="highlighter-rouge">UnsafeMutablePointer</code>.</p> <h2 id="proposed-solution"> <a href="#proposed-solution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Proposed Solution </h2> <p>We first introduce each aspect of the proposed API so that the Motivation section can show examples. The Detailed design section lists the complete API.</p> <h3 id="unsaferawpointer"> <a href="#unsaferawpointer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> UnsafeRawPointer </h3> <p>New raw pointer types, <code class="highlighter-rouge">UnsafeRawPointer</code> and <code class="highlighter-rouge">UnsafeMutableRawPointer</code>, will represent a raw, untyped view of memory. Typed pointers, <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> and <code class="highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code>, continue to represent a typed view of memory. Memory access through a raw pointer accesses raw memory, and memory access through a typed pointer accesses typed memory. Because a raw pointer may alias with any type, the semantics of reading and writing through a raw pointer are similar to C <code class="highlighter-rouge">memcpy</code>. Memory access through a typed pointer adheres to strict aliasing.</p> <h3 id="memory-allocation-and-initialization"> <a href="#memory-allocation-and-initialization" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Memory allocation and initialization </h3> <p><code class="highlighter-rouge">UnsafeMutableRawPointer</code> will provide <code class="highlighter-rouge">allocate</code> and <code class="highlighter-rouge">deallocate</code> methods:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutableRawPointer</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">bytes</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">deallocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Initializing memory via an <code class="highlighter-rouge">UnsafeMutableRawPointer</code> produces an <code class="highlighter-rouge">UnsafeMutablePointer&lt;Pointee&gt;</code>, and deinitializing the <code class="highlighter-rouge">UnsafeMutablePointer&lt;Pointee&gt;</code> returns an <code class="highlighter-rouge">UnsafeMutableRawPointer</code>.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutableRawPointer</span> <span class="p">{</span>
  <span class="c1">// Returns an UnsafeMutablePointer into the newly initialized memory.</span>
  <span class="kd">func</span> <span class="n">initializeMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">/// Returns a raw pointer to the uninitialized memory.</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawPointer</span>
<span class="p">}</span>
</code></pre></div></div> <p>The type parameter <code class="highlighter-rouge">T</code> passed to <code class="highlighter-rouge">initializeMemory</code> is an explicit argument because the user must reason about the types size and alignment at the point of initialization. Inferring the type from the value argument could result in miscompilation if the inferred type ever deviates from the users original expectations. The type parameter also importantly conveys that the raw memory becomes accessible via a pointer to that type at the point of the call. The type should be explicitly spelled at this point because accesing the memory via a typed pointer of an unrelated type could also result in miscompilation.</p> <h3 id="binding-memory-to-a-type"> <a href="#binding-memory-to-a-type" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binding memory to a type </h3> <p>With the above API for allocation and initialization, the only way to acquire a typed pointer is by using a raw pointer to initialize memory. Raw pointer initialization implicitly binds the memory to the initialized type. A memory locations bound type is an abstract, dynamic property of the memory used to formalize type safety.</p> <p>Whenever memory is accessed via a typed pointer, the memory must be bound to a related type. This includes operations on Unsafe[Mutable]Pointer<T> in addition to regular language constructs, which are always strictly typed. It does not include memory accessed via a raw pointer, which is not strictly typed. Violations result in undefined behavior.</T></p> <p>The user may defer initialization and explicitly bind memory to a type using the <code class="highlighter-rouge">bindMemory</code> API:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">RawPointer</span> <span class="p">{</span>
  <span class="c1">/// Returns an `Unsafe[Mutable]Pointer&lt;T&gt;` pointing to this memory.</span>
  <span class="kd">func</span> <span class="n">bindMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">Pointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Calling <code class="highlighter-rouge">bindMemory</code> on a newly allocated raw pointer produces a typed pointer to uninitialized memory. The bound memory can then be safely initialized using a typed pointer:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">ptrToA</span> <span class="o">=</span> <span class="n">rawPtr</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ptrToA</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">())</span>
</code></pre></div></div> <p>Note that typed pointer initialization does not bind the type. The memory must already be bound to the correct type as a precondition.</p> <p>Allocating and binding memory to a type may be performed in one step by using <code class="highlighter-rouge">UnsafeMutablePointer.allocate()</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">capacity</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="raw-memory-access"> <a href="#raw-memory-access" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Raw memory access </h3> <p>Loading from and storing to memory via an <code class="highlighter-rouge">Unsafe[Mutable]RawPointer</code> is safe independent of the memorys bound type as long as layout guarantees are met (per the ABI), and care is taken to properly initialize and deinitialize nontrivial values (see <a href="#trivial-types">Trivial types</a>). This allows raw memory to be reinterpreted without rebinding the memory type. Rebinding memory invalidates existing typed pointers, but loading from and storing to raw memory does not.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutableRawPointer</span> <span class="p">{</span>
  <span class="c1">/// Read raw bytes from memory at `self + offset` and construct a</span>
  <span class="c1">/// value of type `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The underlying pointer plus `offset` is properly</span>
  <span class="c1">///   aligned for accessing `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The memory is initialized to a value of some type, `U`,</span>
  <span class="c1">///   such that `T` is layout compatible with `U`.</span>
  <span class="kd">func</span> <span class="n">load</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span>

  <span class="c1">/// Store a value's bytes into raw memory at `self + offset`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The underlying pointer plus `offset` is properly</span>
  <span class="c1">///   aligned for storing type `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `T` is a trivial type.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The memory is uninitialized, or initialized to some</span>
  <span class="c1">///   trivial type `U` such that `T` and `U` are mutually layout</span>
  <span class="c1">///   compatible.</span>
  <span class="c1">/// </span>
  <span class="c1">/// - Postcondition: The memory is initialized to raw bytes. If the</span>
  <span class="c1">///   memory is bound to type `U`, then it now contains a value of</span>
  <span class="c1">///   type `U`.</span>
  <span class="kd">func</span> <span class="n">storeBytes</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">toByteOffset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="highlighter-rouge">load</code> and <code class="highlighter-rouge">storeBytes</code> operations are asymmetric. <code class="highlighter-rouge">load</code> reads raw bytes but properly constructs a new value of type <code class="highlighter-rouge">T</code> with its own lifetime. Any copied references will be retained. In contrast, <code class="highlighter-rouge">storeBytes</code> only operates on a values raw bytes, writing them into untyped memory. The in-memory copy will not be constructed and any previously initialized value in this memory will not be deinitialized (it cannot be because its type is unknown). Consequently, <code class="highlighter-rouge">storeBytes</code> should only be performed on trivial types.</p> <p>Assigning memory to a nontrivial type via a raw pointer is done by binding the type:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rawPtr</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">PreviousType</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">rawPtr</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">NewType</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">NewType</span><span class="p">())</span>
</code></pre></div></div> <h3 id="bytewise-pointer-arithmetic"> <a href="#bytewise-pointer-arithmetic" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Bytewise pointer arithmetic </h3> <p>Providing an API for accessing raw memory would not serve much purpose without the ability to compute byte offsets. Naturally, <code class="highlighter-rouge">UnsafeRaw[Mutable]Pointer</code> is Strideable as a sequence of bytes.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeRawPointer</span> <span class="p">:</span> <span class="kt">Strideable</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">distance</span><span class="p">(</span><span class="nv">to</span> <span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>

  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeRawPointer</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

<span class="kd">public</span> <span class="kd">func</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

<span class="kd">public</span> <span class="kd">func</span> <span class="o">+</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeRawPointer</span>

<span class="kd">public</span> <span class="kd">func</span> <span class="o">-</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div> <h3 id="unsafepointer-conversion"> <a href="#unsafepointer-conversion" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> UnsafePointer conversion </h3> <p>Currently, an <code class="highlighter-rouge">UnsafePointer</code> initializer supports conversion between potentially incompatible pointer types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">Pointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">init</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">Pointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>This initializer will be removed. <code class="highlighter-rouge">UnsafePointer</code> conversion is still possible, but is now explicit and provably correct based on the conversions preconditions and postconditions.</p> <p>Recall that <code class="highlighter-rouge">bindMemory(to:capacity:)</code> produces a typed pointer from a raw pointer. As explained above, it can be used to bind uninitialized memory for deferred initialization. When invoked on memory that is already bound, and potentially already initialized, it effectively rebinds the memory. Because memory can only be bound to one type at a time, all strictly typed memory operations that subsequently access this memory must be consistent with the newly bound type.</p> <p>A convenience API makes it easy to handle type mismatches that arise from interoperability without compromising on safety. In this case, the user already has a typed pointer but needs to temporarily rebind the memory for the purpose of invoking code that expects a different type. <code class="highlighter-rouge">withMemoryRebound&lt;T&gt;(to:capacity:)</code> rebinds memory to the specified type, executes a closure with a pointer to the rebound memory, then rebinds memory to the original type before returning:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">Pointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="n">withMemoryRebound</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">capacity</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span>
    <span class="n">_</span> <span class="nv">body</span><span class="p">:</span> <span class="p">(</span><span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">Pointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="k">rethrows</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is safe provided that the <code class="highlighter-rouge">body</code> closure does not capture <code class="highlighter-rouge">self</code>.</p> <p>It is possible to directly acquire a typed pointer from a raw pointer without rebinding the type, bypassing static safety. This does not weaken the rules for typed memory access because it relies on the precondition is that memory is already bound to the returned pointers type. This is useful when the memorys bound type is known but the pointers type has been erased:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">RawPointer</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="n">assumingMemoryBound</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Unsafe</span><span class="p">[</span><span class="kt">Mutable</span><span class="p">]</span><span class="kt">Pointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>For a more detailed discussion, see the <a href="#memory-model-explanation">Memory model explanation</a>.</p> <h2 id="motivation"> <a href="#motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Motivation </h2> <p>The following examples show the differences between memory access as it currently would be done using <code class="highlighter-rouge">UnsafeMutablePointer</code> vs. the proposed <code class="highlighter-rouge">UnsafeMutableRawPointer</code>.</p> <p>Consider two layout compatible, but unrelated structs, <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, and helpers that read from these structs via unsafe pointers:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- common definitions used by old and new code ---</span>
<span class="kd">struct</span> <span class="kt">A</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">B</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printA</span><span class="p">(</span><span class="n">_</span> <span class="nv">pA</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">pA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printB</span><span class="p">(</span><span class="n">_</span> <span class="nv">pB</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">pB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div> <p>Normal allocation, initialization, access, and deinitialization of a struct looks like this with <code class="highlighter-rouge">UnsafePointer</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="kd">func</span> <span class="nf">initA</span><span class="p">(</span><span class="nv">pA</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pA</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span><span class="mi">42</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">initB</span><span class="p">(</span><span class="nv">pB</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pB</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span><span class="mi">13</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">normalLifetime</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

  <span class="nf">initA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="nf">printA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="n">pA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">pA</span><span class="o">.</span><span class="nf">deallocateCapacity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>This code continues to work. However, with <code class="highlighter-rouge">UnsafeMutableRawPointer</code>, it is possible to distinguish between raw allocated memory, and memory that has been initialized as some type. First, we define new initialization helpers that take raw pointers and return typed pointers:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">initRawA</span><span class="p">(</span><span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span><span class="mi">42</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">initRawB</span><span class="p">(</span><span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span><span class="mi">13</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now we can allocate raw memory and obtain a typed pointer through initialization:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">normalLifetime</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">rawPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                                                <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

  <span class="c1">// rawPtr cannot be assigned to a value of `A`, forcing initialization before</span>
  <span class="c1">// typed access.</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="nf">initRawA</span><span class="p">(</span><span class="n">rawPtr</span><span class="p">)</span>

  <span class="nf">printA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="k">let</span> <span class="nv">uninitPtr</span> <span class="o">=</span> <span class="n">pA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">uninitPtr</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                       <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <hr /> <p>Consider another example, now ignoring memory deallocation for brevity. Technically, it is correct to initialize values of type <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> in different memory locations, but confusing and dangerous with the current <code class="highlighter-rouge">UnsafeMutablePointer</code> API:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="c1">// Return a pointer to (A, B).</span>
<span class="kd">func</span> <span class="nf">initAB</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="c1">// Memory is uninitialized, but pA is already typed.</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>

  <span class="c1">// Part of the memory is initialized to `A`. Redundant conversion of</span>
  <span class="c1">// UnsafeMutablePointer values like this is not uncommon, and it is</span>
  <span class="c1">// nonobvious at the point of conversion that it does not actually</span>
  <span class="c1">// change the pointer type.</span>
  <span class="nf">initA</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">pA</span><span class="p">))</span>

  <span class="c1">// pA is recast as pB with no indication that the pointee type has changed.</span>
  <span class="nf">initB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">pA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">pA</span>
<span class="p">}</span>
</code></pre></div></div> <p>Code in the caller is confusing:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="kd">func</span> <span class="nf">testInitAB</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="nf">initAB</span><span class="p">()</span>
  <span class="nf">printA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="c1">// pA is again recast as pB with no indication that the pointee type changes.</span>
  <span class="nf">printB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">pA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

  <span class="c1">// Or recast to pB first, which is also misleading because the pointer still</span>
  <span class="c1">// points to an initialized `A` value at the point of the cast.</span>
  <span class="nf">printB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>With <code class="highlighter-rouge">UnsafeMutableRawPointer</code> there is no need to cast to an invalid pointer type in order to access manually allocated memory:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="c1">// Return a pointer to an untyped memory region initialized with (A, B).</span>
<span class="kd">func</span> <span class="nf">initRawAB</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawPointer</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">rawPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                                                <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

  <span class="c1">// Initialize the first Int with `A`, producing UnsafeMutablePointer&lt;A&gt;.</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="nf">initRawA</span><span class="p">(</span><span class="n">rawPtr</span><span class="p">)</span>

  <span class="c1">// Initialize the second Int with `B`.</span>
  <span class="c1">// This implicitly casts UnsafeMutablePointer&lt;A&gt; to UnsafeMutableRawPointer,</span>
  <span class="c1">// which is equivalent to initB(rawPtr + MemoryLayout&lt;Int&gt;.stride).</span>
  <span class="c1">// Unlike the old API, no unsafe pointer conversion is needed.</span>
  <span class="nf">initRawB</span><span class="p">(</span><span class="n">pA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">rawPtr</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now, in the caller, unsafe conversion from raw memory to typed memory is always explicit:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="c1">// Code in the caller is explicit:</span>
<span class="kd">func</span> <span class="nf">testInitAB</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Get a raw pointer to (A, B).</span>
  <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="nf">initRawAB</span><span class="p">()</span>

  <span class="c1">// The untyped memory is explicitly converted to a pointer-to-A.</span>
  <span class="c1">// Safe because we know the underlying memory is bound to `A` via</span>
  <span class="c1">// raw pointer initialization.</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="nf">printA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="c1">// Converting from a pointer-to-A into a pointer-to-B without</span>
  <span class="c1">// rebinding the type requires casting to an UnsafeRawPointer.</span>
  <span class="nf">printB</span><span class="p">(</span><span class="kt">UnsafeRawPointer</span><span class="p">(</span><span class="n">pA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>

  <span class="c1">// Or directly convert the original UnsafeRawPointer into pointer-to-B.</span>
  <span class="nf">printB</span><span class="p">((</span><span class="n">p</span> <span class="o">+</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">)</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is much more explicit and verifiable, but still not statically type safe. However, now that it is possible to bind memory to a type, this example may be rewritten so that strict aliasing rules are statically enforced. Now the caller no longer needs to assume the pointer type that was used to initialize memory in <code class="highlighter-rouge">initAB</code>. They only need to agree on the layout of the memory:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new and improved version ---</span>
<span class="c1">// Return a pointer to an untyped memory region initialized with (A, B).</span>
<span class="kd">func</span> <span class="nf">initRawAB</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawPointer</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">intPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
  <span class="n">intPtr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span> <span class="c1">// knowing A is layout compatible with Int</span>
  <span class="n">intPtr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">13</span> <span class="c1">// knowing B is layout compatible with Int</span>
  <span class="k">return</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="n">intPtr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testInitAB</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Get a raw pointer to (A, B).</span>
  <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="nf">initRawAB</span><span class="p">()</span>

  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nf">printA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="c1">// Knowing the `B` has the same alignment as `A`.</span>
  <span class="k">let</span> <span class="nv">pB</span> <span class="o">=</span> <span class="kt">UnsafeRawPointer</span><span class="p">(</span><span class="n">pA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nf">printB</span><span class="p">(</span><span class="n">pB</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><hr /> <p>Initializing or assigning values of different types to the same location using a typed pointer is undefined. Here, the compiler can choose to ignore the order of assignment, and <code class="highlighter-rouge">initAthenB</code> may print 13 twice or 42 twice.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="kd">func</span> <span class="nf">initAthenB</span><span class="p">(</span><span class="n">_</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

  <span class="nf">initA</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  <span class="c1">// *p = 42</span>
  <span class="nf">printA</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

  <span class="nf">initB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  <span class="c1">// *p = 13</span>
  <span class="nf">printB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p>With the proposed API, assigning values of different types to the same location can now be safely done by properly initializing and deinitializing the memory through <code class="highlighter-rouge">UnsafeMutableRawPointer</code>. Ultimately, the values may still be accessed via the same convenient <code class="highlighter-rouge">UnsafeMutablePointer</code> type. Type punning has not happened, because the <code class="highlighter-rouge">UnsafeMutablePointer</code> has the same type as the memorys bound type whenever it is dereferenced.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="n">initAthenB</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">rawPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                                                <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="nf">initRawA</span><span class="p">(</span><span class="n">rawPtr</span><span class="p">)</span> <span class="c1">// raw pointer initialization binds memory to `A`</span>
  <span class="nf">printA</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>

  <span class="c1">// After deinitializing pA, uninitPtr receives a pointer to</span>
  <span class="c1">// untyped raw memory, which may be reused for `B`.</span>
  <span class="k">let</span> <span class="nv">uninitPtr</span> <span class="o">=</span> <span class="n">pA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

  <span class="c1">// rawPtr and uninitPtr have the same value, thus are substitutable.</span>
  <span class="nf">assert</span><span class="p">(</span><span class="n">rawPtr</span> <span class="o">==</span> <span class="n">uninitPtr</span><span class="p">)</span>

  <span class="c1">// initB rebinds the memory to `B` before writing to memory, so</span>
  <span class="c1">// reinitialization cannot be reordered with previous accesses to pA.</span>
  <span class="nf">initRawB</span><span class="p">(</span><span class="n">uninitPtr</span><span class="p">)</span>
  <span class="nf">printB</span><span class="p">(</span><span class="n">pB</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><hr /> <p>No API currently exists that allows initialized memory to hold either <code class="highlighter-rouge">A</code> or <code class="highlighter-rouge">B</code>.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="c1">// This conditional initialization looks valid, but is dangerous.</span>
<span class="kd">func</span> <span class="nf">initAorB</span><span class="p">(</span><span class="n">_</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">isA</span> <span class="p">{</span>
    <span class="nf">initA</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nf">initB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Code in the caller could produce undefined behavior:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="kd">func</span> <span class="nf">testInitAorB</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

  <span class="c1">// If the compiler inlines, then the initialization and use of the</span>
  <span class="c1">// values of type `A` and `B`, which share memory, could be incorrectly</span>
  <span class="c1">// interleaved.</span>
  <span class="nf">initAorB</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
  <span class="nf">printA</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

  <span class="nf">initAorB</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
  <span class="nf">printB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="highlighter-rouge">UnsafeMutableRawPointer</code> allows initialized memory to hold either <code class="highlighter-rouge">A</code> or <code class="highlighter-rouge">B</code>. The same <code class="highlighter-rouge">UnsafeMutableRawPointer</code> value can be reused across multiple initializations and deinitializations. Unlike the old API, this is safe because the memory initialization on a raw pointer writes to untyped memory and binds the memory type. Binding memory to a type separates access to the distinct types from the compilers viewpoint.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">initRawAorB</span><span class="p">(</span><span class="n">_</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Unsafe pointer conversion is no longer required to initialize memory.</span>
  <span class="k">if</span> <span class="n">isA</span> <span class="p">{</span>
    <span class="nf">initRawA</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nf">initRawB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Code in the caller is well defined because <code class="highlighter-rouge">initAorB</code> is now a compiler barrier for unsafe pointer access. Furthermore, each unsafe pointer cast is explicit:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">testInitAorB</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                                           <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

  <span class="nf">initRawAorB</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
  <span class="nf">printA</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>

  <span class="nf">initRawAorB</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
  <span class="nf">printB</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div><hr /> <p><code class="highlighter-rouge">UnsafeMutableRawPointer</code> provides a legal way to reinterpret memory in-place, which was previously unsupported. The following example is safe because the load of <code class="highlighter-rouge">B</code> reads from untyped memory via a raw pointer.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">testReinterpret</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                                           <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

  <span class="c1">// Initialize raw memory to `A`.</span>
  <span class="nf">initRawAorB</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nv">isA</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>

  <span class="c1">// Load from raw memory as `B` (reinterpreting the value in memory).</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is not type-punning because a typed pointer is never accessed. Note that <code class="highlighter-rouge">printB(p.assumingMemoryBound(to: B.self))</code> would be illegal, because the a typed pointer to <code class="highlighter-rouge">B</code> cannot be used to access an unrelated type <code class="highlighter-rouge">A</code>.</p><hr /> <p>Developers may be forced to work with loosely typed APIs, particularly for interoperability:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">readBytes</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 3rd party implementation...</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">readCStr</span><span class="p">(</span><span class="n">_</span> <span class="nv">string</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">CChar</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 3rd party implementation...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Working with these third party APIs exclusively using <code class="highlighter-rouge">UnsafeMutablePointer</code> would lead to undefined behavior, as shown here using the current API:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="kd">func</span> <span class="nf">stringFromBytes</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">bytes</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">bytes</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">bytes</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1">// Unsafe pointer conversion is required to invoke readCString.</span>
  <span class="c1">// If readCString is inlineable and compiled with strict aliasing,</span>
  <span class="c1">// then it could read uninitialized memory.</span>
  <span class="nf">readCStr</span><span class="p">(</span><span class="kt">UnsafePointer</span><span class="p">(</span><span class="n">bytes</span><span class="p">))</span>

  <span class="c1">// The signature of readBytes is consistent with the `bytes` argument type.</span>
  <span class="nf">readBytes</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Reading from uninitialized memory is now prevented by explicitly rebinding the type.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">stringFromBytes</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">buffer</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">buffer</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">buffer</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="n">buffer</span><span class="o">.</span><span class="nf">withMemoryRebound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CChar</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">readCStr</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">readBytes</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Rather than temporarily rebinding memory, the user may want to rebind memory to <code class="highlighter-rouge">CChar</code> once and keep the same typed pointer around for future use without keeping track of the memory capacity. In that case, the program could continue to write <code class="highlighter-rouge">UInt8</code> values to memory without casting to <code class="highlighter-rouge">CChar</code> and without rebinding memory as long as those writes use the <code class="highlighter-rouge">UnsafeMutableRawPointer.storeBytes</code> API for raw memory access:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- new version ---</span>
<span class="kd">func</span> <span class="nf">mutateBuffer</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">rawBuffer</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                   <span class="nv">alignedTo</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">rawBuffer</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
  <span class="n">rawBuffer</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">atIndex</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

  <span class="k">let</span> <span class="nv">cstr</span> <span class="o">=</span> <span class="n">rawBuffer</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CChar</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1">// Access memory as CChar.</span>
  <span class="nf">readCStr</span><span class="p">(</span><span class="n">cstr</span><span class="p">)</span>

  <span class="c1">// Write UInt8 values to memory without needing explicitly cast each</span>
  <span class="c1">// value to CChar first.</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">size</span> <span class="p">{</span>
    <span class="n">rawBuffer</span><span class="o">.</span><span class="nf">storeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="nf">getByte</span><span class="p">(),</span> <span class="nv">toByteOffset</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Access memory again as CChar.</span>
  <span class="nf">readCStr</span><span class="p">(</span><span class="n">cstr</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">getByte</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span> <span class="p">{</span>
  <span class="c1">// 3rd party implementation...</span>
<span class="p">}</span>
</code></pre></div></div><hr /> <p>The side effects of illegal type punning may result in storing values in the wrong sequence, reading uninitialized memory, or memory corruption. It could even result in execution following code paths that arent expected as shown here:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- old version ---</span>
<span class="kd">func</span> <span class="nf">testUndefinedExecution</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">pA</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">pA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kt">A</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span><span class="mi">42</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">pA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">42</span> <span class="p">{</span>
    <span class="c1">// Code path should never execute...</span>
    <span class="nf">releaseDemons</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// This compiler may inline this, and hoist the store above the</span>
  <span class="c1">// previous check.</span>
  <span class="nf">unforeseenCode</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">releaseDemons</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Something that should never be executed...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">assignB</span><span class="p">(</span><span class="n">_</span> <span class="nv">pB</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kt">B</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span><span class="mi">13</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">unforeseenCode</span><span class="p">(</span><span class="n">_</span> <span class="nv">pA</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// At some arbitrary point in the future, the same memory is</span>
  <span class="c1">// innocuously assigned to B.</span>
  <span class="nf">assignB</span><span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="p">(</span><span class="n">pA</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <p>Prohibiting conversion between incompatible <code class="highlighter-rouge">UnsafePointer</code> types, providing an API for binding memory to a type, and supporting raw memory access are necessary to avoid the dangers of type punning and encourage safe idioms for working with pointers.</p> <h2 id="memory-model-explanation"> <a href="#memory-model-explanation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Memory model explanation </h2> <h3 id="raw-vs-typed-pointers"> <a href="#raw-vs-typed-pointers" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Raw vs. Typed Pointers </h3> <p>The fundamental difference between <code class="highlighter-rouge">Unsafe[Mutable]RawPointer</code> and <code class="highlighter-rouge">Unsafe[Mutable]Pointer&lt;Pointee&gt;</code> is simply that the former is used for untyped memory access, and the later is used for typed memory access. Lets refer to these as raw pointers and typed pointers. Because operations on raw pointers access untyped memory, the compiler cannot make assumptions about the underlying type of memory and must be conservative. With operations on typed pointers, the compiler may make strict assumptions about the type of the underlying memory, which allows more aggressive optimization.</p> <h3 id="memory-initialization"> <a href="#memory-initialization" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Memory initialization </h3> <p>All allocated memory is either uninitialized or initialized. Upon initialization, memory contains a typed value. Initialized memory may be assigned to a new value of the same type. Upon deinitialization, the memory no longer holds a value.</p> <p>Consider the sequence of abstract memory operations:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">rawptr = allocate()</code></td> <td>uninitialized</td> </tr> <tr> <td><code class="highlighter-rouge">tptr = rawptr.initializeMemory(T)</code></td> <td>initialized</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.pointee = T</code></td> <td>initialized</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.deinitialize()</code></td> <td>uninitialized</td> </tr> </tbody> </table></div> <p>Initializing memory via a raw pointer binds the memory type. Initialized memory must always be bound to a type. Deinitialization does not unbind the type. Memory remains bound to a type until it is rebound to a different type.</p> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">rawptr = allocate()</code></td> <td>uninitialized</td> <td>None</td> </tr> <tr> <td><code class="highlighter-rouge">tptr = rawptr.initializeMemory(T)</code></td> <td>initialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.deinitialize()</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">uptr = rawptr.initializeMemory(U)</code></td> <td>initialized</td> <td>bound to U</td> </tr> <tr> <td><code class="highlighter-rouge">uptr.deinitialize()</code></td> <td>uninitialized</td> <td>bound to U</td> </tr> <tr> <td><code class="highlighter-rouge">rawptr.deallocate()</code></td> <td>invalid</td> <td>None</td> </tr> </tbody> </table></div> <p>Rebinding memory effectively changes the type of any initialized values within the rebound memory region. Accessing the memory via a typed pointer of unrelated type is undefined:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">tptr = rawptr.initializeMemory(T)</code></td> <td>initialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.deinitialize()</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">uptr = rawptr.initializeMemory(U)</code></td> <td>initialized</td> <td>bound to U</td> </tr> <tr> <td><code class="highlighter-rouge">uptr.deinitialize()</code></td> <td>uninitialized</td> <td>bound to U</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.initialize()</code></td> <td>undefined</td> <td>undefined</td> </tr> </tbody> </table></div> <p>By this convention, raw pointers primarily refer to uninitialized memory and typed pointers primarily refer to initialized memory. This is not a requirement, and important use cases follow different conventions. After a raw pointer is initialized, the raw pointer value remains valid and can continue to be used to access the underlying memory in an untyped way. Conversely, a raw pointer can bound to a typed pointer without initializing the underlying memory.</p> <h3 id="binding-memory-type"> <a href="#binding-memory-type" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binding memory type </h3> <p>A raw pointers memory may be explicitly bound to a type, bypassing raw initialization:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">ptrA</span> <span class="o">=</span> <span class="n">rawPtr</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <p>The resulting typed pointer may then be used to initialize memory:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptrA</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">())</span>
</code></pre></div></div> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">rawptr = allocate()</code></td> <td>uninitialized</td> <td>None</td> </tr> <tr> <td><code class="highlighter-rouge">tptr = rawptr.bindMemory(T)</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.initialize()</code></td> <td>initialized</td> <td>bound to T</td> </tr> </tbody> </table></div> <p>The memory remains bound to this type until it is rebound through raw pointer initialization or another call to <code class="highlighter-rouge">bindMemory(to:)</code>.</p> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">rawptr = allocate()</code></td> <td>uninitialized</td> <td>None</td> </tr> <tr> <td><code class="highlighter-rouge">tptr = rawptr.bindMemory(T)</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.initialize()</code></td> <td>initialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.deinitialize()</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">uptr = rawptr.bindMemory(U)</code></td> <td>uninitialized</td> <td>bound to U</td> </tr> <tr> <td><code class="highlighter-rouge">uptr.initialize()</code></td> <td>initialized</td> <td>bound to U</td> </tr> </tbody> </table></div> <p>Allocation and binding can be combined as typed allocation:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">tptr = allocate(T)</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.initialize()</code></td> <td>initialized</td> <td>bound to T</td> </tr> </tbody> </table></div> <h3 id="typed-pointer-initialization"> <a href="#typed-pointer-initialization" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Typed pointer initialization </h3> <p>Initializing memory via a typed pointer requires the memory to be already be bound to that type. This is often more convenient than working with raw pointers, and can improve performance in some cases. In particular, it is an effective technique for implementing data structures that manage storage for contiguous elements. The data structure may allocate a buffer with extra capacity and track the initialized state of each element position as such:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">getAt</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">A</span> <span class="p">{</span>
  <span class="k">if</span> <span class="o">!</span><span class="nf">isInitializedAt</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">ptrA</span> <span class="o">+</span> <span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">Type</span><span class="p">())</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ptrA</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div> <p>For example, see the <a href="#c-buffer">C buffer</a> use case below.</p> <p>When using a typed pointer to initialize memory, the programmer must ensure that memory has been bound to that type and takes responsibility for tracking the initialized state of memory.</p> <h3 id="strict-aliasing"> <a href="#strict-aliasing" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Strict aliasing </h3> <p>Accessing memory via a pointer type that is unrelated to the memorys bound type violates strict aliasing, and is thus undefined. For the purpose of this proposal, we simply specify when strict aliasing applies and that aliasing types must be related. For an explanation of related types and layout compatibility, see <a href="https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst">proposed Type Safe Memory Access documentation</a>.</p> <p>Regardless of whether strict aliasing applies, accessing initialized in-memory values always requires the access type to be layout compatible with the values type. This applies to access via the raw pointer API in addition to typed pointer access. Similarly, rebinding initialized in-memory values to another type requires both the previous and new type to be mutually layout compatible.</p> <p>Accessing memory via a typed pointer (or normal, safe language construct) has an <em>additional</em> requirement that the pointer type must be related to the memorys bound type. For this reason, typed pointers are only obtained by initializing raw memory or explicitly binding the memory type. In practice, with the proposed API, the only way to violate strict aliasing is to reuse a typed pointer value after the underlying memory has been rebound to an unrelated type:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Abstract Operation</th> <th>Memory State</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">tptr = rawptr.bindMemory(T)</code></td> <td>uninitialized</td> <td>bound to T</td> </tr> <tr> <td><code class="highlighter-rouge">uptr = rawptr.bindMemory(U)</code></td> <td>uninitialized</td> <td>bound to U</td> </tr> <tr> <td><code class="highlighter-rouge">tptr.initialize()</code></td> <td>undefined</td> <td><code class="highlighter-rouge">T</code> is unrelated to <code class="highlighter-rouge">U</code></td> </tr> </tbody> </table></div> <h3 id="accessing-initialized-memory-with-a-raw-pointer"> <a href="#accessing-initialized-memory-with-a-raw-pointer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Accessing initialized memory with a raw pointer. </h3> <p>A program may read from and write to memory via a raw pointer even after the memory has been initialized:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">rawPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">SomeType</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span>
                                              <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">SomeType</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">ptrToSomeType</span> <span class="o">=</span> <span class="n">rawPtr</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">SomeType</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">SomeType</span><span class="p">())</span>

<span class="c1">// read raw initialized memory</span>
<span class="k">let</span> <span class="nv">reinterpretedValue</span> <span class="o">=</span> <span class="n">rawPtr</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">AnotherType</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>

<span class="c1">// overwrite raw initialized memory</span>
<span class="n">rawPtr</span><span class="o">.</span><span class="nf">storeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="kt">AnotherType</span><span class="p">(),</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">AnotherType</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
</code></pre></div></div> <p><code class="highlighter-rouge">SomeType</code> and <code class="highlighter-rouge">AnotherType</code> need not to be related types. They must only be layout compatible. In other words, the programmer must ensure compatibility of the size, alignment, and position of references. This requires some knowledge of the ABI.</p> <p>Loading from raw memory reinterprets the in-memory bytes, and constructs a new local value. If that value contains class references, the class type of those reference must be related to the instances dynamic type. This is a incontrovertible property of all reference values in the system.</p> <p>Storing a value into raw memory does not support reference types. Additionally, it requires consideration of the type of value being overwritten because a raw store overwrites memory contents without destroying the previous value. Storing to raw memory is safe if either the memory is uninitialized or initialized to a trivial type. The value being stored must also be trivial so that it can be assigned via a bit-for-bit copy.</p> <h3 id="trivial-types"> <a href="#trivial-types" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Trivial types </h3> <p>A trivial type promises that assignment just requires a fixed-size bit-for-bit copy without any indirection or reference-counting operations. Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enums.</p> <p>Examples of trivial types:</p> <ul> <li>Integer and floating-point types</li> <li><code class="highlighter-rouge">Bool</code></li> <li><code class="highlighter-rouge">Optional&lt;T&gt;</code> where <code class="highlighter-rouge">T</code> is trivial</li> <li><code class="highlighter-rouge">Unmanaged&lt;T: AnyObject&gt;</code></li> <li>struct types where all members are trivial</li> <li>enum types where all payloads are trivial</li> </ul> <h2 id="expected-use-cases"> <a href="#expected-use-cases" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Expected use cases </h2> <p>This section lists several typical use cases involving <code class="highlighter-rouge">UnsafeRawPointer</code> and <code class="highlighter-rouge">UnsafePointer</code>.</p> <p>For explanatory purposes consider the following global definitions:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">A</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">B</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">ptrToA</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span>
<span class="k">var</span> <span class="nv">eltCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div> <h3 id="single-value"> <a href="#single-value" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Single value </h3> <p>Using a pointer to a single value:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">createValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ptrToA</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">42</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deleteValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="c-array"> <a href="#c-array" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> C array </h3> <p>Using a fully initialized set of contiguous homogeneous values:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">createCArray</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ptrToA</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">count</span><span class="p">)</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">count</span><span class="p">)</span>
  <span class="n">eltCount</span> <span class="o">=</span> <span class="n">count</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deleteCArray</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="n">eltCount</span><span class="p">)</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">eltCount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="c-buffer"> <a href="#c-buffer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> C buffer </h3> <p>Managing a buffer with a mix of initialized and uninitialized contiguous elements. Typically, information about which elements are initialized will be separately maintained to ensure that each methods preconditions are met:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">createCBuffer</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ptrToA</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">eltCount</span> <span class="o">=</span> <span class="n">size</span>
<span class="p">}</span>

<span class="c1">// - precondition: memory at `index` is uninitialized.</span>
<span class="kd">func</span> <span class="nf">initElement</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">with</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// - precondition: memory at `index` is initialized.</span>
<span class="kd">func</span> <span class="nf">getElement</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">A</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">ptrToA</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// - precondition: memory at `index` is initialized.</span>
<span class="kd">func</span> <span class="nf">assignElement</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">with</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ptrToA</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="p">}</span>

<span class="c1">// - precondition: memory at `index` is initialized.</span>
<span class="kd">func</span> <span class="nf">deinitElement</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// - precondition: memory for all elements is uninitialized.</span>
<span class="kd">func</span> <span class="nf">freeCBuffer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">eltCount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="manual-layout-of-typed-aligned-memory"> <a href="#manual-layout-of-typed-aligned-memory" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Manual layout of typed, aligned memory </h3> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Layout an object with header type `A` followed by `n` elements of type `B`.</span>
<span class="kd">func</span> <span class="nf">createValueWithTail</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Assuming the alignment of `A` satisfies the alignment of `B`.</span>
  <span class="k">let</span> <span class="nv">numBytes</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">+</span> <span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">)</span>

  <span class="k">let</span> <span class="nv">rawPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span>
    <span class="nv">bytes</span><span class="p">:</span> <span class="n">numBytes</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>

  <span class="c1">// Initialize the object header.</span>
  <span class="n">ptrToA</span> <span class="o">=</span> <span class="n">rawPtr</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">42</span><span class="p">))</span>

  <span class="c1">// Append `count` elements of type `B` to the object tail.</span>
  <span class="n">eltCount</span> <span class="o">=</span> <span class="n">count</span>
  <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span>
    <span class="nv">as</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">13</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getTailElement</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">B</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kt">UnsafeRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deleteValueWithTail</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="n">eltCount</span><span class="p">)</span>

  <span class="k">let</span> <span class="nv">numBytes</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">+</span> <span class="p">(</span><span class="n">eltCount</span> <span class="o">*</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">)</span>

  <span class="n">ptrToA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span>
    <span class="nv">bytes</span><span class="p">:</span> <span class="n">numBytes</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="raw-buffer-of-unknown-type"> <a href="#raw-buffer-of-unknown-type" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Raw buffer of unknown type </h3> <p>Direct bytewise memory access to a buffer of unknown type:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Format1:</span>
<span class="c1">//   flags: UInt16</span>
<span class="c1">//   state: UInt16</span>
<span class="c1">//   value: Int32</span>

<span class="c1">// Format2:</span>
<span class="c1">//   value: Int32</span>

<span class="kd">func</span> <span class="nf">receiveMsg</span><span class="p">(</span><span class="nv">flags</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">readMsg</span><span class="p">(</span><span class="nv">msgBuf</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">,</span> <span class="nv">isFormat1</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">isFormat1</span> <span class="p">{</span>
    <span class="nf">receiveMsg</span><span class="p">(</span><span class="nv">flags</span><span class="p">:</span> <span class="n">msgBuf</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">self</span><span class="p">),</span>
      <span class="nv">state</span><span class="p">:</span> <span class="n">msgBuf</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">self</span><span class="p">),</span>
      <span class="nv">value</span><span class="p">:</span> <span class="n">msgBuf</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nf">receiveMsg</span><span class="p">(</span><span class="nv">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="n">msgBuf</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="loads-and-stores-on-untyped-memory"> <a href="#loads-and-stores-on-untyped-memory" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Loads and stores on untyped memory </h3> <p>Accessing raw underlying memory bytes, independent of the memorys bound type:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Direct bytewise element copy.</span>
<span class="kd">func</span> <span class="nf">copyArrayElement</span><span class="p">(</span><span class="nv">fromIndex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">toIndex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">srcPtr</span> <span class="o">=</span> <span class="kt">UnsafeRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="n">fromIndex</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">destPtr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="n">toIndex</span><span class="p">)</span>

  <span class="n">destPtr</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">srcPtr</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Bytewise element swap.</span>
<span class="c1">// Initializes and deinitializes temporaries of type Int.</span>
<span class="c1">// Int is layout compatible with `A`.</span>
<span class="kd">func</span> <span class="nf">swapArrayElements</span><span class="p">(</span><span class="n">index</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">index</span> <span class="nv">j</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">rawPtrI</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">rawPtrJ</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="n">ptrToA</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">tmpi</span> <span class="o">=</span> <span class="n">rawPtrI</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">tmpj</span> <span class="o">=</span> <span class="n">rawPtrJ</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="n">rawPtrI</span><span class="o">.</span><span class="nf">storeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">tmpj</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="n">rawPtrJ</span><span class="o">.</span><span class="nf">storeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">tmpi</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="custom-memory-allocation"> <a href="#custom-memory-allocation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Custom memory allocation </h3> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">freePtr</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>

<span class="kd">func</span> <span class="nf">allocate32</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawPointer</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">newPtr</span> <span class="o">=</span> <span class="n">freePtr</span> <span class="p">{</span>
    <span class="n">freePtr</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="k">return</span> <span class="n">newPtr</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deallocate32</span><span class="p">(</span><span class="n">_</span> <span class="nv">rawPtr</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">freePtr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="n">rawPtr</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">freePtr</span> <span class="o">=</span> <span class="n">rawPtr</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createA</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">allocate32</span><span class="p">()</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">A</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">A</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createB</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">allocate32</span><span class="p">()</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">B</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">B</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deleteA</span><span class="p">(</span><span class="nv">ptrToA</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">deallocate32</span><span class="p">(</span><span class="n">ptrToA</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deleteB</span><span class="p">(</span><span class="nv">ptrToB</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">deallocate32</span><span class="p">(</span><span class="n">ptrToB</span><span class="o">.</span><span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="detailed-design"> <a href="#detailed-design" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Detailed design </h2> <h3 id="pointer-conversion-details"> <a href="#pointer-conversion-details" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Pointer conversion details </h3> <p><code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> to <code class="highlighter-rouge">UnsafeRawPointer</code> conversion will be provided via an unlabeled initializer.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UnsafeRawPointer</span><span class="p">:</span> <span class="n">_Pointer</span> <span class="p">{</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">:</span> <span class="n">_Pointer</span> <span class="p">{</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Conversion from <code class="highlighter-rouge">UnsafeRawPointer</code> to a typed <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> requires invoking <code class="highlighter-rouge">UnsafeRawPointer.bindMemory(to:capacity:)</code> or <code class="highlighter-rouge">UnsafeRawPointer.assumingMemoryBound(to:)</code>, explicitly spelling the destination type:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">UnsafeRawPointer</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">pT</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="n">n</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">let</span> <span class="nv">pT2</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
</code></pre></div></div> <p>Just as with <code class="highlighter-rouge">unsafeBitCast</code>, although the destination of the cast can usually be inferred, we want the developer to explicitly state the intended destination type, both because type inference can be surprising, and because its important for code comprehension.</p> <p>Some existing conversions between <code class="highlighter-rouge">UnsafePointer</code> types do not convert <code class="highlighter-rouge">Pointee</code> types but instead coerce an <code class="highlighter-rouge">UnsafePointer</code> to an <code class="highlighter-rouge">UnsafeMutablePointer</code>. This is no longer an inferred conversion, but must be explicitly requested:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UnsafeMutablePointer</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="k">mutating</span> <span class="nv">from</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="implicit-argument-conversion"> <a href="#implicit-argument-conversion" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Implicit argument conversion </h3> <p>Consider two C functions that take <code class="highlighter-rouge">const</code> pointers:</p><pre><code class="language-C">void takesConstTPtr(const T*);
void takesConstVoidPtr(const void*);
</code></pre><p>Which will be imported with immutable pointer argument types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">takesConstTPtr</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span>
</code></pre></div></div> <p>Mutable pointers can be passed implicitly as immutable pointers.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">unsafeMutablePtr</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="k">let</span> <span class="nv">mutableRawPtr</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span>
<span class="nf">takesConstTPtr</span><span class="p">(</span><span class="n">unsafeMutablePtr</span><span class="p">)</span>
<span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="n">mutableRawPtr</span><span class="p">)</span>
</code></pre></div></div> <p>Any mutable or immutable typed pointer can be passed implicitly as an immutable void pointer:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">unsafePtr</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="k">let</span> <span class="nv">unsafeMutablePtr</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="n">unsafePtr</span><span class="p">)</span>
<span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="n">unsafeMutablePtr</span><span class="p">)</span>
</code></pre></div></div> <p>Implicit inout conversion will continue to work:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">anyT</span><span class="p">:</span> <span class="kt">T</span>
<span class="nf">takesConstTPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anyT</span><span class="p">)</span>
<span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anyT</span><span class="p">)</span>
</code></pre></div></div> <p><code class="highlighter-rouge">Array</code>/<code class="highlighter-rouge">String</code> conversion will continue to work:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="p">[</span><span class="kt">T</span><span class="p">()]</span>
<span class="nf">takesConstTPtr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="s">"string"</span>
<span class="nf">takesConstVoidPtr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div> <p>Consider two C functions that take non-<code class="highlighter-rouge">const</code> pointers:</p><pre><code class="language-C">void takesTPtr(T*);
void takesVoidPtr(void*);
</code></pre><p>Which will be imported with mutable pointer argument types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">takesTPtr</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">takesVoidPtr</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">)</span>
</code></pre></div></div> <p>Any mutable pointer type can be passed implicitly as a mutable void pointer:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">unsafeMutablePtr</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="nf">takesVoidPtr</span><span class="p">(</span><span class="n">unsafeMutablePtr</span><span class="p">)</span>
</code></pre></div></div> <p>Implicit inout conversion will continue to work:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">anyT</span> <span class="o">=</span> <span class="kt">T</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="nf">takesTPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anyT</span><span class="p">)</span>
<span class="nf">takesVoidPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anyT</span><span class="p">)</span>
</code></pre></div></div> <p><code class="highlighter-rouge">Array</code>/<code class="highlighter-rouge">String</code> conversion to mutable pointer is still not allowed.</p> <h3 id="bulk-copies"> <a href="#bulk-copies" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Bulk copies </h3> <p>The following API entry points support copying or moving values between unsafe pointers.</p> <p>Given values of these types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">unsafePtr</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="k">let</span> <span class="nv">unsafeMutablePtr</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
<span class="k">let</span> <span class="nv">rawPtr</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span>
<span class="k">let</span> <span class="nv">mutableRawPtr</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span>
<span class="k">let</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">Int</span>
</code></pre></div></div> <h4 id="unsaferawpointer-to-unsafemutablerawpointer-raw-copy-memcpy"> <a href="#unsaferawpointer-to-unsafemutablerawpointer-raw-copy-memcpy" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">UnsafeRawPointer</code> to <code class="highlighter-rouge">UnsafeMutableRawPointer</code> raw copy (<code class="highlighter-rouge">memcpy</code>): </h4> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutableRawPtr</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">rawPtr</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div> <h4 id="unsafepointert-to-unsafemutablerawpointer"> <a href="#unsafepointert-to-unsafemutablerawpointer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> to <code class="highlighter-rouge">UnsafeMutableRawPointer</code>: </h4> <p>A raw copy from typed to raw memory can also be done by calling <code class="highlighter-rouge">copyBytes</code>, exactly as shown above. Implicit argument conversion from <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> to <code class="highlighter-rouge">UnsafeRawPointer</code> makes this seamless.</p> <p>Additionally, raw memory can be bulk initialized from typed memory:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mraw</span><span class="o">.</span><span class="nf">initializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">unsafePtr</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div> <h4 id="unsafemutablepointert-to-unsafemutablerawpointer"> <a href="#unsafemutablepointert-to-unsafemutablerawpointer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code> to <code class="highlighter-rouge">UnsafeMutableRawPointer</code>: </h4> <p>Because <code class="highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code> arguments are implicitly converted to <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code>, the <code class="highlighter-rouge">initializeMemory</code> call above works seamlessly.</p> <p>Additionally, a mutable typed pointer can be moved-from:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mraw</span><span class="o">.</span><span class="nf">moveInitializeMemory</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">unsafeMutablePtr</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div> <h4 id="unsaferawpointer-to-unsafemutablepointert"> <a href="#unsaferawpointer-to-unsafemutablepointert" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">UnsafeRawPointer</code> to <code class="highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code>: </h4> <p>No bulk conversion is currently supported from raw to typed memory.</p> <h4 id="unsafepointert-to-unsafemutablepointert"> <a href="#unsafepointert-to-unsafemutablepointert" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> to <code class="highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code>: </h4> <p>Copying between typed memory is still supported via bulk assignment (the naming style is updated for consistency):</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ump</span><span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">up</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
<span class="n">ump</span><span class="o">.</span><span class="nf">moveAssign</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">up</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div> <h3 id="cstring-conversion"> <a href="#cstring-conversion" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> CString conversion </h3> <p>One of the more common unsafe pointer conversions arises from viewing a C string as either an array of bytes (<code class="highlighter-rouge">UInt8</code>) or C characters (<code class="highlighter-rouge">CChar</code>). In Swift, this manifests as arguments of type <code class="highlighter-rouge">UnsafePointer&lt;UInt8&gt;</code> and <code class="highlighter-rouge">UnsafePointer&lt;CChar&gt;</code>. The String API even encourages interoperability between C APIs and a Strings UTF8 encoding. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">utf8</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">nulTerminatedUTF8</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">fd</span><span class="p">,</span> <span class="nv">fileName</span><span class="p">)</span> <span class="o">=</span> <span class="n">utf8</span><span class="o">.</span><span class="n">withUnsafeMutableBufferPointer</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">utf8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">CInt</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="nv">cStrBuf</span> <span class="o">=</span> <span class="kt">UnsafeRawPointer</span><span class="p">(</span><span class="n">utf8</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">CChar</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">fd</span> <span class="o">=</span> <span class="nf">mkstemps</span><span class="p">(</span><span class="n">cStrBuf</span><span class="p">,</span> <span class="n">suffixlen</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">fileName</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">cString</span><span class="p">:</span> <span class="n">cStrBuf</span><span class="p">)</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>This particular case is theoretically invalid because <code class="highlighter-rouge">nulTerminatedUTF8</code> writes a buffer of <code class="highlighter-rouge">UInt8</code> and <code class="highlighter-rouge">mkstemps</code> overwrites the same memory as a buffer of <code class="highlighter-rouge">CChar</code>. More commonly, the pointer conversion is valid because the buffer is only initialized once. Nonetheless, the explicit casting is extremely awkward for such a common use case. To avoid excessive <code class="highlighter-rouge">UnsafePointer</code> conversion and ease migration to the <code class="highlighter-rouge">UnsafeRawPointer</code> model, helpers will be added to the <code class="highlighter-rouge">String</code> API.</p> <p>In <code class="highlighter-rouge">CString.swift</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">cString</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>And in <code class="highlighter-rouge">StringUTF8.swift</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">nulTerminatedUTF8CString</span><span class="p">:</span> <span class="kt">ContiguousArray</span><span class="o">&lt;</span><span class="kt">CChar</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>With these two helpers, conversion between <code class="highlighter-rouge">UnsafePointer&lt;CChar&gt;</code> and <code class="highlighter-rouge">UnsafePointer&lt;UInt8&gt;</code> is safe without sacrificing efficiency. The <code class="highlighter-rouge">String</code> initializer already copies the byte array into the Strings internal representation, so can trivially convert the element type. The <code class="highlighter-rouge">nulTerminatedUTF8CString</code> function also copies the strings internal representation into an array of <code class="highlighter-rouge">UInt8</code>. With this helper, no unsafe casting is necessary in the previous example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">utf8Cstr</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">nulTerminatedUTF8CString</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">fd</span><span class="p">,</span> <span class="nv">fileName</span><span class="p">)</span> <span class="o">=</span> <span class="n">utf8</span><span class="o">.</span><span class="n">withUnsafeMutableBufferPointer</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">utf8CStrBuf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">CInt</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="nv">fd</span> <span class="o">=</span> <span class="nf">mkstemps</span><span class="p">(</span><span class="n">utf8CStrBuf</span><span class="p">,</span> <span class="n">suffixlen</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">fileName</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">cString</span><span class="p">:</span> <span class="n">utf8CStrBuf</span><span class="p">)</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="full-unsaferawpointer-api"> <a href="#full-unsaferawpointer-api" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Full <code class="highlighter-rouge">UnsafeRawPointer</code> API </h3> <p>Most of the API was already presented above. For the sake of having it in one place, a list of the expected <code class="highlighter-rouge">UnsafeMutableRawPointer</code> members is shown below.</p> <p>For full doc comments, see the <a href="https://github.com/atrick/swift/blob/rawptr/stdlib/public/core/UnsafeRawPointer.swift.gyb">github revision</a>.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">UnsafeMutableRawPointer</span> <span class="p">:</span> <span class="kt">Strideable</span><span class="p">,</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="n">_Pointer</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">_rawValue</span><span class="p">:</span> <span class="kt">Builtin</span><span class="o">.</span><span class="kt">RawPointer</span>
  <span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span>

  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">_rawValue</span> <span class="p">:</span> <span class="kt">Builtin</span><span class="o">.</span><span class="kt">RawPointer</span><span class="p">)</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">other</span> <span class="p">:</span> <span class="kt">OpaquePointer</span><span class="p">)</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">other</span> <span class="p">:</span> <span class="kt">OpaquePointer</span><span class="p">?)</span>
  <span class="nf">init</span><span class="p">?(</span><span class="nv">bitPattern</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="nf">init</span><span class="p">?(</span><span class="nv">bitPattern</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">)</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kd">init</span><span class="p">?</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">?)</span>

  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">allocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawPointer</span>

  <span class="kd">func</span> <span class="nf">deallocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

  <span class="kd">func</span> <span class="n">bindMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>

  <span class="kd">func</span> <span class="n">assumingMemoryBound</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>

  <span class="kd">func</span> <span class="n">initializeMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">at</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>

  <span class="kd">func</span> <span class="n">initializeMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>

  <span class="kd">func</span> <span class="n">initializeMemory</span><span class="o">&lt;</span><span class="kt">C</span> <span class="p">:</span> <span class="kt">Collection</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">C</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="kt">C</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">C</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span><span class="o">&gt;</span>

  <span class="kd">func</span> <span class="n">moveInitializeMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="kd">func</span> <span class="n">load</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span>

  <span class="kd">func</span> <span class="n">storeBytes</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">toByteOffset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">distance</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
  <span class="kd">func</span> <span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeRawPointer</span>
<span class="p">}</span>
</code></pre></div></div> <p>The immutable <code class="highlighter-rouge">UnsafeRawPointer</code> members are:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">UnsafeRawPointer</span> <span class="p">:</span> <span class="kt">Strideable</span><span class="p">,</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="n">_Pointer</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">_rawValue</span><span class="p">:</span> <span class="kt">Builtin</span><span class="o">.</span><span class="kt">RawPointer</span>
  <span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span>

  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">_rawValue</span> <span class="p">:</span> <span class="kt">Builtin</span><span class="o">.</span><span class="kt">RawPointer</span><span class="p">)</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">other</span> <span class="p">:</span> <span class="kt">OpaquePointer</span><span class="p">)</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">other</span> <span class="p">:</span> <span class="kt">OpaquePointer</span><span class="p">?)</span>
  <span class="nf">init</span><span class="p">?(</span><span class="nv">bitPattern</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="nf">init</span><span class="p">?(</span><span class="nv">bitPattern</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">)</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kd">init</span><span class="p">?</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">?)</span>

  <span class="kd">func</span> <span class="nf">deallocate</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

  <span class="kd">func</span> <span class="n">bindMemory</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
  <span class="kd">func</span> <span class="n">assumingMemoryBound</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>

  <span class="kd">func</span> <span class="n">load</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span>

  <span class="kd">func</span> <span class="nf">distance</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
  <span class="kd">func</span> <span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeRawPointer</span>
<span class="p">}</span>

</code></pre></div></div> <p>The added <code class="highlighter-rouge">UnsafeMutablePointer</code> members are:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="k">mutating</span> <span class="nv">from</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span><span class="p">)</span>

  <span class="kd">func</span> <span class="n">withMemoryRebound</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">capacity</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span>
    <span class="n">_</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">@noescape</span> <span class="p">(</span><span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="k">rethrows</span>

<span class="p">}</span>
</code></pre></div></div> <p>The added <code class="highlighter-rouge">UnsafePointer</code> members are:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Inferred initialization from mutable to immutable.</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The following unsafe pointer conversions on <code class="highlighter-rouge">Unsafe[Mutable]Pointer</code> members are removed:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kd">init</span><span class="p">?</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">?)</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kd">init</span><span class="p">?</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">?)</span>
<span class="p">}</span>
<span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">init</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kd">init</span><span class="p">?</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">from</span> <span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">?)</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="highlighter-rouge">UnsafeMutablePointer.deinitialize</code> now returns a raw pointer:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">deinitialize</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawPointer</span>
<span class="p">}</span>
</code></pre></div></div> <p>The following <code class="highlighter-rouge">UnsafeMutablePointer</code> members are renamed:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="kd">func</span> <span class="nf">deallocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">initialize</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">Pointee</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">assign</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="kd">func</span> <span class="nf">moveInitialize</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="err">$</span><span class="p">{</span><span class="k">Self</span><span class="p">},</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="kd">func</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="kd">func</span> <span class="n">initialize</span><span class="o">&lt;</span><span class="kt">C</span> <span class="p">:</span> <span class="kt">Collection</span><span class="o">&gt;</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">C</span><span class="p">)</span>
  <span class="kd">func</span> <span class="nf">moveAssign</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="err">$</span><span class="p">{</span><span class="k">Self</span><span class="p">},</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The following <code class="highlighter-rouge">UnsafeMutablePointer</code> members are removed:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">assignBackwardFrom</span><span class="p">(</span><span class="n">_</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Pointee</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
  <span class="kd">func</span> <span class="nf">moveInitializeBackwardFrom</span><span class="p">(</span><span class="n">_</span> <span class="nv">source</span><span class="p">:</span> <span class="err">$</span><span class="p">{</span><span class="k">Self</span><span class="p">},</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="impact-on-existing-code"> <a href="#impact-on-existing-code" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Impact on existing code </h2> <p>The largest impact of this change is that <code class="highlighter-rouge">void*</code> and <code class="highlighter-rouge">const void*</code> are imported as <code class="highlighter-rouge">UnsafeMutableRawPointer</code> and <code class="highlighter-rouge">UnsafeRawPointer</code>. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.</p> <p>Any Swift projects that rely on type inference to convert between <code class="highlighter-rouge">UnsafePointer</code> types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the <code class="highlighter-rouge">UnsafeRawPointer</code> API. Otherwise, they can work around the new restriction by using <code class="highlighter-rouge">bindMemory(to:capacity:)</code>, <code class="highlighter-rouge">assumingMemoryBound&lt;T&gt;(to)</code>, or adding a <code class="highlighter-rouge">mutating</code> label to their initializer.</p> <p>The <a href="https://github.com/atrick/swift/commits/unsafeptr_convert">unsafeptr_convert branch</a> contains an implementation of a previous design, which will soon be ported to the <a href="https://github.com/atrick/swift/commits/rawptr">rawptr branch</a>.</p> <h3 id="swift-code-migration"> <a href="#swift-code-migration" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Swift code migration </h3> <p>All occurrences of the type <code class="highlighter-rouge">Unsafe[Mutable]Pointer&lt;Void&gt;</code> will be automatically replaced with <code class="highlighter-rouge">Unsafe[Mutable]RawPointer</code>.</p> <p>Initialization of the form <code class="highlighter-rouge">Unsafe[Mutable]Pointer</code>(p) will automatically be replaced by <code class="highlighter-rouge">Unsafe[Mutable]RawPointer(p)</code> whenever the type checker determines that is the expressions expected type.</p> <p>Conversion between incompatible <code class="highlighter-rouge">Unsafe[Mutable]Pointer</code> values will produce a diagnostic explaining asking the user to migrate to one of these forms:</p> <ul> <li><code class="highlighter-rouge">Unsafe[Mutable]RawPointer($0).withMemoryRebound(to:capacity:)</code></li> <li><code class="highlighter-rouge">Unsafe[Mutable]RawPointer($0).bindMemory(to:capacity:)</code></li> <li><code class="highlighter-rouge">Unsafe[Mutable]RawPointer($0).assumingMemoryBound(to: T.self)</code></li> </ul> <p>The following UnsafeMutablePointer methods:</p> <ul> <li><code class="highlighter-rouge">initializeFrom(_: UnsafePointer&lt;Pointee&gt;, count: Int)</code></li> <li><code class="highlighter-rouge">initializeBackwardFrom(_: UnsafePointer&lt;Pointee&gt;, count: Int)</code></li> <li><code class="highlighter-rouge">assignFrom(_ source: Unsafe[Mutable]Pointer&lt;Pointee&gt;, count: Int)</code></li> <li><code class="highlighter-rouge">moveAssignFrom(_ source: Unsafe[Mutable]Pointer&lt;Pointee&gt;, count: Int)</code></li> </ul> <p>will be automatically converted to:</p> <ul> <li><code class="highlighter-rouge">initialize(from: UnsafePointer&lt;Pointee&gt;, count: Int)</code></li> <li><code class="highlighter-rouge">assign(from source: Unsafe[Mutable]Pointer&lt;Pointee&gt;, count: Int)</code></li> </ul> <h3 id="standard-library-changes"> <a href="#standard-library-changes" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Standard library changes </h3> <p>Disallowing inferred <code class="highlighter-rouge">UnsafePointer</code> conversion requires some standard library code to use an explicit <code class="highlighter-rouge">.bindMemory(to:capacity:)</code> whenever the conversion may previously violate strict aliasing.</p> <p>All occurrences of <code class="highlighter-rouge">Unsafe[Mutable]Pointer&lt;Void&gt;</code> in the standard library are converted to <code class="highlighter-rouge">Unsafe[Mutable]RawPointer</code>. e.g. <code class="highlighter-rouge">unsafeAddress()</code> now returns <code class="highlighter-rouge">UnsafeRawPointer</code>, not <code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code>.</p> <p>Some occurrences of <code class="highlighter-rouge">Unsafe[Mutable]Pointer&lt;Pointee&gt;</code> in the standard library are replaced with <code class="highlighter-rouge">UnsafeRawPointer</code>, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.</p> <p><code class="highlighter-rouge">StringCore.baseAddress</code> changes from <code class="highlighter-rouge">OpaquePointer</code> to <code class="highlighter-rouge">UnsafeMutableRawPointer</code> because it is computing byte offsets and accessing the memory. <code class="highlighter-rouge">OpaquePointer</code> is meant for bridging, but should be truly opaque; that is, non-dereferenceable and not involved in address computation.</p> <p>The <code class="highlighter-rouge">StringCore</code> implementation does a considerable amount of casting between different views of the <code class="highlighter-rouge">String</code> storage. For interoperability and optimization, String buffers frequently need to be cast to and from <code class="highlighter-rouge">CChar</code>. This will be made safe by using <code class="highlighter-rouge">bindMemory(to:capacity:)</code>.</p> <p><code class="highlighter-rouge">CoreAudio</code> utilities now use <code class="highlighter-rouge">Unsafe[Mutable]RawPointer</code>.</p> <h2 id="implementation-status"> <a href="#implementation-status" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Implementation status </h2> <p>An <a href="https://github.com/atrick/swift/commits/unsafeptr_convert">unsafeptr_convert branch</a> has the first prototype, named <code class="highlighter-rouge">UnsafeBytePointer</code>, and includes standard library and type system changes listed below. A <a href="https://github.com/atrick/swift/commits/rawptr">rawptr branch</a> has the latest proposed implementation of <code class="highlighter-rouge">UnsafeRawPointer</code>. I am currently updating the <code class="highlighter-rouge">rawptr</code> branch to include the following changes.</p> <p>There are a several things going on here in order to make it possible to build the standard library with the changes:</p> <ul> <li> <p>A new <code class="highlighter-rouge">UnsafeRawPointer</code> type is defined.</p> </li> <li> <p>The type system imports <code class="highlighter-rouge">void*</code> as UnsafeRawPointer.</p> </li> <li> <p>The type system handles implicit conversions to UnsafeRawPointer.</p> </li> <li> <p><code class="highlighter-rouge">UnsafeRawPointer</code> replaces both <code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code> and <code class="highlighter-rouge">UnsafeMutablePointer&lt;Void&gt;</code> (Recent feedback suggestes that <code class="highlighter-rouge">UnsafeMutablePointer</code> should also be introduced).</p> </li> <li> <p>The standard library was relying on inferred <code class="highlighter-rouge">UnsafePointer</code> conversion in over 100 places. Most of these conversions now either take an explicit label, such as <code class="highlighter-rouge">mutating</code> or have been rewritten.</p> </li> <li> <p>Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use <code class="highlighter-rouge">UnsafeRawPointer</code> instead.</p> </li> <li> <p>Explicit labeled <code class="highlighter-rouge">Unsafe[Mutable]Pointer</code> initializers are added.</p> </li> <li> <p>The inferred <code class="highlighter-rouge">Unsafe[Mutable]Pointer</code> conversion is removed.</p> </li> </ul> <p>Remaining work:</p> <ul> <li> <p>A SIL-level builtin needs to be implemented for binding a region of memory.</p> </li> <li> <p>A name mangled abbreviation needs to be created for <code class="highlighter-rouge">UnsafeRawPointer</code>.</p> </li> <li> <p>We may want a convenience utility for binding null-terminated string without providing a capacity.</p> </li> <li> <p>The StringAPI tests should probably be rewritten with <code class="highlighter-rouge">UnsafeRawPointer</code>.</p> </li> <li> <p>The NSStringAPI utilities and tests may need to be ported to <code class="highlighter-rouge">UnsafeRawPointer</code></p> </li> <li> <p>The CoreAudio utilities and tests may need to be ported to <code class="highlighter-rouge">UnsafeRawPointer</code>.</p> </li> </ul> <h2 id="future-improvements-and-planned-additive-api"> <a href="#future-improvements-and-planned-additive-api" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Future improvements and planned additive API </h2> <p><code class="highlighter-rouge">UnsafeRawPointer</code> should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows packed struct members. At that time we may also want to add an unaligned flag to <code class="highlighter-rouge">UnsafeRawPointer</code>s <code class="highlighter-rouge">load</code> and <code class="highlighter-rouge">initialize</code> methods.</p> <h2 id="alternatives-previously-considered"> <a href="#alternatives-previously-considered" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Alternatives previously considered </h2> <h3 id="unsafebitcast-workaround"> <a href="#unsafebitcast-workaround" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> unsafeBitCast workaround </h3> <p>In some cases, developers can safely reinterpret values to achieve the same effect as type punning:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">ptrI32</span> <span class="o">=</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ptrI32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Int32</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">u</span> <span class="o">=</span> <span class="nf">unsafeBitCast</span><span class="p">(</span><span class="n">ptrI32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
</code></pre></div></div> <p>Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isnt a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.</p> <h3 id="typepunnedmemory-property"> <a href="#typepunnedmemory-property" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> typePunnedMemory property </h3> <p>We considered adding a <code class="highlighter-rouge">typePunnedMemory</code> property to the existing <code class="highlighter-rouge">Unsafe[Mutabale]Pointer</code> API. This would provide a legal way to access a potentially type punned <code class="highlighter-rouge">Unsafe[Mutabale]Pointer</code>. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.</p> <h3 id="special-unsafemutablepointer-type"> <a href="#special-unsafemutablepointer-type" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Special UnsafeMutablePointer<RawByte> type</RawByte> </h3> <p>The opaque <code class="highlighter-rouge">_RawByte</code> struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a <code class="highlighter-rouge">_RawByte</code> could be loaded but its value cannot be directly inspected). <code class="highlighter-rouge">UnsafePointer&lt;_RawByte&gt;</code> is a clever alternative to <code class="highlighter-rouge">UnsafeRawPointer</code>. However, it doesnt do enough to prevent undefined behavior. The loaded <code class="highlighter-rouge">_RawByte</code> would naturally be accessed via <code class="highlighter-rouge">unsafeBitCast</code>, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.</p> <p>To solve the safety problem with <code class="highlighter-rouge">UnsafePointer&lt;_RawByte&gt;</code>, the compiler could associate special semantics with a <code class="highlighter-rouge">UnsafePointer</code> bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, <code class="highlighter-rouge">UnsafePointer&lt;T&gt;.load&lt;U&gt;</code> would be a nonsensical vestige.</p> <h3 id="unsafebytepointer"> <a href="#unsafebytepointer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> UnsafeBytePointer </h3> <p>This first version of this proposal introduced an <code class="highlighter-rouge">UnsafeBytePointer</code>. <code class="highlighter-rouge">UnsafeRawPointer</code> better conveys the types role with respect to uninitialized memory. The best way to introduce <code class="highlighter-rouge">UnsafeRawPointer</code> to users is by showing how it represents uninitialized memory. It is the result of allocation, input to initialization, and result of deinitialization. This helps users understand the relationship between initializing memory and imbuing it with a type.</p> <p>Furthermore, we do not intend to allow direct access to the bytes via subscript which would be implied by <code class="highlighter-rouge">UnsafeBytePointer</code>.</p> <h3 id="alternate-proposal-for-void-type"> <a href="#alternate-proposal-for-void-type" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Alternate proposal for <code class="highlighter-rouge">void*</code> type </h3> <p>Changing the imported type for <code class="highlighter-rouge">void*</code> will be somewhat disruptive. We could continue to import <code class="highlighter-rouge">void*</code> as <code class="highlighter-rouge">UnsafeMutablePointer&lt;Void&gt;</code> and <code class="highlighter-rouge">const void*</code> as <code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code>, which will continue to serve as an opaque untyped pointer. Converting to <code class="highlighter-rouge">UnsafeRawPointer</code> would be necessary to perform pointer arithmetic or to conservatively handle possible type punning.</p> <p>This alternative is <em>much</em> less disruptive, but we are left with two forms of untyped pointer, one of which (<code class="highlighter-rouge">UnsafePointer</code>) the type system somewhat conflates with typed pointers.</p> <p>There seems to be general agreement that <code class="highlighter-rouge">UnsafeMutablePointer&lt;Void&gt;</code> is fundamentally the wrong way to represent untyped memory.</p> <p>From a practical perspective, given the current restrictions of the language, its not clear how to statically enforce the necessary rules for casting <code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code> once general <code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> conversions are disallowed. The following conversions should be inferred, and implied for function arguments (ignoring mutability):</p> <ul> <li> <p><code class="highlighter-rouge">UnsafePointer&lt;T&gt;</code> to <code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code></p> </li> <li> <p><code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code> to <code class="highlighter-rouge">UnsafeRawPointer</code></p> </li> </ul> <p>I did not implement this simpler design because my primary goal was to enforce legal pointer conversion and rid Swift code of undefined behavior. I cant do that while allowing <code class="highlighter-rouge">UnsafePointer&lt;Void&gt;</code> conversions.</p> <p>The general consensus now is that as long as we are making source breaking changes to <code class="highlighter-rouge">UnsafePointer</code>, we should try to shoot for an overall better design that helps programmers understand the concepts.</p> </div> </div> </div> </div> </body> </html>
