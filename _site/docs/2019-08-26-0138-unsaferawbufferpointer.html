<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>SE-0138 UnsafeRawBufferPointer - Swift Evolution List</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>SE-0138 UnsafeRawBufferPointer | Swift Evolution List</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="SE-0138 UnsafeRawBufferPointer" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Yuhuu!" /> <meta property="og:description" content="Yuhuu!" /> <link rel="canonical" href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" /> <meta property="og:url" content="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" /> <meta property="og:site_name" content="Swift Evolution List" /> <script type="application/ld+json"> {"url":"http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html","headline":"SE-0138 UnsafeRawBufferPointer","description":"Yuhuu!","@type":"WebPage","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Swift Evolution List</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/about/" class="navigation-list-link">About</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html" class="navigation-list-link">SE-0001 Allow (most) keywords as argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0002-remove-currying.html" class="navigation-list-link">SE-0002 Removing currying `func` declaration syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html" class="navigation-list-link">SE-0003 Removing `var` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html" class="navigation-list-link">SE-0004 Remove the `++` and `--` operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html" class="navigation-list-link">SE-0005 Better Translation of Objective-C APIs Into Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html" class="navigation-list-link">SE-0006 Apply API Guidelines to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html" class="navigation-list-link">SE-0007 Remove C-style for-loops with conditions and incrementers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html" class="navigation-list-link">SE-0008 Add a Lazy flatMap for Sequences of Optionals #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html" class="navigation-list-link">SE-0009 Require self for accessing instance members</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html" class="navigation-list-link">SE-0010 Add StaticString.UnicodeScalarView</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html" class="navigation-list-link">SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html" class="navigation-list-link">SE-0012 Add `@noescape` to public library API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html" class="navigation-list-link">SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html" class="navigation-list-link">SE-0014 Constraining `AnySequence.init`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html" class="navigation-list-link">SE-0015 Tuple comparison operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html" class="navigation-list-link">SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html" class="navigation-list-link">SE-0017 Change `Unmanaged` to use `UnsafePointer`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html" class="navigation-list-link">SE-0018 Flexible Memberwise Initialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html" class="navigation-list-link">SE-0019 Swift Testing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html" class="navigation-list-link">SE-0020 Swift Language Version Build Configuration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html" class="navigation-list-link">SE-0021 Naming Functions with Argument Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html" class="navigation-list-link">SE-0022 Referencing the Objective-C selector of a method</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html" class="navigation-list-link">SE-0023 API Design Guidelines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html" class="navigation-list-link">SE-0024 Optional Value Setter `??=`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html" class="navigation-list-link">SE-0025 Scoped Access Level</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html" class="navigation-list-link">SE-0026 Abstract classes and methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html" class="navigation-list-link">SE-0027 Expose code unit initializers on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html" class="navigation-list-link">SE-0028 Modernizing Swift's Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html" class="navigation-list-link">SE-0029 Remove implicit tuple splat behavior from function applications</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html" class="navigation-list-link">SE-0030 Property Behaviors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html" class="navigation-list-link">SE-0031 Adjusting `inout` Declarations for Type Decoration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html" class="navigation-list-link">SE-0032 Add `first(where:)` method to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html" class="navigation-list-link">SE-0033 Import Objective-C Constants as Swift Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html" class="navigation-list-link">SE-0034 Disambiguating Line Control Statements from Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html" class="navigation-list-link">SE-0035 Limiting `inout` capture to `@noescape` contexts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0036-enum-dot.html" class="navigation-list-link">SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html" class="navigation-list-link">SE-0037 Clarify interaction between comments & operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html" class="navigation-list-link">SE-0038 Package Manager C Language Target Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html" class="navigation-list-link">SE-0039 Modernizing Playground Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0040-attributecolons.html" class="navigation-list-link">SE-0040 Replacing Equal Signs with Colons For Attribute Arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html" class="navigation-list-link">SE-0041 Updating Protocol Naming Conventions for Conversions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html" class="navigation-list-link">SE-0042 Flattening the function type of unapplied method references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html" class="navigation-list-link">SE-0043 Declare variables in 'case' labels with multiple patterns </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0044-import-as-member.html" class="navigation-list-link">SE-0044 Import as member</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html" class="navigation-list-link">SE-0045 Add prefix(while:) and drop(while:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0046-first-label.html" class="navigation-list-link">SE-0046 Establish consistent label behavior across all parameters including first labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html" class="navigation-list-link">SE-0047 Defaulting non-Void functions so they warn on unused results</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html" class="navigation-list-link">SE-0048 Generic Type Aliases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html" class="navigation-list-link">SE-0049 Move @noescape and @autoclosure to be type attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html" class="navigation-list-link">SE-0050 Decoupling Floating Point Strides from Generic Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html" class="navigation-list-link">SE-0051 Conventionalizing `stride` semantics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html" class="navigation-list-link">SE-0052 Change IteratorType post-nil guarantee</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html" class="navigation-list-link">SE-0053 Remove explicit use of `let` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html" class="navigation-list-link">SE-0054 Abolish `ImplicitlyUnwrappedOptional` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html" class="navigation-list-link">SE-0055 Make unsafe pointer nullability explicit using Optional</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html" class="navigation-list-link">SE-0056 Allow trailing closures in `guard` conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html" class="navigation-list-link">SE-0057 Importing Objective-C Lightweight Generics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html" class="navigation-list-link">SE-0058 Allow Swift types to provide custom Objective-C representations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html" class="navigation-list-link">SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html" class="navigation-list-link">SE-0060 Enforcing order of defaulted parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html" class="navigation-list-link">SE-0061 Add Generic Result and Error Handling to autoreleasepool()</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html" class="navigation-list-link">SE-0062 Referencing Objective-C key-paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html" class="navigation-list-link">SE-0063 SwiftPM System Module Search Paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0064-property-selectors.html" class="navigation-list-link">SE-0064 Referencing the Objective-C selector of property getters and setters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html" class="navigation-list-link">SE-0065 A New Model for Collections and Indices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html" class="navigation-list-link">SE-0066 Standardize function type argument syntax to require parentheses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html" class="navigation-list-link">SE-0067 Enhanced Floating Point Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0068-universal-self.html" class="navigation-list-link">SE-0068 Expanding Swift `Self` to class members and value types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html" class="navigation-list-link">SE-0069 Mutability and Foundation Value Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html" class="navigation-list-link">SE-0070 Make Optional Requirements Objective-C-only</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0071-member-keywords.html" class="navigation-list-link">SE-0071 Allow (most) keywords in member references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html" class="navigation-list-link">SE-0072 Fully eliminate implicit bridging conversions from Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0073-noescape-once.html" class="navigation-list-link">SE-0073 Marking closures as executing exactly once</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0074-binary-search.html" class="navigation-list-link">SE-0074 Implementation of Binary Search functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0075-import-test.html" class="navigation-list-link">SE-0075 Adding a Build Configuration Import Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html" class="navigation-list-link">SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html" class="navigation-list-link">SE-0077 Improved operator declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html" class="navigation-list-link">SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html" class="navigation-list-link">SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html" class="navigation-list-link">SE-0080 Failable Numeric Conversion Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html" class="navigation-list-link">SE-0081 Move `where` clause to end of declaration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html" class="navigation-list-link">SE-0082 Package Manager Editable Packages</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html" class="navigation-list-link">SE-0083 Remove bridging conversion behavior from dynamic casts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html" class="navigation-list-link">SE-0084 Allow trailing commas in parameter lists and tuples</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html" class="navigation-list-link">SE-0085 Package Manager Command Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html" class="navigation-list-link">SE-0086 Drop NS Prefix in Swift Foundation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html" class="navigation-list-link">SE-0087 Rename `lazy` to `@lazy`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html" class="navigation-list-link">SE-0088 Modernize libdispatch for Swift 3 naming conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html" class="navigation-list-link">SE-0089 Renaming `String.init<T>(_: T)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html" class="navigation-list-link">SE-0090 Remove `.self` and freely allow type references in expressions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html" class="navigation-list-link">SE-0091 Improving operator requirements in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html" class="navigation-list-link">SE-0092 Typealiases in protocols and protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0093-slice-base.html" class="navigation-list-link">SE-0093 Adding a public `base` property to slices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0094-sequence-function.html" class="navigation-list-link">SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html" class="navigation-list-link">SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0096-dynamictype.html" class="navigation-list-link">SE-0096 Converting `dynamicType` from a property to an operator</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html" class="navigation-list-link">SE-0097 Normalizing naming for "negative" attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html" class="navigation-list-link">SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html" class="navigation-list-link">SE-0099 Restructuring Condition Clauses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html" class="navigation-list-link">SE-0100 Add sequence-based initializers and merge methods to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html" class="navigation-list-link">SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html" class="navigation-list-link">SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html" class="navigation-list-link">SE-0103 Make non-escaping closures the default</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0104-improved-integers.html" class="navigation-list-link">SE-0104 Protocol-oriented integers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html" class="navigation-list-link">SE-0105 Removing Where Clauses from For-In Loops</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html" class="navigation-list-link">SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" class="navigation-list-link">SE-0107 UnsafeRawPointer API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html" class="navigation-list-link">SE-0108 Remove associated type inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html" class="navigation-list-link">SE-0109 Remove the `Boolean` protocol </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html" class="navigation-list-link">SE-0110 Distinguish between single-tuple and multiple-argument function types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html" class="navigation-list-link">SE-0111 Remove type system significance of function argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html" class="navigation-list-link">SE-0112 Improved NSError Bridging</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html" class="navigation-list-link">SE-0113 Add integral rounding functions to FloatingPoint</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html" class="navigation-list-link">SE-0114 Updating Buffer "Value" Names to "Header" Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html" class="navigation-list-link">SE-0115 Rename Literal Syntax Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0116-id-as-any.html" class="navigation-list-link">SE-0116 Import Objective-C `id` as Swift `Any` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html" class="navigation-list-link">SE-0117 Allow distinguishing between public access and public overridability</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html" class="navigation-list-link">SE-0118 Closure Parameter Names and Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html" class="navigation-list-link">SE-0119 Remove access modifiers from extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html" class="navigation-list-link">SE-0120 Revise `partition` Method Signature</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html" class="navigation-list-link">SE-0121 Remove `Optional` Comparison Operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html" class="navigation-list-link">SE-0122 Use colons for subscript declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html" class="navigation-list-link">SE-0123 Disallow coercion to optionals in operator arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html" class="navigation-list-link">SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html" class="navigation-list-link">SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html" class="navigation-list-link">SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html" class="navigation-list-link">SE-0127 Cleaning up stdlib Pointer and Buffer Routines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html" class="navigation-list-link">SE-0128 Change failable UnicodeScalar initializers to failable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html" class="navigation-list-link">SE-0129 Package Manager Test Naming Conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html" class="navigation-list-link">SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0131-anyhashable.html" class="navigation-list-link">SE-0131 Add `AnyHashable` to the standard library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html" class="navigation-list-link">SE-0132 Rationalizing Sequence end-operation names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html" class="navigation-list-link">SE-0133 Rename `flatten()` to `joined()`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html" class="navigation-list-link">SE-0134 Rename two UTF8-related properties on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html" class="navigation-list-link">SE-0135 Package Manager Support for Differentiating Packages by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html" class="navigation-list-link">SE-0136 Memory layout of values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html" class="navigation-list-link">SE-0137 Avoiding Lock-In to Legacy Protocol Designs</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" class="navigation-list-link active">SE-0138 UnsafeRawBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html" class="navigation-list-link">SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html" class="navigation-list-link">SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html" class="navigation-list-link">SE-0141 Availability by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html" class="navigation-list-link">SE-0142 Permit where clauses to constrain associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" class="navigation-list-link">SE-0143 Conditional conformances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html" class="navigation-list-link">SE-0144 Allow Single Dollar Sign as a Valid Identifier</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html" class="navigation-list-link">SE-0145 Package Manager Version Pinning</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html" class="navigation-list-link">SE-0146 Package Manager Product Definitions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html" class="navigation-list-link">SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html" class="navigation-list-link">SE-0148 Generic Subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html" class="navigation-list-link">SE-0149 Package Manager Support for Top of Tree development</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html" class="navigation-list-link">SE-0150 Package Manager Support for branches</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html" class="navigation-list-link">SE-0151 Package Manager Swift Language Compatibility Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html" class="navigation-list-link">SE-0152 Package Manager Tools Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html" class="navigation-list-link">SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html" class="navigation-list-link">SE-0154 Provide Custom Collections for Dictionary Keys and Values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html" class="navigation-list-link">SE-0155 Normalize Enum Case Representation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html" class="navigation-list-link">SE-0156 Class and Subtype existentials</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html" class="navigation-list-link">SE-0157 Support recursive constraints on associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html" class="navigation-list-link">SE-0158 Package Manager Manifest API Redesign</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html" class="navigation-list-link">SE-0159 Fix Private Access Levels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0160-objc-inference.html" class="navigation-list-link">SE-0160 Limiting `@objc` inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0161-key-paths.html" class="navigation-list-link">SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html" class="navigation-list-link">SE-0162 Package Manager Custom Target Layouts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html" class="navigation-list-link">SE-0163 String Revision: Collection Conformance, C Interop, Transcoding</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html" class="navigation-list-link">SE-0164 Remove final support in protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0165-dict.html" class="navigation-list-link">SE-0165 Dictionary & Set Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" class="navigation-list-link">SE-0166 Swift Archival & Serialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html" class="navigation-list-link">SE-0167 Swift Encoders</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html" class="navigation-list-link">SE-0168 Multi-Line String Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html" class="navigation-list-link">SE-0169 Improve Interaction Between `private` Declarations and Extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html" class="navigation-list-link">SE-0170 NSNumber bridging and Numeric types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html" class="navigation-list-link">SE-0171 Reduce with `inout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html" class="navigation-list-link">SE-0172 One-sided Ranges</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0173-swap-indices.html" class="navigation-list-link">SE-0173 Add `MutableCollection.swapAt(_:_:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html" class="navigation-list-link">SE-0174 Change `filter` to return an associated type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html" class="navigation-list-link">SE-0175 Package Manager Revised Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" class="navigation-list-link">SE-0176 Enforce Exclusive Access to Memory</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html" class="navigation-list-link">SE-0177 Add clamp(to:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html" class="navigation-list-link">SE-0178 Add `unicodeScalars` property to `Character`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html" class="navigation-list-link">SE-0179 Swift `run` Command</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html" class="navigation-list-link">SE-0180 String Index Overhaul</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html" class="navigation-list-link">SE-0181 Package Manager C/C++ Language Standard Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html" class="navigation-list-link">SE-0182 String Newline Escaping</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html" class="navigation-list-link">SE-0183 Substring performance affordances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html" class="navigation-list-link">SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html" class="navigation-list-link">SE-0185 Synthesizing `Equatable` and `Hashable` conformance</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html" class="navigation-list-link">SE-0186 Remove ownership keyword support in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html" class="navigation-list-link">SE-0187 Introduce Sequence.compactMap(_:)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html" class="navigation-list-link">SE-0188 Make Standard Library Index Types Hashable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html" class="navigation-list-link">SE-0189 Restrict Cross-module Struct Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html" class="navigation-list-link">SE-0190 Target environment platform condition</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html" class="navigation-list-link">SE-0191 Eliminate `IndexDistance` from `Collection`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" class="navigation-list-link">SE-0192 Handling Future Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html" class="navigation-list-link">SE-0193 Cross-module inlining and specialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html" class="navigation-list-link">SE-0194 Derived Collection of Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html" class="navigation-list-link">SE-0195 Introduce User-defined "Dynamic Member Lookup" Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html" class="navigation-list-link">SE-0196 Compiler Diagnostic Directives</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0197-remove-where.html" class="navigation-list-link">SE-0197 Adding in-place `removeAll(where:)` to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html" class="navigation-list-link">SE-0198 Playground QuickLook API Revamp #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html" class="navigation-list-link">SE-0199 Adding `toggle` to `Bool`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html" class="navigation-list-link">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html" class="navigation-list-link">SE-0201 Package Manager Local Dependencies</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0202-random-unification.html" class="navigation-list-link">SE-0202 Random Unification</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html" class="navigation-list-link">SE-0203 Rename Sequence.elementsEqual</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html" class="navigation-list-link">SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html" class="navigation-list-link">SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html" class="navigation-list-link">SE-0206 Hashable Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0207-containsOnly.html" class="navigation-list-link">SE-0207 Add an `allSatisfy` algorithm to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html" class="navigation-list-link">SE-0208 Package Manager System Library Targets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html" class="navigation-list-link">SE-0209 Package Manager Swift Language Version API Update</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html" class="navigation-list-link">SE-0210 Add an `offset(of:)` method to `MemoryLayout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html" class="navigation-list-link">SE-0211 Add Unicode Properties to `Unicode.Scalar`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html" class="navigation-list-link">SE-0212 Compiler Version Directive</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html" class="navigation-list-link">SE-0213 Literal initialization via coercion</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html" class="navigation-list-link">SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html" class="navigation-list-link">SE-0215 Conform `Never` to `Equatable` and `Hashable`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html" class="navigation-list-link">SE-0216 Introduce user-defined dynamically "callable" types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0217-bangbang.html" class="navigation-list-link">SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html" class="navigation-list-link">SE-0218 Introduce `compactMapValues` to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html" class="navigation-list-link">SE-0219 Package Manager Dependency Mirroring</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0220-count-where.html" class="navigation-list-link">SE-0220 `count(where:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0221-character-properties.html" class="navigation-list-link">SE-0221 Character Properties</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html" class="navigation-list-link">SE-0222 Lazy CompactMap Sequence</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html" class="navigation-list-link">SE-0223 Accessing an Array's Uninitialized Buffer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html" class="navigation-list-link">SE-0224 Support 'less than' operator in compilation conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html" class="navigation-list-link">SE-0225 Adding `isMultiple` to `BinaryInteger`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html" class="navigation-list-link">SE-0226 Package Manager Target Based Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html" class="navigation-list-link">SE-0227 Identity key path</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html" class="navigation-list-link">SE-0228 Fix `ExpressibleByStringInterpolation`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0229-simd.html" class="navigation-list-link">SE-0229 SIMD Vectors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html" class="navigation-list-link">SE-0230 Flatten nested optionals resulting from 'try?'</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html" class="navigation-list-link">SE-0231 Optional Iteration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html" class="navigation-list-link">SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html" class="navigation-list-link">SE-0233 Make `Numeric` Refine a new `AdditiveArithmetic` Protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html" class="navigation-list-link">SE-0234 Remove `Sequence.SubSequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0235-add-result.html" class="navigation-list-link">SE-0235 Add Result to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html" class="navigation-list-link">SE-0236 Package Manager Platform Deployment Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html" class="navigation-list-link">SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html" class="navigation-list-link">SE-0238 Package Manager Target Specific Build Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0239-codable-range.html" class="navigation-list-link">SE-0239 Add Codable conformance to Range types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html" class="navigation-list-link">SE-0240 Ordered Collection Diffing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html" class="navigation-list-link">SE-0241 Deprecate String Index Encoded Offsets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html" class="navigation-list-link">SE-0242 Synthesize default values for the memberwise initializer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html" class="navigation-list-link">SE-0243 Integer-convertible character literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html" class="navigation-list-link">SE-0244 Opaque Result Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html" class="navigation-list-link">SE-0245 Add an Array Initializer with Access to Uninitialized Storage</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0246-mathable.html" class="navigation-list-link">SE-0246 Generic Math(s) Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html" class="navigation-list-link">SE-0247 Contiguous Strings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html" class="navigation-list-link">SE-0248 String Gaps and Missing APIs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html" class="navigation-list-link">SE-0249 Key Path Expressions as Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html" class="navigation-list-link">SE-0250 Swift Code Style Guidelines and Formatter</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0251-simd-additions.html" class="navigation-list-link">SE-0251 SIMD additions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html" class="navigation-list-link">SE-0252 Key Path Member Lookup</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0253-callable.html" class="navigation-list-link">SE-0253 Introduce callables </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html" class="navigation-list-link">SE-0254 Static and class subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0255-omit-return.html" class="navigation-list-link">SE-0255 Implicit returns from single-expression functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html" class="navigation-list-link">SE-0256 Introduce `{Mutable}ContiguousCollection` protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0257-elide-comma.html" class="navigation-list-link">SE-0257 Eliding commas from multiline expression lists</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html" class="navigation-list-link"> Feature name</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Swift Evolution List" aria-label="Search Swift Evolution List" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/pondok-programmer/swift-evolution-jekyll">Swift Evolution List</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h1 id="unsaferawbufferpointer"> <a href="#unsaferawbufferpointer" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> UnsafeRawBufferPointer </h1> <ul> <li>Proposal: <a href="0138-unsaferawbufferpointer.md">SE-0138</a></li> <li>Author: <a href="https://github.com/atrick">Andrew Trick</a></li> <li>Review manager: <a href="https://github.com/dabrahams">Dave Abrahams</a></li> <li>Status: <strong>Implemented (Swift 3.0.1)</strong></li> <li>Decision Notes: <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160919/027167.html">Rationale</a></li> </ul> <p>Contents:</p> <ul> <li><a href="#introduction">Introduction</a></li> <li><a href="#motivation">Motivation</a></li> <li><a href="#proposed-solution">Proposed Solution</a></li> <li><a href="#migration-examples">Migration Examples</a></li> <li><a href="#detailed-design">Detailed design</a></li> <li><a href="#implementation-status">Implementation status</a></li> <li><a href="#impact-on-existing-code">Impact on existing code</a></li> <li><a href="#alternatives-considered">Alternatives considered</a></li> </ul> <h2 id="introduction"> <a href="#introduction" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduction </h2> <p>This is a purely additive proposal to improve the Swift 3 migration experience.</p> <p><a href="0107-unsaferawpointer.md">SE-0107: UnsafeRawPointer</a> formalized Swifts memory model with respect to strict aliasing and prevented arbitrary conversion between <code class="highlighter-rouge">UnsafePointer</code> types. When moving to Swift 3, users will need to migrate much of their code dealing with <code class="highlighter-rouge">UnsafePointer</code>s. The new <code class="highlighter-rouge">UnsafeRawPointer</code> makes that possible. It provides a legal means to operate on raw memory (independent of the type of values in memory), and it provides an API for binding memory to a type for subsequent normal typed access. However, migration is not always straightforward because SE-0107 provided only minimal support for raw pointers. Extending raw pointer support to the <code class="highlighter-rouge">UnsafeBufferPointer</code> type will fill in this funcionality gap. This is especially important for code that currently views raw bytes of memory as <code class="highlighter-rouge">UnsafeBufferPointer&lt;UInt8&gt;</code>. Converting between <code class="highlighter-rouge">UInt8</code> and the clients element type at every API transition is difficult to do safely with the <code class="highlighter-rouge">bindMemory</code> API, but that can be avoided entirely by changing the type the represents a view into raw bytes to <code class="highlighter-rouge">UnsafeRawBufferPointer</code>. For more background, see the <a href="https://swift.org/migration-guide/se-0107-migrate.html">UnsafeRawPointer Migration Guide</a>.</p> <p>Swift-evolution threads:</p> <ul> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160808/thread.html#26173">Week #1</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160815/thread.html#26254">Week #2</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160822/thread.html#26553">Week #3</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160829/thread.html#26812">Week #4 (1)</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160829/thread.html#26844">Week #4 (2)</a></li> <li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160905/thread.html#26947">Week #5</a></li> </ul> <h2 id="motivation"> <a href="#motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Motivation </h2> <p>This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing <code class="highlighter-rouge">UnsafeRawPointer</code>. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should do everything possible in the remaining time to improve the migration experience and encourage correct use of the memory model by introducing this low-risk additive API.</p> <p>Almost all APIs that use raw pointers need to pass or return a length associated with the raw memory buffer. It is obvious that providing a type that encapsulates a raw pointer with length would improve the safety and readability of all of these interfaces. It would also support automatic debug-mode bounds checking on each side of the interface.</p> <p>In the short time that users have been migrating code, I have already seen several cases that view raw memory as a collection of <code class="highlighter-rouge">UInt8</code> values. It is natural for the same type that encapsulates a raw pointer and length to also allow clients to view that memory as raw bytes without the need to explicitly bind the memory type each time memory is accessed. This would also improve performance in some cases that Ive encoutered by avoiding array copies. Lets call this new type <code class="highlighter-rouge">Unsafe[Mutable]RawBufferPointer</code>.</p> <p>Any array could be viewed as <code class="highlighter-rouge">UnsafeRawBufferPointer</code>, and that raw view of the bytes could be used by any interface that expects a collection of <code class="highlighter-rouge">UInt8</code>. An new array method <code class="highlighter-rouge">withUnsafeBytes</code> could expose this raw view of the array as a sequence of bytes as follows:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">intArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">var</span> <span class="nv">byteBuffer</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">]()</span>

<span class="n">intArray</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span>

  <span class="n">byteBuffer</span> <span class="o">+=</span> <span class="nv">$0</span>
  
  <span class="nf">assert</span><span class="p">(</span><span class="n">byteBuffer</span><span class="p">[</span><span class="mi">0</span><span class="o">..&lt;</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">assert</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">byteBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Any data type could be safely passed to APIs that work with raw memory via <code class="highlighter-rouge">UnsafeRawBufferPointer</code>, such as output streams and flat buffers. A new <code class="highlighter-rouge">withUnsafeBytes</code> function could view a value as a sequence of bytes as follows:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// imported struct Header</span>
<span class="kd">struct</span> <span class="kt">Header</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="k">var</span> <span class="nv">header</span> <span class="o">=</span> <span class="kt">Header</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="nf">withUnsafeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">write</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Data of any type could be loaded from raw memory that was constructed as an array of <code class="highlighter-rouge">UInt8</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">readHeader</span><span class="p">(</span><span class="n">fromBytes</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Header</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bytes</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Header</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">let</span> <span class="nv">header</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span>
  <span class="nf">readHeader</span><span class="p">(</span><span class="nv">fromBytes</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Foundation <code class="highlighter-rouge">Data</code> already provides high-level, safe encapsulation of raw memory and is the common currency for passing raw memory across framework boundaries. <code class="highlighter-rouge">Data</code> owns its underlying memory, provides value semantics, and performs release-mode bounds checks. The proposed <code class="highlighter-rouge">UnsafeRawBufferPointer</code> is an unowned view into an arbitrary slice of memory. Once <code class="highlighter-rouge">UnsafeRawBufferPointer</code> is in place, the <code class="highlighter-rouge">Data</code> API can be extended to more safely interoperate with <code class="highlighter-rouge">UnsafePointers</code>.</p> <h2 id="proposed-solution"> <a href="#proposed-solution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Proposed solution </h2> <p>Introduce <code class="highlighter-rouge">UnsafeRawBufferPointer</code> and <code class="highlighter-rouge">UnsafeMutableRawBufferPointer</code> types, which will respectively conform to <code class="highlighter-rouge">Collection</code> and <code class="highlighter-rouge">MutableCollection</code> of <code class="highlighter-rouge">UInt8</code>. These types will provide a debug-mode bounds-checked subset of <code class="highlighter-rouge">Unsafe[Mutable]RawPointer</code>s interface to raw memory: <code class="highlighter-rouge">load(fromByteOffset:as:)</code>, <code class="highlighter-rouge">storeBytes(of:toByteOffset:as:)</code>, and <code class="highlighter-rouge">copyBytes(from:count:)</code>.</p> <p>Please see the doc comments provided in <a href="#detailed-design">Detailed design</a>.</p> <p>Add an <code class="highlighter-rouge">Array.withUnsafe[Mutable]Bytes&lt;R&gt;(_)</code> method that passes an <code class="highlighter-rouge">UnsafeRawBufferPointer</code> view of the array buffer to the closure body.</p> <p>Add a <code class="highlighter-rouge">withUnsafeMutableBytes&lt;T, R&gt;(of:_)</code> function that passes an <code class="highlighter-rouge">UnsafeRawBufferPointer</code> view of a value of type <code class="highlighter-rouge">T</code> to the closure body.</p> <h2 id="amendment-to-normalize-the-slice-type"> <a href="#amendment-to-normalize-the-slice-type" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Amendment to normalize the slice type </h2> <p>The original version of this proposal defined <code class="highlighter-rouge">Unsafe[Mutable]BufferPointer</code> to be its own <code class="highlighter-rouge">SubSequence</code> type. This is the <code class="highlighter-rouge">Collection</code>s slice type returned by a range subscript getter. Using a single type for buffers and buffer slices is very convenient for working with flat memory regions, but it is inconsistent with Swifts <code class="highlighter-rouge">Collection</code> semantics. The problem is that it transparently rebases the slices <code class="highlighter-rouge">Int</code>-type indices to zero. This has the potential to break generic algorithms, which expect to use the same indices across both the original <code class="highlighter-rouge">Collection</code> and its slices.</p> <p>The amended version of this proposal changes <code class="highlighter-rouge">SubSequence</code> to <code class="highlighter-rouge">[Mutable]RandomAccessSlice&lt;Unsafe[Mutable]RawBufferPointer&gt;</code></p> <p><code class="highlighter-rouge">rebasing</code> initializers have been added to allow explicit conversion from a slice to a zero-based <code class="highlighter-rouge">Unsafe[Mutable]RawBufferPointer</code>.</p> <p>This results in the following behavioral changes:</p> <p>Passing a region within buffer to another function that takes a buffer can no longer be done via subscript:</p> <p>Incorrect: <code class="highlighter-rouge">takesRawBuffer(buffer[i..&lt;j])</code></p> <p>This now requires an explicit cast:</p> <p>Correct: <code class="highlighter-rouge">takesRawBuffer(UnsafeRawBufferPointer(rebasing: buffer[i..&lt;j]))</code></p> <p>Subscript assignment directly from a buffer no longer compiles:</p> <p>Incorrect: <code class="highlighter-rouge">buffer[n..&lt;m] = smaller_buffer</code></p> <p>This now requires creation of a slice from the complete source buffer:</p> <p>Correct: <code class="highlighter-rouge">buffer[n..&lt;m] = smaller_buffer.suffix(from: 0)</code></p> <p>UnsafeRawBufferPointers slice type no longer has a nonmutating subscript setter. So assigning into a mutable <code class="highlighter-rouge">let</code> buffer no longer compiles:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let slice = buffer[n..&lt;m]
slice[i..&lt;j] = buffer[k..&lt;l]
</code></pre></div></div> <p>The assigned buffer slice now needs to be a <code class="highlighter-rouge">var</code>.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var slice = buffer[n..&lt;m]
slice[i..&lt;j] = buffer[k..&lt;l]
</code></pre></div></div> <h2 id="migration-examples"> <a href="#migration-examples" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Migration Examples </h2> <p>Consider these real code migration examples:</p> <ul> <li>Network messages, see below.</li> <li>swift-package-manager/<a href="https://github.com/apple/swift-package-manager/blob/master/Sources/Basic/OutputByteStream.swift">OutputByteStream</a></li> <li><a href="https://github.com/mzaks/FlatBuffersSwift">mzaks/FlatBuffersSwift</a></li> <li><a href="https://github.com/owensd/json-swift/blob/master/src/JSValue.Parsing.swift">owensd/json-swift</a></li> </ul> <p>This is a small sample of projects that popped up during initial migration. As migration proceeds, more examples continue to surface that would benefit from <code class="highlighter-rouge">UnsafeRawBufferPointer</code>. Ideally, code that manages untyped memory buffers can now do so with Foundations <code class="highlighter-rouge">Data</code> API, avoiding unsafe code altogether. However, when code does drop down the level of <code class="highlighter-rouge">UnsafePointer</code>, it should be natural to use the unsafe APIs correctly. As these examples show, <code class="highlighter-rouge">UnsafeRawBufferPointer</code> makes it natural to use unsafe pointers correctly when dealing with raw bytes.</p> <h3 id="network-messages"> <a href="#network-messages" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Network Messages </h3> <p>This is a simplified example derived from production code encountered during migration.</p> <p>Originally, this code was reading and writing messages in a <code class="highlighter-rouge">UInt8</code> buffer, then recasting an <code class="highlighter-rouge">UnsafePointer</code> to other data types while decoding the message. This is undefined behavior, but was the most reasonable way to solve the problem given existing APIs. Without providing an alternative, developers are resorting to <code class="highlighter-rouge">unsafeBitCast</code> or <code class="highlighter-rouge">assumingMemoryBound</code> in these cases to force code to compile, which doesnt make the code any more correct.</p> <p>This is the code after forced migration, without fixing memory model issues:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Original Handler...</span>

<span class="k">var</span> <span class="nv">handler</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int32</span><span class="p">,</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="o">=</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">handleMessages</span><span class="p">(</span><span class="n">_</span> <span class="nv">start</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">start</span> <span class="o">=</span> <span class="n">start</span>
  <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="n">count</span>
  <span class="k">while</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">headerSize</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">let</span> <span class="nv">channelID</span> <span class="o">=</span>
      <span class="kt">Int32</span><span class="p">(</span><span class="nf">unsafeBitCast</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="n">pointee</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">payloadSize</span> <span class="o">=</span>
      <span class="kt">Int</span><span class="p">(</span><span class="nf">unsafeBitCast</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">),</span>
          <span class="nv">to</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="n">pointee</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">totalSize</span> <span class="o">=</span> <span class="n">headerSize</span> <span class="o">+</span> <span class="n">payloadSize</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">totalSize</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="nf">handler</span><span class="p">(</span><span class="n">channelID</span><span class="p">,</span>
      <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">UnsafeBufferPointer</span><span class="p">(</span>
        <span class="nv">start</span><span class="p">:</span> <span class="n">start</span><span class="o">.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">headerSize</span><span class="p">),</span> <span class="nv">count</span><span class="p">:</span> <span class="n">payloadSize</span><span class="p">)))</span>
    <span class="c1">// Advance to the start of the next packet.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">totalSize</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">-=</span> <span class="n">totalSize</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">count</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="highlighter-rouge">UnsafeRawBufferPointer</code> provides a convenient way to rewrite the handler and eliminate undefined behavior:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Updated Handler...</span>

<span class="c1">// imported struct Header</span>
<span class="kd">struct</span> <span class="kt">Header</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">channel</span><span class="p">:</span> <span class="kt">Int32</span>
  <span class="k">var</span> <span class="nv">payloadSize</span><span class="p">:</span> <span class="kt">Int32</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">handler</span><span class="p">:</span> <span class="p">(</span><span class="n">_</span> <span class="nv">channel</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="o">=</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">handleMessages</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">payloadIndex</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Header</span><span class="o">&gt;.</span><span class="n">stride</span>
    <span class="k">if</span> <span class="n">payloadIndex</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">header</span> <span class="o">=</span> <span class="n">bytes</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">Header</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">payloadIndex</span> <span class="o">+</span> <span class="kt">Int</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">payloadSize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="nf">handler</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">bytes</span><span class="p">[</span><span class="n">payloadIndex</span> <span class="o">..&lt;</span> <span class="n">index</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">index</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now consider the original code that calls this handler:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Original input driver...</span>

<span class="c1">// imported</span>
<span class="kd">func</span> <span class="nf">read</span><span class="p">(</span><span class="n">from</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">,</span> <span class="nv">n</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">read</span><span class="p">(</span><span class="n">from</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">data</span><span class="p">:</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">let</span> <span class="nv">tmpBufferSize</span> <span class="o">=</span> <span class="mi">4096</span>
  <span class="k">let</span> <span class="nv">tmp</span> <span class="o">=</span> <span class="kt">UnsafeMutableBufferPointer</span><span class="p">(</span>
    <span class="nv">start</span><span class="p">:</span> <span class="kt">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">tmpBufferSize</span><span class="p">),</span>
    <span class="nv">count</span><span class="p">:</span> <span class="n">tmpBufferSize</span><span class="p">)</span>
        
  <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">inputFD</span><span class="p">,</span> <span class="n">tmp</span><span class="o">.</span><span class="n">baseAddress</span><span class="p">,</span> <span class="n">tmpBufferSize</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="n">data</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span>
        <span class="nv">contentsOf</span><span class="p">:</span> <span class="kt">UnsafeBufferPointer</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">tmp</span><span class="o">.</span><span class="n">baseAddress</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span><span class="n">result</span><span class="p">))</span>
      <span class="k">let</span> <span class="nv">remaining</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withUnsafeBufferPointer</span> <span class="p">{</span> <span class="n">bufferPtr</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
        <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="nf">extractAndHandleMessages</span><span class="p">(</span>
          <span class="n">bufferPtr</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span>
          <span class="n">bufferPtr</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">remaining</span><span class="o">..&lt;</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">remaining</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="nf">extractAndHandleMessages</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">UnsafeBufferPointer</span><span class="p">(</span>
          <span class="nv">start</span><span class="p">:</span> <span class="n">tmp</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">result</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">),</span>
          <span class="nv">count</span><span class="p">:</span><span class="n">remaining</span><span class="p">))</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">tmp</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!.</span><span class="nf">deallocate</span><span class="p">(</span><span class="nv">capacity</span><span class="p">:</span> <span class="n">tmpBufferSize</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The input driver should now be written using <code class="highlighter-rouge">UnsafeRawBufferPointer</code> as follows:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Updated input driver...</span>

<span class="c1">// imported</span>
<span class="kd">func</span> <span class="nf">read</span><span class="p">(</span><span class="n">from</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">,</span> <span class="nv">n</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">read</span><span class="p">(</span><span class="n">from</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">tmpBuffer</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawBufferPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">4096</span><span class="p">)</span>
  <span class="k">defer</span> <span class="p">{</span> <span class="n">tmpBuffer</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">()</span> <span class="p">}</span>

  <span class="k">let</span> <span class="nv">basePtr</span> <span class="o">=</span> <span class="n">tmpBuffer</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span>
  <span class="k">var</span> <span class="nv">position</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">basePtr</span> <span class="o">+</span> <span class="n">position</span><span class="p">,</span> <span class="n">tmpBuffer</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">position</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">FileError</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">dataBytes</span> <span class="o">=</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">(</span><span class="n">tmpBuffer</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="nv">upTo</span><span class="p">:</span> <span class="n">position</span> <span class="o">+</span> <span class="n">result</span><span class="p">))</span>
    <span class="k">let</span> <span class="nv">remaining</span> <span class="o">=</span> <span class="nf">handleMessages</span><span class="p">(</span><span class="n">dataBytes</span><span class="p">)</span>

    <span class="n">tmpBuffer</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">dataBytes</span><span class="o">.</span><span class="nf">suffix</span><span class="p">(</span><span class="n">remaining</span><span class="p">))</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">remaining</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>On the sender side, the original post-migration code is:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Original message send...</span>

<span class="c1">// imported</span>
<span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="n">from</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">,</span> <span class="nv">n</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">int32ToArray</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">UnsafeBufferPointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">start</span><span class="p">:</span> <span class="nf">unsafeBitCast</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;.</span><span class="k">self</span><span class="p">),</span>
    <span class="nv">count</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int32</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="n">_</span> <span class="nv">channel</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="n">_</span> <span class="nv">message</span><span class="p">:</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">])</span> <span class="k">throws</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">channel</span> <span class="o">=</span> <span class="n">channel</span>
  <span class="k">var</span> <span class="nv">length</span> <span class="o">=</span> <span class="kt">Int32</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">header</span> <span class="o">=</span> <span class="nf">int32ToArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">)</span> <span class="o">+</span> <span class="nf">int32ToArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">length</span><span class="p">)</span>
  <span class="n">header</span><span class="o">.</span><span class="n">withUnsafeBufferPointer</span> <span class="p">{</span> <span class="n">ptr</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">outputFD</span><span class="p">,</span> <span class="n">ptr</span><span class="o">.</span><span class="n">baseAddress</span><span class="p">,</span> <span class="n">ptr</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">FileError</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">message</span><span class="o">.</span><span class="n">withUnsafeBufferPointer</span> <span class="p">{</span> <span class="n">ptr</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">outputFD</span><span class="p">,</span> <span class="n">ptr</span><span class="o">.</span><span class="n">baseAddress</span><span class="p">,</span> <span class="n">ptr</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">FileError</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>With <code class="highlighter-rouge">UnsafeRawBufferPointer</code>, the sender code can be written as follows:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Updated message send...</span>

<span class="c1">// imported</span>
<span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="n">from</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="nv">p</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">,</span> <span class="nv">n</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="n">to</span> <span class="nv">fd</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="n">onChannel</span> <span class="nv">channel</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">,</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">header</span> <span class="o">=</span> <span class="kt">Header</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span> <span class="nv">payloadSize</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
  <span class="k">try</span> <span class="nf">withUnsafeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="nv">$0</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span> <span class="nv">$0</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">FileError</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">FileError</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="swift-package-manager-outputbytestream"> <a href="#swift-package-manager-outputbytestream" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> swift-package-manager OutputByteStream </h3> <p><code class="highlighter-rouge">UnsafeRawBufferPointer</code> is a useful tool for composing APIs like Swift package managers OutputByteStream which needs to operate on raw memory independent of the type, and also needs to view that data as an array of bytes.</p> <p>Consider this current limitation of the OutputStream API:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">LocalFileOutputStream</span> <span class="p">{</span>
  <span class="k">override</span> <span class="kd">final</span> <span class="kd">func</span> <span class="n">writeImpl</span><span class="o">&lt;</span><span class="kt">C</span><span class="p">:</span> <span class="kt">Collection</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">C</span><span class="p">)</span>
    <span class="k">where</span> <span class="kt">C</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt8</span> <span class="p">{</span>

    <span class="c1">// FIXME: This will be copying bytes but we don't have option currently.</span>
    <span class="k">var</span> <span class="nv">contents</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">](</span><span class="n">bytes</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">n</span> <span class="o">=</span> <span class="nf">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contents</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">contents</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
</code></pre></div></div> <p>Instead, <code class="highlighter-rouge">UnsafeRawBufferPointer</code> should be the common type for data handoff in the base class:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">OutputByteStream</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">writeImpl</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Without claiming this is the best architecture for this utility, we can claim that the author should be able to implement the architecture they have chosen correctly and without unnecessary overhead. Moving to <code class="highlighter-rouge">UnsafeRawBufferPointer</code> fixes three design issues in this code that stem from inadequate support for raw memory.</p> <p>Fix #1: The public API of a high-performance utility no longer depends on a generic type conforming to a protocol. There was no reason for this utility to care about the type being streamed, so this was a significant unnecessary overhead.</p> <p>Fix #2: The <code class="highlighter-rouge">LocalFileOutputStream</code> subclass can now directly access the bytes without copying into an array:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">LocalFileOutputStream</span> <span class="p">{</span>
  <span class="k">override</span> <span class="kd">final</span> <span class="kd">func</span> <span class="nf">writeImpl</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Cast to a mutating raw pointer for legacy libc interop.</span>
    <span class="k">let</span> <span class="nv">ptr</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="nv">mutating</span><span class="p">:</span> <span class="n">bytes</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">n</span> <span class="o">=</span> <span class="nf">fwrite</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">contents</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
      <span class="o">...</span>
</code></pre></div></div> <p>The <code class="highlighter-rouge">BufferedOutputByteStream</code> subclass can continue working with a collection of bytes, so theres no loss in functionality:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">BufferedOutputByteStream</span><span class="p">:</span> <span class="kt">OutputByteStream</span> <span class="p">{</span>
    <span class="c1">// FIXME: For inmemory implementation we should be share this buffer with OutputByteStream.</span>
    <span class="c1">// One way to do this is by allowing OuputByteStream to install external buffers.</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">contents</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">]()</span>

  <span class="k">override</span> <span class="kd">final</span> <span class="kd">func</span> <span class="nf">writeImpl</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">contents</span> <span class="o">+=</span> <span class="n">bytes</span>
  <span class="p">}</span>
</code></pre></div></div> <p>Fix #3: <code class="highlighter-rouge">OutputByteStream</code> can be naturally redesigned as follows to directly access a buffer of raw memory, which is already bounds checked and never needs to grow. A subclass like <code class="highlighter-rouge">BufferedOutputByteStream</code> can continue to manage its buffer as an array. There are no extra copies or impedance mismatch between base class and subclass:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">OutputByteStream</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">buffer</span><span class="p">:</span> <span class="kt">UnsafeMutableRawBufferPointer</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">position</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="k">var</span> <span class="nv">bufferedBytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">(</span><span class="n">buffer</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="nv">upTo</span><span class="p">:</span> <span class="n">position</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">availableBufferSize</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">position</span>
  <span class="p">}</span>

  <span class="kd">class</span> <span class="k">var</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1024</span> <span class="p">}</span>

  <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="kt">UnsafeMutableRawBufferPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="nf">type</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="n">bufferSize</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">deinit</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="kd">private</span> <span class="kd">func</span> <span class="nf">appendToBuffer</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">position</span> <span class="o">..&lt;</span> <span class="n">position</span> <span class="o">+</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">bytes</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">+=</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">writeImpl</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Subclasses must implement this"</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="kd">final</span> <span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">availableBufferSize</span> <span class="p">{</span>
      <span class="nf">appendToBuffer</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="nv">upTo</span><span class="p">:</span> <span class="n">availableBufferSize</span><span class="p">))</span>
      <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span>
  <span class="p">}</span>

  <span class="c1">/// Write a sequence of bytes to the buffer.</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">ArraySlice</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bytes</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span>
      <span class="nf">write</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">/// Write a sequence of bytes to the buffer.</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">bytes</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span>
      <span class="nf">write</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// In-memory implementation of OutputByteStream.</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">BufferedOutputByteStream</span><span class="p">:</span> <span class="kt">OutputByteStream</span> <span class="p">{</span>

  <span class="c1">/// Default buffer size of the data buffer.</span>
  <span class="k">override</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

  <span class="c1">/// Contents of the stream.</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">contents</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UInt8</span><span class="p">]()</span>

  <span class="k">override</span> <span class="kd">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">override</span> <span class="kd">final</span> <span class="kd">func</span> <span class="nf">writeImpl</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">contents</span> <span class="o">+=</span> <span class="n">bytes</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="flatbuffers"> <a href="#flatbuffers" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> FlatBuffers </h3> <p>Using <code class="highlighter-rouge">UnsafeRawBufferPointer</code>, the code for <a href="https://github.com/mzaks/FlatBuffersSwift/blob/master/FlatBuffersSwift/FlatBufferBuilder.swift#L88">putting a value</a> can be correctly expressed using <code class="highlighter-rouge">UnsafeRawBufferPointer</code> without binding memory:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">FlatBufferBuilder</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">_data</span> <span class="p">:</span> <span class="kt">UnsafeMutableRawBufferPointer</span>
  <span class="k">var</span> <span class="nv">cursor</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// ignore left/right cursor for brevity.</span>
  
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">freeSpace</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_data</span><span class="o">.</span><span class="nf">suffix</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">}</span>

  <span class="kd">public</span> <span class="kd">func</span> <span class="n">put</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">v</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">size</span>
    <span class="nf">increaseCapacity</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1">// ... and align</span>
    <span class="nf">withUnsafeBytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">freeSpace</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="nv">$0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">cursor</span> <span class="o">+=</span> <span class="n">c</span>
  <span class="p">}</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="n">put</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">increaseCapacity</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">ptr</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span> <span class="o">+</span> <span class="n">cursor</span>
    <span class="n">freeSpace</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">length</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">+=</span> <span class="n">length</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://github.com/mzaks/FlatBuffersSwift/blob/master/FlatBuffersSwift/FlatBufferReader.swift">FlatBufferReader</a> can also be fixed with <code class="highlighter-rouge">UnsafeRawBufferPointer</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">FlatBufferReader</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">_data</span> <span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span>

  <span class="kd">func</span> <span class="n">fromBytes</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span> <span class="nv">position</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_data</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="n">position</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="k">get</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">objectOffset</span><span class="p">:</span> <span class="kt">Offset</span><span class="p">,</span> <span class="nv">propertyIndex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">propertyOffset</span> <span class="o">=</span> <span class="nf">getPropertyOffset</span><span class="p">(</span><span class="n">propertyIndex</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">position</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">objectOffset</span> <span class="o">+</span> <span class="n">propertyOffset</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">fromBytes</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">position</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="owensdjson-swift"> <a href="#owensdjson-swift" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> owensd/json-swift </h3> <p>This JSON parsing library can accept <code class="highlighter-rouge">struct Data</code> input <a href="https://github.com/owensd/json-swift/blob/master/src/JSValue.Parsing.swift#L23">here</a>. It then passes the bytes in data to a lower-level <code class="highlighter-rouge">parse</code> routine that operates directly on UnsafeBufferPointer<UInt8>. (The library accepts various input sources, including NSData and String, then drops down to unsafe pointer to avoid copying). During 3.0 migration, a call to `bindMemory(to:count:)` would need to be introduced to make it safe to reinterpret memory as `UInt8`:</UInt8></p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">JSParsingSequence</span> <span class="o">=</span> <span class="kt">UnsafeBufferPointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">seq</span><span class="p">:</span> <span class="kt">JSParsingSequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">JSParsingResult</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">JSParsingResult</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="k">as</span> <span class="kt">NSData</span><span class="p">)</span><span class="o">.</span><span class="n">bytes</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">bytes</span> <span class="o">=</span> <span class="kt">UnsafeBufferPointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">ptr</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

  <span class="k">return</span> <span class="nf">parse</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>This requires the developer to understand how the memory binding APIs work, which is unreasonable for normal interaction with <code class="highlighter-rouge">Data</code>. It also uses a deprecated interface to <code class="highlighter-rouge">Data</code> and has a lifetime bug. Getting <code class="highlighter-rouge">bytes</code> out of <code class="highlighter-rouge">Data</code> should now be done using <code class="highlighter-rouge">withUnsafeBytes</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="n">_</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeBufferPointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span> <span class="k">in</span>
    <span class="nf">parse</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This now implicitly binds memory, which is a big improvement. However, there is no reason that the parsers view of memory needs to to be typed as <code class="highlighter-rouge">UnsafeBufferPointer&lt;UInt8&gt;</code>. The JSON parser should operate on an <code class="highlighter-rouge">UnsafeRawBufferPointer</code> sequence, eliminating the need to bind memory at all. Once the <code class="highlighter-rouge">Data</code> interface is extended to support calling closures that take <code class="highlighter-rouge">UnsafeRawBufferPointer</code>, it will be possible to write a safer version of the code that completely avoids binding memory:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">JSParsingSequence</span> <span class="o">=</span> <span class="kt">UnsafeRawBufferPointer</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">NSData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">JSParsingResult</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span> <span class="k">in</span>
    <span class="nf">parse</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="detailed-design"> <a href="#detailed-design" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Detailed design </h2> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="k">for</span> <span class="n">mutable</span> <span class="nf">in</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">):</span>
<span class="o">%</span>  <span class="k">Self</span> <span class="o">=</span> <span class="err">'</span><span class="kt">UnsafeMutableRawBufferPointer</span><span class="err">'</span> <span class="k">if</span> <span class="n">mutable</span> <span class="k">else</span> <span class="err">'</span><span class="kt">UnsafeRawBufferPointer</span><span class="err">'</span>
<span class="o">%</span>  <span class="kt">Mutable</span> <span class="o">=</span> <span class="err">'</span><span class="kt">Mutable</span><span class="err">'</span> <span class="k">if</span> <span class="n">mutable</span> <span class="k">else</span> <span class="err">''</span>

<span class="c1">/// A non-owning view over a region of memory as a Collection of bytes</span>
<span class="c1">/// independent of the type of values held in that memory. Each 8-bit byte in</span>
<span class="c1">/// memory is viewed as a `UInt8` value.</span>
<span class="c1">///</span>
<span class="c1">/// Reads and writes on memory via `UnsafeRawBufferPointer` are untyped</span>
<span class="c1">/// operations. Accessing this Collection's bytes does not bind the</span>
<span class="c1">/// underlying memory to `UInt8`. The underlying memory must be bound</span>
<span class="c1">/// to some trivial type whenever it is accessed via a typed operation.</span>
<span class="c1">///</span>
<span class="c1">/// - Note: A trivial type can be copied with just a bit-for-bit</span>
<span class="c1">///   copy without any indirection or reference-counting operations.</span>
<span class="c1">///   Generally, native Swift types that do not contain strong or</span>
<span class="c1">///   weak references or other forms of indirection are trivial, as</span>
<span class="c1">///   are imported C structs and enums.</span>
<span class="c1">///</span>
<span class="c1">/// In addition to the `Collection` interface, the following subset of</span>
<span class="c1">/// `Unsafe${Mutable}RawPointer`'s interface to raw memory is</span>
<span class="c1">/// provided with debug mode bounds checks:</span>
<span class="c1">/// - `load(fromByteOffset:as:)`,</span>
<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
<span class="c1">/// - `storeBytes(of:toByteOffset:as:)`</span>
<span class="c1">/// - `copyBytes(from:count:)`</span>
<span class="o">%</span>  <span class="n">end</span>
<span class="c1">///</span>
<span class="c1">/// This is only a view into memory and does not own the memory. Copying a value</span>
<span class="c1">/// of type `Unsafe${Mutable}RawBufferPointer` does not copy the underlying</span>
<span class="c1">/// memory. However, initialiing another collection, such as `[UInt8]`, with an</span>
<span class="c1">/// `Unsafe${Mutable}RawBufferPointer` into copies bytes out of memory.</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ```swift</span>
<span class="c1">///   // View a slice of memory at someBytes. Nothing is copied.</span>
<span class="c1">///   var destBytes = someBytes[0..&lt;n]</span>
<span class="c1">///</span>
<span class="c1">///   // Copy the slice of memory into a buffer of UInt8.</span>
<span class="c1">///   var byteArray = [UInt8](destBytes)</span>
<span class="c1">///</span>
<span class="c1">///   // Copy another slice of memory into the buffer.</span>
<span class="c1">///   byteArray += someBytes[n..&lt;m]</span>
<span class="c1">/// ```</span>
<span class="c1">///</span>
<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
<span class="c1">/// And assigning into a range of subscripts copies bytes into the memory.</span>
<span class="c1">///</span>
<span class="c1">/// Example (continued):</span>
<span class="c1">/// ```swift</span>
<span class="c1">///   // Copy a another slice of memory back into the original slice.</span>
<span class="c1">///   destBytes[0..&lt;n] = someBytes[m..&lt;(m+n)]</span>
<span class="c1">/// ```</span>
<span class="c1">///</span>
<span class="o">%</span>  <span class="n">end</span>
<span class="c1">/// TODO: Specialize `index` and `formIndex` and</span>
<span class="c1">/// `_failEarlyRangeCheck` as in `UnsafeBufferPointer`.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawBufferPointer</span>
  <span class="p">:</span> <span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">Collection</span><span class="p">,</span> <span class="kt">RandomAccessCollection</span> <span class="p">{</span>

  <span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">Index</span> <span class="o">=</span> <span class="kt">Int</span>
  <span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">IndexDistance</span> <span class="o">=</span> <span class="kt">Int</span>
  <span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">SubSequence</span> <span class="o">=</span>
    <span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RandomAccessSlice</span><span class="o">&lt;</span><span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawBufferPointer</span><span class="o">&gt;</span>

  <span class="c1">/// An iterator for the bytes referenced by `${Self}`.</span>
  <span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Iterator</span> <span class="p">:</span> <span class="kt">IteratorProtocol</span><span class="p">,</span> <span class="kt">Sequence</span> <span class="p">{</span>

    <span class="c1">/// Advances to the next byte and returns it, or `nil` if no next byte</span>
    <span class="c1">/// exists.</span>
    <span class="c1">///</span>
    <span class="c1">/// Once `nil` has been returned, all subsequent calls return `nil`.</span>
    <span class="kd">public</span> <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">_position</span> <span class="o">==</span> <span class="n">_end</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
      
      <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">_position</span><span class="o">!.</span><span class="nf">load</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
      <span class="n">_position</span><span class="o">!</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>

    <span class="kd">internal</span> <span class="k">var</span> <span class="nv">_position</span><span class="p">,</span> <span class="nv">_end</span><span class="p">:</span> <span class="kt">UnsafeRawPointer</span><span class="p">?</span>
  <span class="p">}</span>

<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
  <span class="c1">/// Allocate memory for `size` bytes with word alignment.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Postcondition: The memory is allocated, but not initialized.</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">count</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnsafeMutableRawBufferPointer</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">UnsafeMutableRawBufferPointer</span><span class="p">(</span>
      <span class="nv">start</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="o">.</span><span class="nf">allocate</span><span class="p">(</span>
        <span class="nv">bytes</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">UInt</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">),</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="n">mutable</span>

  <span class="c1">/// Deallocate this memory allocated for `bytes` number of bytes.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The memory is not initialized.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Postcondition: The memory has been deallocated.</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">deallocate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_position</span><span class="p">?</span><span class="o">.</span><span class="nf">deallocate</span><span class="p">(</span>
      <span class="nv">bytes</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="nv">alignedTo</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">UInt</span><span class="o">&gt;.</span><span class="n">alignment</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">/// Reads raw bytes from memory at `self + offset` and constructs a</span>
  <span class="c1">/// value of type `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `offset + MemoryLayout&lt;T&gt;.size &lt; self.count`</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The underlying pointer plus `offset` is properly</span>
  <span class="c1">///   aligned for accessing `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The memory is initialized to a value of some type, `U`,</span>
  <span class="c1">///   such that `T` is layout compatible with `U`.</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="n">load</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fromByteOffset</span> <span class="nv">offset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">as</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
    <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"${Self}.load with negative offset"</span><span class="p">)</span>
    <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
      <span class="s">"${Self}.load out of bounds"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">baseAddress</span><span class="o">!.</span><span class="nf">load</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="p">}</span>

<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
  <span class="c1">/// Stores a value's bytes into raw memory at `self + offset`.</span>
  <span class="c1">///  </span>
  <span class="c1">/// - Precondition: `offset + MemoryLayout&lt;T&gt;.size &lt; self.count`</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The underlying pointer plus `offset` is properly</span>
  <span class="c1">///   aligned for storing type `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `T` is a trivial type.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The memory is uninitialized, or initialized to</span>
  <span class="c1">///   some trivial type `U` such that `T` and `U` are mutually layout</span>
  <span class="c1">///   compatible.</span>
  <span class="c1">/// </span>
  <span class="c1">/// - Postcondition: The memory is initialized to raw bytes. If the</span>
  <span class="c1">///   memory is bound to type `U`, then it now contains a value of</span>
  <span class="c1">///   type `U`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Note: A trivial type can be copied with just a bit-for-bit</span>
  <span class="c1">///   copy without any indirection or reference-counting operations.</span>
  <span class="c1">///   Generally, native Swift types that do not contain strong or</span>
  <span class="c1">///   weak references or other forms of indirection are trivial, as</span>
  <span class="c1">///   are imported C structs and enums.</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="n">storeBytes</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">of</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="n">toByteOffset</span> <span class="nv">offset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"${Self}.storeBytes with negative offset"</span><span class="p">)</span>
    <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
      <span class="s">"${Self}.storeBytes out of bounds"</span><span class="p">)</span>

    <span class="n">baseAddress</span><span class="o">!.</span><span class="nf">storeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="nv">toByteOffset</span><span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">/// Copies `count` bytes from `source` into memory at `self`.</span>
  <span class="c1">///  </span>
  <span class="c1">/// - Precondition: `count` is non-negative.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: The memory at `source..&lt;source + count` is</span>
  <span class="c1">///   initialized to some trivial type `T`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: If the memory at `self..&lt;self+count` is bound to</span>
  <span class="c1">///   a type `U`, then `U` is a trivial type, the underlying</span>
  <span class="c1">///   pointers `source` and `self` are properly aligned for type</span>
  <span class="c1">///   `U`, and `count` is a multiple of `MemoryLayout&lt;U&gt;.stride`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Postcondition: The memory at `self..&lt;self+count` is</span>
  <span class="c1">///   initialized to raw bytes. If the memory is bound to type `U`,</span>
  <span class="c1">///   then it contains values of type `U`.</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">copyBytes</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
      <span class="s">"${Self}.copyBytes source has too many elements"</span><span class="p">)</span>
    <span class="n">baseAddress</span><span class="p">?</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="kd">func</span> <span class="n">copyBytes</span><span class="o">&lt;</span><span class="kt">C</span> <span class="p">:</span> <span class="kt">Collection</span><span class="o">&gt;</span><span class="p">(</span><span class="n">from</span> <span class="nv">source</span><span class="p">:</span> <span class="kt">C</span>
  <span class="p">)</span> <span class="k">where</span> <span class="kt">C</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt8</span> <span class="p">{</span>
    <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="nf">numericCast</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
      <span class="s">"${Self}.copyBytes source has too many elements"</span><span class="p">)</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">position</span> <span class="o">=</span> <span class="n">_position</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">byteValue</span><span class="p">)</span> <span class="k">in</span> <span class="n">source</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">position</span><span class="o">.</span><span class="nf">storeBytes</span><span class="p">(</span>
        <span class="nv">of</span><span class="p">:</span> <span class="n">byteValue</span><span class="p">,</span> <span class="nv">toByteOffset</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="n">mutable</span>

  <span class="c1">/// Creates `${Self}` over the `count` contiguous bytes beginning at `start`.</span>
  <span class="c1">///</span>
  <span class="c1">/// If `start` is nil, `count` must be 0. However, `count` may be 0 even for</span>
  <span class="c1">/// a nonzero `start`.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawPointer</span><span class="p">?,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">_precondition</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"${Self} with negative count"</span><span class="p">)</span>
    <span class="nf">_precondition</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">start</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span>
      <span class="s">"${Self} has a nil start and nonzero count"</span><span class="p">)</span>
    <span class="n">_position</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">_end</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="n">count</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// Creates `${Self}` over the contiguous bytes in `buffer`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `T` is a trivial type.</span>
  <span class="kd">public</span> <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">buffer</span><span class="p">:</span> <span class="kt">UnsafeMutableBufferPointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">buffer</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">buffer</span><span class="o">.</span><span class="n">count</span> <span class="o">*</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">)</span>
  <span class="p">}</span>

<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
  <span class="c1">/// Converts UnsafeRawBufferPointer to UnsafeMutableRawBufferPointer.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="k">mutating</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="nv">mutating</span><span class="p">:</span> <span class="n">bytes</span><span class="o">.</span><span class="n">baseAddress</span><span class="p">),</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>
<span class="o">%</span>  <span class="nv">else</span><span class="p">:</span>
  <span class="c1">/// Converts UnsafeMutableRawBufferPointer to UnsafeRawBufferPointer.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">bytes</span><span class="p">:</span> <span class="kt">UnsafeMutableRawBufferPointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">bytes</span><span class="o">.</span><span class="n">baseAddress</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">bytes</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">/// Creates an `${Self}` view over the contiguous memory in `buffer`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `T` is a trivial type.</span>
  <span class="kd">public</span> <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">buffer</span><span class="p">:</span> <span class="kt">UnsafeBufferPointer</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="kt">UnsafeMutableRawPointer</span><span class="p">(</span><span class="nv">mutating</span><span class="p">:</span> <span class="n">buffer</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">),</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">buffer</span><span class="o">.</span><span class="n">count</span> <span class="o">*</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">)</span>
  <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="o">!</span><span class="n">mutable</span>

<span class="o">%</span>  <span class="k">if</span> <span class="n">not</span> <span class="nv">mutable</span><span class="p">:</span>
  <span class="c1">/// Creates a raw buffer over the same memory as the given raw buffer slice.</span>
  <span class="c1">///</span>
  <span class="c1">/// The new raw buffer will represent the same region of memory as the slice,</span>
  <span class="c1">/// but it's indices will be rebased to zero. Given:</span>
  <span class="c1">///</span>
  <span class="c1">///   let slice = buffer[n..&lt;m]</span>
  <span class="c1">///   let rebased = UnsafeRawBufferPointer(rebasing: slice)</span>
  <span class="c1">///</span>
  <span class="c1">/// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter slice: the raw buffer slice to rebase.</span>
  <span class="kd">@_inlineable</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">rebasing</span> <span class="nv">slice</span><span class="p">:</span> <span class="kt">RandomAccessSlice</span><span class="o">&lt;</span><span class="kt">UnsafeRawBufferPointer</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span> <span class="o">+</span> <span class="n">slice</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="o">!</span><span class="n">mutable</span>

  <span class="c1">/// Creates a raw buffer over the same memory as the given raw buffer slice.</span>
  <span class="c1">///</span>
  <span class="c1">/// The new raw buffer will represent the same region of memory as the slice,</span>
  <span class="c1">/// but it's indices will be rebased to zero. Given:</span>
  <span class="c1">///</span>
  <span class="c1">///   let slice = buffer[n..&lt;m]</span>
  <span class="c1">///   let rebased = UnsafeRawBufferPointer(rebasing: slice)</span>
  <span class="c1">///</span>
  <span class="c1">/// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter slice: the raw buffer slice to rebase.</span>
  <span class="kd">@_inlineable</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span>
    <span class="n">rebasing</span> <span class="nv">slice</span><span class="p">:</span> <span class="kt">MutableRandomAccessSlice</span><span class="o">&lt;</span><span class="kt">UnsafeMutableRawBufferPointer</span><span class="o">&gt;</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span> <span class="o">+</span> <span class="n">slice</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">/// Always zero, which is the index of the first byte in a</span>
  <span class="c1">/// non-empty buffer.</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">startIndex</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="c1">/// The "past the end" position---that is, the position one greater than the</span>
  <span class="c1">/// last valid subscript argument.</span>
  <span class="c1">///</span>
  <span class="c1">/// The `endIndex` property of an `Unsafe${Mutable}RawBufferPointer` instance is</span>
  <span class="c1">/// always identical to `count`.</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">endIndex</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">count</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">Indices</span> <span class="o">=</span> <span class="kt">CountableRange</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>

  <span class="kd">public</span> <span class="k">var</span> <span class="nv">indices</span><span class="p">:</span> <span class="kt">Indices</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">startIndex</span><span class="o">..&lt;</span><span class="n">endIndex</span>
  <span class="p">}</span>

  <span class="c1">/// Accesses the `i`th byte in the memory region as a `UInt8` value.</span>
  <span class="kd">public</span> <span class="nf">subscript</span><span class="p">(</span><span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">endIndex</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">_position</span><span class="o">!.</span><span class="nf">load</span><span class="p">(</span><span class="nv">fromByteOffset</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
    <span class="k">nonmutating</span> <span class="k">set</span> <span class="p">{</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">endIndex</span><span class="p">)</span>
      <span class="n">_position</span><span class="o">!.</span><span class="nf">storeBytes</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">newValue</span><span class="p">,</span> <span class="nv">toByteOffset</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="n">mutable</span>
  <span class="p">}</span>

  <span class="c1">/// Accesses the bytes in the memory region within `bounds` as a `UInt8`</span>
  <span class="c1">/// values.</span>
  <span class="kd">public</span> <span class="nf">subscript</span><span class="p">(</span><span class="nv">bounds</span><span class="p">:</span> <span class="kt">Range</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RandomAccessSlice</span><span class="o">&lt;</span><span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawBufferPointer</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">&gt;=</span> <span class="n">startIndex</span><span class="p">)</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">&lt;=</span> <span class="n">endIndex</span><span class="p">)</span>
      <span class="k">return</span> <span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RandomAccessSlice</span><span class="p">(</span><span class="nv">base</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">bounds</span><span class="p">:</span> <span class="n">bounds</span><span class="p">)</span>
    <span class="p">}</span>
<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
    <span class="k">nonmutating</span> <span class="k">set</span> <span class="p">{</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">&gt;=</span> <span class="n">startIndex</span><span class="p">)</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">&lt;=</span> <span class="n">endIndex</span><span class="p">)</span>
      <span class="nf">_debugPrecondition</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="n">newValue</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">newValue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">baseAddress</span><span class="o">!</span> <span class="o">+</span> <span class="n">bounds</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">)</span><span class="o">.</span><span class="nf">copyBytes</span><span class="p">(</span>
          <span class="nv">from</span><span class="p">:</span> <span class="n">newValue</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span><span class="p">,</span>
          <span class="nv">count</span><span class="p">:</span> <span class="n">newValue</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="n">mutable</span>
  <span class="p">}</span>

  <span class="c1">/// Returns an iterator over the bytes of this sequence.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Complexity: O(1).</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">makeIterator</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Iterator</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Iterator</span><span class="p">(</span><span class="nv">_position</span><span class="p">:</span> <span class="n">_position</span><span class="p">,</span> <span class="nv">_end</span><span class="p">:</span> <span class="n">_end</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">/// A pointer to the first byte of the buffer.</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">baseAddress</span><span class="p">:</span> <span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawPointer</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_position</span>
  <span class="p">}</span>

  <span class="c1">/// The number of bytes in the buffer.</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">pos</span> <span class="o">=</span> <span class="n">_position</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">_end</span><span class="o">!</span> <span class="o">-</span> <span class="n">pos</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="nv">_position</span><span class="p">,</span> <span class="nv">_end</span><span class="p">:</span> <span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawPointer</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">RawBufferPointer</span> <span class="p">:</span> <span class="kt">CustomDebugStringConvertible</span> <span class="p">{</span>
  <span class="c1">/// A textual representation of `self`, suitable for debugging.</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">debugDescription</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"${Self}"</span>
      <span class="o">+</span> <span class="s">"(start: </span><span class="se">\(</span><span class="n">_position</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">describing</span><span class="p">:))</span> <span class="p">??</span> <span class="s">"nil"</span><span class="se">)</span><span class="s">, count: </span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">)"</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// Invokes `body` with an `${Self}` argument and returns the</span>
<span class="c1">/// result.</span>
<span class="o">%</span>  <span class="k">if</span> <span class="nv">mutable</span><span class="p">:</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="n">withUnsafeMutableBytes</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">Result</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">arg</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">T</span><span class="p">,</span>
  <span class="n">_</span> <span class="nv">body</span><span class="p">:</span> <span class="p">(</span><span class="kt">UnsafeMutableRawBufferPointer</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Result</span>
<span class="p">)</span> <span class="k">rethrows</span> <span class="o">-&gt;</span> <span class="kt">Result</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">try</span> <span class="nf">withUnsafeMutablePointer</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">try</span> <span class="nf">body</span><span class="p">(</span><span class="kt">UnsafeMutableRawBufferPointer</span><span class="p">(</span>
        <span class="nv">start</span><span class="p">:</span> <span class="nv">$0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">%</span>  <span class="nv">else</span><span class="p">:</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="n">withUnsafeBytes</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">Result</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">arg</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">T</span><span class="p">,</span>
  <span class="n">_</span> <span class="nv">body</span><span class="p">:</span> <span class="p">(</span><span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Result</span>
<span class="p">)</span> <span class="k">rethrows</span> <span class="o">-&gt;</span> <span class="kt">Result</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">try</span> <span class="nf">withUnsafePointer</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="nf">body</span><span class="p">(</span><span class="kt">UnsafeRawBufferPointer</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="nv">$0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="n">mutable</span>

<span class="o">%</span> <span class="n">end</span> <span class="err">#</span> <span class="k">for</span> <span class="n">mutable</span>

<span class="o">%</span> <span class="k">for</span> <span class="k">Self</span> <span class="k">in</span> <span class="p">[</span><span class="err">'</span><span class="kt">ContiguousArray</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="kt">ArraySlice</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="kt">Array</span><span class="err">'</span><span class="p">]:</span>

<span class="kd">extension</span> <span class="err">$</span><span class="p">{</span><span class="k">Self</span><span class="p">}</span> <span class="p">{</span>
  <span class="c1">/// Calls a closure with a view of the array's underlying bytes of memory as a</span>
  <span class="c1">/// Collection of `UInt8`.</span>
  <span class="c1">/// ${contiguousCaveat}</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `Pointee` is a trivial type.</span>
  <span class="c1">///</span>
  <span class="c1">/// The following example shows how you copy bytes into an array:</span>
  <span class="c1">///</span>
  <span class="c1">///    var numbers = [Int32](repeating: 0, count: 2)</span>
  <span class="c1">///    var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]</span>
  <span class="c1">///    numbers.withUnsafeMutableBytes { destBytes in</span>
  <span class="c1">///      byteValues.withUnsafeBytes { srcBytes in</span>
  <span class="c1">///        destBytes.copyBytes(from: srcBytes)</span>
  <span class="c1">///      }</span>
  <span class="c1">///    }</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter that points to</span>
  <span class="c1">/// the contiguous storage for the array. If `body` has a return value, it is</span>
  <span class="c1">/// used as the return value for the `withUnsafeBytes(_:)` method. The</span>
  <span class="c1">/// argument is valid only for the duration of the closure's execution.</span>
  <span class="c1">/// - Returns: The return value of the `body` closure parameter, if any.</span>
  <span class="c1">///</span>
  <span class="c1">/// - SeeAlso: `withUnsafeBytes`, `UnsafeRawBufferPointer`</span>
  <span class="kd">public</span> <span class="k">mutating</span> <span class="kd">func</span> <span class="n">withUnsafeMutableBytes</span><span class="o">&lt;</span><span class="kt">R</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">body</span><span class="p">:</span> <span class="p">(</span><span class="kt">UnsafeMutableRawBufferPointer</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">R</span>
  <span class="p">)</span> <span class="k">rethrows</span> <span class="o">-&gt;</span> <span class="kt">R</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">try</span> <span class="k">self</span><span class="o">.</span><span class="n">withUnsafeMutableBufferPointer</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">try</span> <span class="nf">body</span><span class="p">(</span><span class="kt">UnsafeMutableRawBufferPointer</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// Calls a closure with a view of the array's underlying bytes of memory as a</span>
  <span class="c1">/// Collection of `UInt8`.</span>
  <span class="c1">/// ${contiguousCaveat}</span>
  <span class="c1">///</span>
  <span class="c1">/// - Precondition: `Pointee` is a trivial type.</span>
  <span class="c1">///</span>
  <span class="c1">/// The following example shows how you copy the contents of an array into a</span>
  <span class="c1">/// buffer of `UInt8`:</span>
  <span class="c1">///</span>
  <span class="c1">///    let numbers = [1, 2, 3]</span>
  <span class="c1">///    var byteBuffer = [UInt8]()</span>
  <span class="c1">///    numbers.withUnsafeBytes {</span>
  <span class="c1">///        byteBuffer += $0</span>
  <span class="c1">///    }</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter that points to</span>
  <span class="c1">/// the contiguous storage for the array. If `body` has a return value, it is</span>
  <span class="c1">/// used as the return value for the `withUnsafeBytes(_:)` method. The</span>
  <span class="c1">/// argument is valid only for the duration of the closure's execution.</span>
  <span class="c1">/// - Returns: The return value of the `body` closure parameter, if any.</span>
  <span class="c1">///</span>
  <span class="c1">/// - SeeAlso: `withUnsafeBytes`, `UnsafeRawBufferPointer`</span>
  <span class="kd">public</span> <span class="kd">func</span> <span class="n">withUnsafeBytes</span><span class="o">&lt;</span><span class="kt">R</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">body</span><span class="p">:</span> <span class="p">(</span><span class="kt">UnsafeRawBufferPointer</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">R</span>
  <span class="p">)</span> <span class="k">rethrows</span> <span class="o">-&gt;</span> <span class="kt">R</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">try</span> <span class="k">self</span><span class="o">.</span><span class="n">withUnsafeBufferPointer</span> <span class="p">{</span>
      <span class="k">try</span> <span class="nf">body</span><span class="p">(</span><span class="kt">UnsafeRawBufferPointer</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">%</span><span class="n">end</span>

<span class="o">%</span> <span class="k">for</span> <span class="n">mutable</span> <span class="nf">in</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">):</span>
<span class="o">%</span>  <span class="kt">Mutable</span> <span class="o">=</span> <span class="err">'</span><span class="kt">Mutable</span><span class="err">'</span> <span class="k">if</span> <span class="n">mutable</span> <span class="k">else</span> <span class="err">''</span>

<span class="kd">extension</span> <span class="kt">Unsafe</span><span class="err">$</span><span class="p">{</span><span class="kt">Mutable</span><span class="p">}</span><span class="kt">BufferPointer</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>

<span class="o">%</span>  <span class="k">if</span> <span class="n">not</span> <span class="kt">Mutable</span><span class="p">:</span>
  <span class="c1">/// Creates a buffer over the same memory as the given buffer slice.</span>
  <span class="c1">///</span>
  <span class="c1">/// The new buffer will represent the same region of memory as the slice,</span>
  <span class="c1">/// but it's indices will be rebased to zero. Given:</span>
  <span class="c1">///</span>
  <span class="c1">///   let slice = buffer[n..&lt;m]</span>
  <span class="c1">///   let rebased = UnsafeBufferPointer(rebasing: slice)</span>
  <span class="c1">///</span>
  <span class="c1">/// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter slice: the raw buffer slice to rebase.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">rebasing</span> <span class="nv">slice</span><span class="p">:</span> <span class="kt">RandomAccessSlice</span><span class="o">&lt;</span><span class="kt">UnsafeBufferPointer</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span> <span class="o">+</span> <span class="n">slice</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>
<span class="o">%</span>  <span class="n">end</span> <span class="err">#</span> <span class="o">!</span><span class="n">mutable</span>

  <span class="c1">/// Creates a buffer over the same memory as the given buffer slice.</span>
  <span class="c1">///</span>
  <span class="c1">/// The new buffer will represent the same region of memory as the slice,</span>
  <span class="c1">/// but it's indices will be rebased to zero. Given:</span>
  <span class="c1">///</span>
  <span class="c1">///   let slice = buffer[n..&lt;m]</span>
  <span class="c1">///   let rebased = UnsafeBufferPointer(rebasing: slice)</span>
  <span class="c1">///</span>
  <span class="c1">/// One may assume `rebased.startIndex == 0` and `rebased[0] == slice[n]`.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter slice: the buffer slice to rebase.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span>
    <span class="n">rebasing</span> <span class="nv">slice</span><span class="p">:</span>
    <span class="kt">MutableRandomAccessSlice</span><span class="o">&lt;</span><span class="kt">UnsafeMutableBufferPointer</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;&gt;</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">baseAddress</span><span class="o">!</span> <span class="o">+</span> <span class="n">slice</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span>
      <span class="nv">count</span><span class="p">:</span> <span class="n">slice</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">%</span> <span class="n">end</span>
</code></pre></div></div> <h2 id="implementation-status"> <a href="#implementation-status" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Implementation status </h2> <p>This proposal is fully implemented on my <a href="https://github.com/atrick/swift/commits/unsafebytes">unsafebytes branch</a></p> <h2 id="impact-on-existing-code"> <a href="#impact-on-existing-code" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Impact on existing code </h2> <p>None</p> <h2 id="alternatives-considered"> <a href="#alternatives-considered" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Alternatives considered </h2> <p>Expect developers to continue using <code class="highlighter-rouge">[UInt8]</code> as type-erased buffers but rebind memory each time they cross API boundaries.</p> <p>Expect developers to convert to UnsafeRawPointer without a solution for viewing the raw data as a collection of bytes.</p> <p>There is no alternative to introducing an <code class="highlighter-rouge">UnsafeRawBufferPointer</code> API that doesnt require developers to understand the subtle semantics of raw pointers and binding memory to a type. My experience helping developers migrate their code, which they likely did not write in the first place, shows that this is an unreasonable expectation.</p> </div> </div> </div> </div> </body> </html>
