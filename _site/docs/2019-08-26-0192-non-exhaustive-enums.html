<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>SE-0192 Handling Future Enum Cases - Swift Evolution List</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>SE-0192 Handling Future Enum Cases | Swift Evolution List</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="SE-0192 Handling Future Enum Cases" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Yuhuu!" /> <meta property="og:description" content="Yuhuu!" /> <link rel="canonical" href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" /> <meta property="og:url" content="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" /> <meta property="og:site_name" content="Swift Evolution List" /> <script type="application/ld+json"> {"url":"http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html","headline":"SE-0192 Handling Future Enum Cases","description":"Yuhuu!","@type":"WebPage","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Swift Evolution List</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/about/" class="navigation-list-link">About</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html" class="navigation-list-link">SE-0001 Allow (most) keywords as argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0002-remove-currying.html" class="navigation-list-link">SE-0002 Removing currying `func` declaration syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html" class="navigation-list-link">SE-0003 Removing `var` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html" class="navigation-list-link">SE-0004 Remove the `++` and `--` operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html" class="navigation-list-link">SE-0005 Better Translation of Objective-C APIs Into Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html" class="navigation-list-link">SE-0006 Apply API Guidelines to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html" class="navigation-list-link">SE-0007 Remove C-style for-loops with conditions and incrementers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html" class="navigation-list-link">SE-0008 Add a Lazy flatMap for Sequences of Optionals #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html" class="navigation-list-link">SE-0009 Require self for accessing instance members</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html" class="navigation-list-link">SE-0010 Add StaticString.UnicodeScalarView</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html" class="navigation-list-link">SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html" class="navigation-list-link">SE-0012 Add `@noescape` to public library API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html" class="navigation-list-link">SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html" class="navigation-list-link">SE-0014 Constraining `AnySequence.init`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html" class="navigation-list-link">SE-0015 Tuple comparison operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html" class="navigation-list-link">SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html" class="navigation-list-link">SE-0017 Change `Unmanaged` to use `UnsafePointer`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html" class="navigation-list-link">SE-0018 Flexible Memberwise Initialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html" class="navigation-list-link">SE-0019 Swift Testing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html" class="navigation-list-link">SE-0020 Swift Language Version Build Configuration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html" class="navigation-list-link">SE-0021 Naming Functions with Argument Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html" class="navigation-list-link">SE-0022 Referencing the Objective-C selector of a method</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html" class="navigation-list-link">SE-0023 API Design Guidelines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html" class="navigation-list-link">SE-0024 Optional Value Setter `??=`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html" class="navigation-list-link">SE-0025 Scoped Access Level</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html" class="navigation-list-link">SE-0026 Abstract classes and methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html" class="navigation-list-link">SE-0027 Expose code unit initializers on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html" class="navigation-list-link">SE-0028 Modernizing Swift's Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html" class="navigation-list-link">SE-0029 Remove implicit tuple splat behavior from function applications</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html" class="navigation-list-link">SE-0030 Property Behaviors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html" class="navigation-list-link">SE-0031 Adjusting `inout` Declarations for Type Decoration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html" class="navigation-list-link">SE-0032 Add `first(where:)` method to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html" class="navigation-list-link">SE-0033 Import Objective-C Constants as Swift Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html" class="navigation-list-link">SE-0034 Disambiguating Line Control Statements from Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html" class="navigation-list-link">SE-0035 Limiting `inout` capture to `@noescape` contexts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0036-enum-dot.html" class="navigation-list-link">SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html" class="navigation-list-link">SE-0037 Clarify interaction between comments & operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html" class="navigation-list-link">SE-0038 Package Manager C Language Target Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html" class="navigation-list-link">SE-0039 Modernizing Playground Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0040-attributecolons.html" class="navigation-list-link">SE-0040 Replacing Equal Signs with Colons For Attribute Arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html" class="navigation-list-link">SE-0041 Updating Protocol Naming Conventions for Conversions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html" class="navigation-list-link">SE-0042 Flattening the function type of unapplied method references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html" class="navigation-list-link">SE-0043 Declare variables in 'case' labels with multiple patterns </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0044-import-as-member.html" class="navigation-list-link">SE-0044 Import as member</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html" class="navigation-list-link">SE-0045 Add prefix(while:) and drop(while:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0046-first-label.html" class="navigation-list-link">SE-0046 Establish consistent label behavior across all parameters including first labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html" class="navigation-list-link">SE-0047 Defaulting non-Void functions so they warn on unused results</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html" class="navigation-list-link">SE-0048 Generic Type Aliases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html" class="navigation-list-link">SE-0049 Move @noescape and @autoclosure to be type attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html" class="navigation-list-link">SE-0050 Decoupling Floating Point Strides from Generic Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html" class="navigation-list-link">SE-0051 Conventionalizing `stride` semantics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html" class="navigation-list-link">SE-0052 Change IteratorType post-nil guarantee</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html" class="navigation-list-link">SE-0053 Remove explicit use of `let` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html" class="navigation-list-link">SE-0054 Abolish `ImplicitlyUnwrappedOptional` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html" class="navigation-list-link">SE-0055 Make unsafe pointer nullability explicit using Optional</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html" class="navigation-list-link">SE-0056 Allow trailing closures in `guard` conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html" class="navigation-list-link">SE-0057 Importing Objective-C Lightweight Generics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html" class="navigation-list-link">SE-0058 Allow Swift types to provide custom Objective-C representations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html" class="navigation-list-link">SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html" class="navigation-list-link">SE-0060 Enforcing order of defaulted parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html" class="navigation-list-link">SE-0061 Add Generic Result and Error Handling to autoreleasepool()</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html" class="navigation-list-link">SE-0062 Referencing Objective-C key-paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html" class="navigation-list-link">SE-0063 SwiftPM System Module Search Paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0064-property-selectors.html" class="navigation-list-link">SE-0064 Referencing the Objective-C selector of property getters and setters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html" class="navigation-list-link">SE-0065 A New Model for Collections and Indices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html" class="navigation-list-link">SE-0066 Standardize function type argument syntax to require parentheses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html" class="navigation-list-link">SE-0067 Enhanced Floating Point Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0068-universal-self.html" class="navigation-list-link">SE-0068 Expanding Swift `Self` to class members and value types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html" class="navigation-list-link">SE-0069 Mutability and Foundation Value Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html" class="navigation-list-link">SE-0070 Make Optional Requirements Objective-C-only</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0071-member-keywords.html" class="navigation-list-link">SE-0071 Allow (most) keywords in member references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html" class="navigation-list-link">SE-0072 Fully eliminate implicit bridging conversions from Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0073-noescape-once.html" class="navigation-list-link">SE-0073 Marking closures as executing exactly once</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0074-binary-search.html" class="navigation-list-link">SE-0074 Implementation of Binary Search functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0075-import-test.html" class="navigation-list-link">SE-0075 Adding a Build Configuration Import Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html" class="navigation-list-link">SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html" class="navigation-list-link">SE-0077 Improved operator declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html" class="navigation-list-link">SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html" class="navigation-list-link">SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html" class="navigation-list-link">SE-0080 Failable Numeric Conversion Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html" class="navigation-list-link">SE-0081 Move `where` clause to end of declaration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html" class="navigation-list-link">SE-0082 Package Manager Editable Packages</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html" class="navigation-list-link">SE-0083 Remove bridging conversion behavior from dynamic casts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html" class="navigation-list-link">SE-0084 Allow trailing commas in parameter lists and tuples</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html" class="navigation-list-link">SE-0085 Package Manager Command Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html" class="navigation-list-link">SE-0086 Drop NS Prefix in Swift Foundation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html" class="navigation-list-link">SE-0087 Rename `lazy` to `@lazy`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html" class="navigation-list-link">SE-0088 Modernize libdispatch for Swift 3 naming conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html" class="navigation-list-link">SE-0089 Renaming `String.init<T>(_: T)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html" class="navigation-list-link">SE-0090 Remove `.self` and freely allow type references in expressions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html" class="navigation-list-link">SE-0091 Improving operator requirements in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html" class="navigation-list-link">SE-0092 Typealiases in protocols and protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0093-slice-base.html" class="navigation-list-link">SE-0093 Adding a public `base` property to slices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0094-sequence-function.html" class="navigation-list-link">SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html" class="navigation-list-link">SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0096-dynamictype.html" class="navigation-list-link">SE-0096 Converting `dynamicType` from a property to an operator</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html" class="navigation-list-link">SE-0097 Normalizing naming for "negative" attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html" class="navigation-list-link">SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html" class="navigation-list-link">SE-0099 Restructuring Condition Clauses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html" class="navigation-list-link">SE-0100 Add sequence-based initializers and merge methods to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html" class="navigation-list-link">SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html" class="navigation-list-link">SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html" class="navigation-list-link">SE-0103 Make non-escaping closures the default</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0104-improved-integers.html" class="navigation-list-link">SE-0104 Protocol-oriented integers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html" class="navigation-list-link">SE-0105 Removing Where Clauses from For-In Loops</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html" class="navigation-list-link">SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" class="navigation-list-link">SE-0107 UnsafeRawPointer API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html" class="navigation-list-link">SE-0108 Remove associated type inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html" class="navigation-list-link">SE-0109 Remove the `Boolean` protocol </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html" class="navigation-list-link">SE-0110 Distinguish between single-tuple and multiple-argument function types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html" class="navigation-list-link">SE-0111 Remove type system significance of function argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html" class="navigation-list-link">SE-0112 Improved NSError Bridging</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html" class="navigation-list-link">SE-0113 Add integral rounding functions to FloatingPoint</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html" class="navigation-list-link">SE-0114 Updating Buffer "Value" Names to "Header" Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html" class="navigation-list-link">SE-0115 Rename Literal Syntax Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0116-id-as-any.html" class="navigation-list-link">SE-0116 Import Objective-C `id` as Swift `Any` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html" class="navigation-list-link">SE-0117 Allow distinguishing between public access and public overridability</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html" class="navigation-list-link">SE-0118 Closure Parameter Names and Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html" class="navigation-list-link">SE-0119 Remove access modifiers from extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html" class="navigation-list-link">SE-0120 Revise `partition` Method Signature</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html" class="navigation-list-link">SE-0121 Remove `Optional` Comparison Operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html" class="navigation-list-link">SE-0122 Use colons for subscript declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html" class="navigation-list-link">SE-0123 Disallow coercion to optionals in operator arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html" class="navigation-list-link">SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html" class="navigation-list-link">SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html" class="navigation-list-link">SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html" class="navigation-list-link">SE-0127 Cleaning up stdlib Pointer and Buffer Routines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html" class="navigation-list-link">SE-0128 Change failable UnicodeScalar initializers to failable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html" class="navigation-list-link">SE-0129 Package Manager Test Naming Conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html" class="navigation-list-link">SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0131-anyhashable.html" class="navigation-list-link">SE-0131 Add `AnyHashable` to the standard library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html" class="navigation-list-link">SE-0132 Rationalizing Sequence end-operation names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html" class="navigation-list-link">SE-0133 Rename `flatten()` to `joined()`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html" class="navigation-list-link">SE-0134 Rename two UTF8-related properties on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html" class="navigation-list-link">SE-0135 Package Manager Support for Differentiating Packages by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html" class="navigation-list-link">SE-0136 Memory layout of values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html" class="navigation-list-link">SE-0137 Avoiding Lock-In to Legacy Protocol Designs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" class="navigation-list-link">SE-0138 UnsafeRawBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html" class="navigation-list-link">SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html" class="navigation-list-link">SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html" class="navigation-list-link">SE-0141 Availability by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html" class="navigation-list-link">SE-0142 Permit where clauses to constrain associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" class="navigation-list-link">SE-0143 Conditional conformances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html" class="navigation-list-link">SE-0144 Allow Single Dollar Sign as a Valid Identifier</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html" class="navigation-list-link">SE-0145 Package Manager Version Pinning</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html" class="navigation-list-link">SE-0146 Package Manager Product Definitions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html" class="navigation-list-link">SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html" class="navigation-list-link">SE-0148 Generic Subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html" class="navigation-list-link">SE-0149 Package Manager Support for Top of Tree development</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html" class="navigation-list-link">SE-0150 Package Manager Support for branches</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html" class="navigation-list-link">SE-0151 Package Manager Swift Language Compatibility Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html" class="navigation-list-link">SE-0152 Package Manager Tools Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html" class="navigation-list-link">SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html" class="navigation-list-link">SE-0154 Provide Custom Collections for Dictionary Keys and Values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html" class="navigation-list-link">SE-0155 Normalize Enum Case Representation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html" class="navigation-list-link">SE-0156 Class and Subtype existentials</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html" class="navigation-list-link">SE-0157 Support recursive constraints on associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html" class="navigation-list-link">SE-0158 Package Manager Manifest API Redesign</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html" class="navigation-list-link">SE-0159 Fix Private Access Levels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0160-objc-inference.html" class="navigation-list-link">SE-0160 Limiting `@objc` inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0161-key-paths.html" class="navigation-list-link">SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html" class="navigation-list-link">SE-0162 Package Manager Custom Target Layouts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html" class="navigation-list-link">SE-0163 String Revision: Collection Conformance, C Interop, Transcoding</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html" class="navigation-list-link">SE-0164 Remove final support in protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0165-dict.html" class="navigation-list-link">SE-0165 Dictionary & Set Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" class="navigation-list-link">SE-0166 Swift Archival & Serialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html" class="navigation-list-link">SE-0167 Swift Encoders</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html" class="navigation-list-link">SE-0168 Multi-Line String Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html" class="navigation-list-link">SE-0169 Improve Interaction Between `private` Declarations and Extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html" class="navigation-list-link">SE-0170 NSNumber bridging and Numeric types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html" class="navigation-list-link">SE-0171 Reduce with `inout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html" class="navigation-list-link">SE-0172 One-sided Ranges</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0173-swap-indices.html" class="navigation-list-link">SE-0173 Add `MutableCollection.swapAt(_:_:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html" class="navigation-list-link">SE-0174 Change `filter` to return an associated type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html" class="navigation-list-link">SE-0175 Package Manager Revised Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" class="navigation-list-link">SE-0176 Enforce Exclusive Access to Memory</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html" class="navigation-list-link">SE-0177 Add clamp(to:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html" class="navigation-list-link">SE-0178 Add `unicodeScalars` property to `Character`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html" class="navigation-list-link">SE-0179 Swift `run` Command</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html" class="navigation-list-link">SE-0180 String Index Overhaul</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html" class="navigation-list-link">SE-0181 Package Manager C/C++ Language Standard Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html" class="navigation-list-link">SE-0182 String Newline Escaping</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html" class="navigation-list-link">SE-0183 Substring performance affordances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html" class="navigation-list-link">SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html" class="navigation-list-link">SE-0185 Synthesizing `Equatable` and `Hashable` conformance</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html" class="navigation-list-link">SE-0186 Remove ownership keyword support in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html" class="navigation-list-link">SE-0187 Introduce Sequence.compactMap(_:)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html" class="navigation-list-link">SE-0188 Make Standard Library Index Types Hashable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html" class="navigation-list-link">SE-0189 Restrict Cross-module Struct Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html" class="navigation-list-link">SE-0190 Target environment platform condition</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html" class="navigation-list-link">SE-0191 Eliminate `IndexDistance` from `Collection`</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" class="navigation-list-link active">SE-0192 Handling Future Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html" class="navigation-list-link">SE-0193 Cross-module inlining and specialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html" class="navigation-list-link">SE-0194 Derived Collection of Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html" class="navigation-list-link">SE-0195 Introduce User-defined "Dynamic Member Lookup" Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html" class="navigation-list-link">SE-0196 Compiler Diagnostic Directives</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0197-remove-where.html" class="navigation-list-link">SE-0197 Adding in-place `removeAll(where:)` to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html" class="navigation-list-link">SE-0198 Playground QuickLook API Revamp #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html" class="navigation-list-link">SE-0199 Adding `toggle` to `Bool`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html" class="navigation-list-link">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html" class="navigation-list-link">SE-0201 Package Manager Local Dependencies</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0202-random-unification.html" class="navigation-list-link">SE-0202 Random Unification</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html" class="navigation-list-link">SE-0203 Rename Sequence.elementsEqual</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html" class="navigation-list-link">SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html" class="navigation-list-link">SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html" class="navigation-list-link">SE-0206 Hashable Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0207-containsOnly.html" class="navigation-list-link">SE-0207 Add an `allSatisfy` algorithm to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html" class="navigation-list-link">SE-0208 Package Manager System Library Targets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html" class="navigation-list-link">SE-0209 Package Manager Swift Language Version API Update</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html" class="navigation-list-link">SE-0210 Add an `offset(of:)` method to `MemoryLayout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html" class="navigation-list-link">SE-0211 Add Unicode Properties to `Unicode.Scalar`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html" class="navigation-list-link">SE-0212 Compiler Version Directive</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html" class="navigation-list-link">SE-0213 Literal initialization via coercion</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html" class="navigation-list-link">SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html" class="navigation-list-link">SE-0215 Conform `Never` to `Equatable` and `Hashable`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html" class="navigation-list-link">SE-0216 Introduce user-defined dynamically "callable" types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0217-bangbang.html" class="navigation-list-link">SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html" class="navigation-list-link">SE-0218 Introduce `compactMapValues` to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html" class="navigation-list-link">SE-0219 Package Manager Dependency Mirroring</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0220-count-where.html" class="navigation-list-link">SE-0220 `count(where:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0221-character-properties.html" class="navigation-list-link">SE-0221 Character Properties</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html" class="navigation-list-link">SE-0222 Lazy CompactMap Sequence</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html" class="navigation-list-link">SE-0223 Accessing an Array's Uninitialized Buffer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html" class="navigation-list-link">SE-0224 Support 'less than' operator in compilation conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html" class="navigation-list-link">SE-0225 Adding `isMultiple` to `BinaryInteger`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html" class="navigation-list-link">SE-0226 Package Manager Target Based Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html" class="navigation-list-link">SE-0227 Identity key path</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html" class="navigation-list-link">SE-0228 Fix `ExpressibleByStringInterpolation`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0229-simd.html" class="navigation-list-link">SE-0229 SIMD Vectors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html" class="navigation-list-link">SE-0230 Flatten nested optionals resulting from 'try?'</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html" class="navigation-list-link">SE-0231 Optional Iteration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html" class="navigation-list-link">SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html" class="navigation-list-link">SE-0233 Make `Numeric` Refine a new `AdditiveArithmetic` Protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html" class="navigation-list-link">SE-0234 Remove `Sequence.SubSequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0235-add-result.html" class="navigation-list-link">SE-0235 Add Result to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html" class="navigation-list-link">SE-0236 Package Manager Platform Deployment Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html" class="navigation-list-link">SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html" class="navigation-list-link">SE-0238 Package Manager Target Specific Build Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0239-codable-range.html" class="navigation-list-link">SE-0239 Add Codable conformance to Range types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html" class="navigation-list-link">SE-0240 Ordered Collection Diffing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html" class="navigation-list-link">SE-0241 Deprecate String Index Encoded Offsets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html" class="navigation-list-link">SE-0242 Synthesize default values for the memberwise initializer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html" class="navigation-list-link">SE-0243 Integer-convertible character literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html" class="navigation-list-link">SE-0244 Opaque Result Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html" class="navigation-list-link">SE-0245 Add an Array Initializer with Access to Uninitialized Storage</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0246-mathable.html" class="navigation-list-link">SE-0246 Generic Math(s) Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html" class="navigation-list-link">SE-0247 Contiguous Strings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html" class="navigation-list-link">SE-0248 String Gaps and Missing APIs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html" class="navigation-list-link">SE-0249 Key Path Expressions as Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html" class="navigation-list-link">SE-0250 Swift Code Style Guidelines and Formatter</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0251-simd-additions.html" class="navigation-list-link">SE-0251 SIMD additions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html" class="navigation-list-link">SE-0252 Key Path Member Lookup</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0253-callable.html" class="navigation-list-link">SE-0253 Introduce callables </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html" class="navigation-list-link">SE-0254 Static and class subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0255-omit-return.html" class="navigation-list-link">SE-0255 Implicit returns from single-expression functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html" class="navigation-list-link">SE-0256 Introduce `{Mutable}ContiguousCollection` protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0257-elide-comma.html" class="navigation-list-link">SE-0257 Eliding commas from multiline expression lists</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html" class="navigation-list-link"> Feature name</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Swift Evolution List" aria-label="Search Swift Evolution List" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/pondok-programmer/swift-evolution-jekyll">Swift Evolution List</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h1 id="handling-future-enum-cases"> <a href="#handling-future-enum-cases" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Handling Future Enum Cases </h1> <ul> <li>Proposal: <a href="0192-non-exhaustive-enums.md">SE-0192</a></li> <li>Author: <a href="https://github.com/jrose-apple">Jordan Rose</a></li> <li>Review Manager: <a href="https://github.com/tkremenek">Ted Kremenek</a></li> <li>Status: <strong>Implemented (Swift 5)</strong></li> <li>Implementation: <a href="https://github.com/apple/swift/pull/14945">apple/swift#14945</a></li> <li>Previous revision: <a href="https://github.com/apple/swift-evolution/blob/a773d07ff4beab8b7855adf0ac56d1e13bb7b44c/proposals/0192-non-exhaustive-enums.md">1</a>, <a href="https://github.com/jrose-apple/swift-evolution/blob/57dfa2408fe210ed1d5a1251f331045b988ee2f0/proposals/0192-non-exhaustive-enums.md">2 (informal)</a>, <a href="https://github.com/apple/swift-evolution/blob/af284b519443d3d985f77cc366005ea908e2af59/proposals/0192-non-exhaustive-enums.md">3</a></li> <li>Pre-review discussion: <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170807/038663.html">Enums and Source Compatibility</a>, with additional <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170911/039787.html">orphaned thread</a></li> <li>Review discussion: <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20180101/042480.html">Review author summarizes some feedback from review discussion and proposes alternatives</a>, <a href="https://forums.swift.org/t/se-0192-non-exhaustive-enums/7291/337">full discussion thread</a>, plus <a href="https://forums.swift.org/t/handling-unknown-cases-in-enums-re-se-0192/7388/">Handling unknown cases in enums</a></li> <li>Decision Notes: <a href="https://forums.swift.org/t/se-0192-non-exhaustive-enums-review-2/11043/62">Rationale</a></li> </ul> <!-- *During the review process, add the following fields as needed:* * Decision Notes: [Rationale](https://lists.swift.org/pipermail/swift-evolution/), [Additional Commentary](https://lists.swift.org/pipermail/swift-evolution/) * Bugs: [SR-NNNN](https://bugs.swift.org/browse/SR-NNNN), [SR-MMMM](https://bugs.swift.org/browse/SR-MMMM) * Previous Proposal: [SE-XXXX](XXXX-filename.md) --> <h2 id="introduction"> <a href="#introduction" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduction </h2> <p>Currently, adding a new case to an enum is a source-breaking change, something thats at odds with Apples established process for evolving APIs. This proposal aims to distinguish between enums that are <em>frozen</em> (meaning they will never get any new cases) and those that are <em>non-frozen,</em> and to ensure that clients handle any future cases when dealing with the latter.</p> <p>A key note: in this version of the proposal, <em>nothing changes for user-defined Swift enums.</em> This only affects C enums and enums in the standard library and overlays today. (This refers to libraries that Apple could hypothetically ship with its OSs, as it does with Foundation.framework and the Objective-C runtime.) The features described here may be used by third-party libraries in the future.</p> <h3 id="post-acceptance-revision"> <a href="#post-acceptance-revision" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Post-acceptance revision </h3> <ul> <li>Since the proposal was accepted months after it was written, the rollout plan turned out to be a little too aggressive. Therefore, in Swift 5 the diagnostic for omitting <code class="highlighter-rouge">@unknown default:</code> or <code class="highlighter-rouge">@unknown case _:</code> will only be a warning, and in Swift 4 mode there will be no diagnostic at all. (The previous version of the proposal used an error and a warning, respectively.) Developers are still free to use <code class="highlighter-rouge">@unknown</code> in Swift 4 mode, in which case the compiler will still produce a warning if all known cases are not handled.</li> </ul> <h3 id="revision-at-acceptance"> <a href="#revision-at-acceptance" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Revision at acceptance </h3> <ul> <li>The new case <code class="highlighter-rouge">unknown:</code> was changed to the <code class="highlighter-rouge">unknown</code> attribute, which can only be applied to <code class="highlighter-rouge">default:</code> and <code class="highlighter-rouge">case _:</code>.</li> </ul> <h3 id="differences-from-the-first-revision"> <a href="#differences-from-the-first-revision" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Differences from the first revision </h3> <ul> <li><a href="https://forums.swift.org/t/se-0192-non-exhaustive-enums/7291/337">This now only affects C enums and enums defined in the standard library and overlays</a></li> <li>The <code class="highlighter-rouge">unknown</code> case has been added, to preserve exhaustivity checking</li> <li>The term used to describe enums that will not change is now frozen rather than exhaustive</li> <li>The proposal now describes what will happen if you break the contract in a new library version</li> <li>Much more discussion of future directions and alternatives considered</li> </ul> <p>Thanks to everyone who offered feedback!</p> <h2 id="motivation"> <a href="#motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Motivation </h2> <p>Its well-established that many enums need to grow new cases in new versions of a library. For example, in last years release of iOS 10, Foundations <a href="https://developer.apple.com/documentation/foundation/datecomponentsformatter.unitsstyle">DateComponentsFormatter.UnitsStyle</a> gained a <code class="highlighter-rouge">brief</code> case and UIKits <a href="https://developer.apple.com/documentation/uikit/uikeyboardtype">UIKeyboardType</a> gained an <code class="highlighter-rouge">asciiCapableNumberPad</code> case. Large error enums also often grow new cases to go with new operations supported by the library. This all implies that library authors <em>must</em> have a way to add new cases to enums without breaking binary compatibility.</p> <p>At the same time, we really like that you can exhaustively switch over enums. This feature helps prevent bugs and makes it possible to enforce <a href="https://developer.apple.com/swift/blog/?id=28">definitive initialization</a> without having <code class="highlighter-rouge">default</code> cases in every <code class="highlighter-rouge">switch</code>. So we dont want to get rid of enums where every case is known, either. This calls for a distinction between enums where every case can be known statically and enums that might grow new cases in the future.</p> <p>To see how this distinction will play out in practice, I investigated the public headers of Foundation in the macOS SDK. Out of all 60 or so <code class="highlighter-rouge">NS_ENUM</code>s in Foundation, only 6 of them are clearly intended to be switched exhaustively:</p> <ul> <li><a href="https://developer.apple.com/documentation/foundation/comparisonresult">ComparisonResult</a></li> <li><a href="https://developer.apple.com/documentation/foundation/nskeyvaluechange">NSKeyValueChange</a> / <a href="https://developer.apple.com/documentation/foundation/nskeyvaluesetmutationkind">NSKeyValueSetMutationKind</a></li> <li><a href="https://developer.apple.com/documentation/foundation/nsrectedge">NSRectEdge</a></li> <li><a href="https://developer.apple.com/documentation/foundation/filemanager.urlrelationship">FileManager.URLRelationship</a></li> <li><em>maybe</em> <a href="https://developer.apple.com/documentation/foundation/nsdecimalnumber.calculationerror">Decimal.CalculationError</a></li> </ul> <p>with a handful more that could go either way, such as <a href="https://developer.apple.com/documentation/foundation/stream.status">Stream.Status</a>. This demonstrates that there is a clear default for public enums, at least in Objective-C.</p> <h2 id="proposed-solution"> <a href="#proposed-solution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Proposed solution </h2> <p>In Swift 4.2, enums imported from C and enums defined in the standard library and overlays are either <em>frozen</em> or <em>non-frozen.</em> (Grammatical note: they are not unfrozen because that implies that they were frozen at one point.)</p> <p>When a client tries to switch over a non-frozen enum, they should include a catch-all case of some kind (<code class="highlighter-rouge">default</code>, <code class="highlighter-rouge">case _</code>, etc). In Swift 5 mode, omitting this case will result in a warning.</p> <p>All enums written in Swift outside of the standard library and overlays will implicitly be considered frozen in Swift 4.2. Enums imported from C will be non-frozen by default, with a new C-side annotation to treat them as frozen.</p> <h2 id="detailed-design"> <a href="#detailed-design" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Detailed design </h2> <p>When switching over a non-frozen enum, the switch statement that matches against it must include a catch-all case (usually <code class="highlighter-rouge">default</code> or an ignore <code class="highlighter-rouge">_</code> pattern).</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">eatenByPet</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="o">.</span><span class="nv">thoughtItWasDueNextWeek</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <p>Failure to do so will produce a warning in Swift 5. A program will trap at run time if an unknown enum case is actually encountered.</p> <p>All other uses of enums (<code class="highlighter-rouge">if case</code>, creation, accessing members, etc) do not change. Only the exhaustiveness checking of switches is affected by the frozen/non-frozen distinction. Non-exhaustive switches over frozen enums (and boolean values) will continue to be invalid in all language modes.</p> <p>Heres a more complicated example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="p">(</span><span class="n">excuse</span><span class="p">,</span> <span class="n">notifiedTeacherBeforeDeadline</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">eatenByPet</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">thoughtItWasDueNextWeek</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="kc">false</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <p>This switch handles all <em>known</em> patterns, but still doesnt account for the possibility of a new enum case when the second tuple element is <code class="highlighter-rouge">true</code>. This should result in a warning in Swift 5, like the first example.</p> <h3 id="unknown"> <a href="#unknown" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">@unknown</code> </h3> <p>The downside of using a <code class="highlighter-rouge">default</code> case is that the compiler can no longer alert a developer that a particular enum has elements that arent explicitly handled in the <code class="highlighter-rouge">switch</code>. To remedy this, switch cases will gain a new attribute, <code class="highlighter-rouge">@unknown</code>.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">eatenByPet</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="o">.</span><span class="nv">thoughtItWasDueNextWeek</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="kd">@unknown</span> <span class="k">default</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <p>Like the regular <code class="highlighter-rouge">default</code>, <code class="highlighter-rouge">@unknown default</code> matches any value; it is a catch-all case. However, the compiler will produce a <em>warning</em> if all known elements of the enum have not already been matched. This is a warning rather than an error so that adding new elements to the enum remains a source-compatible change. (This is also why <code class="highlighter-rouge">@unknown default</code> matches any value rather than just those not seen at compile-time.)</p> <p><code class="highlighter-rouge">@unknown</code> may only be applied to <code class="highlighter-rouge">default</code> or a case consisting of the single pattern <code class="highlighter-rouge">_</code>. Even in the latter case, <code class="highlighter-rouge">@unknown</code> must be used with the last case in a <code class="highlighter-rouge">switch</code>. This restriction is discussed further in the <code class="highlighter-rouge">unknown</code> patterns section under Future directions.</p> <p>The compiler will warn if all enums in the pattern being matched by <code class="highlighter-rouge">@unknown</code> are explicitly annotated as frozen, or if there are no enums in the pattern at all. This is a warning rather than an error so that annotating an enum as frozen remains a source-compatible change. If the pattern contains any enums that are implicitly frozen (i.e. because it is a user-defined Swift enum), <code class="highlighter-rouge">@unknown</code> is permitted, in order to make it easier to adapt to newly-added cases.</p> <p><code class="highlighter-rouge">@unknown</code> has a downside that it is not testable, since there is no way to create an enum value that does not match any known cases, and there wouldnt be a safe way to use it if there was one. However, combining <code class="highlighter-rouge">@unknown</code> with other cases using <code class="highlighter-rouge">fallthrough</code> can get the effect of following another cases behavior while still getting compiler warnings for new cases.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">eatenByPet</span><span class="p">:</span>
  <span class="nf">showCutePicturesOfPet</span><span class="p">()</span>

<span class="k">case</span> <span class="o">.</span><span class="nv">thoughtItWasDueNextWeek</span><span class="p">:</span>
  <span class="k">fallthrough</span>
<span class="kd">@unknown</span> <span class="k">default</span><span class="p">:</span>
  <span class="nf">askForDueDateExtension</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="c-enums"> <a href="#c-enums" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> C enums </h3> <p>Enums imported from C are tricky, because its difficult to tell whether theyre part of the current project or not. An <code class="highlighter-rouge">NS_ENUM</code> in Apples SDK should probably be treated as non-frozen, but one in your own framework might be frozen. Even there, though, its possible that theres a private case defined in a .m file:</p> <div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MyAppPaperSupport.h</span>
<span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">PaperSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PaperSizeUSLetter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">PaperSizeA4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">PaperSizePhoto4x6</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MyAppPaperSupport.m</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">PaperSize</span> <span class="n">PaperSizeStickyNote</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
</code></pre></div></div> <p>(While this pattern may be unfamiliar, it is used in Apples SDKs, though not often.)</p> <p>Therefore, enums imported from C will be treated conservatively: an otherwise-unannotated <code class="highlighter-rouge">NS_ENUM</code> will be imported as non-frozen and treated as such in all contexts. The newly-added C attribute <code class="highlighter-rouge">enum_extensibility</code> can be used to override this behavior:</p> <div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">GregorianMonth</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GregorianMonthJanuary</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">GregorianMonthFebruary</span><span class="p">,</span>
  <span class="n">GregorianMonthMarch</span><span class="p">,</span>
  <span class="n">GregorianMonthApril</span><span class="p">,</span>
  <span class="n">GregorianMonthMay</span><span class="p">,</span>
  <span class="n">GregorianMonthJune</span><span class="p">,</span>
  <span class="n">GregorianMonthJuly</span><span class="p">,</span>
  <span class="n">GregorianMonthAugust</span><span class="p">,</span>
  <span class="n">GregorianMonthSeptember</span><span class="p">,</span>
  <span class="n">GregorianMonthOctober</span><span class="p">,</span>
  <span class="n">GregorianMonthNovember</span><span class="p">,</span>
  <span class="n">GregorianMonthDecember</span><span class="p">,</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">enum_extensibility</span><span class="p">(</span><span class="n">closed</span><span class="p">)));</span>
</code></pre></div></div> <p>Apple doesnt speak about future plans for its SDKs, so having an alternate form of <code class="highlighter-rouge">NS_ENUM</code> that includes this attribute is out of scope for this proposal.</p> <p>Apart from the effect on switches, a frozen C enums <code class="highlighter-rouge">init(rawValue:)</code> will also enforce that the case is one of those known at compile time. Imported non-frozen enums will continue to perform no checking on the raw value.</p> <blockquote> <p>This section only applies to enums that Swift considers true enums, rather than option sets or funny integer values. In the past, the only way to get this behavior was to use the <code class="highlighter-rouge">NS_ENUM</code> or <code class="highlighter-rouge">CF_ENUM</code> macros, but the presence of <code class="highlighter-rouge">enum_extensibility(closed)</code> <em>or</em> <code class="highlighter-rouge">enum_extensibility(open)</code> will instruct Swift to treat the enum as a true enum. Similarly, the newly-added <code class="highlighter-rouge">flag_enum</code> C attribute can be used to signify an option set like <code class="highlighter-rouge">NS_OPTIONS</code>.</p> </blockquote> <h3 id="effect-on-the-standard-library-and-overlays"> <a href="#effect-on-the-standard-library-and-overlays" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on the standard library and overlays </h3> <p>The majority of enums defined in the standard library do not need the flexibility afforded by being non-frozen, and so will be marked as frozen. This includes the following enums:</p> <ul> <li> ClosedRange.Index</li> <li> FloatingPointSign</li> <li> FloatingPointClassification</li> <li> Never</li> <li> Optional</li> <li> UnicodeDecodingResult</li> <li> Unicode.ParseResult</li> </ul> <p>The following public enums in the standard library will <em>not</em> be marked as frozen:</p> <ul> <li>DecodingError</li> <li>EncodingError</li> <li>FloatingPointRoundingRule</li> <li>Mirror.AncestorRepresentation</li> <li>Mirror.DisplayStyle</li> <li>PlaygroundQuickLook (deprecated anyway)</li> </ul> <p>And while the overlays are not strictly part of the Swift Open Source project (since they are owned by framework teams at Apple), the tentative plan would be to mark these two enums as frozen:</p> <ul> <li> ARCamera.TrackingState (a tri-state of on, off, and limited(Reason))</li> <li> DispatchTimeoutResult (success and timed out)</li> </ul> <p>And the other public enums in the overlays would be non-frozen:</p> <ul> <li>ARCamera.TrackingState.Reason</li> <li>Calendar.Component</li> <li>Calendar.Identifier</li> <li>Calendar.MatchingPolicy</li> <li>Calendar.RepeatedTimePolicy</li> <li>Calendar.SearchDirection</li> <li>CGPathFillRule</li> <li>Data.Deallocator</li> <li>DispatchData.Deallocator</li> <li>DispatchIO.StreamType</li> <li>DispatchPredicate</li> <li>DispatchQoS.QoSClass</li> <li>DispatchQueue.AutoreleaseFrequency</li> <li>DispatchQueue.GlobalQueuePriority (deprecated anyway)</li> <li>DispatchTimeInterval</li> <li>JSONDecoder.DataDecodingStrategy</li> <li>JSONDecoder.DateDecodingStrategy</li> <li>JSONDecoder.KeyDecodingStrategy</li> <li>JSONDecoder.NonConformingFloatDecodingStrategy</li> <li>JSONEncoder.DataEncodingStrategy</li> <li>JSONEncoder.DateEncodingStrategy</li> <li>JSONEncoder.KeyEncodingStrategy</li> <li>JSONEncoder.NonConformingFloatEncodingStrategy</li> <li>MachErrorCode</li> <li>POSIXErrorCode</li> </ul> <h2 id="comparison-with-other-languages"> <a href="#comparison-with-other-languages" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Comparison with other languages </h2> <p>Enums, unions, variant types, sum types, or algebraic data types are present in a number of other modern languages, most of which dont seem to treat this as an important problem.</p> <h3 id="languages-without-non-frozen-enums"> <a href="#languages-without-non-frozen-enums" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Languages without non-frozen enums </h3> <p><strong>Haskell</strong> and <strong>OCaml</strong> make heavy use of enums (algebraic data types, or just types) without any feature like this; adding a new case is always a source-breaking change. (Neither of these languages seems to care much about binary compatibility.) This is definitely a sign that you can have a successful language without a form of non-frozen enum other than protocols. <strong>Kotlin</strong> also falls in this bucket, although it uses enums (enum classes) less frequently.</p> <p>The <strong>C#</strong> docs have a nice section on <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum#robust-programming">how the language isnt very helpful</a> for distinguishing frozen and non-frozen enums. <strong>Objective-C</strong>, of course, is in the same bucket, though Apple could start doing things with the <code class="highlighter-rouge">enum_extensibility</code> Clang attribute that was recently added.</p> <h3 id="languages-with-alternate-designs"> <a href="#languages-with-alternate-designs" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Languages with alternate designs </h3> <p><strong>F#</strong> enums (unions) <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/signatures">either expose all of their cases or none of them</a>. The Swift equivalent of this would be not allowing you to switch on such an enum at all, as if it were a struct with private fields.</p> <p>Enums in <strong>D</strong> are like enums in C, but D distinguishes <code class="highlighter-rouge">switch</code> from <code class="highlighter-rouge">final switch</code>, and only the latter is exhaustive. That is, its a client-side decision at the use site, rather than a decision by the definer of the enum.</p> <p><strong>Scala</strong> has enums, but the pattern most people seem to use is sealed traits, which in Swift terms would be protocols where all conforming types are known, usually singletons. A non-frozen enum would then just be a normal protocol. Some downsides of applying this to Swift are discussed below under Use protocols instead.</p> <h3 id="languages-with-designs-similar-to-this-proposal"> <a href="#languages-with-designs-similar-to-this-proposal" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Languages with designs similar to this proposal </h3> <p><strong>Rust</strong> has an <a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md">accepted proposal</a> to add non-frozen enums that looks a lot like this one, but where frozen is still the default to not break existing Rust programs. (There are some interesting differences that come up in Rust but not Swift; in particular they need a notion of non-frozen structs because their structs can be decomposed in pattern-matching as well.)</p> <h2 id="source-compatibility"> <a href="#source-compatibility" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Source compatibility </h2> <p>It is now a source-compatible change to add a case to a non-frozen enum (whether imported from C or defined in the standard library).</p> <p>It is not a source-compatible change to add a case to a frozen enum.</p> <p>It is still not a source-compatible change to remove a case from a public enum (frozen or non-frozen).</p> <p>It is a source-compatible change to change a non-frozen enum into a frozen enum, but not vice versa.</p> <h3 id="breaking-the-contract"> <a href="#breaking-the-contract" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Breaking the contract </h3> <p>If a library author adds a case to a frozen enum, any existing switches will likely not handle this new case. The compiler will produce an error for any such switch (i.e. those without a <code class="highlighter-rouge">default</code> case or <code class="highlighter-rouge">_</code> pattern to match the enum value), noting that the case is unhandled; this is the same error that is produced for a non-exhaustive switch in Swift 4.</p> <p>If a library author changes an enum previously marked frozen to make it non-frozen, the compiler will produce a warning for any switch that does not have a catch-all case.</p> <h2 id="effect-on-abi-stability"> <a href="#effect-on-abi-stability" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on ABI stability </h2> <p>The layout of a non-frozen Swift enum must not be exposed to clients, since the library may choose to add a new case that does not fit in that layout in its next release. This results in extra indirection when that enum appears in public API. The layout of a frozen enum will continue to be made available to clients for optimization purposes.</p> <p>This change does not affect the layout of <code class="highlighter-rouge">@objc</code> enums, whether imported from C or defined in Swift. (Note that the representation of a non-<code class="highlighter-rouge">@objc</code> enums case may differ from its raw value; this improves the efficiency of <code class="highlighter-rouge">switch</code> statements when all cases are known at compile time.)</p> <h2 id="effect-on-library-evolution"> <a href="#effect-on-library-evolution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on Library Evolution </h2> <p>It is now a binary-compatible change to add a case to a non-frozen enum.</p> <p>It is still not a binary-compatible change to remove a case from a public enum (frozen or non-frozen).</p> <p>It is not a binary-compatible change to add <code class="highlighter-rouge">@objc</code> to an enum, nor to remove it.</p> <p>Taking an existing non-frozen enum and making it frozen is something wed like to support without breaking binary compatibility, but there is no design for that yet. The reverse will not be allowed.</p> <h3 id="breaking-the-contract-1"> <a href="#breaking-the-contract-1" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Breaking the contract </h3> <p>Because the compiler uses the set of cases in a frozen enum to determine its in-memory representation and calling convention, adding a new case or marking such an enum as non-frozen will result in undefined behavior from any client apps that have not been recompiled. This means a loss of memory-safety and type-safety on par with a misuse of unsafe types, which would most likely lead to crashes but could lead to code unexpectedly being executed or skipped. In short, things would be very bad.</p> <p>Some ideas for how to prevent library authors from breaking the rules accidentally are discussed in Compatibility checking under Future directions.</p> <p>As a special case, switching over an unexpected value in an <code class="highlighter-rouge">@objc</code> enum (whether imported or defined in Swift) will always result in a trap rather than undefined behavior, even if the enum is frozen.</p> <h2 id="future-directions"> <a href="#future-directions" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Future directions </h2> <h3 id="non-frozen-swift-enums-outside-the-standard-library"> <a href="#non-frozen-swift-enums-outside-the-standard-library" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Non-frozen Swift enums outside the standard library </h3> <p>Earlier versions of this proposal included syntax that allowed <em>all</em> public Swift enums to have a frozen/non-frozen distinction, rather than just those in the standard library and overlays. This is still something we want to support, but the core team has made it clear that such a distinction is only worth it for libraries that have binary compatibility concerns (such as those installed into a standard location and used by multiple clients), at least without a more developed notion of versioning and version-locking. Exactly what it means to be a library with binary compatibility concerns is a large topic that deserves its own proposal.</p> <h3 id="unknown-patterns"> <a href="#unknown-patterns" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">unknown</code> patterns </h3> <p>As described, <code class="highlighter-rouge">@unknown</code> cases can only be used to match the entire switched value; it does not work when trying to match a tuple element, or another enums associated type. In theory, we could make a new <em>pattern</em> kind that allows matching unknown cases anywhere within a larger pattern:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="p">(</span><span class="n">excuse</span><span class="p">,</span> <span class="n">notifiedTeacherBeforeDeadline</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">eatenByPet</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">thoughtItWasDueNextWeek</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="err">#</span><span class="n">unknown</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="kc">false</span><span class="p">):</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <p>(The <code class="highlighter-rouge">#unknown</code> spelling is chosen by analogy with <code class="highlighter-rouge">#selector</code> to not conflict with existing syntax; it is not intended to be a final proposal.)</p> <p>However, this produces potentially surprising results when followed by a case that could also match a particular input. Because <code class="highlighter-rouge">@unknown</code> is only supported on catch-all cases, the input <code class="highlighter-rouge">(.thoughtItWasDueNextWeek, true)</code> would result in case 2 being chosen rather than case 3.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="p">(</span><span class="n">excuse</span><span class="p">,</span> <span class="n">notifiedTeacherBeforeDeadline</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">eatenByPet</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span> <span class="c1">// 1</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="err">#</span><span class="n">unknown</span><span class="p">,</span> <span class="kc">true</span><span class="p">):</span> <span class="c1">// 2</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="o">.</span><span class="n">thoughtItWasDueNextWeek</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span> <span class="c1">// 3</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="kc">false</span><span class="p">):</span> <span class="c1">// 4</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <p>The compiler would warn about this, at least, since there is a known value that can reach the <code class="highlighter-rouge">unknown</code> pattern.</p> <p><code class="highlighter-rouge">@unknown</code> must appear only on the last case in a switch to avoid this issue. However, its not possible to enforce the same thing for arbitrary patterns because there may be multiple enums in the pattern whose unknown cases need to be treated differently.</p> <p>A key point of this discussion is that as proposed <code class="highlighter-rouge">@unknown</code> merely produces a <em>warning</em> when the compiler can see that some enum cases are unhandled, rather than an error. If the compiler produced an error instead, it would make more sense to use a pattern-like syntax for <code class="highlighter-rouge">unknown</code> (see the naming discussions under Alternatives considered). However, if the compiler produced an error, then adding a new case would not be a source-compatible change.</p> <p>For these reasons, generalized <code class="highlighter-rouge">unknown</code> patterns are not being included in this proposal.</p> <h3 id="using-unknown-with-other-catch-all-cases"> <a href="#using-unknown-with-other-catch-all-cases" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Using <code class="highlighter-rouge">@unknown</code> with other catch-all cases </h3> <p>At the moment, <code class="highlighter-rouge">@unknown</code> is only supported on cases that are written as <code class="highlighter-rouge">default:</code> or as <code class="highlighter-rouge">case _:</code>. However, there are other ways to form catch-all cases, such as <code class="highlighter-rouge">case let value:</code>, or <code class="highlighter-rouge">case (_, let b):</code> for a tuple input. Supporting <code class="highlighter-rouge">@unknown</code> with these cases was considered outside the scope of this proposal, which had already gone on for quite a while, but there are no known technical issues with lifting this restriction.</p> <h3 id="non-public-cases"> <a href="#non-public-cases" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Non-public cases </h3> <p>The work required for non-frozen enums also allows for the existence of non-public cases in a public enum. This already shows up in practice in Apples SDKs, as described briefly in the section on C enums above. Like enum inheritance, this kind of behavior can mostly be emulated by using a second enum inside the library, but thats not sufficient if the non-public values need to be vended opaquely to clients.</p> <p>Were such a proposal to be written, I advise that a frozen enum not be permitted to have non-public cases. An enum in a user-defined library would then be implicitly considered frozen if and only if it had no non-public cases.</p> <h3 id="compatibility-checking"> <a href="#compatibility-checking" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Compatibility checking </h3> <p>Of course, the compiler cant stop a library author from adding a new case to a frozen enum, even though that will break source and binary compatibility. We already have two ideas on how we could catch mistakes of this nature:</p> <ul> <li> <p>A checker that can compare APIs across library versions, using swiftmodule files or similar.</p> </li> <li> <p>Encoding the layout of a type in a symbol name. Clients could link against this symbol so that theyd fail to launch if it changes, but even without that an automated system could check the list of exported symbols to make sure nothing was removed.</p> </li> </ul> <p>Frozen enums remain useful even without any automated checking, and such checking should account for more than just enums, so its not being included in this proposal.</p> <h3 id="efficient-representation-of-enums-with-raw-types"> <a href="#efficient-representation-of-enums-with-raw-types" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Efficient representation of enums with raw types </h3> <p>For enums with raw types, a 32-bit integer can be used as the representation rather than a fully opaque value, on the grounds that 4 billion is a reasonable upper limit for the number of distinct cases in an enum without payloads. However, this would make it an ABI-breaking change to add or remove a raw type from an enum, and would make the following definitions not equivalent:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* non-frozen */</span> <span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPMethod</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">case</span> <span class="k">get</span> <span class="o">=</span> <span class="s">"GET"</span>
  <span class="k">case</span> <span class="n">put</span> <span class="o">=</span> <span class="s">"PUT"</span>
  <span class="k">case</span> <span class="n">post</span> <span class="o">=</span> <span class="s">"POST"</span>
  <span class="k">case</span> <span class="n">delete</span> <span class="o">=</span> <span class="s">"DELETE"</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* non-frozen */</span> <span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPMethod</span><span class="p">:</span> <span class="kt">RawRepresentable</span> <span class="p">{</span>
  <span class="k">case</span> <span class="k">get</span>
  <span class="k">case</span> <span class="n">put</span>
  <span class="k">case</span> <span class="n">post</span>
  <span class="k">case</span> <span class="n">delete</span>

  <span class="kd">public</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">rawValue</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">"GET"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="k">get</span>
    <span class="k">case</span> <span class="s">"PUT"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">put</span>
    <span class="k">case</span> <span class="s">"POST"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">post</span>
    <span class="k">case</span> <span class="s">"DELETE"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">delete</span>
    <span class="k">default</span><span class="p">:</span> <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="k">var</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">get</span><span class="p">:</span> <span class="k">return</span> <span class="s">"GET"</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">put</span><span class="p">:</span> <span class="k">return</span> <span class="s">"PUT"</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">post</span><span class="p">:</span> <span class="k">return</span> <span class="s">"POST"</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">delete</span><span class="p">:</span> <span class="k">return</span> <span class="s">"DELETE"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>As such, this representation change is out of scope for this proposal.</p> <h2 id="alternatives-considered"> <a href="#alternatives-considered" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Alternatives considered </h2> <h3 id="terminology-and-syntax"> <a href="#terminology-and-syntax" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Terminology and syntax </h3> <h4 id="terminology-closed-and-open"> <a href="#terminology-closed-and-open" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Terminology: closed and open </h4> <p>The original description of the problem used closed and open to describe frozen and non-frozen enums, respectively. However, this conflicts with the use of <code class="highlighter-rouge">open</code> in classes and their members. In this usage, <code class="highlighter-rouge">open</code> is clearly a greater level of access than <code class="highlighter-rouge">public</code>, in that clients of an <code class="highlighter-rouge">open</code> class can do everything they can with a <code class="highlighter-rouge">public</code> class and more; it is source-compatible to turn a <code class="highlighter-rouge">public</code> class into an <code class="highlighter-rouge">open</code> one. For enums, however, it is frozen enums that are greater: you can do everything you can with a non-frozen enum and more, and it would be source-compatible for a standard library contributor to turn a non-frozen enum into a frozen one (at the cost of a warning).</p> <h4 id="terminology-other-options"> <a href="#terminology-other-options" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Terminology: other options </h4> <p>Several more options were suggested during initial discussions:</p> <ul> <li>complete / incomplete</li> <li>covered</li> <li>exhaustive / non-exhaustive</li> <li>non-extensible</li> <li>final / non-final</li> <li>finite / non-finite (not infinite)</li> <li>fixed</li> <li>locked</li> <li>sealed / non-sealed</li> <li>total / partial</li> </ul> <p>I didnt have a strong preference for any particular choice as long as it <em>isnt</em> closed / open, for the reasons described above. In the first revision of this proposal I picked exhaustive because it matches the name proposed <a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md">in Rust</a>. (Unfortunately, Clangs <code class="highlighter-rouge">enum_extensibility</code> attribute, recently added by us at Apple, uses <code class="highlighter-rouge">open</code> and <code class="highlighter-rouge">closed</code>.)</p> <p>Note that nonextensible does have one problem: Apple already uses <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID206"><code class="highlighter-rouge">NS_TYPED_EXTENSIBLE_ENUM </code></a> to refer to enum-like sets of constants (usually strings) that <em>clients</em> can add cases to. Thats not the same meaning as the exhaustiveness discussed in this proposal.</p> <p>During the first review for this proposal, Brent Royal-Gordon suggested frozen, which was met with general approval or at least no major objections.</p> <h4 id="unknown-naming"> <a href="#unknown-naming" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">unknown</code> naming </h4> <p>The first version of this proposal did not include <code class="highlighter-rouge">unknown</code>, but did discuss it as a considered alternative under the name <code class="highlighter-rouge">future</code>. Previous discussions have also used <code class="highlighter-rouge">unexpected</code> or <code class="highlighter-rouge">undeclared</code> to describe this feature as well.</p> <p>It was pointed out that neither <code class="highlighter-rouge">future</code> nor <code class="highlighter-rouge">unexpected</code> really described the feature being provided. <code class="highlighter-rouge">unknown</code> does not just handle cases added in the future; it also handles private cases and invalid values for C enums. Nor are such cases entirely unexpected, since the compiler is telling the developer to expect them. <code class="highlighter-rouge">undeclared</code> has fewer issues, but certainly private cases can be declared <em>somewhere;</em> the declarations just arent visible.</p> <p>The intermediate revision of this proposal where <code class="highlighter-rouge">unknown</code> was first added used the spelling <code class="highlighter-rouge">unknown case</code>, but restricted the new case to only match values that <em>were</em> enums rather than values <em>containing</em> enums. When that restriction was loosened, the reading of <code class="highlighter-rouge">unknown case</code> as (enum) cases that I dont know about no longer made as much sense.</p> <p>During discussion, the name <code class="highlighter-rouge">unknown default</code> (or <code class="highlighter-rouge">@unknown default</code>) was suggested as an alternative to <code class="highlighter-rouge">unknown case</code>, since the semantics behave very much like <code class="highlighter-rouge">default</code>. However, it isnt the default thats unknown. Other proposed spellings included <code class="highlighter-rouge">default unknown</code> (a simple attempt to avoid reading unknown as an adjective modifying default) and <code class="highlighter-rouge">default(unknown)</code> (by analogy with <code class="highlighter-rouge">private(set)</code>). Nevertheless, this attribute syntax won out in the end by not tying it to <code class="highlighter-rouge">default</code>; the alternate spelling <code class="highlighter-rouge">@unknown case _</code> is also accepted.</p> <p>Moving away from unknown, <code class="highlighter-rouge">@unused default</code> was also suggested, but the case is <em>not</em> unused. A more accurate <code class="highlighter-rouge">@runtimeReachableOnly</code> (or even <code class="highlighter-rouge">@runtimeOnly</code>) was proposed instead, but thats starting to get overly verbose for something that will appear reasonably often.</p> <p>For standalone names, <code class="highlighter-rouge">fallback</code> was also suggested, but semantically that seems a little too close to default, and in terms of actual keywords it was pointed out that this was very similar to <code class="highlighter-rouge">fallthrough</code> despite having no relation. <code class="highlighter-rouge">invisible</code> was suggested as well (though in the context of patterns rather than cases), but that doesnt exactly apply to future cases.</p> <p>To summarize, the following spellings were considered for <code class="highlighter-rouge">unknown</code>:</p> <ul> <li><code class="highlighter-rouge">future:</code></li> <li><code class="highlighter-rouge">unexpected:</code></li> <li><code class="highlighter-rouge">undeclared:</code></li> <li><code class="highlighter-rouge">unknown case:</code></li> <li><code class="highlighter-rouge">unknown default:</code></li> <li><code class="highlighter-rouge">@unknown default:</code></li> <li><code class="highlighter-rouge">@unused default:</code></li> <li><code class="highlighter-rouge">@runtimeReachableOnly default:</code></li> <li><code class="highlighter-rouge">default unknown:</code></li> <li><code class="highlighter-rouge">default(unknown):</code></li> <li><code class="highlighter-rouge">fallback:</code></li> <li><code class="highlighter-rouge">invisible:</code></li> </ul> <p>For the review of the proposal, I picked <code class="highlighter-rouge">unknown:</code> as the best option, admittedly as much for <em>not</em> having <em>unwanted</em> connotations as for having <em>good</em> connotations. The core team ultimately went with <code class="highlighter-rouge">@unknown default:</code> / <code class="highlighter-rouge">@unknown case _:</code> instead.</p> <p>A bigger change would be to make a custom <em>pattern</em> instead of a custom <em>case,</em> even if it were subject to the same restrictions in implementation (see <code class="highlighter-rouge">unknown</code> patterns above). This usually meant using a symbol of some kind to distinguish the unknown from a normal label or pattern, leading to <code class="highlighter-rouge">case #unknown</code> or similar. This makes the new feature less special, since its just another pattern. However, it would be surprising to have such a pattern but keep the restrictions described in this proposal; thus, it would only make sense to do this if we were going to implement fully general pattern-matching for this feature. See <code class="highlighter-rouge">unknown</code> patterns above for more discussion.</p> <p>Finally, there was the option to put an annotation on a <code class="highlighter-rouge">switch</code> instead of customizing the catch-all case, e.g. <code class="highlighter-rouge">@warnUnknownCases switch x {</code>. This is implementable but feels easier for a developer to forget to write, and the compiler can only help if the developer actually <em>has</em> implemented all of the current cases alongside their <code class="highlighter-rouge">default</code> case.</p> <h3 id="switch"> <a href="#switch" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">switch!</code> </h3> <p><code class="highlighter-rouge">switch!</code> was an alternative to <code class="highlighter-rouge">@unknown</code> that would not support any action other than trapping when the enum is not one of the known cases. This avoids some of the problems with <code class="highlighter-rouge">@unknown</code> (such as making it much less important to test), but isnt exactly in the spirit of non-frozen enums, where you <em>know</em> there will be more cases in the future.</p> <p>The following two examples would be equivalent (except perhaps in the form of the diagnostic produced).</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span><span class="o">!</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">eatenByPet</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="o">.</span><span class="nv">thoughtItWasDueNextWeek</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">eatenByPet</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="o">.</span><span class="nv">thoughtItWasDueNextWeek</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="nv">unknown</span><span class="p">:</span>
  <span class="nf">fatalError</span><span class="p">(</span><span class="s">"unknown case in switch: </span><span class="se">\(</span><span class="n">excuse</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="testing-invalid-cases"> <a href="#testing-invalid-cases" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Testing invalid cases </h3> <p>Another issue with non-frozen enums is that clients cannot properly test what happens when a new case is introduced, almost by definition. Brent Royal-Gordon came up with the idea to have a new type annotation that would allow the creation of an invalid enum value. Since this is only something to use for testing, the initial version of the idea used <code class="highlighter-rouge">@testable</code> as the spelling for the annotation. The tests could then use a special expression, <code class="highlighter-rouge">#invalid</code>, to pass this invalid value to a function with a <code class="highlighter-rouge">@testable</code> enum parameter.</p> <p>However, this would only work in cases where the action to be taken does not actually depend on the enum value. If it needs to be passed to the original library that owns the enum, or used with an API that is not does not have this annotation, the code still cannot be tested properly.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="n">_</span> <span class="nv">transaction</span><span class="p">:</span> <span class="kd">@testable</span> <span class="kt">Transaction</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">transaction</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">.</span><span class="nf">deposit</span><span class="p">(</span><span class="k">let</span> <span class="nv">amount</span><span class="p">):</span>
    <span class="c1">// </span>
  <span class="k">case</span> <span class="o">.</span><span class="nf">withdrawal</span><span class="p">(</span><span class="k">let</span> <span class="nv">amount</span><span class="p">):</span>
    <span class="c1">// </span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">process</span><span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="c1">// hmm</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is an additive feature, so we can come back and consider it in more detail even if we leave it out of the language for now. Meanwhile, the effect can be imitated using an Optional or ImplicitlyUnwrappedOptional parameter.</p> <h3 id="allow-enums-defined-in-source-packages-to-be-considered-non-frozen"> <a href="#allow-enums-defined-in-source-packages-to-be-considered-non-frozen" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Allow enums defined in source packages to be considered non-frozen </h3> <p>The first version of this proposal applied the frozen/non-frozen distinction to all public enums, even those in user-defined libraries. The motivation for this was to allow package authors to add cases to their enums without it being a source-breaking change, meaning it can be done in a minor version release of a library (i.e. one intended to be backwards-compatible). Like deprecations, this can produce new warnings, but not new errors, and it should not (if done carefully) break existing code.</p> <p>The core team decided that this feature was not worth the disruption and long-term inconvenience it would cause for users who did not care about this capability.</p> <h3 id="leave-out-unknown"> <a href="#leave-out-unknown" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Leave out <code class="highlighter-rouge">@unknown</code> </h3> <p>The <a href="https://github.com/apple/swift-evolution/blob/a773d07ff4beab8b7855adf0ac56d1e13bb7b44c/proposals/0192-non-exhaustive-enums.md">initial version</a> of this proposal did not include <code class="highlighter-rouge">@unknown</code>, and required people to use a normal <code class="highlighter-rouge">default</code> to handle cases added in the future instead. However, many people were unhappy with the loss of exhaustivity checking for <code class="highlighter-rouge">switch</code> statements, both for enums in libraries distributed as source and enums imported from Apples SDKs. While this is an additive feature that does not affect ABI, it seems to be one that the community considers a necessary part of a language model that provides non-frozen enums.</p> <h3 id="mixing-unknown-with-other-catch-all-cases"> <a href="#mixing-unknown-with-other-catch-all-cases" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Mixing <code class="highlighter-rouge">@unknown</code> with other catch-all cases </h3> <p>The proposal as written forbids having two catch-all cases in the same <code class="highlighter-rouge">switch</code> where only one is marked <code class="highlighter-rouge">@unknown</code>. Most people would expect this to have the following behavior:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">eatenByPet</span><span class="p">:</span>
  <span class="c1">// Specific known case</span>
<span class="kd">@unknown</span> <span class="k">case</span> <span class="nv">_</span><span class="p">:</span>
  <span class="c1">// Any cases not recognized by the compiler</span>
<span class="k">case</span> <span class="nv">_</span><span class="p">:</span>
  <span class="c1">// Any other cases the compiler *does* know about,</span>
  <span class="c1">// such as .thoughtItWasDueNextWeek</span>
<span class="p">}</span>
</code></pre></div></div> <p>However, I cant think of an actual use case for this; its not clear what action one would take in the <code class="highlighter-rouge">@unknown</code> case that they wouldnt take in the later default case. Furthermore, this becomes a situation where the same code behaves differently before and after recompilation:</p> <ol> <li>A new case is added to the HomeworkExcuse enum, say, <code class="highlighter-rouge">droppedInMud</code>.</li> <li>When using the new version of the library with an existing built client app, the <code class="highlighter-rouge">droppedInMud</code> case will end up in the <code class="highlighter-rouge">@unknown</code> part of the <code class="highlighter-rouge">switch</code>.</li> <li>When the client app <em>is</em> recompiled, the <code class="highlighter-rouge">droppedInMud</code> case will end up in the <code class="highlighter-rouge">case _</code> case. The compiler will not (and cannot) provide any indication that the behavior has changed.</li> </ol> <p>Without a resolution to these concerns, this feature does not seem worth including in the proposal. Its also additive and has no ABI impact, so if we do find use cases for it in the future we can always add it then.</p> <h3 id="introduce-a-new-declaration-kind-instead"> <a href="#introduce-a-new-declaration-kind-instead" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduce a new declaration kind instead </h3> <p>There have been a few suggestions to distinguish <code class="highlighter-rouge">enum</code> from some other kind of declaration that acts similarly but allows adding cases:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">choices</span> <span class="kt">HomeworkExcuse</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">eatenByPet</span>
  <span class="k">case</span> <span class="n">thoughtItWasDueNextWeek</span>
<span class="p">}</span>
</code></pre></div></div> <p>My biggest concern with this is that if we ever <em>do</em> expand this beyond the standard library and overlays, it increases the possibility of a library author accidentally publishing a (frozen) <code class="highlighter-rouge">enum</code> when they meant to publish a (non-frozen) <code class="highlighter-rouge">choices</code>. As described above, the opposite mistake is one that can be corrected without breaking source compatibility, but this one cannot.</p> <p>A smaller concern is that both <code class="highlighter-rouge">enum</code> and <code class="highlighter-rouge">choices</code> would behave the same when they <em>arent</em> <code class="highlighter-rouge">public</code>.</p> <p>Stepping back, increasing the surface area of the language in this way does not seem desirable. Exhaustive switching has been a key part of how Swift enums work, but it is not their only feature. Given how people already struggle with the decision of struct vs. class when defining a new type, introducing another pair of similar but different declaration kinds would have to come with strong benefits.</p> <p>My conclusion is that it is better to think of frozen and non-frozen enums as two variants of the same declaration kind, rather than as two different declaration kinds.</p> <h3 id="use-protocols-instead"> <a href="#use-protocols-instead" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Use protocols instead </h3> <p>Everything you can do with non-frozen enums, you can do with protocols as well, except for:</p> <ul> <li>exhaustivity checking with <code class="highlighter-rouge">@unknown</code></li> <li>forbidding others from adding their own cases</li> </ul> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">HomeworkExcuse</span> <span class="p">{}</span>
<span class="kd">struct</span> <span class="kt">EatenByPet</span><span class="p">:</span> <span class="kt">HomeworkExcuse</span> <span class="p">{}</span>
<span class="kd">struct</span> <span class="kt">ThoughtItWasDueNextWeek</span><span class="p">:</span> <span class="kt">HomeworkExcuse</span> <span class="p">{}</span>

<span class="k">switch</span> <span class="n">excuse</span> <span class="p">{</span>
<span class="k">case</span> <span class="k">is</span> <span class="kt">EatenByPet</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="k">case</span> <span class="k">is</span> <span class="kt">ThoughtItWasDueNextWeek</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="k">default</span><span class="p">:</span>
  <span class="c1">// </span>
<span class="p">}</span>
</code></pre></div></div> <p>(Associated values are a little harder to get out of the cases, but lets assume we could come up for syntax as well.)</p> <p>This is a valid model; its close to what Scala does (as mentioned above), and is independently useful in Swift. However, using this as the only way to get non-frozen enum semantics would lead to a world where <code class="highlighter-rouge">enum</code> is dangerous for library authors, because <code class="highlighter-rouge">public enum</code> is now a promise that no new cases will be added. Nothing else in Swift works that way. More practically, getting around this restriction would mean rewriting existing code to use the more verbose syntax of separate types conforming to a common protocol.</p> <p>(If Swift were younger, perhaps we would consider using protocols for <em>all</em> non-imported enums, not just non-frozen ones. But at this point that would be <em>way</em> too big a change to the language.)</p> <h3 id="import-non-frozen-c-enums-as-rawrepresentable-structs"> <a href="#import-non-frozen-c-enums-as-rawrepresentable-structs" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Import non-frozen C enums as RawRepresentable structs </h3> <p>The Swift compiler already makes a distinction between plain C enums, enums marked with the <code class="highlighter-rouge">flag_enum</code> Clang attribute (<code class="highlighter-rouge">NS_OPTIONS</code>), and enums marked with the <code class="highlighter-rouge">enum_extensibility</code> Clang attribute (<code class="highlighter-rouge">NS_ENUM</code>). The first two categories were deemed to not be sufficiently similar to Swift enums and are imported instead as structs. Given that were most immediately concerned about <em>C</em> enums growing new cases (specifically, those in Apples existing Objective-C SDKs), we could sidestep the problem by importing <em>all</em> C enums as structs except for those marked <code class="highlighter-rouge">enum_extensibility(closed)</code>. However, this doesnt solve the problem for future Swift libraries, while still requiring changes to existing <code class="highlighter-rouge">switch</code> statements across many many projects, and it doesnt support the exhaustivity checking provided by <code class="highlighter-rouge">unknown</code>. Furthermore, it would probably be harder to implement high-quality migration support from Swift 4 to Swift 5, since the structs-formerly-enums will look like any other structs imported from C.</p> <h3 id="get-apple-to-stop-adding-new-cases-to-c-enums"> <a href="#get-apple-to-stop-adding-new-cases-to-c-enums" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Get Apple to stop adding new cases to C enums </h3> <p>This isnt going to happen, but I thought Id mention it since it was brought up during discussion. While some may consider this a distasteful use of the C language, its an established pattern for Apple frameworks and is not going to change.</p> <h3 id="can-there-be-a-kind-of-open-enum-where-you-can-add-new-cases-in-extensions"> <a href="#can-there-be-a-kind-of-open-enum-where-you-can-add-new-cases-in-extensions" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Can there be a kind of open enum where you can add new cases in extensions? </h3> <p>There is no push to allow adding new cases to an enum from <em>outside</em> a library. This use case (no pun intended) is more appropriate for a RawRepresentable struct, where the library defines some initial values as static properties. (You can already switch over struct values in Swift as long as they are Equatable.)</p> </div> </div> </div> </div> </body> </html>
