<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>SE-0166 Swift Archival & Serialization - Swift Evolution List</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>SE-0166 Swift Archival &amp; Serialization | Swift Evolution List</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="SE-0166 Swift Archival &amp; Serialization" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Yuhuu!" /> <meta property="og:description" content="Yuhuu!" /> <link rel="canonical" href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" /> <meta property="og:url" content="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" /> <meta property="og:site_name" content="Swift Evolution List" /> <script type="application/ld+json"> {"url":"http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html","headline":"SE-0166 Swift Archival &amp; Serialization","description":"Yuhuu!","@type":"WebPage","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Swift Evolution List</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/about/" class="navigation-list-link">About</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html" class="navigation-list-link">SE-0001 Allow (most) keywords as argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0002-remove-currying.html" class="navigation-list-link">SE-0002 Removing currying `func` declaration syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html" class="navigation-list-link">SE-0003 Removing `var` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html" class="navigation-list-link">SE-0004 Remove the `++` and `--` operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html" class="navigation-list-link">SE-0005 Better Translation of Objective-C APIs Into Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html" class="navigation-list-link">SE-0006 Apply API Guidelines to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html" class="navigation-list-link">SE-0007 Remove C-style for-loops with conditions and incrementers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html" class="navigation-list-link">SE-0008 Add a Lazy flatMap for Sequences of Optionals #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html" class="navigation-list-link">SE-0009 Require self for accessing instance members</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html" class="navigation-list-link">SE-0010 Add StaticString.UnicodeScalarView</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html" class="navigation-list-link">SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html" class="navigation-list-link">SE-0012 Add `@noescape` to public library API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html" class="navigation-list-link">SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html" class="navigation-list-link">SE-0014 Constraining `AnySequence.init`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html" class="navigation-list-link">SE-0015 Tuple comparison operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html" class="navigation-list-link">SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html" class="navigation-list-link">SE-0017 Change `Unmanaged` to use `UnsafePointer`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html" class="navigation-list-link">SE-0018 Flexible Memberwise Initialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html" class="navigation-list-link">SE-0019 Swift Testing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html" class="navigation-list-link">SE-0020 Swift Language Version Build Configuration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html" class="navigation-list-link">SE-0021 Naming Functions with Argument Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html" class="navigation-list-link">SE-0022 Referencing the Objective-C selector of a method</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html" class="navigation-list-link">SE-0023 API Design Guidelines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html" class="navigation-list-link">SE-0024 Optional Value Setter `??=`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html" class="navigation-list-link">SE-0025 Scoped Access Level</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html" class="navigation-list-link">SE-0026 Abstract classes and methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html" class="navigation-list-link">SE-0027 Expose code unit initializers on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html" class="navigation-list-link">SE-0028 Modernizing Swift's Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html" class="navigation-list-link">SE-0029 Remove implicit tuple splat behavior from function applications</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html" class="navigation-list-link">SE-0030 Property Behaviors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html" class="navigation-list-link">SE-0031 Adjusting `inout` Declarations for Type Decoration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html" class="navigation-list-link">SE-0032 Add `first(where:)` method to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html" class="navigation-list-link">SE-0033 Import Objective-C Constants as Swift Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html" class="navigation-list-link">SE-0034 Disambiguating Line Control Statements from Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html" class="navigation-list-link">SE-0035 Limiting `inout` capture to `@noescape` contexts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0036-enum-dot.html" class="navigation-list-link">SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html" class="navigation-list-link">SE-0037 Clarify interaction between comments & operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html" class="navigation-list-link">SE-0038 Package Manager C Language Target Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html" class="navigation-list-link">SE-0039 Modernizing Playground Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0040-attributecolons.html" class="navigation-list-link">SE-0040 Replacing Equal Signs with Colons For Attribute Arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html" class="navigation-list-link">SE-0041 Updating Protocol Naming Conventions for Conversions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html" class="navigation-list-link">SE-0042 Flattening the function type of unapplied method references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html" class="navigation-list-link">SE-0043 Declare variables in 'case' labels with multiple patterns </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0044-import-as-member.html" class="navigation-list-link">SE-0044 Import as member</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html" class="navigation-list-link">SE-0045 Add prefix(while:) and drop(while:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0046-first-label.html" class="navigation-list-link">SE-0046 Establish consistent label behavior across all parameters including first labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html" class="navigation-list-link">SE-0047 Defaulting non-Void functions so they warn on unused results</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html" class="navigation-list-link">SE-0048 Generic Type Aliases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html" class="navigation-list-link">SE-0049 Move @noescape and @autoclosure to be type attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html" class="navigation-list-link">SE-0050 Decoupling Floating Point Strides from Generic Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html" class="navigation-list-link">SE-0051 Conventionalizing `stride` semantics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html" class="navigation-list-link">SE-0052 Change IteratorType post-nil guarantee</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html" class="navigation-list-link">SE-0053 Remove explicit use of `let` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html" class="navigation-list-link">SE-0054 Abolish `ImplicitlyUnwrappedOptional` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html" class="navigation-list-link">SE-0055 Make unsafe pointer nullability explicit using Optional</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html" class="navigation-list-link">SE-0056 Allow trailing closures in `guard` conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html" class="navigation-list-link">SE-0057 Importing Objective-C Lightweight Generics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html" class="navigation-list-link">SE-0058 Allow Swift types to provide custom Objective-C representations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html" class="navigation-list-link">SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html" class="navigation-list-link">SE-0060 Enforcing order of defaulted parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html" class="navigation-list-link">SE-0061 Add Generic Result and Error Handling to autoreleasepool()</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html" class="navigation-list-link">SE-0062 Referencing Objective-C key-paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html" class="navigation-list-link">SE-0063 SwiftPM System Module Search Paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0064-property-selectors.html" class="navigation-list-link">SE-0064 Referencing the Objective-C selector of property getters and setters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html" class="navigation-list-link">SE-0065 A New Model for Collections and Indices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html" class="navigation-list-link">SE-0066 Standardize function type argument syntax to require parentheses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html" class="navigation-list-link">SE-0067 Enhanced Floating Point Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0068-universal-self.html" class="navigation-list-link">SE-0068 Expanding Swift `Self` to class members and value types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html" class="navigation-list-link">SE-0069 Mutability and Foundation Value Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html" class="navigation-list-link">SE-0070 Make Optional Requirements Objective-C-only</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0071-member-keywords.html" class="navigation-list-link">SE-0071 Allow (most) keywords in member references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html" class="navigation-list-link">SE-0072 Fully eliminate implicit bridging conversions from Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0073-noescape-once.html" class="navigation-list-link">SE-0073 Marking closures as executing exactly once</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0074-binary-search.html" class="navigation-list-link">SE-0074 Implementation of Binary Search functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0075-import-test.html" class="navigation-list-link">SE-0075 Adding a Build Configuration Import Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html" class="navigation-list-link">SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html" class="navigation-list-link">SE-0077 Improved operator declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html" class="navigation-list-link">SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html" class="navigation-list-link">SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html" class="navigation-list-link">SE-0080 Failable Numeric Conversion Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html" class="navigation-list-link">SE-0081 Move `where` clause to end of declaration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html" class="navigation-list-link">SE-0082 Package Manager Editable Packages</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html" class="navigation-list-link">SE-0083 Remove bridging conversion behavior from dynamic casts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html" class="navigation-list-link">SE-0084 Allow trailing commas in parameter lists and tuples</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html" class="navigation-list-link">SE-0085 Package Manager Command Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html" class="navigation-list-link">SE-0086 Drop NS Prefix in Swift Foundation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html" class="navigation-list-link">SE-0087 Rename `lazy` to `@lazy`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html" class="navigation-list-link">SE-0088 Modernize libdispatch for Swift 3 naming conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html" class="navigation-list-link">SE-0089 Renaming `String.init<T>(_: T)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html" class="navigation-list-link">SE-0090 Remove `.self` and freely allow type references in expressions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html" class="navigation-list-link">SE-0091 Improving operator requirements in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html" class="navigation-list-link">SE-0092 Typealiases in protocols and protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0093-slice-base.html" class="navigation-list-link">SE-0093 Adding a public `base` property to slices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0094-sequence-function.html" class="navigation-list-link">SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html" class="navigation-list-link">SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0096-dynamictype.html" class="navigation-list-link">SE-0096 Converting `dynamicType` from a property to an operator</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html" class="navigation-list-link">SE-0097 Normalizing naming for "negative" attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html" class="navigation-list-link">SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html" class="navigation-list-link">SE-0099 Restructuring Condition Clauses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html" class="navigation-list-link">SE-0100 Add sequence-based initializers and merge methods to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html" class="navigation-list-link">SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html" class="navigation-list-link">SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html" class="navigation-list-link">SE-0103 Make non-escaping closures the default</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0104-improved-integers.html" class="navigation-list-link">SE-0104 Protocol-oriented integers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html" class="navigation-list-link">SE-0105 Removing Where Clauses from For-In Loops</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html" class="navigation-list-link">SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" class="navigation-list-link">SE-0107 UnsafeRawPointer API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html" class="navigation-list-link">SE-0108 Remove associated type inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html" class="navigation-list-link">SE-0109 Remove the `Boolean` protocol </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html" class="navigation-list-link">SE-0110 Distinguish between single-tuple and multiple-argument function types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html" class="navigation-list-link">SE-0111 Remove type system significance of function argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html" class="navigation-list-link">SE-0112 Improved NSError Bridging</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html" class="navigation-list-link">SE-0113 Add integral rounding functions to FloatingPoint</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html" class="navigation-list-link">SE-0114 Updating Buffer "Value" Names to "Header" Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html" class="navigation-list-link">SE-0115 Rename Literal Syntax Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0116-id-as-any.html" class="navigation-list-link">SE-0116 Import Objective-C `id` as Swift `Any` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html" class="navigation-list-link">SE-0117 Allow distinguishing between public access and public overridability</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html" class="navigation-list-link">SE-0118 Closure Parameter Names and Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html" class="navigation-list-link">SE-0119 Remove access modifiers from extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html" class="navigation-list-link">SE-0120 Revise `partition` Method Signature</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html" class="navigation-list-link">SE-0121 Remove `Optional` Comparison Operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html" class="navigation-list-link">SE-0122 Use colons for subscript declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html" class="navigation-list-link">SE-0123 Disallow coercion to optionals in operator arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html" class="navigation-list-link">SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html" class="navigation-list-link">SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html" class="navigation-list-link">SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html" class="navigation-list-link">SE-0127 Cleaning up stdlib Pointer and Buffer Routines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html" class="navigation-list-link">SE-0128 Change failable UnicodeScalar initializers to failable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html" class="navigation-list-link">SE-0129 Package Manager Test Naming Conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html" class="navigation-list-link">SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0131-anyhashable.html" class="navigation-list-link">SE-0131 Add `AnyHashable` to the standard library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html" class="navigation-list-link">SE-0132 Rationalizing Sequence end-operation names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html" class="navigation-list-link">SE-0133 Rename `flatten()` to `joined()`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html" class="navigation-list-link">SE-0134 Rename two UTF8-related properties on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html" class="navigation-list-link">SE-0135 Package Manager Support for Differentiating Packages by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html" class="navigation-list-link">SE-0136 Memory layout of values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html" class="navigation-list-link">SE-0137 Avoiding Lock-In to Legacy Protocol Designs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" class="navigation-list-link">SE-0138 UnsafeRawBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html" class="navigation-list-link">SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html" class="navigation-list-link">SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html" class="navigation-list-link">SE-0141 Availability by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html" class="navigation-list-link">SE-0142 Permit where clauses to constrain associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" class="navigation-list-link">SE-0143 Conditional conformances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html" class="navigation-list-link">SE-0144 Allow Single Dollar Sign as a Valid Identifier</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html" class="navigation-list-link">SE-0145 Package Manager Version Pinning</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html" class="navigation-list-link">SE-0146 Package Manager Product Definitions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html" class="navigation-list-link">SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html" class="navigation-list-link">SE-0148 Generic Subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html" class="navigation-list-link">SE-0149 Package Manager Support for Top of Tree development</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html" class="navigation-list-link">SE-0150 Package Manager Support for branches</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html" class="navigation-list-link">SE-0151 Package Manager Swift Language Compatibility Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html" class="navigation-list-link">SE-0152 Package Manager Tools Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html" class="navigation-list-link">SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html" class="navigation-list-link">SE-0154 Provide Custom Collections for Dictionary Keys and Values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html" class="navigation-list-link">SE-0155 Normalize Enum Case Representation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html" class="navigation-list-link">SE-0156 Class and Subtype existentials</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html" class="navigation-list-link">SE-0157 Support recursive constraints on associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html" class="navigation-list-link">SE-0158 Package Manager Manifest API Redesign</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html" class="navigation-list-link">SE-0159 Fix Private Access Levels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0160-objc-inference.html" class="navigation-list-link">SE-0160 Limiting `@objc` inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0161-key-paths.html" class="navigation-list-link">SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html" class="navigation-list-link">SE-0162 Package Manager Custom Target Layouts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html" class="navigation-list-link">SE-0163 String Revision: Collection Conformance, C Interop, Transcoding</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html" class="navigation-list-link">SE-0164 Remove final support in protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0165-dict.html" class="navigation-list-link">SE-0165 Dictionary & Set Enhancements</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" class="navigation-list-link active">SE-0166 Swift Archival & Serialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html" class="navigation-list-link">SE-0167 Swift Encoders</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html" class="navigation-list-link">SE-0168 Multi-Line String Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html" class="navigation-list-link">SE-0169 Improve Interaction Between `private` Declarations and Extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html" class="navigation-list-link">SE-0170 NSNumber bridging and Numeric types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html" class="navigation-list-link">SE-0171 Reduce with `inout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html" class="navigation-list-link">SE-0172 One-sided Ranges</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0173-swap-indices.html" class="navigation-list-link">SE-0173 Add `MutableCollection.swapAt(_:_:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html" class="navigation-list-link">SE-0174 Change `filter` to return an associated type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html" class="navigation-list-link">SE-0175 Package Manager Revised Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" class="navigation-list-link">SE-0176 Enforce Exclusive Access to Memory</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html" class="navigation-list-link">SE-0177 Add clamp(to:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html" class="navigation-list-link">SE-0178 Add `unicodeScalars` property to `Character`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html" class="navigation-list-link">SE-0179 Swift `run` Command</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html" class="navigation-list-link">SE-0180 String Index Overhaul</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html" class="navigation-list-link">SE-0181 Package Manager C/C++ Language Standard Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html" class="navigation-list-link">SE-0182 String Newline Escaping</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html" class="navigation-list-link">SE-0183 Substring performance affordances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html" class="navigation-list-link">SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html" class="navigation-list-link">SE-0185 Synthesizing `Equatable` and `Hashable` conformance</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html" class="navigation-list-link">SE-0186 Remove ownership keyword support in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html" class="navigation-list-link">SE-0187 Introduce Sequence.compactMap(_:)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html" class="navigation-list-link">SE-0188 Make Standard Library Index Types Hashable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html" class="navigation-list-link">SE-0189 Restrict Cross-module Struct Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html" class="navigation-list-link">SE-0190 Target environment platform condition</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html" class="navigation-list-link">SE-0191 Eliminate `IndexDistance` from `Collection`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" class="navigation-list-link">SE-0192 Handling Future Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html" class="navigation-list-link">SE-0193 Cross-module inlining and specialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html" class="navigation-list-link">SE-0194 Derived Collection of Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html" class="navigation-list-link">SE-0195 Introduce User-defined "Dynamic Member Lookup" Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html" class="navigation-list-link">SE-0196 Compiler Diagnostic Directives</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0197-remove-where.html" class="navigation-list-link">SE-0197 Adding in-place `removeAll(where:)` to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html" class="navigation-list-link">SE-0198 Playground QuickLook API Revamp #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html" class="navigation-list-link">SE-0199 Adding `toggle` to `Bool`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html" class="navigation-list-link">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html" class="navigation-list-link">SE-0201 Package Manager Local Dependencies</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0202-random-unification.html" class="navigation-list-link">SE-0202 Random Unification</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html" class="navigation-list-link">SE-0203 Rename Sequence.elementsEqual</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html" class="navigation-list-link">SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html" class="navigation-list-link">SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html" class="navigation-list-link">SE-0206 Hashable Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0207-containsOnly.html" class="navigation-list-link">SE-0207 Add an `allSatisfy` algorithm to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html" class="navigation-list-link">SE-0208 Package Manager System Library Targets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html" class="navigation-list-link">SE-0209 Package Manager Swift Language Version API Update</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html" class="navigation-list-link">SE-0210 Add an `offset(of:)` method to `MemoryLayout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html" class="navigation-list-link">SE-0211 Add Unicode Properties to `Unicode.Scalar`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html" class="navigation-list-link">SE-0212 Compiler Version Directive</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html" class="navigation-list-link">SE-0213 Literal initialization via coercion</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html" class="navigation-list-link">SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html" class="navigation-list-link">SE-0215 Conform `Never` to `Equatable` and `Hashable`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html" class="navigation-list-link">SE-0216 Introduce user-defined dynamically "callable" types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0217-bangbang.html" class="navigation-list-link">SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html" class="navigation-list-link">SE-0218 Introduce `compactMapValues` to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html" class="navigation-list-link">SE-0219 Package Manager Dependency Mirroring</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0220-count-where.html" class="navigation-list-link">SE-0220 `count(where:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0221-character-properties.html" class="navigation-list-link">SE-0221 Character Properties</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html" class="navigation-list-link">SE-0222 Lazy CompactMap Sequence</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html" class="navigation-list-link">SE-0223 Accessing an Array's Uninitialized Buffer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html" class="navigation-list-link">SE-0224 Support 'less than' operator in compilation conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html" class="navigation-list-link">SE-0225 Adding `isMultiple` to `BinaryInteger`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html" class="navigation-list-link">SE-0226 Package Manager Target Based Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html" class="navigation-list-link">SE-0227 Identity key path</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html" class="navigation-list-link">SE-0228 Fix `ExpressibleByStringInterpolation`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0229-simd.html" class="navigation-list-link">SE-0229 SIMD Vectors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html" class="navigation-list-link">SE-0230 Flatten nested optionals resulting from 'try?'</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html" class="navigation-list-link">SE-0231 Optional Iteration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html" class="navigation-list-link">SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html" class="navigation-list-link">SE-0233 Make `Numeric` Refine a new `AdditiveArithmetic` Protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html" class="navigation-list-link">SE-0234 Remove `Sequence.SubSequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0235-add-result.html" class="navigation-list-link">SE-0235 Add Result to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html" class="navigation-list-link">SE-0236 Package Manager Platform Deployment Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html" class="navigation-list-link">SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html" class="navigation-list-link">SE-0238 Package Manager Target Specific Build Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0239-codable-range.html" class="navigation-list-link">SE-0239 Add Codable conformance to Range types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html" class="navigation-list-link">SE-0240 Ordered Collection Diffing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html" class="navigation-list-link">SE-0241 Deprecate String Index Encoded Offsets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html" class="navigation-list-link">SE-0242 Synthesize default values for the memberwise initializer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html" class="navigation-list-link">SE-0243 Integer-convertible character literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html" class="navigation-list-link">SE-0244 Opaque Result Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html" class="navigation-list-link">SE-0245 Add an Array Initializer with Access to Uninitialized Storage</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0246-mathable.html" class="navigation-list-link">SE-0246 Generic Math(s) Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html" class="navigation-list-link">SE-0247 Contiguous Strings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html" class="navigation-list-link">SE-0248 String Gaps and Missing APIs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html" class="navigation-list-link">SE-0249 Key Path Expressions as Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html" class="navigation-list-link">SE-0250 Swift Code Style Guidelines and Formatter</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0251-simd-additions.html" class="navigation-list-link">SE-0251 SIMD additions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html" class="navigation-list-link">SE-0252 Key Path Member Lookup</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0253-callable.html" class="navigation-list-link">SE-0253 Introduce callables </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html" class="navigation-list-link">SE-0254 Static and class subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0255-omit-return.html" class="navigation-list-link">SE-0255 Implicit returns from single-expression functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html" class="navigation-list-link">SE-0256 Introduce `{Mutable}ContiguousCollection` protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0257-elide-comma.html" class="navigation-list-link">SE-0257 Eliding commas from multiline expression lists</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html" class="navigation-list-link"> Feature name</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Swift Evolution List" aria-label="Search Swift Evolution List" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/pondok-programmer/swift-evolution-jekyll">Swift Evolution List</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h1 id="swift-archival--serialization"> <a href="#swift-archival--serialization" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Swift Archival &amp; Serialization </h1> <ul> <li>Proposal: <a href="0166-swift-archival-serialization.md">SE-0166</a></li> <li>Authors: <a href="https://github.com/itaiferber">Itai Ferber</a>, <a href="https://github.com/mlehew">Michael LeHew</a>, <a href="https://github.com/parkera">Tony Parker</a></li> <li>Review Manager: <a href="https://github.com/DougGregor">Doug Gregor</a></li> <li>Status: <strong>Implemented (Swift 4)</strong></li> <li>Decision Notes: <a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-April/000367.html">Rationale</a></li> <li>Implementation: <a href="https://github.com/apple/swift/pull/9004">apple/swift#9004</a></li> </ul> <h2 id="introduction"> <a href="#introduction" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduction </h2> <p>Foundation’s current archival and serialization APIs (<code class="highlighter-rouge">NSCoding</code>, <code class="highlighter-rouge">NSJSONSerialization</code>, <code class="highlighter-rouge">NSPropertyListSerialization</code>, etc.), while fitting for the dynamism of Objective-C, do not always map optimally into Swift. This document lays out the design of an updated API that improves the developer experience of performing archival and serialization in Swift.</p> <p>Specifically:</p> <ul> <li>It aims to provide a solution for the archival of Swift <code class="highlighter-rouge">struct</code> and <code class="highlighter-rouge">enum</code> types</li> <li>It aims to provide a more type-safe solution for serializing to external formats, such as JSON and plist</li> </ul> <h2 id="motivation"> <a href="#motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Motivation </h2> <p>The primary motivation for this proposal is the inclusion of native Swift <code class="highlighter-rouge">enum</code> and <code class="highlighter-rouge">struct</code> types in archival and serialization. Currently, developers targeting Swift cannot participate in <code class="highlighter-rouge">NSCoding</code> without being willing to abandon <code class="highlighter-rouge">enum</code> and <code class="highlighter-rouge">struct</code> types — <code class="highlighter-rouge">NSCoding</code> is an <code class="highlighter-rouge">@objc</code> protocol, conformance to which excludes non-<code class="highlighter-rouge">class</code> types. This can be limiting in Swift because small <code class="highlighter-rouge">enums</code> and <code class="highlighter-rouge">structs</code> can be an idiomatic approach to model representation; developers who wish to perform archival have to either forgo the Swift niceties that constructs like <code class="highlighter-rouge">enums</code> provide, or provide an additional compatibility layer between their “real” types and their archivable types.</p> <p>Secondarily, we would like to refine Foundation’s existing serialization APIs (<code class="highlighter-rouge">NSJSONSerialization</code> and <code class="highlighter-rouge">NSPropertyListSerialization</code>) to better match Swift’s strong type safety. From experience, we find that the conversion from the unstructured, untyped data of these formats into strongly-typed data structures is a good fit for archival mechanisms, rather than taking the less safe approach that 3rd-party JSON conversion approaches have taken (described further in an appendix below).</p> <p>We would like to offer a solution to these problems without sacrificing ease of use or type safety.</p> <h2 id="agenda"> <a href="#agenda" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Agenda </h2> <p>This proposal is the first stage of three that introduce different facets of a whole Swift archival and serialization API:</p> <ol> <li>This proposal describes the basis for this API, focusing on the protocols that users adopt and interface with</li> <li>The next stage will propose specific API for new encoders</li> <li>The final stage will discuss how this new API will interop with <code class="highlighter-rouge">NSCoding</code> as it is today</li> </ol> <p><a href="0167-swift-encoders.md">SE-0167</a> provides stages 2 and 3.</p> <h2 id="proposed-solution"> <a href="#proposed-solution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Proposed solution </h2> <p>We will be introducing the <code class="highlighter-rouge">Encodable</code> and <code class="highlighter-rouge">Decodable</code> protocols, adoption of which will allow end user types to participate in encoding and decoding:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Codable implies Encodable and Decodable</span>
<span class="c1">// If all properties are Codable, protocol implementation is automatically generated by the compiler:</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Location</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">latitude</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">longitude</span><span class="p">:</span> <span class="kt">Double</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Animal</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">chicken</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="n">dog</span>
    <span class="k">case</span> <span class="n">turkey</span>
    <span class="k">case</span> <span class="n">cow</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Farm</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">Location</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">animals</span><span class="p">:</span> <span class="p">[</span><span class="kt">Animal</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div> <p>With developer participation, we will offer encoders and decoders (described in <a href="0167-swift-encoders.md">SE-0167</a>, not here) that take advantage of this conformance to offer type-safe serialization of user models:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">farm</span> <span class="o">=</span> <span class="kt">Farm</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Old MacDonald's Farm"</span><span class="p">,</span>
                <span class="nv">location</span><span class="p">:</span> <span class="kt">Location</span><span class="p">(</span><span class="nv">latitude</span><span class="p">:</span> <span class="mf">51.621648</span><span class="p">,</span> <span class="nv">longitude</span><span class="p">:</span> <span class="mf">0.269273</span><span class="p">),</span>
                <span class="nv">animals</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">chicken</span><span class="p">,</span> <span class="o">.</span><span class="n">dog</span><span class="p">,</span> <span class="o">.</span><span class="n">cow</span><span class="p">,</span> <span class="o">.</span><span class="n">turkey</span><span class="p">,</span> <span class="o">.</span><span class="n">dog</span><span class="p">,</span> <span class="o">.</span><span class="n">chicken</span><span class="p">,</span> <span class="o">.</span><span class="n">cow</span><span class="p">,</span> <span class="o">.</span><span class="n">turkey</span><span class="p">,</span> <span class="o">.</span><span class="n">dog</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">payload</span><span class="p">:</span> <span class="kt">Data</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONEncoder</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">farm</span><span class="p">)</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">farm</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Farm</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">payload</span><span class="p">)</span>

    <span class="c1">// Extracted as user types:</span>
    <span class="k">let</span> <span class="nv">coordinates</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">farm</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">farm</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">longitude</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="c1">// Encountered error during deserialization</span>
<span class="p">}</span>
</code></pre></div></div> <p>This gives developers access to their data in a type-safe manner and a recognizable interface.</p> <h2 id="detailed-design"> <a href="#detailed-design" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Detailed design </h2> <p>We will be introducing the following new types to the Swift standard library:</p> <ul> <li><code class="highlighter-rouge">protocol Encodable</code> &amp; <code class="highlighter-rouge">protocol Decodable</code>: Adopted by types to opt into archival. Implementation can be synthesized by the compiler in cases where all properties are also <code class="highlighter-rouge">Encodable</code> or <code class="highlighter-rouge">Decodable</code></li> <li><code class="highlighter-rouge">protocol CodingKey</code>: Adopted by types used as keys for keyed containers, replacing <code class="highlighter-rouge">String</code> keys with semantic types. Implementation can be synthesized by the compiler in most cases</li> <li><code class="highlighter-rouge">protocol Encoder</code>: Adopted by types which can take <code class="highlighter-rouge">Encodable</code> values and encode them into a native format <ul> <li><code class="highlighter-rouge">protocol KeyedEncodingContainerProtocol</code>: Adopted by types which provide a concrete way to store encoded values by <code class="highlighter-rouge">CodingKey</code>. Types adopting <code class="highlighter-rouge">Encoder</code> should provide types conforming to <code class="highlighter-rouge">KeyedEncodingContainerProtocol</code> to vend <ul> <li><code class="highlighter-rouge">struct KeyedEncodingContainer&lt;Key : CodingKey&gt;</code>: A concrete type-erased box for exposing <code class="highlighter-rouge">KeyedEncodingContainerProtocol</code> types; this is a type consumers of the API interact with directly</li> </ul> </li> <li><code class="highlighter-rouge">protocol UnkeyedEncodingContainer</code>: Adopted by types which provide a concrete way to stored encoded values with no keys. Types adopting <code class="highlighter-rouge">Encoder</code> should provide types conforming to <code class="highlighter-rouge">UnkeyedEncodingContainer</code> to vend</li> <li><code class="highlighter-rouge">protocol SingleValueEncodingContainer</code>: Adopted by types which provide a concrete way to store a single encoded value. Types adopting <code class="highlighter-rouge">Encoder</code> should provide types conforming to <code class="highlighter-rouge">SingleValueEncodingContainer</code> to vend</li> </ul> </li> <li><code class="highlighter-rouge">protocol Decoder</code>: Adopted by types which can take payloads in a native format and decode <code class="highlighter-rouge">Decodable</code> values out of them <ul> <li><code class="highlighter-rouge">protocol KeyedDecodingContainerProtocol</code>: Adopted by types which provide a concrete way to retrieve encoded values from storage by <code class="highlighter-rouge">CodingKey</code>. Types adopting <code class="highlighter-rouge">Decoder</code> should provide types conforming to <code class="highlighter-rouge">KeyedDecodingContainerProtocol</code> to vend <ul> <li><code class="highlighter-rouge">struct KeyedDecodingContainer&lt;Key : CodingKey&gt;</code>: A concrete type-erased box for exposing <code class="highlighter-rouge">KeyedDecodingContainerProtocol</code> types; this is a type consumers of the API interact with directly</li> </ul> </li> <li><code class="highlighter-rouge">protocol UnkeyedDecodingContainer</code>: Adopted by types which provide a concrete way to retrieve encoded values from storage with no keys. Types adopting <code class="highlighter-rouge">Decoder</code> should provide types conforming to <code class="highlighter-rouge">UnkeyedDecodingContainer</code> to vend</li> <li><code class="highlighter-rouge">protocol SingleValueDecodingContainer</code>: Adopted by types which provide a concrete way to retrieve a single encoded value from storage. Types adopting <code class="highlighter-rouge">Decoder</code> should provide types conforming to <code class="highlighter-rouge">SingleValueDecodingContainer</code> to vend</li> </ul> </li> <li><code class="highlighter-rouge">struct CodingUserInfoKey</code>: A <code class="highlighter-rouge">String RawRepresentable struct</code> for representing keys to use in <code class="highlighter-rouge">Encoders</code>’ and <code class="highlighter-rouge">Decoders</code>’ <code class="highlighter-rouge">userInfo</code> dictionaries</li> </ul> <p>To support user types, we expose the <code class="highlighter-rouge">Encodable</code> and <code class="highlighter-rouge">Decodable</code> protocols:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Conformance to `Encodable` indicates that a type can encode itself to an external representation.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Encodable</span> <span class="p">{</span>
    <span class="c1">/// Encodes `self` into the given encoder.</span>
    <span class="c1">///</span>
    <span class="c1">/// If `self` fails to encode anything, `encoder` will encode an empty keyed container in its place.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter encoder: The encoder to write data to.</span>
    <span class="c1">/// - throws: An error if any values are invalid for `encoder`'s format.</span>
    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `Decodable` indicates that a type can decode itself from an external representation.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Decodable</span> <span class="p">{</span>
    <span class="c1">/// Initializes `self` by decoding from `decoder`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter decoder: The decoder to read data from.</span>
    <span class="c1">/// - throws: An error if reading from the decoder fails, or if read data is corrupted or otherwise invalid.</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `Codable` indicates that a type can convert itself into and out of an external representation.</span>
<span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">Codable</span> <span class="o">=</span> <span class="kt">Encodable</span> <span class="o">&amp;</span> <span class="kt">Decodable</span>
</code></pre></div></div> <p>By adopting these protocols, user types opt in to this system.</p> <p>Structured types (i.e. types which encode as a collection of properties) encode and decode their properties in a keyed manner. Keys are semantic <code class="highlighter-rouge">String</code>-convertible <code class="highlighter-rouge">enums</code> which map properties to encoded names. Keys must conform to the <code class="highlighter-rouge">CodingKey</code> protocol:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Conformance to `CodingKey` indicates that a type can be used as a key for encoding and decoding.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">CodingKey</span> <span class="p">{</span>
    <span class="c1">/// The string to use in a named collection (e.g. a string-keyed dictionary).</span>
    <span class="k">var</span> <span class="nv">stringValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Initializes `self` from a string.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter stringValue: The string value of the desired key.</span>
    <span class="c1">/// - returns: An instance of `Self` from the given string, or `nil` if the given string does not correspond to any instance of `Self`.</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">stringValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>

    <span class="c1">/// The int to use in an indexed collection (e.g. an int-keyed dictionary).</span>
    <span class="k">var</span> <span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Initializes `self` from an integer.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter intValue: The integer value of the desired key.</span>
    <span class="c1">/// - returns: An instance of `Self` from the given integer, or `nil` if the given integer does not correspond to any instance of `Self`.</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>For performance, where relevant, keys may be <code class="highlighter-rouge">Int</code>-convertible, and <code class="highlighter-rouge">Encoders</code> may choose to make use of <code class="highlighter-rouge">Ints</code> over <code class="highlighter-rouge">Strings</code> as appropriate. Framework types should provide keys which have both for flexibility and performance across different types of <code class="highlighter-rouge">Encoders</code>.</p> <p>By default, <code class="highlighter-rouge">CodingKey</code> conformance can be derived for <code class="highlighter-rouge">enums</code> which have no raw type and no associated values, or <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Int</code> backing:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Keys1</span> <span class="p">:</span> <span class="kt">CodingKey</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">a</span> <span class="c1">// (stringValue: "a", intValue: nil)</span>
    <span class="k">case</span> <span class="n">b</span> <span class="c1">// (stringValue: "b", intValue: nil)</span>

    <span class="c1">// The compiler automatically generates the following:</span>
    <span class="k">var</span> <span class="nv">stringValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">a</span><span class="p">:</span> <span class="k">return</span> <span class="s">"a"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">b</span><span class="p">:</span> <span class="k">return</span> <span class="s">"b"</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">init</span><span class="p">?(</span><span class="nv">stringValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">stringValue</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">"a"</span><span class="p">:</span> <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="n">a</span>
        <span class="k">case</span> <span class="s">"b"</span><span class="p">:</span> <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="n">b</span>
        <span class="k">default</span><span class="p">:</span> <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="nf">init</span><span class="p">?(</span><span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">Keys2</span> <span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">CodingKey</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">c</span> <span class="o">=</span> <span class="s">"foo"</span> <span class="c1">// (stringValue: "foo", intValue: nil)</span>
    <span class="k">case</span> <span class="n">d</span>         <span class="c1">// (stringValue: "d", intValue: nil)</span>

    <span class="c1">// stringValue, init?(stringValue:), intValue, and init?(intValue:) are generated by the compiler as well</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">Keys3</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">CodingKey</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">// (stringValue: "e", intValue: 4)</span>
    <span class="k">case</span> <span class="n">f</span>     <span class="c1">// (stringValue: "f", intValue: 5)</span>
    <span class="k">case</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1">// (stringValue: "g", intValue: 9)</span>

    <span class="c1">// stringValue, init?(stringValue:), intValue, and init?(intValue:) are generated by the compiler as well</span>
<span class="p">}</span>
</code></pre></div></div> <p>Coding keys which are not <code class="highlighter-rouge">enum</code>s, have associated values, or have other raw representations must implement these methods manually.</p> <p>In addition to automatic <code class="highlighter-rouge">CodingKey</code> requirement synthesis for <code class="highlighter-rouge">enums</code>, <code class="highlighter-rouge">Encodable</code> &amp; <code class="highlighter-rouge">Decodable</code> requirements can be automatically synthesized for certain types as well:</p> <ol> <li>Types conforming to <code class="highlighter-rouge">Encodable</code> whose properties are all <code class="highlighter-rouge">Encodable</code> get an automatically generated <code class="highlighter-rouge">String</code>-backed <code class="highlighter-rouge">CodingKey</code> <code class="highlighter-rouge">enum</code> mapping properties to case names. Similarly for <code class="highlighter-rouge">Decodable</code> types whose properties are all <code class="highlighter-rouge">Decodable</code></li> <li>Types falling into (1) — and types which manually provide a <code class="highlighter-rouge">CodingKey</code> <code class="highlighter-rouge">enum</code> (named <code class="highlighter-rouge">CodingKeys</code>, directly, or via a <code class="highlighter-rouge">typealias</code>) whose cases map 1-to-1 to <code class="highlighter-rouge">Encodable</code>/<code class="highlighter-rouge">Decodable</code> properties by name — get automatic synthesis of <code class="highlighter-rouge">init(from:)</code> and <code class="highlighter-rouge">encode(to:)</code> as appropriate, using those properties and keys</li> <li>Types which fall into neither (1) nor (2) will have to provide a custom key type if needed and provide their own <code class="highlighter-rouge">init(from:)</code> and <code class="highlighter-rouge">encode(to:)</code>, as appropriate</li> </ol> <p>This synthesis can always be overridden by a manual implementation of any protocol requirements. Many types will either allow for automatic synthesis of all of codability (1), or provide a custom key subset and take advantage of automatic method synthesis (2).</p> <h3 id="encoding-and-decoding"> <a href="#encoding-and-decoding" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Encoding and Decoding </h3> <p>Types which are <code class="highlighter-rouge">Encodable</code> encode their data into a container provided by their <code class="highlighter-rouge">Encoder</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// An `Encoder` is a type which can encode values into a native format for external representation.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Encoder</span> <span class="p">{</span>
    <span class="c1">/// Returns an encoding container appropriate for holding multiple values keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.unkeyedContainer()` call.</span>
    <span class="c1">/// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call.</span>
    <span class="kd">func</span> <span class="n">container</span><span class="o">&lt;</span><span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span>

    <span class="c1">/// Returns an encoding container appropriate for holding multiple unkeyed values.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new empty unkeyed container.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.container(keyedBy:)` call.</span>
    <span class="c1">/// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call.</span>
    <span class="kd">func</span> <span class="nf">unkeyedContainer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>

    <span class="c1">/// Returns an encoding container appropriate for holding a single primitive value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new empty single value container.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.container(keyedBy:)` call.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.unkeyedContainer()` call.</span>
    <span class="c1">/// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call.</span>
    <span class="kd">func</span> <span class="nf">singleValueContainer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">SingleValueEncodingContainer</span>

    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Continuing examples from before; below is automatically generated by the compiler if no customization is needed.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Location</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">enum</span> <span class="kt">CodingKeys</span> <span class="p">:</span> <span class="kt">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">latitude</span>
        <span class="k">case</span> <span class="n">longitude</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// Generic keyed encoder gives type-safe key access: cannot encode with keys of the wrong type.</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">CodingKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>

        <span class="c1">// The encoder is generic on the key -- free key autocompletion here.</span>
        <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">longitude</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Farm</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">enum</span> <span class="kt">CodingKeys</span> <span class="p">:</span> <span class="kt">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">name</span>
        <span class="k">case</span> <span class="n">location</span>
        <span class="k">case</span> <span class="n">animals</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">CodingKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">location</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">animals</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">animals</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Similarly, <code class="highlighter-rouge">Decodable</code> types initialize from data read from their <code class="highlighter-rouge">Decoder</code>’s container:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// A `Decoder` is a type which can decode values from a native format into in-memory representations.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Decoder</span> <span class="p">{</span>
    <span class="c1">/// Returns the data stored in `self` as represented in a container keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="kd">func</span> <span class="n">container</span><span class="o">&lt;</span><span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span>

    <span class="c1">/// Returns the data stored in `self` as represented in a container appropriate for holding values with no keys.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: An unkeyed container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="kd">func</span> <span class="nf">unkeyedContainer</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>

    <span class="c1">/// Returns the data stored in `self` as represented in a container appropriate for holding a single primitive value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A single value container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a single value container.</span>
    <span class="kd">func</span> <span class="nf">singleValueContainer</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">SingleValueDecodingContainer</span>

    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Continuing examples from before; below is automatically generated by the compiler if no customization is needed.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Location</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">CodingKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="n">latitude</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Double</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
        <span class="n">longitude</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Double</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Farm</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">CodingKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">location</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Location</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">location</span><span class="p">)</span>
        <span class="n">animals</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">([</span><span class="kt">Animal</span><span class="p">]</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">animals</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="keyed-containers"> <a href="#keyed-containers" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Keyed Containers </h3> <p>Keyed containers are the primary interface that most <code class="highlighter-rouge">Codable</code> types interact with for encoding and decoding. Through these, <code class="highlighter-rouge">Codable</code> types have strongly-keyed access to encoded data by using keys that are semantically correct for the operations they want to express.</p> <p>Since semantically incompatible keys will rarely (if ever) share the same key type, it is impossible to mix up key types within the same container (as is possible with <code class="highlighter-rouge">String</code> keys), and since the type is known statically, keys get autocompletion by the compiler.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Conformance to `KeyedEncodingContainerProtocol` indicates that a type provides a view into an `Encoder`'s storage and is used to hold the encoded properties of an `Encodable` type in a keyed manner.</span>
<span class="c1">///</span>
<span class="c1">/// Encoders should provide types conforming to `KeyedEncodingContainerProtocol` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedEncodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span>

    <span class="c1">/// Encodes the given value for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the value with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given value for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the value with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given object weakly for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// For `Encoder`s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</span>
    <span class="c1">///</span>
    <span class="c1">/// For formats which don't support this feature, the default implementation encodes the given object unconditionally.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter object: The object to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the object with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encodeWeak</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">&amp;</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// `KeyedEncodingContainer` is a type-erased box for `KeyedEncodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">K</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">KeyedEncodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="o">=</span> <span class="kt">K</span>

    <span class="c1">/// Initializes `self` with the given container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter container: The container to hold.</span>
    <span class="kd">init</span><span class="o">&lt;</span><span class="kt">Container</span> <span class="p">:</span> <span class="kt">KeyedEncodingContainerProtocol</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">container</span><span class="p">:</span> <span class="kt">Container</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Container</span><span class="o">.</span><span class="kt">Key</span> <span class="o">==</span> <span class="kt">Key</span>

    <span class="c1">// + methods from KeyedEncodingContainerProtocol</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `KeyedDecodingContainerProtocol` indicates that a type provides a view into a `Decoder`'s storage and is used to hold the encoded properties of a `Decodable` type in a keyed manner.</span>
<span class="c1">///</span>
<span class="c1">/// Decoders should provide types conforming to `KeyedDecodingContainerProtocol` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span>

    <span class="c1">/// All the keys the `Decoder` has for this container.</span>
    <span class="c1">///</span>
    <span class="c1">/// Different keyed containers from the same `Decoder` may return different keys here; it is possible to encode with multiple key types which are not convertible to one another. This should report all keys present which are convertible to the requested type.</span>
    <span class="k">var</span> <span class="nv">allKeys</span><span class="p">:</span> <span class="p">[</span><span class="kt">Key</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns whether the `Decoder` contains a value associated with the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// The value associated with the given key may be a null value as appropriate for the data format.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to search for.</span>
    <span class="c1">/// - returns: Whether the `Decoder` has an entry for the given key.</span>
    <span class="kd">func</span> <span class="nf">contains</span><span class="p">(</span><span class="n">_</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

    <span class="c1">/// Decodes a value of the given type for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - parameter key: The key that the decoded value is associated with.</span>
    <span class="c1">/// - returns: A value of the requested type, if present for the given key and convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key or if the value is null.</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span>

    <span class="c1">/// Decodes a value of the given type for the given key, if present.</span>
    <span class="c1">///</span>
    <span class="c1">/// This method returns `nil` if the container does not have a value associated with `key`, or if the value is null. The difference between these states can be distinguished with a `contains(_:)` call.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - parameter key: The key that the decoded value is associated with.</span>
    <span class="c1">/// - returns: A decoded value of the requested type, or `nil` if the `Decoder` does not have an entry associated with the given key, or if the value is a null value.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="kd">func</span> <span class="n">decodeIfPresent</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span>

    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// `KeyedDecodingContainer` is a type-erased box for `KeyedDecodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">K</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="o">=</span> <span class="kt">K</span>

    <span class="c1">/// Initializes `self` with the given container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter container: The container to hold.</span>
    <span class="kd">init</span><span class="o">&lt;</span><span class="kt">Container</span> <span class="p">:</span> <span class="kt">KeyedDecodingContainerProtocol</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">container</span><span class="p">:</span> <span class="kt">Container</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Container</span><span class="o">.</span><span class="kt">Key</span> <span class="o">==</span> <span class="kt">Key</span>

    <span class="c1">// + methods from KeyedDecodingContainerProtocol</span>
<span class="p">}</span>
</code></pre></div></div> <p>These <code class="highlighter-rouge">encode(_:forKey:)</code> and <code class="highlighter-rouge">decode(_:forKey:)</code> overloads give strong, static type guarantees about what is encodable (preventing accidental attempts to encode an invalid type), and provide a list of primitive types which are common to all encoders and decoders that users can rely on.</p> <p>When the conditional conformance feature lands in Swift, the ability to express that “a collection of things which are <code class="highlighter-rouge">Codable</code> is <code class="highlighter-rouge">Codable</code>” will allow collections (<code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">Dictionary</code>, etc.) to be extended and fall into these overloads as well.</p> <h3 id="unkeyed-containers"> <a href="#unkeyed-containers" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Unkeyed Containers </h3> <p>For some types, when the source and destination of a payload can be guaranteed to agree on the payload layout and format (e.g. in cross-process communication, where both sides agree on the payload format), it may be appropriate to eschew the encoding of keys and encode sequentially, without keys. In this case, a type may choose to make use of an unkeyed container for its properties:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Conformance to `UnkeyedEncodingContainer` indicates that a type provides a view into an `Encoder`'s storage and is used to hold the encoded properties of an `Encodable` type sequentially, without keys.</span>
<span class="c1">///</span>
<span class="c1">/// Encoders should provide types conforming to `UnkeyedEncodingContainer` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedEncodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Encodes the given value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">?)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given object weakly.</span>
    <span class="c1">///</span>
    <span class="c1">/// For `Encoder`s that implement this functionality, this will only encode the given object if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</span>
    <span class="c1">///</span>
    <span class="c1">/// For formats which don't support this feature, the default implementation encodes the given object unconditionally.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter object: The object to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encodeWeak</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">&amp;</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">?)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the elements of the given sequence.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation of these is given in an extension.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter sequence: The sequences whose contents to encode.</span>
    <span class="c1">/// - throws: An error if any of the contained values throws an error.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Bool</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int</span>
    <span class="c1">// ...</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="p">:</span> <span class="kt">Encodable</span>

    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `UnkeyedDecodingContainer` indicates that a type provides a view into a `Decoder`'s storage and is used to hold the encoded properties of a `Decodable` type sequentially, without keys.</span>
<span class="c1">///</span>
<span class="c1">/// Decoders should provide types conforming to `UnkeyedDecodingContainer` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedDecodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Returns the number of elements (if known) contained within this container.</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns whether there are no more elements left to be decoded in the container.</span>
    <span class="k">var</span> <span class="nv">isAtEnd</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Decodes a value of the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - returns: A value of the requested type, if present for the given key and convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span>

    <span class="c1">/// Decodes a value of the given type, if present.</span>
    <span class="c1">///</span>
    <span class="c1">/// This method returns `nil` if the container has no elements left to decode, or if the value is null. The difference between these states can be distinguished by checking `isAtEnd`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - returns: A decoded value of the requested type, or `nil` if the value is a null value, or if there are no more elements to decode.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">decodeIfPresent</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span>

    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Unkeyed encoding is fragile and generally not appropriate for archival without specific format guarantees, so keyed encoding remains the recommended approach (and is why <code class="highlighter-rouge">CodingKey</code> <code class="highlighter-rouge">enums</code> are synthesized by default unless otherwise declined).</p> <h3 id="single-value-containers"> <a href="#single-value-containers" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Single Value Containers </h3> <p>For other types, an array or dictionary container may not even make sense (e.g. values which are <code class="highlighter-rouge">RawRepresentable</code> as a single primitive value). Those types may encode and decode directly as a single value, instead of requesting an outer container:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// A `SingleValueEncodingContainer` is a container which can support the storage and direct encoding of a single non-keyed value.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">SingleValueEncodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Encodes a single value of the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="c1">/// - precondition: May not be called after a previous `self.encode(_:)` call.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="c1">/// A `SingleValueDecodingContainer` is a container which can support the storage and direct decoding of a single non-keyed value.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">SingleValueDecodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Decodes a single value of the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type to decode as.</span>
    <span class="c1">/// - returns: A value of the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value cannot be converted to the requested type.</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="c1">// Continuing example from before; below is automatically generated by the compiler if no customization is needed.</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Animal</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// Encode as a single value; no keys.</span>
        <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">rawValue</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// Decodes as a single value; no keys.</span>
        <span class="k">let</span> <span class="nv">intValue</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">Self</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">intValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span> <span class="o">=</span> <span class="n">value</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">CocoaError</span><span class="o">.</span><span class="nf">error</span><span class="p">(</span><span class="o">.</span><span class="n">coderReadCorrupt</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>In the example given above, since <code class="highlighter-rouge">Animal</code> uses a single value container, <code class="highlighter-rouge">[.chicken, .dog, .cow, .turkey, .dog, .chicken, .cow, .turkey, .dog]</code> would encode directly as <code class="highlighter-rouge">[1, 2, 4, 3, 2, 1, 4, 3, 2]</code>.</p> <h3 id="nesting"> <a href="#nesting" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Nesting </h3> <p>In practice, some types may also need to control how data is nested within their container, or potentially nest other containers within their container. Keyed containers allow this by returning nested containers of differing types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Continuing from before</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedEncodingContainerProtocol</span> <span class="p">{</span>
    <span class="c1">/// Stores a keyed encoding container for the given key and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter keyType: The key type to use for the container.</span>
    <span class="c1">/// - parameter key: The key to encode the container for.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">keyType</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Stores an unkeyed encoding container for the given key and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to encode the container for.</span>
    <span class="c1">/// - returns: A new unkeyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>
    <span class="c1">/// Returns the data stored for the given key as represented in a container keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - parameter key: The key that the nested container is associated with.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Returns the data stored for the given key as represented in an unkeyed container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key that the nested container is associated with.</span>
    <span class="c1">/// - returns: An unkeyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>
<span class="p">}</span>
</code></pre></div></div> <p>This can be common when coding against specific external data representations:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// User type for interfacing with a specific JSON API. JSON API expects encoding as {"id": ..., "properties": {"name": ..., "timestamp": ...}}. Swift type differs from encoded type, and encoding needs to match a spec:</span>
<span class="kd">struct</span> <span class="kt">Record</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="c1">// We care only about these values from the JSON payload</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">timestamp</span><span class="p">:</span> <span class="kt">Double</span>

    <span class="c1">// ...</span>

    <span class="kd">private</span> <span class="kd">enum</span> <span class="kt">Keys</span> <span class="p">:</span> <span class="kt">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">id</span>
        <span class="k">case</span> <span class="n">properties</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">enum</span> <span class="kt">PropertiesKeys</span> <span class="p">:</span> <span class="kt">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">name</span>
        <span class="k">case</span> <span class="n">timestamp</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">Keys</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">dictionary</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="c1">// Set a dictionary for the "properties" key</span>
        <span class="k">let</span> <span class="nv">nested</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="nf">nestedContainer</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">PropertiesKeys</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">nested</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">nested</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">Keys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="n">id</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="k">let</span> <span class="nv">nested</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">nestedContainer</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">PropertiesKeys</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="k">try</span> <span class="n">nested</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="k">try</span> <span class="n">nested</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Double</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Unkeyed containers allow for the same types of nesting:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Continuing from before</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedEncodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Encodes a nested container keyed by the given type and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter keyType: The key type to use for the container.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">keyType</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Encodes an unkeyed encoding container and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new unkeyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedDecodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Decodes a nested container keyed by the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Decodes an unkeyed nested container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: An unkeyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="dynamic-context-based-behavior"> <a href="#dynamic-context-based-behavior" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Dynamic Context-Based Behavior </h3> <p>In some cases, types may need context in order to decide on their external representation. Some types may choose a different representation based on the encoding format that they are being read from or written to, and others based on other runtime contextual information. To facilitate this, <code class="highlighter-rouge">Encoders</code> and <code class="highlighter-rouge">Decoders</code> expose user-supplied context for consumption:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Represents a user-defined key for providing context for encoding and decoding.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">CodingUserInfoKey</span> <span class="p">:</span> <span class="kt">RawRepresentable</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">RawValue</span> <span class="o">=</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Continuing from before:</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Encoder</span> <span class="p">{</span>
    <span class="c1">/// Any contextual information set by the user for encoding.</span>
    <span class="k">var</span> <span class="nv">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingUserInfoKey</span> <span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Decoder</span> <span class="p">{</span>
    <span class="c1">/// Any contextual information set by the user for decoding.</span>
    <span class="k">var</span> <span class="nv">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingUserInfoKey</span> <span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Consuming types may then support setting contextual information to inform their encoding and decoding:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">:</span> <span class="kt">Encodable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">codingUserInfoKey</span> <span class="o">=</span> <span class="kt">CodingUserInfoKey</span><span class="p">(</span><span class="s">"com.foocorp.person.codingUserInfoKey"</span><span class="p">)</span>

    <span class="kd">public</span> <span class="kd">struct</span> <span class="kt">UserInfo</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">shouldEncodePrivateFields</span><span class="p">:</span> <span class="kt">Bool</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">context</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">userInfo</span><span class="p">[</span><span class="kt">Person</span><span class="o">.</span><span class="n">codingUserInfoKey</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">Person</span><span class="o">.</span><span class="kt">UserInfo</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">shouldEncodePrivateFields</span> <span class="p">{</span>
                <span class="c1">// Do something special.</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Fall back to default.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">encoder</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">encoder</span><span class="o">.</span><span class="n">userInfo</span><span class="p">[</span><span class="kt">Person</span><span class="o">.</span><span class="n">codingUserInfoKey</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Person</span><span class="o">.</span><span class="kt">UserInfo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
</code></pre></div></div> <p><code class="highlighter-rouge">Encoders</code> and <code class="highlighter-rouge">Decoders</code> may choose to expose contextual information about their configuration as part of the context as well if necessary.</p> <h3 id="inheritance"> <a href="#inheritance" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Inheritance </h3> <p>Inheritance in this system is supported much like it is with <code class="highlighter-rouge">NSCoding</code> — on encoding, objects which inherit from a type that is <code class="highlighter-rouge">Encodable</code> encode <code class="highlighter-rouge">super</code> using their encoder, and pass a decoder to <code class="highlighter-rouge">super.init(from:)</code> on decode if they inherit from a type that is <code class="highlighter-rouge">Decodable</code>. With the existing <code class="highlighter-rouge">NSCoding</code> API, this is most often done like so, by convention:</p> <div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeWithCoder</span><span class="p">:(</span><span class="n">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">encoder</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">encodeWithCoder</span><span class="p">:</span><span class="n">encoder</span><span class="p">];</span>
    <span class="c1">// ... encode properties</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithCoder</span><span class="p">:(</span><span class="n">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">decoder</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">initWithCoder</span><span class="p">:</span><span class="n">decoder</span><span class="p">]))</span> <span class="p">{</span>
        <span class="c1">// ... decode properties</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In practice, this approach means that the properties of <code class="highlighter-rouge">self</code> and the properties of <code class="highlighter-rouge">super</code> get encoded into the same container: if <code class="highlighter-rouge">self</code> encodes values for keys <code class="highlighter-rouge">"a"</code>, <code class="highlighter-rouge">"b"</code>, and <code class="highlighter-rouge">"c"</code>, and <code class="highlighter-rouge">super</code> encodes <code class="highlighter-rouge">"d"</code>, <code class="highlighter-rouge">"e"</code>, and <code class="highlighter-rouge">"f"</code>, the resulting object is encoded as <code class="highlighter-rouge">{"a": ..., "b": ..., "c": ..., "d": ..., "e": ..., "f": ...}</code>. This approach has two drawbacks:</p> <ol> <li>Things which <code class="highlighter-rouge">self</code> encodes may overwrite <code class="highlighter-rouge">super</code>’s (or vice versa, depending on when <code class="highlighter-rouge">-[super encodeWithCoder:]</code> is called</li> <li><code class="highlighter-rouge">self</code> and <code class="highlighter-rouge">super</code> may not encode into different container types (e.g. <code class="highlighter-rouge">self</code> in a sequential fashion, and <code class="highlighter-rouge">super</code> in a keyed fashion)</li> </ol> <p>The second point is not an issue for <code class="highlighter-rouge">NSKeyedArchiver</code>, since all values encode with keys (sequentially coded elements get autogenerated keys). This proposed API, however, allows for <code class="highlighter-rouge">self</code> and <code class="highlighter-rouge">super</code> to explicitly request conflicting containers (<code class="highlighter-rouge">.array</code> and <code class="highlighter-rouge">.dictionary</code>, which may not be mixed, depending on the data format).</p> <p>To remedy both of these points, we adopt a new convention for inheritance-based coding — encoding <code class="highlighter-rouge">super</code> as a sub-object of <code class="highlighter-rouge">self</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">MyCodable</span> <span class="p">:</span> <span class="kt">SomethingCodable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">CodingKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="c1">// ... encode some properties</span>

        <span class="c1">// superEncoder() gives `super` a nested container to encode into (for</span>
        <span class="c1">// a predefined key).</span>
        <span class="k">try</span> <span class="k">super</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">container</span><span class="o">.</span><span class="nf">superEncoder</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">container</span><span class="p">(</span><span class="nv">keyedBy</span><span class="p">:</span> <span class="kt">CodingKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="c1">// ... decode some properties</span>

        <span class="c1">// Allow `super` to decode from the nested container.</span>
        <span class="k">try</span> <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">container</span><span class="o">.</span><span class="nf">superDecoder</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>If a shared container is desired, it is still possible to call <code class="highlighter-rouge">super.encode(to: encoder)</code> and <code class="highlighter-rouge">super.init(from: decoder)</code>, but we recommend the safer containerized option.</p> <p><code class="highlighter-rouge">superEncoder()</code> and <code class="highlighter-rouge">superDecoder()</code> are provided on containers to provide handles to nested containers for <code class="highlighter-rouge">super</code> to use.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Continuing from before</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedEncodingContainerProtocol</span> <span class="p">{</span>
    <span class="c1">/// Stores a new nested container for the default `super` key and returns a new `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// Equivalent to calling `superEncoder(forKey:)` with `Key(stringValue: "super", intValue: 0)`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>

    <span class="c1">/// Stores a new nested container for the given key and returns a new `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to encode `super` for.</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>
    <span class="c1">/// Returns a `Decoder` instance for decoding `super` from the container associated with the default `super` key.</span>
    <span class="c1">///</span>
    <span class="c1">/// Equivalent to calling `superDecoder(forKey:)` with `Key(stringValue: "super", intValue: 0)`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the default `super` key, or if the stored value is null.</span>
    <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>

    <span class="c1">/// Returns a `Decoder` instance for decoding `super` from the container associated with the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to decode `super` for.</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key, or if the stored value is null.</span>
    <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedEncodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Encodes a nested container and returns an `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedDecodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Decodes a nested container and returns a `Decoder` instance for decoding `super` from that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="primitive-codable-conformance"> <a href="#primitive-codable-conformance" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Primitive <code class="highlighter-rouge">Codable</code> Conformance </h3> <p>The encoding container types offer overloads for working with and processing the API’s primitive types (<code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code>, etc.). However, for ease of implementation (both in this API and others), it can be helpful for these types to conform to <code class="highlighter-rouge">Codable</code> themselves. Thus, along with these overloads, we will offer <code class="highlighter-rouge">Codable</code> conformance on these types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Bool</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Bool</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span> <span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Repeat for others...</span>
</code></pre></div></div> <p>This conformance allows one to write functions which accept <code class="highlighter-rouge">Codable</code> types without needing specific overloads for the fifteen primitive types as well.</p> <p>Since Swift’s function overload rules prefer more specific functions over generic functions, the specific overloads are chosen where possible (e.g. <code class="highlighter-rouge">encode("Hello, world!", forKey: .greeting)</code> will choose <code class="highlighter-rouge">encode(_: String, forKey: Key)</code> over <code class="highlighter-rouge">encode&lt;T : Codable&gt;(_: T, forKey: Key)</code>).</p> <h4 id="additional-extensions"> <a href="#additional-extensions" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Additional Extensions </h4> <p>Along with the primitive <code class="highlighter-rouge">Codable</code> conformance above, extensions on <code class="highlighter-rouge">Codable</code> <code class="highlighter-rouge">RawRepresentable</code> types whose <code class="highlighter-rouge">RawValue</code> is a primitive types will provide default implementations for encoding and decoding:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">RawRepresentable</span> <span class="k">where</span> <span class="kt">RawValue</span> <span class="o">==</span> <span class="kt">Bool</span><span class="p">,</span> <span class="k">Self</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">decoded</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">RawValue</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">Self</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">decoded</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">CocoaError</span><span class="o">.</span><span class="nf">error</span><span class="p">(</span><span class="o">.</span><span class="n">coderReadCorrupt</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">self</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">rawValue</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Repeat for others...</span>
</code></pre></div></div> <p>This allows for trivial <code class="highlighter-rouge">Codable</code> conformance of <code class="highlighter-rouge">enum</code> types (and manual <code class="highlighter-rouge">RawRepresentable</code> implementations) with primitive backing.</p> <h2 id="source-compatibility"> <a href="#source-compatibility" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Source compatibility </h2> <p>This proposal is additive — existing code will not have to change due to this API addition. This implementation can be made available in both Swift 4 and the Swift 3 compatibility mode.</p> <h2 id="effect-on-abi-stability"> <a href="#effect-on-abi-stability" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on ABI stability </h2> <p>The addition of this API will not be an ABI-breaking change. However, this will add limitations for changes in future versions of Swift, as parts of the API will have to remain unchanged between versions of Swift (barring some additions, discussed below).</p> <h2 id="effect-on-api-resilience"> <a href="#effect-on-api-resilience" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on API resilience </h2> <p>Much like new API added to the standard library, once added, many changes to this API will be ABI- and source-breaking changes. In particular, changes which change the types or names of methods or arguments, add required methods on protocols or classes, or remove supplied default implementations will break client behavior.</p> <p>The following types may not have methods added to them without providing default implementations:</p> <ul> <li><code class="highlighter-rouge">Encodable</code></li> <li><code class="highlighter-rouge">Decodable</code></li> <li><code class="highlighter-rouge">CodingKey</code></li> <li><code class="highlighter-rouge">Encoder</code></li> <li><code class="highlighter-rouge">KeyedEncodingContainerProtocol</code> <ul> <li><code class="highlighter-rouge">KeyedEncodingContainer</code></li> </ul> </li> <li><code class="highlighter-rouge">UnkeyedEncodingContainer</code></li> <li><code class="highlighter-rouge">SingleValueEncodingContainer</code></li> <li><code class="highlighter-rouge">Decoder</code></li> <li><code class="highlighter-rouge">KeyedDecodingContainerProtocol</code> <ul> <li><code class="highlighter-rouge">KeyedDecodingContainer</code></li> </ul> </li> <li><code class="highlighter-rouge">UnkeyedEncodingContainer</code></li> <li><code class="highlighter-rouge">SingleValueDecodingContainer</code></li> </ul> <p>Various extensions to Swift primitive types (<code class="highlighter-rouge">Bool</code>, <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code>, etc.) and to <code class="highlighter-rouge">RawRepresentable</code> types (<code class="highlighter-rouge">where RawValue == Bool</code>, <code class="highlighter-rouge">== Int</code>, <code class="highlighter-rouge">== Double</code>, etc.) may also not be removed.</p> <p>In general, changes to the proposed types will be restricted as described in the <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst">library evolution document</a> in the Swift repository.</p> <h2 id="alternatives-considered"> <a href="#alternatives-considered" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Alternatives considered </h2> <p>The following are a few of the more notable approaches considered for the problem:</p> <ol> <li> <p>Leverage the existing <code class="highlighter-rouge">NSCoding</code> implementation by adding support for <code class="highlighter-rouge">struct</code> and <code class="highlighter-rouge">enum</code> types, either through <code class="highlighter-rouge">NSCoding</code> itself, or through a similar protocol.</p> <ul> <li>Although technically feasible, this can feel like a “missed opportunity” for offering something better tuned for Swift. This approach would also not offer any additional integration with <code class="highlighter-rouge">JSONSerialization</code> and <code class="highlighter-rouge">PropertyListSerialization</code>, unless JSON and plist archivers were added to offer support.</li> </ul> </li> <li> <p>The following type-erased, declarative approach:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Similar hack to AnyHashable; these wrap values which have not yet been</span>
 <span class="c1">// encoded, or not yet decoded.</span>
 <span class="kd">struct</span> <span class="kt">AnyEncodable</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
 <span class="kd">struct</span> <span class="kt">AnyDecodable</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">CodingPrimitive</span> <span class="p">{}</span>
 <span class="kd">protocol</span> <span class="kt">PrimitiveCodable</span> <span class="p">{</span> <span class="cm">/* same as above */</span> <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">OrderedCodable</span> <span class="p">{</span>
     <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span>
     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyEncodable</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">KeyedCodable</span> <span class="p">{</span>
     <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span>
     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyEncodable</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="c1">// Same as above</span>
 <span class="kd">protocol</span> <span class="kt">OrderedEncoder</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
 <span class="kd">protocol</span> <span class="kt">OrderedDecoder</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
 <span class="kd">protocol</span> <span class="kt">KeyedEncoder</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
 <span class="kd">protocol</span> <span class="kt">KeyedDecoder</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

 <span class="c1">// Sample:</span>
 <span class="kd">struct</span> <span class="kt">Location</span><span class="p">:</span> <span class="kt">OrderedCodable</span> <span class="p">{</span>
     <span class="k">let</span> <span class="nv">latitude</span><span class="p">:</span> <span class="kt">Double</span>
     <span class="k">let</span> <span class="nv">longitude</span><span class="p">:</span> <span class="kt">Double</span>

     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span> <span class="p">{</span>
         <span class="k">guard</span> <span class="n">array</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* throw */</span> <span class="p">}</span>

         <span class="c1">// These `.as()` calls perform the actual decoding, and fail by</span>
         <span class="c1">// throwing an error.</span>
         <span class="k">let</span> <span class="nv">latitude</span> <span class="o">=</span> <span class="k">try</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nf">as</span><span class="p">(</span><span class="kt">Double</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
         <span class="k">let</span> <span class="nv">longitude</span> <span class="o">=</span> <span class="k">try</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nf">as</span><span class="p">(</span><span class="kt">Double</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
         <span class="k">try</span> <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">latitutde</span><span class="p">:</span> <span class="n">latitude</span><span class="p">,</span> <span class="nv">longitude</span><span class="p">:</span> <span class="n">longitude</span><span class="p">)</span>
     <span class="p">}</span>

     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyEncodable</span><span class="p">]</span> <span class="p">{</span>
         <span class="c1">// With compiler support, AnyEncodable() can be automatic.</span>
         <span class="k">return</span> <span class="p">[</span><span class="kt">AnyEncodable</span><span class="p">(</span><span class="n">latitude</span><span class="p">),</span> <span class="kt">AnyEncodable</span><span class="p">(</span><span class="n">longitude</span><span class="p">)]</span>
     <span class="p">}</span>
 <span class="p">}</span>

 <span class="kd">struct</span> <span class="kt">Farm</span><span class="p">:</span> <span class="kt">KeyedCodable</span> <span class="p">{</span>
     <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
     <span class="k">let</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">Location</span>
     <span class="k">let</span> <span class="nv">animals</span><span class="p">:</span> <span class="p">[</span><span class="kt">Animal</span><span class="p">]</span>

     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">dictionary</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span> <span class="p">{</span>
         <span class="k">guard</span> <span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">"name"</span><span class="p">],</span>
             <span class="k">let</span> <span class="nv">location</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">"location"</span><span class="p">],</span>
             <span class="k">let</span> <span class="nv">animals</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">"animals"</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* throw */</span> <span class="p">}</span>

         <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="k">try</span> <span class="n">name</span><span class="o">.</span><span class="nf">as</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
         <span class="k">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="k">try</span> <span class="n">location</span><span class="o">.</span><span class="nf">as</span><span class="p">(</span><span class="kt">Location</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
         <span class="k">self</span><span class="o">.</span><span class="n">animals</span> <span class="o">=</span> <span class="k">try</span> <span class="n">animals</span><span class="o">.</span><span class="nf">asArrayOf</span><span class="p">(</span><span class="kt">Animal</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
     <span class="p">}</span>

     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyEncodable</span><span class="p">]</span> <span class="p">{</span>
         <span class="c1">// Similarly, AnyEncodable() should go away.</span>
         <span class="k">return</span> <span class="p">[</span><span class="s">"name"</span><span class="p">:</span> <span class="kt">AnyEncodable</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                 <span class="s">"location"</span><span class="p">:</span> <span class="kt">AnyEncodable</span><span class="p">(</span><span class="n">location</span><span class="p">),</span>
                 <span class="s">"animals"</span><span class="p">:</span> <span class="kt">AnyEncodable</span><span class="p">(</span><span class="n">animals</span><span class="p">)]</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Although the more declarative nature of this approach can be appealing, this suffers from the same problem that <code class="highlighter-rouge">JSONSerialization</code> currently does: as-casting. Getting an intermediate type-erased value requires casting to get a “real” value out. Doing this with an <code class="highlighter-rouge">as?</code>-cast requires compiler support to interject code to decode values of a given type out of their type-erased containers (similar to what happens today with <code class="highlighter-rouge">AnyHashable</code>). If the user requests a value of a different type than what is stored, however, the <code class="highlighter-rouge">as?</code>-cast will fail by returning <code class="highlighter-rouge">nil</code> — there is no meaningful way to report the failure. Getting the code to <code class="highlighter-rouge">throw</code> in cases like this requires methods on <code class="highlighter-rouge">AnyDecodable</code> (as shown above), but these can be confusing (when should you use <code class="highlighter-rouge">.as()</code> and when should you use <code class="highlighter-rouge">as?</code>?).</p> <p>Modifications can be made to improve this:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">protocol</span> <span class="kt">OrderedCodable</span> <span class="p">{</span>
     <span class="c1">// AnyDecodable can wrap anything, including [AnyDecodable]; unwrapping</span>
     <span class="c1">// these can be tedious, so we want to give default implementations</span>
     <span class="c1">// that do this.</span>
     <span class="c1">// Default implementations for these are given in terms of the</span>
     <span class="c1">// initializer below.</span>
     <span class="nf">init</span><span class="p">?(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">?)</span> <span class="k">throws</span>
     <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">)</span> <span class="k">throws</span>

     <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span>
     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyEncodable</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">KeyedCodable</span> <span class="p">{</span>
     <span class="c1">// AnyDecodable can wrap anything, including [String: AnyDecodable];</span>
     <span class="c1">// unwrapping these can be tedious, so we want to give default</span>
     <span class="c1">// implementations that do this.</span>
     <span class="c1">// Default implementations for these are given in terms of the</span>
     <span class="c1">// initializer below.</span>
     <span class="nf">init</span><span class="p">?(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">?)</span> <span class="k">throws</span>
     <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">)</span> <span class="k">throws</span>

     <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span>
     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyEncodable</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="c1">// Sample:</span>
 <span class="kd">struct</span> <span class="kt">Location</span><span class="p">:</span> <span class="kt">OrderedCodable</span> <span class="p">{</span>
     <span class="c1">// ...</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span> <span class="p">{</span>
         <span class="k">guard</span> <span class="n">array</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* throw */</span> <span class="p">}</span>
         <span class="k">let</span> <span class="nv">latitude</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Double</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
         <span class="k">let</span> <span class="nv">longitude</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Double</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
         <span class="k">try</span> <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">latitude</span><span class="p">:</span> <span class="n">latitude</span><span class="p">,</span> <span class="nv">longitude</span><span class="p">:</span> <span class="n">longitude</span><span class="p">)</span>
     <span class="p">}</span>
     <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="kd">struct</span> <span class="kt">Farm</span><span class="p">:</span> <span class="kt">KeyedCodable</span> <span class="p">{</span>
     <span class="c1">// ...</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">dictionary</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyDecodable</span><span class="p">])</span> <span class="k">throws</span> <span class="p">{</span>
         <span class="k">guard</span> <span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">String</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">"name"</span><span class="p">]),</span>
             <span class="k">let</span> <span class="nv">Location</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Location</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">"location"</span><span class="p">])</span>
             <span class="k">let</span> <span class="nv">animals</span> <span class="o">=</span> <span class="k">try</span> <span class="p">[</span><span class="kt">Animal</span><span class="p">](</span><span class="nv">from</span><span class="p">:</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">"animals"</span><span class="p">])</span> <span class="k">else</span> <span class="p">{</span>
             <span class="cm">/* throw */</span>
         <span class="p">}</span>

         <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
         <span class="k">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>
         <span class="k">self</span><span class="o">.</span><span class="n">animals</span> <span class="o">=</span> <span class="n">animals</span>
     <span class="p">}</span>
     <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>By providing the new initializer methods, we can perform type casting via initialization, rather than by explicit casts. This pushes the <code class="highlighter-rouge">.as()</code> calls into the Swift primitives (<code class="highlighter-rouge">CodingPrimitive</code>s, <code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">Dictionary</code>), hiding them from end users. However, this has a different problem, namely that by offering the same type-erased initializers, <code class="highlighter-rouge">OrderedCodable</code> and <code class="highlighter-rouge">KeyedCodable</code> now conflict, and it is impossible to conform to both.</p> <p>The declarative benefits here are not enough to outweigh the fact that this does not effectively remove the need to <code class="highlighter-rouge">as?</code>-cast.</p> </li> <li> <p>The following approach, which relies on compiler code generation:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">protocol</span> <span class="kt">Codable</span> <span class="p">{</span>
     <span class="c1">/// `EncodedType` is an intermediate representation of `Self` -- it has</span>
     <span class="c1">/// the properties from `Self` that need to be archived and unarchived</span>
     <span class="c1">/// (and performs that archival work), but represents at type that is</span>
     <span class="c1">/// not yet domain-validated like `self` is.</span>
     <span class="kd">associatedtype</span> <span class="kt">EncodedType</span><span class="p">:</span> <span class="kt">CodingRepresentation</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">encoded</span><span class="p">:</span> <span class="kt">EncodedType</span><span class="p">)</span>
     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="kt">EncodedType</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">CodingPrimitive</span> <span class="p">{}</span>
 <span class="kd">protocol</span> <span class="kt">CodingRepresentation</span> <span class="p">{}</span>
 <span class="kd">protocol</span> <span class="kt">PrimitiveCodingRepresentation</span><span class="p">:</span> <span class="kt">CodingRepresentation</span> <span class="p">{</span>
     <span class="cm">/* Similar to PrimitiveCodable above */</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">OrderedCodingRepresentation</span><span class="p">:</span> <span class="kt">CodingRepresentation</span> <span class="p">{</span>
     <span class="cm">/* Similar to OrderedCodable above */</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">KeyedCodingRepresentation</span><span class="p">:</span> <span class="kt">CodingRepresentation</span> <span class="p">{</span>
     <span class="cm">/* Similar to KeyedCodable above */</span>
 <span class="p">}</span>

 <span class="c1">// Sample:</span>
 <span class="kd">struct</span> <span class="kt">Location</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
     <span class="k">let</span> <span class="nv">latitude</span><span class="p">:</span> <span class="kt">Double</span>
     <span class="k">let</span> <span class="nv">longitude</span><span class="p">:</span> <span class="kt">Double</span>

     <span class="c1">// ---------------------------------------------------------------------</span>
     <span class="c1">// Ideally, the following could be generated by the compiler (in simple</span>
     <span class="c1">// cases; developers can choose to implement subsets of the following</span>
     <span class="c1">// code based on where they might need to perform customizations.</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">encoded</span><span class="p">:</span> <span class="kt">Encoded</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
         <span class="n">latitude</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">latitude</span>
         <span class="n">longitude</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">longitude</span>
     <span class="p">}</span>

     <span class="k">var</span> <span class="nv">encoded</span><span class="p">:</span> <span class="kt">Encoded</span> <span class="p">{</span>
         <span class="k">return</span> <span class="kt">Encoded</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
     <span class="p">}</span>

     <span class="c1">// Keyed coding is the default generated by the compiler; consumers who</span>
     <span class="c1">// want OrderedCodingRepresentation need to provide their own encoded</span>
     <span class="c1">// type.</span>
     <span class="kd">struct</span> <span class="kt">Encoded</span><span class="p">:</span> <span class="kt">OrderedCodingRepresentation</span> <span class="p">{</span>
         <span class="k">let</span> <span class="nv">latitude</span><span class="p">:</span> <span class="kt">String</span>
         <span class="k">let</span> <span class="nv">longitude</span><span class="p">:</span> <span class="kt">String</span>

         <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">Location</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">latitude</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">latitude</span>
             <span class="n">longitude</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">longitude</span>
         <span class="p">}</span>

         <span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">KeyedDecoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
         <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">KeyedEncoder</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
     <span class="p">}</span>
     <span class="c1">// ---------------------------------------------------------------------</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>This approach separates encoding and decoding into constituent steps:</p> <ol> <li>Converting <code class="highlighter-rouge">self</code> into a representation fit for encoding (<code class="highlighter-rouge">EncodedType</code>, particularly if <code class="highlighter-rouge">EncodedType</code> has different properties from <code class="highlighter-rouge">Self</code>)</li> <li>Converting that representation into data (<code class="highlighter-rouge">encode(into:)</code>)</li> <li>Converting arbitrary bytes into validated types (<code class="highlighter-rouge">EncodedType.init(from:)</code>)</li> <li>Converting validated data and types into a domain-validated value (<code class="highlighter-rouge">Self.init(from:)</code>).</li> </ol> <p>These steps can be generated by the compiler in simple cases, with gradations up to the developer providing implementations for all of these. With this approach, it would be possible to:</p> <ol> <li>Have a type where all code generation is left to the compiler</li> <li>Have a type where <code class="highlighter-rouge">EncodedType</code> is autogenerated, but the user implements <code class="highlighter-rouge">init(from:)</code> (allowing for custom domain validation on decode) or <code class="highlighter-rouge">var encoded</code>, or both</li> <li>Have a type where the user supplies <code class="highlighter-rouge">EncodedType</code>, <code class="highlighter-rouge">Self.init(from:)</code>, and <code class="highlighter-rouge">var encoded</code>, but the compiler generates <code class="highlighter-rouge">EncodedType.init(from:)</code> and <code class="highlighter-rouge">EncodedType.encode(into:)</code>. This allows the user to control what properties <code class="highlighter-rouge">EncodedType</code> has (or control its conformance to one of the <code class="highlighter-rouge">CodingRepresentation</code> types) without having to perform the actual <code class="highlighter-rouge">encode</code> and <code class="highlighter-rouge">decode</code> calls</li> <li>Have a type where the user supplies everything, giving them full control of encoding and decoding (for implementing archive versioning and other needs)</li> </ol> <p>While cases 1 and 2 save on boilerplate, types which need to be customized have significantly more boilerplate to write by hand.</p> </li> <li> <p>The following approach, which delineates between keyed encoding (with <code class="highlighter-rouge">String</code> keys) and ordered encoding (this is the approach proposed in v1 and v2 of this proposal):</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">protocol</span> <span class="kt">PrimitiveCodable</span> <span class="p">{</span>
     <span class="kd">associatedtype</span> <span class="kt">Atom</span><span class="p">:</span> <span class="kt">CodingAtom</span>
     <span class="k">var</span> <span class="nv">atomValue</span><span class="p">:</span> <span class="kt">Atom</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">atomValue</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Atom</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">OrderedCodable</span> <span class="p">{</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">OrderedDecoder</span><span class="p">)</span> <span class="k">throws</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">into</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">OrderedEncoder</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">KeyedCodable</span> <span class="p">{</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">KeyedDecoder</span><span class="p">)</span> <span class="k">throws</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">into</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">KeyedEncoder</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">OrderedEncoder</span> <span class="p">{</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">CodingAtom</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">PrimitiveCodable</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">KeyedCodable</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span> <span class="o">&amp;</span> <span class="kt">KeyedCodable</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">OrderedDecoder</span> <span class="p">{</span>
     <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">CodingAtom</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">PrimitiveCodable</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">KeyedCodable</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span> <span class="o">&amp;</span> <span class="kt">KeyedCodable</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">KeyedEncoder</span> <span class="p">{</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">CodingPrimitive</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">PrimitiveCodable</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">KeyedCodable</span>
     <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span> <span class="o">&amp;</span> <span class="kt">KeyedCodable</span>
 <span class="p">}</span>

 <span class="kd">protocol</span> <span class="kt">KeyedDecoder</span> <span class="p">{</span>
     <span class="k">var</span> <span class="nv">allKeys</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
     <span class="kd">func</span> <span class="nf">hasValue</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">CodingPrimitive</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">PrimitiveCodable</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">KeyedCodable</span>
     <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">Value</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Value</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Value</span><span class="p">:</span> <span class="kt">OrderedCodable</span> <span class="o">&amp;</span> <span class="kt">KeyedCodable</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Although this semantically separates between different types of encoding, the multiple protocols can be confusing, and it is not immediately apparent which to adopt and use. This also specifically calls out a difference between string-keyed and non-keyed coding, which is unnecessary.</p> </li> <li> <p>A closure-based version of the current approach which scopes keyed encoders/decoders to call sites via closures:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">protocol</span> <span class="kt">Encoder</span> <span class="p">{</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="k">as</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="k">throws</span>
     <span class="c1">// ...</span>

     <span class="kd">func</span> <span class="n">with</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keys</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">_</span> <span class="nv">block</span><span class="p">:</span> <span class="p">(</span><span class="kt">KeyedEncoder</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="k">rethrows</span>
     <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="kd">internal</span> <span class="kd">struct</span> <span class="kt">Record</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
     <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
     <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
     <span class="k">let</span> <span class="nv">timestamp</span><span class="p">:</span> <span class="kt">Double</span>

     <span class="c1">// ...</span>

     <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">into</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
         <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">with</span><span class="p">(</span><span class="nv">keys</span><span class="p">:</span> <span class="kt">Keys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">keyedEncode</span> <span class="k">in</span>
             <span class="k">try</span> <span class="n">keyedEncode</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">id</span><span class="p">)</span>

             <span class="k">try</span> <span class="n">keyedEncode</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="o">.</span><span class="n">dictionary</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">properties</span><span class="p">,</span> <span class="nv">keys</span><span class="p">:</span> <span class="kt">PropertiesKeys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">properties</span> <span class="k">in</span>
                 <span class="k">try</span> <span class="n">properties</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">name</span><span class="p">)</span>
                 <span class="k">try</span> <span class="n">properties</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>However, this cannot currently be applied to decoding:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
     <span class="c1">// This closure implicitly references self. Since Swift has no</span>
     <span class="c1">// guarantees that this closure will get called exactly once, self must</span>
     <span class="c1">// be fully initialized before this call.</span>
     <span class="c1">//</span>
     <span class="c1">// This would require all instance variables to be vars with default</span>
     <span class="c1">// values.</span>
     <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">with</span><span class="p">(</span><span class="nv">keys</span><span class="p">:</span> <span class="kt">Keys</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">keyedDecoder</span> <span class="k">in</span>
         <span class="n">id</span> <span class="o">=</span> <span class="k">try</span> <span class="n">keyedDecoder</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="o">.</span><span class="n">id</span><span class="p">)</span>
         <span class="c1">// ...</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Although it is not currently possible to initialize <code class="highlighter-rouge">self</code> within a closure in Swift, this may be added in the future as annotations make these guarantees possible.</p> </li> <li> <p>A previous approach similar to the current approach with single value encode calls available directly on <code class="highlighter-rouge">Encoder</code>, and a <code class="highlighter-rouge">KeyedEncoder</code> type instead of <code class="highlighter-rouge">KeyedEncodingContainer</code>:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Encoder</span> <span class="p">{</span>
     <span class="kd">func</span> <span class="n">keyed</span><span class="o">&lt;</span><span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncoder</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span>

     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="k">throws</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="k">throws</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">)</span> <span class="k">throws</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">)</span> <span class="k">throws</span>
     <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="k">throws</span>
     <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="kd">public</span> <span class="kd">class</span> <span class="kt">KeyedEncoder</span><span class="o">&lt;</span><span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="c1">// Identical to KeyedEncodingContainer</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ol> <h1 id="appendix"> <a href="#appendix" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Appendix </h1> <h2 id="jsonserialization-friction-and-third-party-solutions-motivation"> <a href="#jsonserialization-friction-and-third-party-solutions-motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <code class="highlighter-rouge">JSONSerialization</code> Friction and Third-Party Solutions (Motivation) </h2> <p>The following example usage of <code class="highlighter-rouge">JSONSerialization</code> is taken from the README of <a href="https://github.com/swiftyjson/swiftyjson">SwiftyJSON</a>, a third-party library that many developers use to interface with JSON models:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">statusesArray</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="kt">JSONSerialization</span><span class="o">.</span><span class="nf">jsonObject</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="o">.</span><span class="n">allowFragments</span><span class="p">)</span> <span class="k">as?</span> <span class="p">[[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]],</span>
    <span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="n">statusesArray</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">"user"</span><span class="p">]</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">],</span>
    <span class="k">let</span> <span class="nv">username</span> <span class="o">=</span> <span class="n">user</span><span class="p">[</span><span class="s">"name"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="c1">// Finally we got the username</span>
<span class="p">}</span>
</code></pre></div></div> <p>SwiftyJSON attempts to elide the verbosity of casting by offering the following solution instead:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="kt">JSON</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">dataFromNetworking</span><span class="p">)</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">userName</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">"user"</span><span class="p">][</span><span class="s">"name"</span><span class="p">]</span><span class="o">.</span><span class="n">string</span> <span class="p">{</span>
  <span class="c1">// Now you got your value</span>
<span class="p">}</span>
</code></pre></div></div> <p>This friction is not necessarily a design flaw in the API, simply a truth of interfacing between JavaScript and JSON’s generally untyped, unstructured contents, and Swift’s strict typing. Some libraries, like SwiftyJSON, do this at the cost of type safety; others, like ObjectMapper and Argo below, maintain type safety by offering archival functionality for JSON types:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Taken from https://github.com/Hearst-DD/ObjectMapper</span>
<span class="kd">class</span> <span class="kt">User</span><span class="p">:</span> <span class="kt">Mappable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">weight</span><span class="p">:</span> <span class="kt">Double</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyObject</span><span class="p">]?</span>
    <span class="k">var</span> <span class="nv">dictionary</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span> <span class="p">:</span> <span class="kt">AnyObject</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>
    <span class="k">var</span> <span class="nv">bestFriend</span><span class="p">:</span> <span class="kt">User</span><span class="p">?</span>                       <span class="c1">// Nested User object</span>
    <span class="k">var</span> <span class="nv">friends</span><span class="p">:</span> <span class="p">[</span><span class="kt">User</span><span class="p">]?</span>                        <span class="c1">// Array of Users</span>
    <span class="k">var</span> <span class="nv">birthday</span><span class="p">:</span> <span class="kt">NSDate</span><span class="p">?</span>

    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">map</span><span class="p">:</span> <span class="kt">Map</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="c1">// Mappable</span>
    <span class="kd">func</span> <span class="nf">mapping</span><span class="p">(</span><span class="nv">map</span><span class="p">:</span> <span class="kt">Map</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">username</span>    <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"username"</span><span class="p">]</span>
        <span class="n">age</span>         <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"age"</span><span class="p">]</span>
        <span class="n">weight</span>      <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"weight"</span><span class="p">]</span>
        <span class="n">array</span>       <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"arr"</span><span class="p">]</span>
        <span class="n">dictionary</span>  <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"dict"</span><span class="p">]</span>
        <span class="n">bestFriend</span>  <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"best_friend"</span><span class="p">]</span>
        <span class="n">friends</span>     <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"friends"</span><span class="p">]</span>
        <span class="n">birthday</span>    <span class="o">&lt;-</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="s">"birthday"</span><span class="p">],</span> <span class="kt">DateTransform</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Temperature</span><span class="p">:</span> <span class="kt">Mappable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">celsius</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">fahrenheit</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">?(</span><span class="nv">map</span><span class="p">:</span> <span class="kt">Map</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">mapping</span><span class="p">(</span><span class="nv">map</span><span class="p">:</span> <span class="kt">Map</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">celsius</span>     <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"celsius"</span><span class="p">]</span>
        <span class="n">fahrenheit</span>  <span class="o">&lt;-</span> <span class="n">map</span><span class="p">[</span><span class="s">"fahrenheit"</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>or the more functional</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Taken from https://github.com/thoughtbot/Argo</span>
<span class="kd">struct</span> <span class="kt">User</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">let</span> <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
  <span class="k">let</span> <span class="nv">role</span><span class="p">:</span> <span class="kt">Role</span>
  <span class="k">let</span> <span class="nv">companyName</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">let</span> <span class="nv">friends</span><span class="p">:</span> <span class="p">[</span><span class="kt">User</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">User</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="nv">j</span><span class="p">:</span> <span class="kt">JSON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Decoded</span><span class="o">&lt;</span><span class="kt">User</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">curry</span><span class="p">(</span><span class="kt">User</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
      <span class="o">&lt;^&gt;</span> <span class="n">j</span> <span class="o">&lt;|</span> <span class="s">"id"</span>
      <span class="o">&lt;*&gt;</span> <span class="n">j</span> <span class="o">&lt;|</span> <span class="s">"name"</span>
      <span class="o">&lt;*&gt;</span> <span class="n">j</span> <span class="o">&lt;|</span><span class="p">?</span> <span class="s">"email"</span> <span class="c1">// Use ? for parsing optional values</span>
      <span class="o">&lt;*&gt;</span> <span class="n">j</span> <span class="o">&lt;|</span> <span class="s">"role"</span> <span class="c1">// Custom types that also conform to Decodable just work</span>
      <span class="o">&lt;*&gt;</span> <span class="n">j</span> <span class="o">&lt;|</span> <span class="p">[</span><span class="s">"company"</span><span class="p">,</span> <span class="s">"name"</span><span class="p">]</span> <span class="c1">// Parse nested objects</span>
      <span class="o">&lt;*&gt;</span> <span class="n">j</span> <span class="o">&lt;||</span> <span class="s">"friends"</span> <span class="c1">// parse arrays of objects</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Wherever you receive JSON data:</span>
<span class="k">let</span> <span class="nv">json</span><span class="p">:</span> <span class="kt">Any</span><span class="p">?</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="kt">NSJSONSerialization</span><span class="o">.</span><span class="kt">JSONObjectWithData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">j</span><span class="p">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">json</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">user</span><span class="p">:</span> <span class="kt">User</span><span class="p">?</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are tradeoffs made here as well. ObjectMapper requires that all of your properties be optional, while Argo relies on a vast collection of custom operators and custom curried initializer functions to do its work. (While not shown in the snippet above, <code class="highlighter-rouge">User.init</code> code in reality is effectively implemented as <code class="highlighter-rouge">User.init(id)(name)(email)(role)(companyName)(friends)</code>.)</p> <p>We would like to provide a solution that skirts neither type safety, nor ease-of-use and -implementation.</p> <h2 id="unabridged-api"> <a href="#unabridged-api" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Unabridged API </h2> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Conformance to `Encodable` indicates that a type can encode itself to an external representation.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Encodable</span> <span class="p">{</span>
    <span class="c1">/// Encodes `self` into the given encoder.</span>
    <span class="c1">///</span>
    <span class="c1">/// If `self` fails to encode anything, `encoder` will encode an empty keyed container in its place.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter encoder: The encoder to write data to.</span>
    <span class="c1">/// - throws: An error if any values are invalid for `encoder`'s format.</span>
    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `Decodable` indicates that a type can decode itself from an external representation.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Decodable</span> <span class="p">{</span>
    <span class="c1">/// Initializes `self` by decoding from `decoder`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter decoder: The decoder to read data from.</span>
    <span class="c1">/// - throws: An error if reading from the decoder fails, or if read data is corrupted or otherwise invalid.</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `Codable` indicates that a type can convert itself into and out of an external representation.</span>
<span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">Codable</span> <span class="o">=</span> <span class="kt">Encodable</span> <span class="o">&amp;</span> <span class="kt">Decodable</span>

<span class="c1">/// Conformance to `CodingKey` indicates that a type can be used as a key for encoding and decoding.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">CodingKey</span> <span class="p">{</span>
    <span class="c1">/// The string to use in a named collection (e.g. a string-keyed dictionary).</span>
    <span class="k">var</span> <span class="nv">stringValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Initializes `self` from a string.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter stringValue: The string value of the desired key.</span>
    <span class="c1">/// - returns: An instance of `Self` from the given string, or `nil` if the given string does not correspond to any instance of `Self`.</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">stringValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>

    <span class="c1">/// The int to use in an indexed collection (e.g. an int-keyed dictionary).</span>
    <span class="k">var</span> <span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Initializes `self` from an integer.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter intValue: The integer value of the desired key.</span>
    <span class="c1">/// - returns: An instance of `Self` from the given integer, or `nil` if the given integer does not correspond to any instance of `Self`.</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">/// An `Encoder` is a type which can encode values into a native format for external representation.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Encoder</span> <span class="p">{</span>
    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Any contextual information set by the user for encoding.</span>
    <span class="k">var</span> <span class="nv">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingUserInfoKey</span> <span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns an encoding container appropriate for holding multiple values keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.unkeyedContainer()` call.</span>
    <span class="c1">/// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call.</span>
    <span class="kd">func</span> <span class="n">container</span><span class="o">&lt;</span><span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span>

    <span class="c1">/// Returns an encoding container appropriate for holding multiple unkeyed values.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new empty unkeyed container.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.container(keyedBy:)` call.</span>
    <span class="c1">/// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call.</span>
    <span class="kd">func</span> <span class="nf">unkeyedContainer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>

    <span class="c1">/// Returns an encoding container appropriate for holding a single primitive value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new empty single value container.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.container(keyedBy:)` call.</span>
    <span class="c1">/// - precondition: May not be called after a prior `self.unkeyedContainer()` call.</span>
    <span class="c1">/// - precondition: May not be called after a value has been encoded through a previous `self.singleValueContainer()` call.</span>
    <span class="kd">func</span> <span class="nf">singleValueContainer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">SingleValueEncodingContainer</span>
<span class="p">}</span>

<span class="c1">/// A `Decoder` is a type which can decode values from a native format into in-memory representations.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Decoder</span> <span class="p">{</span>
    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Any contextual information set by the user for decoding.</span>
    <span class="k">var</span> <span class="nv">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingUserInfoKey</span> <span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns the data stored in `self` as represented in a container keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="kd">func</span> <span class="n">container</span><span class="o">&lt;</span><span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span>

    <span class="c1">/// Returns the data stored in `self` as represented in a container appropriate for holding values with no keys.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: An unkeyed container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="kd">func</span> <span class="nf">unkeyedContainer</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>

    <span class="c1">/// Returns the data stored in `self` as represented in a container appropriate for holding a single primitive value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A single value container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a single value container.</span>
    <span class="kd">func</span> <span class="nf">singleValueContainer</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">SingleValueDecodingContainer</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `KeyedEncodingContainerProtocol` indicates that a type provides a view into an `Encoder`'s storage and is used to hold the encoded properties of an `Encodable` type in a keyed manner.</span>
<span class="c1">///</span>
<span class="c1">/// Encoders should provide types conforming to `KeyedEncodingContainerProtocol` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedEncodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span>

    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Encodes the given value for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the value with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given value for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the value with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given object weakly for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// For `Encoder`s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</span>
    <span class="c1">///</span>
    <span class="c1">/// For formats which don't support this feature, the default implementation encodes the given object unconditionally.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter object: The object to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the object with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encodeWeak</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">&amp;</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Stores a keyed encoding container for the given key and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter keyType: The key type to use for the container.</span>
    <span class="c1">/// - parameter key: The key to encode the container for.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">keyType</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Stores an unkeyed encoding container for the given key and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to encode the container for.</span>
    <span class="c1">/// - returns: A new unkeyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>

    <span class="c1">/// Stores a new nested container for the default `super` key and returns a new `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// Equivalent to calling `superEncoder(forKey:)` with `Key(stringValue: "super", intValue: 0)`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>

    <span class="c1">/// Stores a new nested container for the given key and returns a new `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to encode `super` for.</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>
<span class="p">}</span>

<span class="c1">/// `KeyedEncodingContainer` is a type-erased box for `KeyedEncodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">K</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">KeyedEncodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="o">=</span> <span class="kt">K</span>

    <span class="c1">/// Initializes `self` with the given container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter container: The container to hold.</span>
    <span class="kd">init</span><span class="o">&lt;</span><span class="kt">Container</span> <span class="p">:</span> <span class="kt">KeyedEncodingContainerProtocol</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">container</span><span class="p">:</span> <span class="kt">Container</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Container</span><span class="o">.</span><span class="kt">Key</span> <span class="o">==</span> <span class="kt">Key</span>

    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Encodes the given value for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the value with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given value for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the value with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">?,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">?,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given object weakly for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// For `Encoder`s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</span>
    <span class="c1">///</span>
    <span class="c1">/// For formats which don't support this feature, the default implementation encodes the given object unconditionally.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter object: The object to encode.</span>
    <span class="c1">/// - parameter key: The key to associate the object with.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encodeWeak</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">&amp;</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">?,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span>

    <span class="c1">/// Stores a keyed encoding container for the given key and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter keyType: The key type to use for the container.</span>
    <span class="c1">/// - parameter key: The key to encode the container for.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">keyType</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Stores an unkeyed encoding container for the given key and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to encode the container for.</span>
    <span class="c1">/// - returns: A new unkeyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>

    <span class="c1">/// Stores a new nested container for the default `super` key and returns a new `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// Equivalent to calling `superEncoder(forKey:)` with `Key(stringValue: "super", intValue: 0)`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>

    <span class="c1">/// Stores a new nested container for the given key and returns a new `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to encode `super` for.</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `KeyedDecodingContainerProtocol` indicates that a type provides a view into a `Decoder`'s storage and is used to hold the encoded properties of a `Decodable` type in a keyed manner.</span>
<span class="c1">///</span>
<span class="c1">/// Decoders should provide types conforming to `KeyedDecodingContainerProtocol` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span>

    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// All the keys the `Decoder` has for this container.</span>
    <span class="c1">///</span>
    <span class="c1">/// Different keyed containers from the same `Decoder` may return different keys here; it is possible to encode with multiple key types which are not convertible to one another. This should report all keys present which are convertible to the requested type.</span>
    <span class="k">var</span> <span class="nv">allKeys</span><span class="p">:</span> <span class="p">[</span><span class="kt">Key</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns whether the `Decoder` contains a value associated with the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// The value associated with the given key may be a null value as appropriate for the data format.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to search for.</span>
    <span class="c1">/// - returns: Whether the `Decoder` has an entry for the given key.</span>
    <span class="kd">func</span> <span class="nf">contains</span><span class="p">(</span><span class="n">_</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

    <span class="c1">/// Decodes a value of the given type for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - parameter key: The key that the decoded value is associated with.</span>
    <span class="c1">/// - returns: A value of the requested type, if present for the given key and convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key or if the value is null.</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span>

    <span class="c1">/// Decodes a value of the given type for the given key, if present.</span>
    <span class="c1">///</span>
    <span class="c1">/// This method returns `nil` if the container does not have a value associated with `key`, or if the value is null. The difference between these states can be distinguished with a `contains(_:)` call.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - parameter key: The key that the decoded value is associated with.</span>
    <span class="c1">/// - returns: A decoded value of the requested type, or `nil` if the `Decoder` does not have an entry associated with the given key, or if the value is a null value.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="kd">func</span> <span class="n">decodeIfPresent</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span>

    <span class="c1">/// Returns the data stored for the given key as represented in a container keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - parameter key: The key that the nested container is associated with.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Returns the data stored for the given key as represented in an unkeyed container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key that the nested container is associated with.</span>
    <span class="c1">/// - returns: An unkeyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>

    <span class="c1">/// Returns a `Decoder` instance for decoding `super` from the container associated with the default `super` key.</span>
    <span class="c1">///</span>
    <span class="c1">/// Equivalent to calling `superDecoder(forKey:)` with `Key(stringValue: "super", intValue: 0)`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the default `super` key, or if the stored value is null.</span>
    <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>

    <span class="c1">/// Returns a `Decoder` instance for decoding `super` from the container associated with the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to decode `super` for.</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key, or if the stored value is null.</span>
    <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>
<span class="p">}</span>

<span class="c1">/// `KeyedDecodingContainer` is a type-erased box for `KeyedDecodingContainerProtocol` types, similar to `AnyCollection` and `AnyHashable`. This is the type which consumers of the API interact with directly.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">K</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Key</span> <span class="o">=</span> <span class="kt">K</span>

    <span class="c1">/// Initializes `self` with the given container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter container: The container to hold.</span>
    <span class="kd">init</span><span class="o">&lt;</span><span class="kt">Container</span> <span class="p">:</span> <span class="kt">KeyedDecodingContainerProtocol</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">container</span><span class="p">:</span> <span class="kt">Container</span><span class="p">)</span> <span class="k">where</span> <span class="kt">Container</span><span class="o">.</span><span class="kt">Key</span> <span class="o">==</span> <span class="kt">Key</span>

    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// All the keys the `Decoder` has for this container.</span>
    <span class="c1">///</span>
    <span class="c1">/// Different keyed containers from the same `Decoder` may return different keys here; it is possible to encode with multiple key types which are not convertible to one another. This should report all keys present which are convertible to the requested type.</span>
    <span class="k">var</span> <span class="nv">allKeys</span><span class="p">:</span> <span class="p">[</span><span class="kt">Key</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns whether the `Decoder` contains a value associated with the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// The value associated with the given key may be a null value as appropriate for the data format.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to search for.</span>
    <span class="c1">/// - returns: Whether the `Decoder` has an entry for the given key.</span>
    <span class="kd">func</span> <span class="nf">contains</span><span class="p">(</span><span class="n">_</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

    <span class="c1">/// Decodes a value of the given type for the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - parameter key: The key that the decoded value is associated with.</span>
    <span class="c1">/// - returns: A value of the requested type, if present for the given key and convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key or if the value is null.</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span>

    <span class="c1">/// Decodes a value of the given type for the given key, if present.</span>
    <span class="c1">///</span>
    <span class="c1">/// This method returns `nil` if the container does not have a value associated with `key`, or if the value is null. The difference between these states can be distinguished with a `contains(_:)` call.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - parameter key: The key that the decoded value is associated with.</span>
    <span class="c1">/// - returns: A decoded value of the requested type, or `nil` if the `Decoder` does not have an entry associated with the given key, or if the value is a null value.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>    <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>   <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span>  <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="kd">func</span> <span class="n">decodeIfPresent</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span>

    <span class="c1">/// Returns the data stored for the given key as represented in a container keyed by the given key type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - parameter key: The key that the nested container is associated with.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Returns the data stored for the given key as represented in an unkeyed container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key that the nested container is associated with.</span>
    <span class="c1">/// - returns: An unkeyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>

    <span class="c1">/// Returns a `Decoder` instance for decoding `super` from the container associated with the default `super` key.</span>
    <span class="c1">///</span>
    <span class="c1">/// Equivalent to calling `superDecoder(forKey:)` with `Key(stringValue: "super", intValue: 0)`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the default `super` key, or if the stored value is null.</span>
    <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>

    <span class="c1">/// Returns a `Decoder` instance for decoding `super` from the container associated with the given key.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter key: The key to decode `super` for.</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if `self` does not have an entry for the given key, or if the stored value is null.</span>
    <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `UnkeyedEncodingContainer` indicates that a type provides a view into an `Encoder`'s storage and is used to hold the encoded properties of an `Encodable` type sequentially, without keys.</span>
<span class="c1">///</span>
<span class="c1">/// Encoders should provide types conforming to `UnkeyedEncodingContainer` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedEncodingContainer</span> <span class="p">{</span>
    <span class="c1">/// The path of coding keys taken to get to this point in encoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Encodes the given value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">?)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given value.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">?)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the given object weakly.</span>
    <span class="c1">///</span>
    <span class="c1">/// For `Encoder`s that implement this functionality, this will only encode the given object if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</span>
    <span class="c1">///</span>
    <span class="c1">/// For formats which don't support this feature, the default implementation encodes the given object unconditionally.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter object: The object to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encodeWeak</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">&amp;</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">?)</span> <span class="k">throws</span>

    <span class="c1">/// Encodes the elements of the given sequence.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation of these is given in an extension.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter sequence: The sequences whose contents to encode.</span>
    <span class="c1">/// - throws: An error if any of the contained values throws an error.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Bool</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int8</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int16</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int32</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int64</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt8</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt16</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt32</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">UInt64</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Float</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Double</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">String</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">encode</span><span class="o">&lt;</span><span class="kt">Sequence</span> <span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contentsOf</span> <span class="nv">sequence</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">)</span> <span class="k">throws</span> <span class="k">where</span> <span class="kt">Sequence</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="p">:</span> <span class="kt">Encodable</span>

    <span class="c1">/// Encodes a nested container keyed by the given type and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter keyType: The key type to use for the container.</span>
    <span class="c1">/// - returns: A new keyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">keyType</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">KeyedEncodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Encodes an unkeyed encoding container and returns it.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new unkeyed encoding container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedEncodingContainer</span>

    <span class="c1">/// Encodes a nested container and returns an `Encoder` instance for encoding `super` into that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Encoder` to pass to `super.encode(to:)`.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superEncoder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Encoder</span>
<span class="p">}</span>

<span class="c1">/// Conformance to `UnkeyedDecodingContainer` indicates that a type provides a view into a `Decoder`'s storage and is used to hold the encoded properties of a `Decodable` type sequentially, without keys.</span>
<span class="c1">///</span>
<span class="c1">/// Decoders should provide types conforming to `UnkeyedDecodingContainer` for their format.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">UnkeyedDecodingContainer</span> <span class="p">{</span>
    <span class="c1">/// The path of coding keys taken to get to this point in decoding.</span>
    <span class="c1">/// A `nil` value indicates an unkeyed container.</span>
    <span class="k">var</span> <span class="nv">codingPath</span><span class="p">:</span> <span class="p">[</span><span class="kt">CodingKey</span><span class="p">?]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns the number of elements (if known) contained within this container.</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Returns whether there are no more elements left to be decoded in the container.</span>
    <span class="k">var</span> <span class="nv">isAtEnd</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="c1">/// Decodes a value of the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// A default implementation is given for these types which calls into the `decodeIfPresent` implementations below.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - returns: A value of the requested type, if present for the given key and convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span>

    <span class="c1">/// Decodes a value of the given type, if present.</span>
    <span class="c1">///</span>
    <span class="c1">/// This method returns `nil` if the container has no elements left to decode, or if the value is null. The difference between these states can be distinguished by checking `isAtEnd`.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type of value to decode.</span>
    <span class="c1">/// - returns: A decoded value of the requested type, or `nil` if the value is a null value, or if there are no more elements to decode.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value is not convertible to the requested type.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">decodeIfPresent</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">decodeIfPresent</span><span class="o">&lt;</span><span class="kt">T</span> <span class="p">:</span> <span class="kt">Decodable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span>

    <span class="c1">/// Decodes a nested container keyed by the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The key type to use for the container.</span>
    <span class="c1">/// - returns: A keyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not a keyed container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="n">nestedContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span> <span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">NestedKey</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">NestedKey</span><span class="o">&gt;</span>

    <span class="c1">/// Decodes an unkeyed nested container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: An unkeyed decoding container view into `self`.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered stored value is not an unkeyed container.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">nestedUnkeyedContainer</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UnkeyedDecodingContainer</span>

    <span class="c1">/// Decodes a nested container and returns a `Decoder` instance for decoding `super` from that container.</span>
    <span class="c1">///</span>
    <span class="c1">/// - returns: A new `Decoder` to pass to `super.init(from:)`.</span>
    <span class="c1">/// - throws: `CocoaError.coderValueNotFound` if the encountered encoded value is null, or of there are no more values to decode.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">superDecoder</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Decoder</span>
<span class="p">}</span>

<span class="c1">/// A `SingleValueEncodingContainer` is a container which can support the storage and direct encoding of a single non-keyed value.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">SingleValueEncodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Encodes a single value of the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter value: The value to encode.</span>
    <span class="c1">/// - throws: `CocoaError.coderInvalidValue` if the given value is invalid in the current context for this format.</span>
    <span class="c1">/// - precondition: May not be called after a previous `self.encode(_:)` call.</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int8</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int16</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int32</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt16</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt32</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">UInt64</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="k">throws</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="c1">/// A `SingleValueDecodingContainer` is a container which can support the storage and direct decoding of a single non-keyed value.</span>
<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">SingleValueDecodingContainer</span> <span class="p">{</span>
    <span class="c1">/// Decodes a single value of the given type.</span>
    <span class="c1">///</span>
    <span class="c1">/// - parameter type: The type to decode as.</span>
    <span class="c1">/// - returns: A value of the requested type.</span>
    <span class="c1">/// - throws: `CocoaError.coderTypeMismatch` if the encountered encoded value cannot be converted to the requested type.</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Bool</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Int64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt8</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt16</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt16</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt32</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt32</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">UInt64</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UInt64</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Double</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
    <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="c1">/// Represents a user-defined key for providing context for encoding and decoding.</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">CodingUserInfoKey</span> <span class="p">:</span> <span class="kt">RawRepresentable</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">RawValue</span> <span class="o">=</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Repeat for all primitive types...</span>
<span class="kd">extension</span> <span class="kt">Bool</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Bool</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span> <span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Repeat for all primitive types...</span>
<span class="kd">public</span> <span class="kd">extension</span> <span class="kt">RawRepresentable</span> <span class="k">where</span> <span class="kt">RawValue</span> <span class="o">==</span> <span class="kt">Bool</span><span class="p">,</span> <span class="k">Self</span> <span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">decoded</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">RawValue</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">Self</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">decoded</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">CocoaError</span><span class="o">.</span><span class="nf">error</span><span class="p">(</span><span class="o">.</span><span class="n">coderReadCorrupt</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">self</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">rawValue</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </div> </div> </body> </html>
