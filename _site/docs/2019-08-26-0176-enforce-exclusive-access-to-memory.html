<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>SE-0176 Enforce Exclusive Access to Memory - Swift Evolution List</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>SE-0176 Enforce Exclusive Access to Memory | Swift Evolution List</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="SE-0176 Enforce Exclusive Access to Memory" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Yuhuu!" /> <meta property="og:description" content="Yuhuu!" /> <link rel="canonical" href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" /> <meta property="og:url" content="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" /> <meta property="og:site_name" content="Swift Evolution List" /> <script type="application/ld+json"> {"url":"http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html","headline":"SE-0176 Enforce Exclusive Access to Memory","description":"Yuhuu!","@type":"WebPage","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Swift Evolution List</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/about/" class="navigation-list-link">About</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0001-keywords-as-argument-labels.html" class="navigation-list-link">SE-0001 Allow (most) keywords as argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0002-remove-currying.html" class="navigation-list-link">SE-0002 Removing currying `func` declaration syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0003-remove-var-parameters.html" class="navigation-list-link">SE-0003 Removing `var` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0004-remove-pre-post-inc-decrement.html" class="navigation-list-link">SE-0004 Remove the `++` and `--` operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0005-objective-c-name-translation.html" class="navigation-list-link">SE-0005 Better Translation of Objective-C APIs Into Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0006-apply-api-guidelines-to-the-standard-library.html" class="navigation-list-link">SE-0006 Apply API Guidelines to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0007-remove-c-style-for-loops.html" class="navigation-list-link">SE-0007 Remove C-style for-loops with conditions and incrementers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0008-lazy-flatmap-for-optionals.html" class="navigation-list-link">SE-0008 Add a Lazy flatMap for Sequences of Optionals #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0009-require-self-for-accessing-instance-members.html" class="navigation-list-link">SE-0009 Require self for accessing instance members</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0010-add-staticstring-unicodescalarview.html" class="navigation-list-link">SE-0010 Add StaticString.UnicodeScalarView</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0011-replace-typealias-associated.html" class="navigation-list-link">SE-0011 Replace `typealias` keyword with `associatedtype` for associated type declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0012-add-noescape-to-public-library-api.html" class="navigation-list-link">SE-0012 Add `@noescape` to public library API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0013-remove-partial-application-super.html" class="navigation-list-link">SE-0013 Remove Partial Application of Non-Final Super Methods (Swift 2.2)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0014-constrained-AnySequence.html" class="navigation-list-link">SE-0014 Constraining `AnySequence.init`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0015-tuple-comparison-operators.html" class="navigation-list-link">SE-0015 Tuple comparison operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0016-initializers-for-converting-unsafe-pointers-to-ints.html" class="navigation-list-link">SE-0016 Add initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0017-convert-unmanaged-to-use-unsafepointer.html" class="navigation-list-link">SE-0017 Change `Unmanaged` to use `UnsafePointer`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0018-flexible-memberwise-initialization.html" class="navigation-list-link">SE-0018 Flexible Memberwise Initialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0019-package-manager-testing.html" class="navigation-list-link">SE-0019 Swift Testing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0020-if-swift-version.html" class="navigation-list-link">SE-0020 Swift Language Version Build Configuration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0021-generalized-naming.html" class="navigation-list-link">SE-0021 Naming Functions with Argument Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0022-objc-selectors.html" class="navigation-list-link">SE-0022 Referencing the Objective-C selector of a method</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0023-api-guidelines.html" class="navigation-list-link">SE-0023 API Design Guidelines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0024-optional-value-setter.html" class="navigation-list-link">SE-0024 Optional Value Setter `??=`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0025-scoped-access-level.html" class="navigation-list-link">SE-0025 Scoped Access Level</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0026-abstract-classes-and-methods.html" class="navigation-list-link">SE-0026 Abstract classes and methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0027-string-from-code-units.html" class="navigation-list-link">SE-0027 Expose code unit initializers on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0028-modernizing-debug-identifiers.html" class="navigation-list-link">SE-0028 Modernizing Swift's Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0029-remove-implicit-tuple-splat.html" class="navigation-list-link">SE-0029 Remove implicit tuple splat behavior from function applications</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0030-property-behavior-decls.html" class="navigation-list-link">SE-0030 Property Behaviors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0031-adjusting-inout-declarations.html" class="navigation-list-link">SE-0031 Adjusting `inout` Declarations for Type Decoration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0032-sequencetype-find.html" class="navigation-list-link">SE-0032 Add `first(where:)` method to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0033-import-objc-constants.html" class="navigation-list-link">SE-0033 Import Objective-C Constants as Swift Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0034-disambiguating-line.html" class="navigation-list-link">SE-0034 Disambiguating Line Control Statements from Debugging Identifiers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0035-limit-inout-capture.html" class="navigation-list-link">SE-0035 Limiting `inout` capture to `@noescape` contexts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0036-enum-dot.html" class="navigation-list-link">SE-0036 Requiring Leading Dot Prefixes for Enum Instance Member Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0037-clarify-comments-and-operators.html" class="navigation-list-link">SE-0037 Clarify interaction between comments & operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0038-swiftpm-c-language-targets.html" class="navigation-list-link">SE-0038 Package Manager C Language Target Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0039-playgroundliterals.html" class="navigation-list-link">SE-0039 Modernizing Playground Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0040-attributecolons.html" class="navigation-list-link">SE-0040 Replacing Equal Signs with Colons For Attribute Arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0041-conversion-protocol-conventions.html" class="navigation-list-link">SE-0041 Updating Protocol Naming Conventions for Conversions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0042-flatten-method-types.html" class="navigation-list-link">SE-0042 Flattening the function type of unapplied method references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0043-declare-variables-in-case-labels-with-multiple-patterns.html" class="navigation-list-link">SE-0043 Declare variables in 'case' labels with multiple patterns </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0044-import-as-member.html" class="navigation-list-link">SE-0044 Import as member</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0045-scan-takewhile-dropwhile.html" class="navigation-list-link">SE-0045 Add prefix(while:) and drop(while:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0046-first-label.html" class="navigation-list-link">SE-0046 Establish consistent label behavior across all parameters including first labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0047-nonvoid-warn.html" class="navigation-list-link">SE-0047 Defaulting non-Void functions so they warn on unused results</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0048-generic-typealias.html" class="navigation-list-link">SE-0048 Generic Type Aliases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0049-noescape-autoclosure-type-attrs.html" class="navigation-list-link">SE-0049 Move @noescape and @autoclosure to be type attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0050-floating-point-stride.html" class="navigation-list-link">SE-0050 Decoupling Floating Point Strides from Generic Implementations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0051-stride-semantics.html" class="navigation-list-link">SE-0051 Conventionalizing `stride` semantics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0052-iterator-post-nil-guarantee.html" class="navigation-list-link">SE-0052 Change IteratorType post-nil guarantee</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0053-remove-let-from-function-parameters.html" class="navigation-list-link">SE-0053 Remove explicit use of `let` from Function Parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0054-abolish-iuo.html" class="navigation-list-link">SE-0054 Abolish `ImplicitlyUnwrappedOptional` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0055-optional-unsafe-pointers.html" class="navigation-list-link">SE-0055 Make unsafe pointer nullability explicit using Optional</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0056-trailing-closures-in-guard.html" class="navigation-list-link">SE-0056 Allow trailing closures in `guard` conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0057-importing-objc-generics.html" class="navigation-list-link">SE-0057 Importing Objective-C Lightweight Generics</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0058-objectivecbridgeable.html" class="navigation-list-link">SE-0058 Allow Swift types to provide custom Objective-C representations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0059-updated-set-apis.html" class="navigation-list-link">SE-0059 Update API Naming Guidelines and Rewrite Set APIs Accordingly</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0060-defaulted-parameter-order.html" class="navigation-list-link">SE-0060 Enforcing order of defaulted parameters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0061-autoreleasepool-signature.html" class="navigation-list-link">SE-0061 Add Generic Result and Error Handling to autoreleasepool()</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0062-objc-keypaths.html" class="navigation-list-link">SE-0062 Referencing Objective-C key-paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0063-swiftpm-system-module-search-paths.html" class="navigation-list-link">SE-0063 SwiftPM System Module Search Paths</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0064-property-selectors.html" class="navigation-list-link">SE-0064 Referencing the Objective-C selector of property getters and setters</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0065-collections-move-indices.html" class="navigation-list-link">SE-0065 A New Model for Collections and Indices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0066-standardize-function-type-syntax.html" class="navigation-list-link">SE-0066 Standardize function type argument syntax to require parentheses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0067-floating-point-protocols.html" class="navigation-list-link">SE-0067 Enhanced Floating Point Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0068-universal-self.html" class="navigation-list-link">SE-0068 Expanding Swift `Self` to class members and value types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0069-swift-mutability-for-foundation.html" class="navigation-list-link">SE-0069 Mutability and Foundation Value Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0070-optional-requirements.html" class="navigation-list-link">SE-0070 Make Optional Requirements Objective-C-only</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0071-member-keywords.html" class="navigation-list-link">SE-0071 Allow (most) keywords in member references</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0072-eliminate-implicit-bridging-conversions.html" class="navigation-list-link">SE-0072 Fully eliminate implicit bridging conversions from Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0073-noescape-once.html" class="navigation-list-link">SE-0073 Marking closures as executing exactly once</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0074-binary-search.html" class="navigation-list-link">SE-0074 Implementation of Binary Search functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0075-import-test.html" class="navigation-list-link">SE-0075 Adding a Build Configuration Import Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.html" class="navigation-list-link">SE-0076 Add overrides taking an UnsafePointer source to non-destructive copying methods on UnsafeMutablePointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0077-operator-precedence.html" class="navigation-list-link">SE-0077 Improved operator declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0078-rotate-algorithm.html" class="navigation-list-link">SE-0078 Implement a rotate algorithm, equivalent to std::rotate() in C++</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0079-upgrade-self-from-weak-to-strong.html" class="navigation-list-link">SE-0079 Allow using optional binding to upgrade `self` from a weak to strong reference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0080-failable-numeric-initializers.html" class="navigation-list-link">SE-0080 Failable Numeric Conversion Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0081-move-where-expression.html" class="navigation-list-link">SE-0081 Move `where` clause to end of declaration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0082-swiftpm-package-edit.html" class="navigation-list-link">SE-0082 Package Manager Editable Packages</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0083-remove-bridging-from-dynamic-casts.html" class="navigation-list-link">SE-0083 Remove bridging conversion behavior from dynamic casts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0084-trailing-commas.html" class="navigation-list-link">SE-0084 Allow trailing commas in parameter lists and tuples</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0085-package-manager-command-name.html" class="navigation-list-link">SE-0085 Package Manager Command Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0086-drop-foundation-ns.html" class="navigation-list-link">SE-0086 Drop NS Prefix in Swift Foundation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0087-lazy-attribute.html" class="navigation-list-link">SE-0087 Rename `lazy` to `@lazy`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0088-libdispatch-for-swift3.html" class="navigation-list-link">SE-0088 Modernize libdispatch for Swift 3 naming conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0089-rename-string-reflection-init.html" class="navigation-list-link">SE-0089 Renaming `String.init<T>(_: T)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0090-remove-dot-self.html" class="navigation-list-link">SE-0090 Remove `.self` and freely allow type references in expressions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0091-improving-operators-in-protocols.html" class="navigation-list-link">SE-0091 Improving operator requirements in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0092-typealiases-in-protocols.html" class="navigation-list-link">SE-0092 Typealiases in protocols and protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0093-slice-base.html" class="navigation-list-link">SE-0093 Adding a public `base` property to slices</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0094-sequence-function.html" class="navigation-list-link">SE-0094 Add sequence(first:next:) and sequence(state:next:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0095-any-as-existential.html" class="navigation-list-link">SE-0095 Replace `protocol<P1,P2>` syntax with `P1 & P2` syntax</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0096-dynamictype.html" class="navigation-list-link">SE-0096 Converting `dynamicType` from a property to an operator</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0097-negative-attributes.html" class="navigation-list-link">SE-0097 Normalizing naming for "negative" attributes</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0098-didset-capitalization.html" class="navigation-list-link">SE-0098 Lowercase `didSet` and `willSet` for more consistent keyword casing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0099-conditionclauses.html" class="navigation-list-link">SE-0099 Restructuring Condition Clauses</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0100-add-sequence-based-init-and-merge-to-dictionary.html" class="navigation-list-link">SE-0100 Add sequence-based initializers and merge methods to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0101-standardizing-sizeof-naming.html" class="navigation-list-link">SE-0101 Reconfiguring `sizeof` and related functions into a unified `MemoryLayout` struct</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0102-noreturn-bottom-type.html" class="navigation-list-link">SE-0102 Remove `@noreturn` attribute and introduce an empty `Never` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0103-make-noescape-default.html" class="navigation-list-link">SE-0103 Make non-escaping closures the default</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0104-improved-integers.html" class="navigation-list-link">SE-0104 Protocol-oriented integers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0105-remove-where-from-forin-loops.html" class="navigation-list-link">SE-0105 Removing Where Clauses from For-In Loops</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0106-rename-osx-to-macos.html" class="navigation-list-link">SE-0106 Add a `macOS` Alias for the `OSX` Platform Configuration Test</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0107-unsaferawpointer.html" class="navigation-list-link">SE-0107 UnsafeRawPointer API</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0108-remove-assoctype-inference.html" class="navigation-list-link">SE-0108 Remove associated type inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0109-remove-boolean.html" class="navigation-list-link">SE-0109 Remove the `Boolean` protocol </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0110-distingish-single-tuple-arg.html" class="navigation-list-link">SE-0110 Distinguish between single-tuple and multiple-argument function types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0111-remove-arg-label-type-significance.html" class="navigation-list-link">SE-0111 Remove type system significance of function argument labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0112-nserror-bridging.html" class="navigation-list-link">SE-0112 Improved NSError Bridging</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0113-rounding-functions-on-floatingpoint.html" class="navigation-list-link">SE-0113 Add integral rounding functions to FloatingPoint</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0114-buffer-naming.html" class="navigation-list-link">SE-0114 Updating Buffer "Value" Names to "Header" Names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0115-literal-syntax-protocols.html" class="navigation-list-link">SE-0115 Rename Literal Syntax Protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0116-id-as-any.html" class="navigation-list-link">SE-0116 Import Objective-C `id` as Swift `Any` type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0117-non-public-subclassable-by-default.html" class="navigation-list-link">SE-0117 Allow distinguishing between public access and public overridability</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0118-closure-parameter-names-and-labels.html" class="navigation-list-link">SE-0118 Closure Parameter Names and Labels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0119-extensions-access-modifiers.html" class="navigation-list-link">SE-0119 Remove access modifiers from extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0120-revise-partition-method.html" class="navigation-list-link">SE-0120 Revise `partition` Method Signature</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0121-remove-optional-comparison-operators.html" class="navigation-list-link">SE-0121 Remove `Optional` Comparison Operators</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0122-use-colons-for-subscript-type-declarations.html" class="navigation-list-link">SE-0122 Use colons for subscript declarations</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0123-disallow-value-to-optional-coercion-in-operator-arguments.html" class="navigation-list-link">SE-0123 Disallow coercion to optionals in operator arguments</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0124-bitpattern-label-for-int-initializer-objectidentfier.html" class="navigation-list-link">SE-0124 `Int.init(ObjectIdentifier)` and `UInt.init(ObjectIdentifier)` should have a `bitPattern:` label</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0125-remove-nonobjectivecbase.html" class="navigation-list-link">SE-0125 Remove `NonObjectiveCBase` and `isUniquelyReferenced`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.html" class="navigation-list-link">SE-0126 Refactor Metatypes, repurpose `T.self` and `Mirror`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0127-cleaning-up-stdlib-ptr-buffer.html" class="navigation-list-link">SE-0127 Cleaning up stdlib Pointer and Buffer Routines</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0128-unicodescalar-failable-initializer.html" class="navigation-list-link">SE-0128 Change failable UnicodeScalar initializers to failable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0129-package-manager-test-naming-conventions.html" class="navigation-list-link">SE-0129 Package Manager Test Naming Conventions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0130-string-initializers-cleanup.html" class="navigation-list-link">SE-0130 Replace repeating `Character` and `UnicodeScalar` forms of String.init</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0131-anyhashable.html" class="navigation-list-link">SE-0131 Add `AnyHashable` to the standard library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0132-sequence-end-ops.html" class="navigation-list-link">SE-0132 Rationalizing Sequence end-operation names</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0133-rename-flatten-to-joined.html" class="navigation-list-link">SE-0133 Rename `flatten()` to `joined()`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0134-rename-string-properties.html" class="navigation-list-link">SE-0134 Rename two UTF8-related properties on String</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0135-package-manager-support-for-differentiating-packages-by-swift-version.html" class="navigation-list-link">SE-0135 Package Manager Support for Differentiating Packages by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0136-memory-layout-of-values.html" class="navigation-list-link">SE-0136 Memory layout of values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0137-avoiding-lock-in.html" class="navigation-list-link">SE-0137 Avoiding Lock-In to Legacy Protocol Designs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0138-unsaferawbufferpointer.html" class="navigation-list-link">SE-0138 UnsafeRawBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0139-bridge-nsnumber-and-nsvalue.html" class="navigation-list-link">SE-0139 Bridge Numeric Types to `NSNumber` and Cocoa Structs to `NSValue`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0140-bridge-optional-to-nsnull.html" class="navigation-list-link">SE-0140 Warn when `Optional` converts to `Any`, and bridge `Optional` As Its Payload Or `NSNull`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0141-available-by-swift-version.html" class="navigation-list-link">SE-0141 Availability by Swift version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0142-associated-types-constraints.html" class="navigation-list-link">SE-0142 Permit where clauses to constrain associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0143-conditional-conformances.html" class="navigation-list-link">SE-0143 Conditional conformances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0144-allow-single-dollar-sign-as-valid-identifier.html" class="navigation-list-link">SE-0144 Allow Single Dollar Sign as a Valid Identifier</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0145-package-manager-version-pinning.html" class="navigation-list-link">SE-0145 Package Manager Version Pinning</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0146-package-manager-product-definitions.html" class="navigation-list-link">SE-0146 Package Manager Product Definitions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0147-move-unsafe-initialize-from.html" class="navigation-list-link">SE-0147 Move UnsafeMutablePointer.initialize(from:) to UnsafeMutableBufferPointer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0148-generic-subscripts.html" class="navigation-list-link">SE-0148 Generic Subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0149-package-manager-top-of-tree.html" class="navigation-list-link">SE-0149 Package Manager Support for Top of Tree development</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0150-package-manager-branch-support.html" class="navigation-list-link">SE-0150 Package Manager Support for branches</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0151-package-manager-swift-language-compatibility-version.html" class="navigation-list-link">SE-0151 Package Manager Swift Language Compatibility Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0152-package-manager-tools-version.html" class="navigation-list-link">SE-0152 Package Manager Tools Version</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.html" class="navigation-list-link">SE-0153 Compensate for the inconsistency of `@NSCopying`'s behaviour</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0154-dictionary-key-and-value-collections.html" class="navigation-list-link">SE-0154 Provide Custom Collections for Dictionary Keys and Values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0155-normalize-enum-case-representation.html" class="navigation-list-link">SE-0155 Normalize Enum Case Representation</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0156-subclass-existentials.html" class="navigation-list-link">SE-0156 Class and Subtype existentials</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0157-recursive-protocol-constraints.html" class="navigation-list-link">SE-0157 Support recursive constraints on associated types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0158-package-manager-manifest-api-redesign.html" class="navigation-list-link">SE-0158 Package Manager Manifest API Redesign</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0159-fix-private-access-levels.html" class="navigation-list-link">SE-0159 Fix Private Access Levels</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0160-objc-inference.html" class="navigation-list-link">SE-0160 Limiting `@objc` inference</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0161-key-paths.html" class="navigation-list-link">SE-0161 Smart KeyPaths: Better Key-Value Coding for Swift</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0162-package-manager-custom-target-layouts.html" class="navigation-list-link">SE-0162 Package Manager Custom Target Layouts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0163-string-revision-1.html" class="navigation-list-link">SE-0163 String Revision: Collection Conformance, C Interop, Transcoding</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0164-remove-final-support-in-protocol-extensions.html" class="navigation-list-link">SE-0164 Remove final support in protocol extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0165-dict.html" class="navigation-list-link">SE-0165 Dictionary & Set Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0166-swift-archival-serialization.html" class="navigation-list-link">SE-0166 Swift Archival & Serialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0167-swift-encoders.html" class="navigation-list-link">SE-0167 Swift Encoders</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0168-multi-line-string-literals.html" class="navigation-list-link">SE-0168 Multi-Line String Literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0169-improve-interaction-between-private-declarations-and-extensions.html" class="navigation-list-link">SE-0169 Improve Interaction Between `private` Declarations and Extensions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0170-nsnumber_bridge.html" class="navigation-list-link">SE-0170 NSNumber bridging and Numeric types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0171-reduce-with-inout.html" class="navigation-list-link">SE-0171 Reduce with `inout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0172-one-sided-ranges.html" class="navigation-list-link">SE-0172 One-sided Ranges</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0173-swap-indices.html" class="navigation-list-link">SE-0173 Add `MutableCollection.swapAt(_:_:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0174-filter-range-replaceable.html" class="navigation-list-link">SE-0174 Change `filter` to return an associated type</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0175-package-manager-revised-dependency-resolution.html" class="navigation-list-link">SE-0175 Package Manager Revised Dependency Resolution</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/2019-08-26-0176-enforce-exclusive-access-to-memory.html" class="navigation-list-link active">SE-0176 Enforce Exclusive Access to Memory</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0177-add-clamped-to-method.html" class="navigation-list-link">SE-0177 Add clamp(to:) to the stdlib</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0178-character-unicode-view.html" class="navigation-list-link">SE-0178 Add `unicodeScalars` property to `Character`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0179-swift-run-command.html" class="navigation-list-link">SE-0179 Swift `run` Command</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0180-string-index-overhaul.html" class="navigation-list-link">SE-0180 String Index Overhaul</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0181-package-manager-cpp-language-version.html" class="navigation-list-link">SE-0181 Package Manager C/C++ Language Standard Support</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0182-newline-escape-in-strings.html" class="navigation-list-link">SE-0182 String Newline Escaping</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0183-substring-affordances.html" class="navigation-list-link">SE-0183 Substring performance affordances</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0184-unsafe-pointers-add-missing.html" class="navigation-list-link">SE-0184 Unsafe[Mutable][Raw][Buffer]Pointer: add missing methods, adjust existing labels for clarity, and remove deallocation size</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0185-synthesize-equatable-hashable.html" class="navigation-list-link">SE-0185 Synthesizing `Equatable` and `Hashable` conformance</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0186-remove-ownership-keyword-support-in-protocols.html" class="navigation-list-link">SE-0186 Remove ownership keyword support in protocols</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0187-introduce-filtermap.html" class="navigation-list-link">SE-0187 Introduce Sequence.compactMap(_:)</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0188-stdlib-index-types-hashable.html" class="navigation-list-link">SE-0188 Make Standard Library Index Types Hashable</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0189-restrict-cross-module-struct-initializers.html" class="navigation-list-link">SE-0189 Restrict Cross-module Struct Initializers</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0190-target-environment-platform-condition.html" class="navigation-list-link">SE-0190 Target environment platform condition</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0191-eliminate-indexdistance.html" class="navigation-list-link">SE-0191 Eliminate `IndexDistance` from `Collection`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0192-non-exhaustive-enums.html" class="navigation-list-link">SE-0192 Handling Future Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0193-cross-module-inlining-and-specialization.html" class="navigation-list-link">SE-0193 Cross-module inlining and specialization</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0194-derived-collection-of-enum-cases.html" class="navigation-list-link">SE-0194 Derived Collection of Enum Cases</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0195-dynamic-member-lookup.html" class="navigation-list-link">SE-0195 Introduce User-defined "Dynamic Member Lookup" Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0196-diagnostic-directives.html" class="navigation-list-link">SE-0196 Compiler Diagnostic Directives</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0197-remove-where.html" class="navigation-list-link">SE-0197 Adding in-place `removeAll(where:)` to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0198-playground-quicklook-api-revamp.html" class="navigation-list-link">SE-0198 Playground QuickLook API Revamp #</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0199-bool-toggle.html" class="navigation-list-link">SE-0199 Adding `toggle` to `Bool`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0200-raw-string-escaping.html" class="navigation-list-link">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0201-package-manager-local-dependencies.html" class="navigation-list-link">SE-0201 Package Manager Local Dependencies</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0202-random-unification.html" class="navigation-list-link">SE-0202 Random Unification</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0203-rename-sequence-elements-equal.html" class="navigation-list-link">SE-0203 Rename Sequence.elementsEqual</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0204-add-last-methods.html" class="navigation-list-link">SE-0204 Add `last(where:)` and `lastIndex(where:)` Methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0205-withUnsafePointer-for-lets.html" class="navigation-list-link">SE-0205 `withUnsafePointer(to:_:)` and `withUnsafeBytes(of:_:)` for immutable values</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0206-hashable-enhancements.html" class="navigation-list-link">SE-0206 Hashable Enhancements</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0207-containsOnly.html" class="navigation-list-link">SE-0207 Add an `allSatisfy` algorithm to `Sequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0208-package-manager-system-library-targets.html" class="navigation-list-link">SE-0208 Package Manager System Library Targets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0209-package-manager-swift-lang-version-update.html" class="navigation-list-link">SE-0209 Package Manager Swift Language Version API Update</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0210-key-path-offset.html" class="navigation-list-link">SE-0210 Add an `offset(of:)` method to `MemoryLayout`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0211-unicode-scalar-properties.html" class="navigation-list-link">SE-0211 Add Unicode Properties to `Unicode.Scalar`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0212-compiler-version-directive.html" class="navigation-list-link">SE-0212 Compiler Version Directive</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0213-literal-init-via-coercion.html" class="navigation-list-link">SE-0213 Literal initialization via coercion</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0214-DictionaryLiteral.html" class="navigation-list-link">SE-0214 Renaming the `DictionaryLiteral` type to `KeyValuePairs`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0215-conform-never-to-hashable-and-equatable.html" class="navigation-list-link">SE-0215 Conform `Never` to `Equatable` and `Hashable`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0216-dynamic-callable.html" class="navigation-list-link">SE-0216 Introduce user-defined dynamically "callable" types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0217-bangbang.html" class="navigation-list-link">SE-0217 Introducing the `!!` "Unwrap or Die" operator to the Swift Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0218-introduce-compact-map-values.html" class="navigation-list-link">SE-0218 Introduce `compactMapValues` to Dictionary</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0219-package-manager-dependency-mirroring.html" class="navigation-list-link">SE-0219 Package Manager Dependency Mirroring</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0220-count-where.html" class="navigation-list-link">SE-0220 `count(where:)`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0221-character-properties.html" class="navigation-list-link">SE-0221 Character Properties</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0222-lazy-compactmap-sequence.html" class="navigation-list-link">SE-0222 Lazy CompactMap Sequence</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0223-array-uninitialized-initializer.html" class="navigation-list-link">SE-0223 Accessing an Array's Uninitialized Buffer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0224-ifswift-lessthan-operator.html" class="navigation-list-link">SE-0224 Support 'less than' operator in compilation conditions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0225-binaryinteger-iseven-isodd-ismultiple.html" class="navigation-list-link">SE-0225 Adding `isMultiple` to `BinaryInteger`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0226-package-manager-target-based-dep-resolution.html" class="navigation-list-link">SE-0226 Package Manager Target Based Dependency Resolution</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0227-identity-keypath.html" class="navigation-list-link">SE-0227 Identity key path</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0228-fix-expressiblebystringinterpolation.html" class="navigation-list-link">SE-0228 Fix `ExpressibleByStringInterpolation`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0229-simd.html" class="navigation-list-link">SE-0229 SIMD Vectors</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0230-flatten-optional-try.html" class="navigation-list-link">SE-0230 Flatten nested optionals resulting from 'try?'</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0231-optional-iteration.html" class="navigation-list-link">SE-0231 Optional Iteration</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0232-remove-customization-points.html" class="navigation-list-link">SE-0232 Remove Some Customization Points from the Standard Library's `Collection` Hierarchy</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0233-additive-arithmetic-protocol.html" class="navigation-list-link">SE-0233 Make `Numeric` Refine a new `AdditiveArithmetic` Protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0234-remove-sequence-subsequence.html" class="navigation-list-link">SE-0234 Remove `Sequence.SubSequence`</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0235-add-result.html" class="navigation-list-link">SE-0235 Add Result to the Standard Library</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0236-package-manager-platform-deployment-settings.html" class="navigation-list-link">SE-0236 Package Manager Platform Deployment Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0237-contiguous-collection.html" class="navigation-list-link">SE-0237 Introduce `withContiguous{Mutable}StorageIfAvailable` methods</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0238-package-manager-build-settings.html" class="navigation-list-link">SE-0238 Package Manager Target Specific Build Settings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0239-codable-range.html" class="navigation-list-link">SE-0239 Add Codable conformance to Range types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0240-ordered-collection-diffing.html" class="navigation-list-link">SE-0240 Ordered Collection Diffing</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0241-string-index-explicit-encoding-offset.html" class="navigation-list-link">SE-0241 Deprecate String Index Encoded Offsets</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0242-default-values-memberwise.html" class="navigation-list-link">SE-0242 Synthesize default values for the memberwise initializer</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0243-codepoint-and-character-literals.html" class="navigation-list-link">SE-0243 Integer-convertible character literals</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0244-opaque-result-types.html" class="navigation-list-link">SE-0244 Opaque Result Types</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0245-array-uninitialized-initializer.html" class="navigation-list-link">SE-0245 Add an Array Initializer with Access to Uninitialized Storage</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0246-mathable.html" class="navigation-list-link">SE-0246 Generic Math(s) Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0247-contiguous-strings.html" class="navigation-list-link">SE-0247 Contiguous Strings</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0248-string-gaps-missing-apis.html" class="navigation-list-link">SE-0248 String Gaps and Missing APIs</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0249-key-path-literal-function-expressions.html" class="navigation-list-link">SE-0249 Key Path Expressions as Functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0250-swift-style-guide-and-formatter.html" class="navigation-list-link">SE-0250 Swift Code Style Guidelines and Formatter</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0251-simd-additions.html" class="navigation-list-link">SE-0251 SIMD additions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0252-keypath-dynamic-member-lookup.html" class="navigation-list-link">SE-0252 Key Path Member Lookup</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0253-callable.html" class="navigation-list-link">SE-0253 Introduce callables </a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0254-static-subscripts.html" class="navigation-list-link">SE-0254 Static and class subscripts</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0255-omit-return.html" class="navigation-list-link">SE-0255 Implicit returns from single-expression functions</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0256-contiguous-collection.html" class="navigation-list-link">SE-0256 Introduce `{Mutable}ContiguousCollection` protocol</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-0257-elide-comma.html" class="navigation-list-link">SE-0257 Eliding commas from multiline expression lists</a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/2019-08-26-xxxx-synthesize-computed-property.html" class="navigation-list-link"> Feature name</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Swift Evolution List" aria-label="Search Swift Evolution List" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/pondok-programmer/swift-evolution-jekyll">Swift Evolution List</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h1 id="enforce-exclusive-access-to-memory"> <a href="#enforce-exclusive-access-to-memory" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Enforce Exclusive Access to Memory </h1> <ul> <li>Proposal: <a href="0176-enforce-exclusive-access-to-memory.md">SE-0176</a></li> <li>Author: <a href="https://github.com/rjmccall">John McCall</a></li> <li>Review Manager: <a href="https://github.com/airspeedswift">Ben Cohen</a></li> <li>Status: <strong>Implemented (Swift 4)</strong></li> <li>Previous Revision: <a href="https://github.com/apple/swift-evolution/blob/7e6816c22a29b0ba9bdf63ff92b380f9e963860a/proposals/0176-enforce-exclusive-access-to-memory.md">1</a></li> <li>Previous Discussion: <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170501/036308.html">Email Thread</a></li> </ul> <h2 id="introduction"> <a href="#introduction" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Introduction </h2> <p>In Swift 3, it is possible to modify a variable while its being used or modified by another part of the program. This can lead to unexpected and confusing results. It also forces a great deal of conservatism onto the implementation of the compiler and the standard libraries, which must generally ensure the basic soundness of the program (no crashes or undefined behavior) even in unusual circumstances.</p> <p>We propose that Swift should instead enforce a general rule that potential modifications of variables must be exclusive with any other access to that variable.</p> <p>This proposal is a core part of the Ownership feature, which was described in the <a href="https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md">ownership manifesto</a>. That document presents the high-level objectives of Ownership, develops a more rigorous theory of memory access in Swift, and applies it in detail to a variety of different language features. In that document, the rule were proposing here is called the Law of Exclusivity. We will not be going into that level of detail in this proposal. Instead, we will lay out the basic rule, how it will be enforced, and the implications for programming in Swift. It should be possible to understand this proposal without actually having read the ownership manifesto at all. That said, if you are interested in the technical details, that document is probably the right place to turn.</p> <h2 id="motivation"> <a href="#motivation" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Motivation </h2> <h3 id="instantaneous-and-non-instantaneous-accesses"> <a href="#instantaneous-and-non-instantaneous-accesses" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Instantaneous and non-instantaneous accesses </h3> <p>On a basic level, Swift is an imperative language which allows programmers to directly access mutable memory.</p> <p>Many of the language features that access memory, like simply loading from or assigning to a variable, are instantaneous. This means that, from the perspective of the current thread, the operation completes without any other code being able to interfere. For example, when you assign to a stored property, the current value is just replaced with the new value. Because arbitrary other code cant run during an instantaneous access, its never possible for two instantaneous accesses to overlap each other (without introducing concurrency, which well talk about later). That makes them very easy to reason about.</p> <p>However, not all accesses are instantaneous. For example, when you call a <code class="highlighter-rouge">mutating</code> method on a stored property, its really one long access to the property: <code class="highlighter-rouge">self</code> just becomes another way of referring to the propertys storage. This access isnt instantaneous because all of the code in the method executes during it, so if that code manages to access the same property again, the accesses will overlap. There are several language features like this already in Swift, and Ownership will add a few more.</p> <h3 id="examples-of-problems-due-to-overlap"> <a href="#examples-of-problems-due-to-overlap" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Examples of problems due to overlap </h3> <p>Heres an example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// These are simple global variables.</span>
<span class="k">var</span> <span class="nv">global</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="nv">total</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="kd">extension</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// Mutating methods access the variable they were called on</span>
  <span class="c1">// for the duration of the method.</span>
  <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">increaseByGlobal</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Any accesses they do will overlap the access to that variable.</span>

    <span class="n">total</span> <span class="o">+=</span> <span class="k">self</span> <span class="c1">// Might access 'total' through both 'total' and 'self'</span>
    <span class="k">self</span> <span class="o">+=</span> <span class="n">global</span> <span class="c1">// Might access 'global' through both 'global' and 'self'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>If <code class="highlighter-rouge">self</code> is <code class="highlighter-rouge">total</code> or <code class="highlighter-rouge">global</code>, the low-level semantics of this method dont change, but the programmers high-level understanding of it almost certainly does. A line that superficially seems to not change global might suddenly start doubling it! And the data dependencies between the two lines instantly go from simple to very complex. Thats very important information for someone maintaining this method, who might be tempted to re-arrange the code in ways that seem equivalent. That kind of maintenance can get very frustrating because of overlap like this.</p> <p>The same considerations apply to the language implementation. The possibility of overlap means the language has to make pessimistic assumptions about the loads and stores in this method. For example, the following code avoids a seemingly-redundant load, but its not actually equivalent because of overlap:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">self</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span>
    <span class="k">self</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">global</span>
</code></pre></div></div> <p>Because these variables just have type <code class="highlighter-rouge">Int</code>, the cost of this pessimism is only an extra load. If the types were more complex, like <code class="highlighter-rouge">String</code>, it might mean doing extra copies of the <code class="highlighter-rouge">String</code> value, which would translate to extra retains and releases of the strings buffer; in a more complex example, that could even lead to the underlying data being copied unnecessarily.</p> <p>In the above examples, weve made the potentially-overlapping accesses obvious, but they dont have to be. For example, here is another method that takes a closure as an argument:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Array</span> <span class="p">{</span>
  <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">modifyElements</span><span class="p">(</span><span class="n">_</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">(</span><span class="k">inout</span> <span class="kt">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="n">startIndex</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">endIndex</span> <span class="p">{</span>
      <span class="nf">closure</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">i</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">after</span><span class="p">:</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This methods implementation seems straightforwardly correct, but unfortunately it doesnt account for overlap. Absolutely nothing prevents the closure from modifying <code class="highlighter-rouge">self</code> during the iteration, which means that <code class="highlighter-rouge">i</code> can suddenly become an invalid index, which could lead to all sorts of unwanted behavior. Even if this never happen in reality, the fact that its <em>possible</em> means that the implementation is blocked from pursuing all sorts of important optimizations.</p> <p>For example, the compiler has an optimization that hoists the uniqueness check on a copy-on-write collection from the inside of a loop (where its run on each iteration) to the outside (so that its only checked once, before the loop begins). But that optimization cant be applied in this example because the closure might change or copy <code class="highlighter-rouge">self</code>. The only realistic way to tell the compiler that that cant happen is to enforce exclusivity on <code class="highlighter-rouge">self</code>.</p> <p>The same considerations that apply to <code class="highlighter-rouge">self</code> in a <code class="highlighter-rouge">mutating</code> method also apply to <code class="highlighter-rouge">inout</code> parameters. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">open</span> <span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="kd">open</span> <span class="k">var</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">collectTitles</span><span class="p">(</span><span class="nv">people</span><span class="p">:</span> <span class="p">[</span><span class="kt">Person</span><span class="p">],</span> <span class="n">into</span> <span class="nv">set</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">person</span> <span class="k">in</span> <span class="n">people</span> <span class="p">{</span>
    <span class="k">set</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">person</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This function mutates a set of strings, but it also repeatedly calls a class method. The compiler cannot know how this method is implemented, because it is <code class="highlighter-rouge">open</code> and therefore overridable from an arbitrary module. Therefore, because of overlap, the compiler must pessimistically assume that each of these method calls might somehow find a way to modify the original variable that <code class="highlighter-rouge">set</code> was bound to. (And if the method did manage to do so, the resulting strange behavior would probably be seen as a bug by the caller of <code class="highlighter-rouge">collectTitles</code>.)</p> <h3 id="eliminating-non-instantaneous-accesses"> <a href="#eliminating-non-instantaneous-accesses" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Eliminating non-instantaneous accesses? </h3> <p>If non-instantaneous accesses create all of these problems with overlapping accesses, should we just eliminate non-instantaneous accesses completely? Well, no, and theres two big reasons why not. In order to make something like a <code class="highlighter-rouge">mutating</code> method not access the original storage of <code class="highlighter-rouge">self</code> for the duration of the method, we would need to make it access a temporary copy instead, which we would assign back to the storage after the method is complete. That is, suppose we had the following Swift code:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>
<span class="n">numbers</span><span class="o">.</span><span class="nf">appendABunchOfStuff</span><span class="p">()</span>
</code></pre></div></div> <p>Currently, behind the scenes, this is implemented somewhat like the following C code:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Array</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">_Array_init</span><span class="p">();</span>
<span class="n">_Array_appendABunchOfStuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numbers</span><span class="p">);</span>
</code></pre></div></div> <p>You can see clearly how <code class="highlighter-rouge">_Array_appendABunchOfStuff</code> will be working directly with the storage of <code class="highlighter-rouge">numbers</code>, creating the abstract possibility of overlapping accesses to that variable. To prevent this in general, we would need to pass a temporary copy instead:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Array</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">_Array_init</span><span class="p">();</span>
<span class="k">struct</span> <span class="n">Array</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_Array_copy</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
<span class="n">_Array_appendABunchOfStuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
<span class="n">_Array_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numbers</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
</code></pre></div></div> <p>Like we said, theres two big problems with this.</p> <p>The first problem is that its awful for performance. Even for a normal type, doing extra copies is wasteful, but doing it with <code class="highlighter-rouge">Array</code> is even worse because its a copy-on-write type. The extra copy here means that there will be multiple references to the buffer, which means that <code class="highlighter-rouge">_Array_appendABunchOfStuff</code> will be forced to copy the buffer instead of modifying it in place. Removing these kinds of copies, and making it easier to reason about when they happen, is a large part of the goal of the Ownership feature.</p> <p>The second problem is that it doesnt even eliminate the potential confusion. Suppose that <code class="highlighter-rouge">_Array_appendABunchOfStuff</code> somehow reads or writes to <code class="highlighter-rouge">numbers</code> (perhaps because <code class="highlighter-rouge">numbers</code> is captured in a closure, or its actually a global variable or a class property or something else that can be potentially accessed from anywhere). Because the method is now modifying the copy in <code class="highlighter-rouge">temp</code>, any reads it makes from <code class="highlighter-rouge">numbers</code> wont see any of the changes its made to <code class="highlighter-rouge">temp</code>, and any changes it makes to <code class="highlighter-rouge">numbers</code> will be silently lost when it returns and the caller unconditionally overwrites <code class="highlighter-rouge">numbers</code> with <code class="highlighter-rouge">temp</code>.</p> <h3 id="consequences-of-non-instantaneous-accesses"> <a href="#consequences-of-non-instantaneous-accesses" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Consequences of non-instantaneous accesses </h3> <p>So we have to accept that accesses can be non-instantaneous. That means programmers can write code that would naturally cause overlapping accesses to the same variable. We currently allow this to happen and make a best effort to live with the consequences. The costs, in general, are a lot of complexity and lost performance.</p> <p>For example, the <code class="highlighter-rouge">Array</code> type has an optimization in its <code class="highlighter-rouge">subscript</code> operator which allows callers to directly access the storage of array elements. This is a very important optimization which, among other things, allows arrays to efficiently hold values of copy-on-write types. However, because the caller can execute arbitrary code while theyre working with the array element storage, and that code might do something like assign a new value to the original array variable and therefore drop the last reference to the array buffer, this optimization has to create a new strong reference to the buffer until the caller is done with the element, which itself causes a whole raft of complexity.</p> <p>Similarly, when the compiler is optimizing a <code class="highlighter-rouge">mutating</code> method, it has to assume that an arbitrary call might completely rewrite <code class="highlighter-rouge">self</code>. This makes it very difficult to perform any meaningful optimization at all, especially in generic code. It also means that the compiler must generally emit a large number of conservative copies just in case things are modified in unexpected ways.</p> <p>Furthermore, the possibility of overlapping accesses has a continued impact on language evolution. Many of the features laid out in the Ownership manifesto rely on static guarantees that Swift simply cannot make without stronger rules about when a variable can be modified.</p> <p>Therefore we think it best to simply disallow overlapping accesses as best as we can.</p> <h2 id="proposed-solution"> <a href="#proposed-solution" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Proposed solution </h2> <p>We should add a rule to Swift that two accesses to the same variable are not allowed to overlap unless both accesses are reads. By variable, we mean any kind of mutable memory: global variables, local variables, class and struct properties, and so on.</p> <p>This rule should be enforced as strongly as possible, depending on what sort of variable it is:</p> <ul> <li> <p>Local variables, inout parameters, and struct properties can generally enforce the rule statically. The compiler can analyze all the accesses to the variable and emit an error if it sees any conflicts.</p> </li> <li> <p>Class properties and global variables will have to enforce the rule dynamically. The runtime can keep track of what accesses are underway and report any conflicts. Local variables will sometimes have to use dynamic enforcement when they are captured in closures.</p> </li> <li> <p>Unsafe pointers will not use any active enforcement; it is the programmers responsibility to follow the rule.</p> </li> <li> <p>No enforcement is required for immutable memory, like a <code class="highlighter-rouge">let</code> binding or property, because all accesses must be reads.</p> </li> </ul> <p>Examples:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// NOT A CONFLICT.  These two accesses to 'x' are both reads.</span>
<span class="c1">// Each completes instantaneously, so the accesses do not overlap and</span>
<span class="c1">// therefore do not conflict.  Even if they were not instantaneous, they</span>
<span class="c1">// are both reads and therefore do no conflict.</span>
<span class="k">let</span> <span class="nv">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>

<span class="c1">// NOT A CONFLICT.  The right-hand side of the assignment is a read of</span>
<span class="c1">// 'x' which completes instantaneously.  The assignment is a write to 'x'</span>
<span class="c1">// which completes instantaneously.  The accesses do not overlap and</span>
<span class="c1">// therefore do not conflict.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

<span class="c1">// NOT A CONFLICT.  The right-hand side is a read of 'x' which completes</span>
<span class="c1">// instantaneously.  Calling the operator involves passing 'x' as an inout</span>
<span class="c1">// argument; this is a write access for the duration of the call, but it does</span>
<span class="c1">// not begin until immediately before the call, after the right-hand side is</span>
<span class="c1">// fully evaluated.  Therefore the accesses do not overlap and do not conflict.</span>
<span class="n">x</span> <span class="o">+=</span> <span class="n">x</span>

<span class="c1">// CONFLICT.  Passing 'x' as an inout argument is a write access for the</span>
<span class="c1">// duration of the call.  Passing the same variable twice means performing</span>
<span class="c1">// two overlapping write accesses to that variable, which therefore conflict.</span>
<span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>

<span class="kd">extension</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">assignResultOf</span><span class="p">(</span><span class="n">_</span> <span class="nv">function</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span> <span class="o">=</span> <span class="nf">function</span><span class="p">()</span>  
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// CONFLICT.  Calling a mutating method on a value type is a write access</span>
<span class="c1">// that lasts for the duration of the method.  The read of 'x' in the closure</span>
<span class="c1">// is evaluated while the method is executing, which means it overlaps</span>
<span class="c1">// the method's formal access to 'x'.  Therefore these accesses conflict.</span>
<span class="n">x</span><span class="o">.</span><span class="n">assignResultOf</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div></div> <h2 id="detailed-design"> <a href="#detailed-design" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Detailed design </h2> <h3 id="concurrency"> <a href="#concurrency" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Concurrency </h3> <p>Swift has always considered read/write and write/write races on the same variable to be undefined behavior. It is the programmers responsibility to avoid such races in their code by using appropriate thread-safe programming techniques.</p> <p>We do not propose changing that. Dynamic enforcement is not required to detect concurrent conflicting accesses, and we propose that by default it should not make any effort to do so. This should allow the dynamic bookkeeping to avoid synchronizing between threads; for example, it can track accesses in a thread-local data structure instead of a global one protected by locks. Our hope is that this will make dynamic access-tracking cheap enough to enable by default in all programs.</p> <p>The implementation should still be <em>permitted</em> to detect concurrent conflicting accesses, of course. Some programmers may wish to use an opt-in thread-safe enforcement mechanism instead, at least in some build configurations.</p> <p>Any future concurrency design in Swift will have the elimination of such races as a primary goal. To the extent that it succeeds, it will also define away any specific problems for exclusivity.</p> <h3 id="value-types"> <a href="#value-types" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Value types </h3> <p>Calling a method on a value type is an access to the entire value: a write if its a <code class="highlighter-rouge">mutating</code> method, a read otherwise. This is because we have to assume that a method might read or write an arbitrary part of the value. Trying to formalize rules like this method only uses these properties would massively complicate the language.</p> <p>For similar reasons, using a computed property or subscript on a value type generally has to be treated as an access to the entire value. Whether the access is a read or write depends on how the property/subscript is used and whether either the getter or the setter is <code class="highlighter-rouge">mutating</code>.</p> <p>Accesses to different stored properties of a <code class="highlighter-rouge">struct</code> or different elements of a tuple are allowed to overlap. However, note that modifying part of a value type still requires exclusive access to the entire value, and that acquiring that access might itself prevent overlapping accesses. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Pair</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Paired</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">pair</span> <span class="o">=</span> <span class="kt">Pair</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">object</span> <span class="o">=</span> <span class="kt">Paired</span><span class="p">()</span>
<span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div> <p>Here, initiating the write-access to <code class="highlighter-rouge">object.pair</code> for the first argument will prevent the write-access to <code class="highlighter-rouge">object.pair</code> for the second argument from succeeding because of the dynamic enforcement used for the property. Attempting to make dynamic enforcement aware of the fact that these accesses are modifying different sub-components of the property would be prohibitive, both in terms of the additional performance cost and in terms of the complexity of the implementation.</p> <p>However, this limitation can be worked around by binding <code class="highlighter-rouge">object.pair</code> to an <code class="highlighter-rouge">inout</code> parameter:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">modifying</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">T</span><span class="p">,</span> <span class="n">_</span> <span class="nv">function</span><span class="p">:</span> <span class="p">(</span><span class="k">inout</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
  <span class="nf">function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">modifying</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">.</span><span class="n">pair</span><span class="p">)</span> <span class="p">{</span> <span class="n">pair</span> <span class="k">in</span> <span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pair</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pair</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div> <p>This works because now there is only a single access to <code class="highlighter-rouge">object.pair</code> and because, once the the <code class="highlighter-rouge">inout</code> parameter is bound to that storage, accesses to the parameter within the function can use purely static enforcement.</p> <p>We expect that workarounds like this will only rarely be required.</p> <p>Note that two different properties can only be assumed to not conflict when they are both known to be stored. This means that, for example, it will not be allowed to have overlapping accesses to different properties of a resilient value type. This is not expected to be a significant problem for programmers.</p> <h3 id="arrays"> <a href="#arrays" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Arrays </h3> <p>Collections do not receive any special treatment in this proposal. For example, <code class="highlighter-rouge">Array</code>s indexed subscript is an ordinary computed subscript on a value type. Accordingly, mutating an element of an array will require exclusive access to the entire array, and therefore will disallow any other simultaneous accesses to the array, even to different elements. For example:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">array</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>

<span class="c1">// NOT A CONFLICT.  These accesses to the elements of 'array' each</span>
<span class="c1">// complete instantaneously and do not overlap each other.  Even if they</span>
<span class="c1">// did overlap for some reason, they are both reads and therefore</span>
<span class="c1">// do not conflict.</span>
<span class="nf">print</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1">// NOT A CONFLICT.  The access done to read 'array[1]' completes</span>
<span class="c1">// before the modifying access to 'array[0]' begins.  Therefore, these</span>
<span class="c1">// accesses do not conflict.</span>
<span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1">// CONFLICT.  Passing 'array[i]' as an inout argument performs a</span>
<span class="c1">// write access to it, and therefore to 'array', for the duration of</span>
<span class="c1">// the call.  This call makes two such accesses to the same array variable,</span>
<span class="c1">// which therefore conflict.</span>
<span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1">// CONFLICT.  Calling a non-mutating method on 'array[0]' performs a</span>
<span class="c1">// read access to it, and thus to 'array', for the duration of the method.</span>
<span class="c1">// Calling a mutating method on 'array[1]' performs a write access to it,</span>
<span class="c1">// and thus to 'array', for the duration of the method.  These accesses</span>
<span class="c1">// therefore conflict.</span>
<span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div> <p>Its always been somewhat fraught to do simultaneous accesses to an array because of copy-on-write. The fact that you should not create an array and then fork off a bunch of threads that assign into different elements concurrently has been independently rediscovered by a number of different programmers. (Under this proposal, we will still not be reliably detecting this problem by default, because it is a race condition; see the section on concurrency.) The main new limitation here is that some idioms which did work on a single thread are going to be forbidden. This may just be a cost of progress, but there are things we can do to mitigate the problem.</p> <p>In the long term, the API of <code class="highlighter-rouge">Array</code> and other collections should be extended to ensure that there are good ways of achieving the tasks that exclusivity enforcement has made difficult. It will take experience living with exclusivity in order to understand the problems and propose the right API additions. In the short term, these problems can be worked around with <code class="highlighter-rouge">withUnsafeMutableBufferPointer</code>.</p> <p>We do know that swapping two array elements will be problematic, and accordingly we are (separately proposing)[https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md] to add a <code class="highlighter-rouge">swapAt</code> method to <code class="highlighter-rouge">MutableCollection</code> that takes two indices rather than two <code class="highlighter-rouge">inout</code> arguments. The Swift 3 compatibility mode should recognize the swap-of-elements pattern and automatically translate it to use <code class="highlighter-rouge">swapAt</code>, and the 3-to-4 migrator should perform this rewrite automatically.</p> <h3 id="class-properties"> <a href="#class-properties" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Class properties </h3> <p>Unlike value types, calling a method on a class doesnt formally access the entire class instance. In fact, we never try to enforce exclusivity of access on the whole object at all; we only enforce it for individual stored properties. Among other things, this means that an access to a class property never conflicts with an access to a different property.</p> <p>There are two major reasons for this difference between value and reference types.</p> <p>The first reason is that its important to allow overlapping method calls to a single class instance. Its quite common for an object to have methods called on it concurrently from different threads. These methods may access different properties, or they may synchronize their accesses to the same properties using locks, dispatch queues, or some other thread-safe technique. Regardless, its a widespread pattern.</p> <p>The second reason is that theres no benefit to trying to enforce exclusivity of access to the entire class instance. For a value type to be mutated, it has to be held in a variable, and its often possible to reason quite strongly about how that variable is used. That means that the exclusivity rule that were proposing here allows us to make some very strong guarantees for value types, generally making them an even tighter, lower-cost abstraction. In contrast, its inherent to the nature of reference types that references can be copied pretty arbitrarily throughout a program. The assumptions we want to make about value types depend on having unique access to the variable holding the value; theres no way to make a similar assumption about reference types without knowing that we have a unique reference to the object, which would radically change the programming model of classes and make them unacceptable for the concurrent patterns described above.</p> <h3 id="disabling-dynamic-enforcement"> <a href="#disabling-dynamic-enforcement" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Disabling dynamic enforcement. </h3> <p>We could add an attribute which allows dynamic enforcement to be downgraded to an unsafe-pointer-style undefined-behavior rule on a variable-by-variable basis. This would allow programmers to opt out of the expense of dynamic enforcement when it is known to be unnecessary (e.g. because exclusivity is checked at some higher level) or when the performance burden is simply too great.</p> <p>There is some concern that adding this attribute might lead to over-use and that we should only support it if we are certain that the overheads cannot be reduced in some better way.</p> <p>Since the rule still applies, and its merely no longer being checked, it makes sense to borrow the checked and unchecked terminology from the optimizer settings.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TreeNode</span> <span class="p">{</span>
  <span class="kd">@exclusivity(unchecked)</span> <span class="k">var</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">TreeNode</span><span class="p">?</span>
  <span class="kd">@exclusivity(unchecked)</span> <span class="k">var</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">TreeNode</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="closures"> <a href="#closures" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Closures </h3> <p>A closure (including both local function declarations and closure expressions, whether explicit or autoclosure) is either escaping or non-escaping. Currently, a closure is considered non-escaping only if it is:</p> <ul> <li> <p>a closure expression which is immediately called,</p> </li> <li> <p>a closure expression which is passed as a non-escaping function argument, or</p> </li> <li> <p>a local function which captures something that is not allowed to escape, like an <code class="highlighter-rouge">inout</code> parameter.</p> </li> </ul> <p>It is likely that this definition will be broadened over time.</p> <p>A variable is said to be escaping if it is captured in an escaping closure; otherwise, it is non-escaping.</p> <p>Escaping variables generally require dynamic enforcement instead of static enforcement. This is because Swift cannot reason about when an escaping closure will be called and thus when the variable will be accessed. There are some circumstances where static enforcement may still be allowed, for example when Swift can reason about how the variable will be used after it is escaped, but this is only possible as a best-effort improvement for special cases, not as a general rule.</p> <p>In contrast, non-escaping variables can always use static enforcement. (In order to achieve this, we must impose a new restriction on recursive uses of non-escaping closures; see below.) This guarantee aligns a number of related semantic and performance goals. For example, a non-escaping variable does not need to be allocated on the heap; by also promising to only use static enforcement for the variable, we are essentially able to guarantee that the variable will have C-like performance, which can be important for some kinds of program. This guarantee also ensures that only static enforcement is needed for <code class="highlighter-rouge">inout</code> parameters, which cannot be captured in escaping closures; this substantially simplifies the implementation model for capturing <code class="highlighter-rouge">inout</code> parameters.</p> <h3 id="diagnosing-dynamic-enforcement-violations-statically"> <a href="#diagnosing-dynamic-enforcement-violations-statically" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Diagnosing dynamic enforcement violations statically </h3> <p>In general, Swift is permitted to upgrade dynamic enforcement to static enforcement when it can prove that two accesses either always or never conflict. This is analogous to Swifts rules about integer overflow.</p> <p>For example, if Swift can prove that two accesses to a global variable will always conflict, then it can report that error statically, even though global variables use dynamic enforcement:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">global</span><span class="p">:</span> <span class="kt">Int</span>
<span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">global</span><span class="p">)</span> <span class="c1">// Two overlapping modifications to 'global'</span>
</code></pre></div></div> <p>Swift is not required to prove that both accesses will actually be executed dynamically in order to report a violation statically. It is sufficient to prove that one of the accesses cannot ever be executed without causing a conflict. For example, in the following example, Swift does not need to prove that <code class="highlighter-rouge">mutate</code> actually calls its argument function:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The inout access lasts for the duration of the call.</span>
<span class="n">global</span><span class="o">.</span><span class="n">mutate</span> <span class="p">{</span> <span class="k">return</span> <span class="n">global</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div></div> <p>When a closure is passed as a non-escaping function argument or captured in a closure that is passed as a non-escaping function argument, Swift may assume that any accesses made by the closure will be executed during the call, potentially conflicting with accesses that overlap the call.</p> <h3 id="restrictions-on-recursive-uses-of-non-escaping-closures"> <a href="#restrictions-on-recursive-uses-of-non-escaping-closures" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Restrictions on recursive uses of non-escaping closures </h3> <p>In order to achieve the goal of guaranteeing the use of static enforcement for variables that are captured only by non-escaping closures, we do need to impose an additional restriction on the use of such closures. This rule is as follows:</p> <blockquote> <p>A non-escaping closure <code class="highlighter-rouge">A</code> may not be recursively invoked during the execution of a non-escaping closure <code class="highlighter-rouge">B</code> which captures the same local variable or <code class="highlighter-rouge">inout</code> parameter unless:</p> <ul> <li> <p><code class="highlighter-rouge">A</code> is defined within <code class="highlighter-rouge">B</code> or</p> </li> <li> <p><code class="highlighter-rouge">A</code> is a local function declaration which is referenced directly by <code class="highlighter-rouge">B</code>.</p> </li> </ul> </blockquote> <p>For clarity, we will call this rule the Non-Escaping Recursion Restriction, or NRR. The NRR is sufficient to prove that non-escaping variables captured by <code class="highlighter-rouge">B</code> will not be interfered with unless <code class="highlighter-rouge">B</code> delegates to something which is locally known by <code class="highlighter-rouge">B</code> to have access to those variables. This, together with the fact that the uses of <code class="highlighter-rouge">B</code> itself can be statically analyzed by its defining function, is sufficient to allow static enforcement for the non-escaping variables it captures. (It also enables some powerful analyses of captured variables within non-escaping closures; we do not need to get into that here.)</p> <p>Because of the tight restrictions on how non-escaping closures can be used in Swift today, its already quite difficult to violate the NRR. The following user-level restrictions are sufficient to ensure that the NRR is obeyed:</p> <ul> <li> <p>A function may not call a non-escaping function parameter passing a non-escaping function parameter as an argument.</p> <p>For the purposes of this rule, a closure which captures a non-escaping function parameter is treated the same as the parameter.</p> <p>We will call this rule the Non-Escaping Parameter Call Restriction, or NPCR.</p> </li> <li> <p>Programmers using <code class="highlighter-rouge">withoutActuallyEscaping</code> should take care not to allow the result to be recursively invoked.</p> </li> </ul> <p>The NPCR is a conservative over-approximation: that is, there is code which does not violate the NRR which will be considered ill-formed under the NPCR. This is unfortunate but inevitable.</p> <p>Here is an example of the sort of code that will be disallowed under the NPCR:</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">recurse</span><span class="p">(</span><span class="nv">fn</span><span class="p">:</span> <span class="p">(()</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
  <span class="c1">// Invoke the closure, passing a closure which, if invoked,</span>
  <span class="c1">// will invoke the closure again.</span>
  <span class="n">fn</span> <span class="p">{</span> <span class="n">fn</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="n">apply</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">argProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">fn</span><span class="p">:</span> <span class="p">(()</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Pass the first argument function to the second.</span>
  <span class="nf">fn</span><span class="p">(</span><span class="n">argProvider</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note that its quite easy to come up with ways to use these functions that wouldnt violate the NRR. For example, if either argument to <code class="highlighter-rouge">apply</code> is not a closure, the call cannot possibly violate the NRR. Nonetheless, we feel that the NPCR is a reasonable restriction:</p> <ul> <li> <p>Functions like <code class="highlighter-rouge">recurse</code> that apply a function to itself are pretty much just of theoretical interest. Recursion is an important programming tool, but nobody writes it like this because its just unnecessarily more difficult to reason about.</p> </li> <li> <p>Functions like <code class="highlighter-rouge">apply</code> that take two closures are not uncommon, but theyre likely to either invoke the closures sequentially, which would not violate the NPCR, or else be some sort of higher-order combinator, which would require the closures to be <code class="highlighter-rouge">@escaping</code> and thus also not violate the NPCR.</p> </li> </ul> <p>Note that passing two non-escaping functions as arguments to the same call does not violate the NPCR. This is because the NPCR will be enforced, recursively, in the callee. (Imported C functions which take non-escaping block parameters can, of course, easily violate the NPCR. They can also easily allow the block to escape. We do not believe there are any existing functions or methods on our target platforms that directly violate the NPCR.)</p> <p>In general, programmers who find the NPCR an unnecessarily overbearing restriction can simply declare their function parameter to be <code class="highlighter-rouge">@escaping</code> or, if they are certain that their code will not violate the NRR, use <code class="highlighter-rouge">withoutActuallyEscaping</code> to disable the NPCR check.</p> <h2 id="source-compatibility"> <a href="#source-compatibility" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Source compatibility </h2> <p>In order to gain the performance and language-design benefits of exclusivity, we will have to enforce it in all language modes. Therefore, exclusivity will eventually demand a source break.</p> <p>We can mitigate some of the impact of this break by implicitly migrating code matching certain patterns to use different patterns that are known to satisfy the exclusivity rule. For example, it would be straightforward to automatically translate calls like <code class="highlighter-rouge">swap(&amp;array[i], &amp;array[j])</code> to <code class="highlighter-rouge">array.swapAt(i, j)</code>. Whether this makes sense for any particular migration remains to be seen; for example, <code class="highlighter-rouge">swap</code> does not appear to be used very often in practice outside of specific collection algorithms.</p> <p>Overall, we do not expect that a significant amount of code will violate exclusivity. This has been borne out so far by our testing. Often the examples that do violate exclusivity can easily be rewritten to avoid conflicts. In some of these cases, it may make sense to do the rewrite automatically to avoid source-compatibility problems.</p> <h2 id="effect-on-abi-stability-and-resilience"> <a href="#effect-on-abi-stability-and-resilience" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Effect on ABI stability and resilience </h2> <p>In order to gain the performance and language-desing benefits of exclusivity, we must be able to assume that it is followed faithfully in various places throughout the ABI. Therefore, exclusivity must be enforced before we commit to a stable ABI, or else well be stuck with the current conservatism around <code class="highlighter-rouge">inout</code> and <code class="highlighter-rouge">mutating</code> methods forever.</p> </div> </div> </div> </div> </body> </html>
